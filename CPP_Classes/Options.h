// This file is automatically generated.  Don't waste your time altering it.
// This file provides initialized variables for all the options to the C++ code.
// It is statically defined because C++ options must be provided in C++ code
// which is more work to be done when moving this code to another application.
#include <string.h>
using namespace cv;
using namespace std;
class Options_Annealing {
public:
	int cityCount =  25;
	bool copyBestFlag =  false;
	bool circularFlag =  true;
	int successCount =  8;
	void RunVB() {}
	Options_Annealing() {
	}
};
class Options_CamShift {
public:
	int camMax =  255;
	Scalar camSBins =  Scalar(0, 40, 32);
	void RunVB() {}
	Options_CamShift() {
	}
};
class Options_Contours2 {
public:
	ContourApproximationModes ApproximationMode =  ContourApproximationModes::CHAIN_APPROX_TC89_KCOS;
	void RunVB() {}
	Options_Contours2() {
	}
};
class Options_Contours {
public:
	RetrievalModes retrievalMode =  cv::RetrievalModes::RETR_EXTERNAL;
	ContourApproximationModes ApproximationMode =  ContourApproximationModes::CHAIN_APPROX_TC89_KCOS;
	double epsilon =  3 / 100;
	int minPixels =  30;
	int cmPerTier =  50;
	int trueTextOffset =  80;
	int maxContourCount =  50;
	void RunVB() {}
	Options_Contours() {
	}
};
class Options_Encode {
public:
	int qualityLevel =  1;
	int scalingLevel =  85;
	int encodeOption =  ImwriteFlags::IMWRITE_JPEG_PROGRESSIVE;
	void RunVB() {}
	Options_Encode() {
	}
};
class Options_Filter {
public:
	int kernelSize =  3;
	void RunVB() {}
	Options_Filter() {
	}
};
class Options_GeneticDrawing {
public:
	int stageTotal =  100;
	double brushPercent =  1.0;
	int strokeCount =  10;
	bool snapCheck =  false;
	int generations =  20;
	void RunVB() {}
	Options_GeneticDrawing() {
	}
};
class Options_MatchShapes {
public:
	ShapeMatchModes matchOption =   ShapeMatchModes::CONTOURS_MATCH_I1;
	double matchThreshold =  0.4;
	double maxYdelta =  0.05;
	double minSize =  120;
	void RunVB() {}
	Options_MatchShapes() {
	}
};
class Options_Plane {
public:
	double rmsThreshold =  0.1;
	bool useMaskPoints =  false;
	bool useContourPoints =  false;
	bool use3Points =  false;
	bool reuseRawDepthData =  false;
	void RunVB() {}
	Options_Plane() {
	}
};
class Options_Neighbors {
public:
	double threshold =  0.005;
	int pixels =  6;
	bool patchZ =  false;
	void RunVB() {}
	Options_Neighbors() {
	}
};
class Options_Interpolate {
public:
	int resizePercent =  2;
	int interpolationThreshold =  4;
	int pixelCountThreshold =  0;
	int saveDefaultThreshold =  resizePercent;
	void RunVB() {}
	Options_Interpolate() {
	}
};
class Options_Resize {
public:
	InterpolationFlags warpFlag =  InterpolationFlags::INTER_NEAREST;
	int radioIndex =  0;
	double resizePercent =  0.03;
	int topLeftOffset =  10;
	void RunVB() {}
	Options_Resize() {
	}
};
class Options_Smoothing {
public:
	int iterations =  8;
	double interiorTension =  0.5;
	int stepSize =  30;
	void RunVB() {}
	Options_Smoothing() {
	}
};
class Options_SuperRes {
public:
	string method =  "farneback";
	int iterations =  10;
	bool restartWithNewOptions =  false;
	void RunVB() {}
	Options_SuperRes() {
	}
};
class Options_SVM2 {
public:
	int SVMType =  ml::SVM::C_SVC;
	void RunVB() {}
	Options_SVM2() {
	}
};
class Options_SVM {
public:
	int kernelType =  ml::SVM::KernelTypes::POLY;
	int granularity =  5;
	double svmDegree =  1;
	int gamma =  1;
	double svmCoef0 =  1;
	double svmC =  1;
	double svmNu =  0.5;
	double svmP =  0;
	int sampleCount =  500;
	void RunVB() {}
	Options_SVM() {
	}
};
class Options_WarpModel {
public:
	bool useGradient =  false;
	int warpMode =  0;
	bool useWarpAffine =  false;
	bool useWarpHomography =  false;
	void RunVB() {}
	Options_WarpModel() {
	}
};
class Options_MinMaxNone {
public:
	bool useMax =  false;
	bool useMin =  false;
	bool useNone =  false;
	void RunVB() {}
	Options_MinMaxNone() {
	}
};
class Options_OpenGL {
public:
	double FOV =  75;
	double yaw =  -3;
	double pitch =  3;
	double roll =  0;
	double zNear =  0;
	double zFar =  20;
	int pointSize =  2;
	double zTrans =  0.5;
	Vec3f eye =  Vec3f(0, 0, -40);
	Vec3f scaleXYZ =  Vec3f(10, 10, 1);
	void RunVB() {}
	Options_OpenGL() {
	}
};
class Options_OpenGLFunctions {
public:
	Scalar moveAmount =  Scalar(0, 0, 0);
	double FOV =  75;
	double yaw =  -3;
	double pitch =  3;
	double roll =  0;
	double zNear =  0;
	double zFar =  20.0;
	double zTrans =  0.5;
	Vec3f eye =  Vec3f(0, 0, -40);
	Vec3f scaleXYZ =  Vec3f(10, 10, 1);
	void RunVB() {}
	Options_OpenGLFunctions() {
	}
};
class Options_MinArea {
public:
vector<cv::Point2f> srcPoints;
	int squareWidth =  100;
	int numPoints =  5;
	void RunVB() {}
	Options_MinArea() {
	}
};
class Options_DCT {
public:
	int dctFlag =  cv::DCT_INVERSE | cv::DCT_ROWS;
	int runLengthMin =  15;
	int removeFrequency =  1;
	void RunVB() {}
	Options_DCT() {
	}
};
class Options_Eigen {
public:
	bool highlight =  false;
	bool recompute =  false;
	int randomCount =  100;
	int linePairCount =  20;
	int noiseOffset =  10;
	void RunVB() {}
	Options_Eigen() {
	}
};
class Options_FitLine {
public:
	int radiusAccuracy =  10;
	int angleAccuracy =  10;
	void RunVB() {}
	Options_FitLine() {
	}
};
class Options_Fractal {
public:
	int iterations =  34;
	void RunVB() {}
	Options_Fractal() {
	}
};
class Options_ProCon {
public:
	int buffer[9];
	int pduration =  1;
	int cduration =  1;
	int bufferSize =  0;
	void RunVB() {}
	Options_ProCon() {
	}
};
class Options_OilPaint {
public:
	int kernelSize =  4;
	int intensity =  20;
	int threshold =  25;
	int filterSize =  3;
	void RunVB() {}
	Options_OilPaint() {
	}
};
class Options_Pointilism {
public:
	int smoothingRadius =  32 * 2 + 1;
	int strokeSize =  3;
	bool useElliptical =  false;
	void RunVB() {}
	Options_Pointilism() {
	}
};
class Options_MotionBlur {
public:
	bool showDirection =  true;
	int kernelSize =  51;
	double theta =  0;
	int restoreLen =  10;
	int SNR =  700;
	int gamma =  5;
	void RunVB() {}
	Options_MotionBlur() {
	}
};
class Options_BinarizeNiBlack {
public:
	int kernelSize =  51;
	double niBlackK =  -200 / 1000;
	double nickK =  100 / 1000;
	double sauvolaK =  100 / 1000;
	double sauvolaR =  64;
	void RunVB() {}
	Options_BinarizeNiBlack() {
	}
};
class Options_Bernson {
public:
	int kernelSize =  51;
	int bgThreshold =  100;
	int contrastMin =  50;
	void RunVB() {}
	Options_Bernson() {
	}
};
class Options_BlockMatching {
public:
	int numDisparity =  2 * 16;
	int blockSize =  15;
	int distance =  20;
	void RunVB() {}
	Options_BlockMatching() {
	}
};
class Options_Cartoonify {
public:
	int medianBlur =  7;
	int medianBlur2 =  3;
	int kernelSize =  5;
	int threshold =  80;
	void RunVB() {}
	Options_Cartoonify() {
	}
};
class Options_Dither {
public:
	int radioIndex =  0;
	int bppIndex =  1;
	void RunVB() {}
	Options_Dither() {
	}
};
class Options_SymmetricalShapes {
public:
	double rotateAngle =  0;
	Scalar fillColor =  Scalar(0, 0, 255);
	int numPoints =  0;
	int nGenPer =  0;
	int radius1 =  0;
	int radius2 =  0;
	double dTheta =  0;
	bool symmetricRipple =  false;
	bool reverseInOut =  false;
	bool fillRequest =  false;
	void RunVB() {}
	Options_SymmetricalShapes() {
	}
};
class Options_DrawArc {
public:
	int saveMargin =  32;
	bool drawFull =  false;
	bool drawFill =  false;
	void RunVB() {}
	Options_DrawArc() {
	}
};
class Options_FilterNorm {
public:
	void RunVB() {}
	Options_FilterNorm() {
	}
};
class Options_SepFilter2D {
public:
	int xDim =  5;
	int yDim =  11;
	double sigma =  17;
	bool diffCheck =  false;
	void RunVB() {}
	Options_SepFilter2D() {
	}
};
class Options_IMUFrameTime {
public:
	int minDelayIMU =  4;
	int minDelayHost =  4;
	int plotLastX =  20;
	void RunVB() {}
	Options_IMUFrameTime() {
	}
};
class Options_KLT {
public:
	int maxCorners =  100;
	double qualityLevel =  0.01;
	int minDistance =  7;
	int blockSize =  7;
	bool nightMode =  false;
	Size subPixWinSize =  Size(10, 10);
	Size winSize =  Size(3, 3);
	void RunVB() {}
	Options_KLT() {
	}
};
class Options_Laplacian {
public:
	Size kernel =  Size(3, 3);
	double scale =  1;
	double delta =  0;
	bool gaussianBlur =  false;
	bool boxFilterBlur =  false;
	int threshold =  15;
	void RunVB() {}
	Options_Laplacian() {
	}
};
class Options_OpticalFlow {
public:
	double pyrScale =  35 / 100;
	int levels =  1;
	int winSize =  1;
	int iterations =  1;
	double polyN =  0;
	double polySigma =  0;
	int OpticalFlowFlags =  cv::OPTFLOW_FARNEBACK_GAUSSIAN;
	int outputScaling =  0;
	void RunVB() {}
	Options_OpticalFlow() {
	}
};
class Options_OpticalFlowSparse {
public:
	int OpticalFlowFlag =  cv::OPTFLOW_FARNEBACK_GAUSSIAN;
	void RunVB() {}
	Options_OpticalFlowSparse() {
	}
};
class Options_XPhoto {
public:
	int colorCode =  ColorConversionCodes::COLOR_BGR2GRAY;
	int dynamicRatio =  0;
	int blockSize =  0;
	void RunVB() {}
	Options_XPhoto() {
	}
};
class Options_InPaint {
public:
	bool telea =  false;
	void RunVB() {}
	Options_InPaint() {
	}
};
class Options_RotatePoly {
public:
	void RunVB() {}
	Options_RotatePoly() {
	}
};
class Options_FPoly {
public:
	int removeThreshold =  4;
	int autoResyncAfterX =  500;
	void RunVB() {}
	Options_FPoly() {
	}
};
class Options_Homography {
public:
	int hMethod =  LMEDS;
	void RunVB() {}
	Options_Homography() {
	}
};
class Options_Random {
public:
	int count =  0;
	void RunVB() {}
	Options_Random() {
	}
};
class Options_Hough {
public:
	int rho =  1;
	double theta =  1000 * CV_PI / 180;
	int threshold =  3;
	int lineCount =  25;
	double relativeIntensity =  90 / 1000;
	void RunVB() {}
	Options_Hough() {
	}
};
class Options_Canny {
public:
	int threshold1 =  100;
	int threshold2 =  150;
	int aperture =  3;
	void RunVB() {}
	Options_Canny() {
	}
};
class Options_ColorMatch {
public:
	bool maxDistanceCheck =  false;
	void RunVB() {}
	Options_ColorMatch() {
	}
};
class Options_Sort {
public:
	int sortOption=  cv::SortFlags::SORT_EVERY_COLUMN + cv::SortFlags::SORT_ASCENDING;
	int sortThreshold =  0;
	void RunVB() {}
	Options_Sort() {
	}
};
class Options_Distance {
public:
	int distanceType =  DistanceTypes::DIST_L1;
	void RunVB() {}
	Options_Distance() {
	}
};
class Options_Warp {
public:
	double alpha =  0;
	double beta =  0;
	double gamma =  0;
	double f =  0;
	double distance =  0;
	void RunVB() {}
	Options_Warp() {
	}
};
class Options_HistCompare {
public:
	HistCompMethods compareMethod =  cv::HistCompMethods::HISTCMP_CORREL;
	string compareName =  "Chi Square Alt";
	void RunVB() {}
	Options_HistCompare() {
	}
};
class Options_MatchCell {
public:
	double overlapPercent =  0.5;
	void RunVB() {}
	Options_MatchCell() {
	}
};
class Options_Extrinsics {
public:
	int leftCorner =  0;
	int rightCorner =  0;
	int topCorner =  0;
	void RunVB() {}
	Options_Extrinsics() {
	}
};
class Options_Translation {
public:
	int leftTrans =  0;
	int rightTrans =  0;
	void RunVB() {}
	Options_Translation() {
	}
};
class Options_OpenGL_Contours {
public:
	int depthPointStyle =  0;
	double filterThreshold =  0.3;
	void RunVB() {}
	Options_OpenGL_Contours() {
	}
};
class Options_Motion {
public:
	int motionThreshold =  0;
	double cumulativePercentThreshold =  0.1;
	void RunVB() {}
	Options_Motion() {
	}
};
class Options_Emax {
public:
	int predictionStepSize =  5;
	bool consistentcolors =  false;

	void RunVB() {}
	Options_Emax() {
	}
};
class Options_Intercepts {
public:
	int interceptRange =  10;
	int mouseMovePoint =  0;
	int selectedIntercept =  0;
	void RunVB() {}
	Options_Intercepts() {
	}
};
class Options_PlaneEstimation {
public:
	bool useDiagonalLines =  false;
	bool useContour_SidePoints =  true;
	void RunVB() {}
	Options_PlaneEstimation() {
	}
};
class Options_ForeGround {
public:
	float maxForegroundDepthInMeters =  1500 / 1000;
	int minSizeContour =  100;
	double depthPerRegion =  0;
	int numberOfRegions =  5;
	void RunVB() {}
	Options_ForeGround() {
	}
};
class Options_Flood {
public:
	int floodFlag =  4 | FloodFillFlags::FLOODFILL_FIXED_RANGE;
	int stepSize =  30;
	int minPixels =  30;
	void RunVB() {}
	Options_Flood() {
	}
};
class Options_ShapeDetect {
public:
	void RunVB() {}
	Options_ShapeDetect() {
	}
};
class Options_Blur {
public:
	int kernelSize =  3;
	double sigma =  1.5;
	void RunVB() {}
	Options_Blur() {
	}
};
class Options_Wavelet {
public:
	bool useHaar =  true;
	int iterations =  3;
	void RunVB() {}
	Options_Wavelet() {
	}
};
class Options_SOM {
public:
	int iterations =  3000;
	double learningRate =  0.1;
	int radius =  15;
	void RunVB() {}
	Options_SOM() {
	}
};
class Options_SURF {
public:
	int hessianThreshold =  2000;
	bool useBFMatcher =  true;
	int verticalRange =  1;
	int pointCount =  200;
	void RunVB() {}
	Options_SURF() {
	}
};
class Options_Sift {
public:
	bool useBFMatcher =  false;
	int pointCount =  200;
	int stepSize =  10;
	void RunVB() {}
	Options_Sift() {
	}
};
class Options_Dilate {
public:
	int kernelSize =  3;
	int iterations =  1;
	MorphShapes morphShape =  cv::MorphShapes::MORPH_CROSS;
	bool noshape =  false;
	void RunVB() {}
	Options_Dilate() {
	}
};
class Options_KMeans {
public:
	int kMeansFlag =  KmeansFlags::KMEANS_RANDOM_CENTERS;
	int kMeansK =  5;
	void RunVB() {}
	Options_KMeans() {
	}
};
class Options_LUT {
public:
	int lutSegments =  10;
	int splits[5];
	int vals[5];
	void RunVB() {}
	Options_LUT() {
	}
};
class Options_WarpModel2 {
public:
	int warpMode =  0;
	bool useWarpAffine =  false;
	bool useWarpHomography =  false;
	void RunVB() {}
	Options_WarpModel2() {
	}
};
class Options_Photoshop {
public:
	int switchColor =  3;
	void RunVB() {}
	Options_Photoshop() {
	}
};
class Options_Gif {
public:
	void RunVB() {}
	Options_Gif() {
	}
};
class Options_IMU {
public:
	int rotateX =  0;
	int rotateY =  0;
	int rotateZ =  0;
	double stableThreshold =  0.02;
	void RunVB() {}
	Options_IMU() {
	}
};
class Options_FeatureMatch {
public:
	int matchOption =  cv::TemplateMatchModes::TM_CCOEFF_NORMED;
	string matchText =  "CCoeffNormed";
	void RunVB() {}
	Options_FeatureMatch() {
	}
};
class Options_HeatMap {
public:
	int redThreshold =  20;
	string viewName =  "vertical";
	bool topView =  true;
	bool sideView =  false;
	void RunVB() {}
	Options_HeatMap() {
	}
};
class Options_Boundary {
public:
	int desiredBoundaries =  15;
	int peakDistance =  20;
	void RunVB() {}
	Options_Boundary() {
	}
};
class Options_Denoise {
public:
	bool removeSinglePixels =  true;
	void RunVB() {}
	Options_Denoise() {
	}
};
class Options_MSER {
public:
	int delta =  9;
	int minArea =  0;
	int maxArea =  0;
	double maxVariation =  0.25;
	double minDiversity =  0.2;
	int maxEvolution =  200;
	double areaThreshold =  1.01;
	double minMargin =  0.003;
	int edgeBlurSize =  5;
	int pass2Setting =  0;
	bool graySetting =  false;
	void RunVB() {}
	Options_MSER() {
	}
};
class Options_Spectrum {
public:
	int gapDepth =  1;
	int gapGray =  1;
	int sampleThreshold =  10;
	void RunVB() {}
	Options_Spectrum() {
	}
};
class Options_HistXD {
public:
	int sideThreshold =  5;
	int topThreshold =  15;
	int threshold3D =  40;
	void RunVB() {}
	Options_HistXD() {
	}
};
class Options_Complexity {
public:
	Scalar plotColor =  Scalar(255, 255, 0);
	void RunVB() {}
	Options_Complexity() {
	}
};
class Options_Edges_All {
public:
	string edgeSelection =  "";
	void RunVB() {}
	Options_Edges_All() {
	}
};
class Options_BGSubtractSynthetic {
public:
	double amplitude =  200;
	double magnitude =  20;
	double waveSpeed =  20;
	double objectSpeed =  15;
	void RunVB() {}
	Options_BGSubtractSynthetic() {
	}
};
class Options_BGSubtract {
public:
	double learnRate =  100 / 1000;
	string methodDesc =  "MOG2";
	int currMethod =  4;
	void RunVB() {}
	Options_BGSubtract() {
	}
};
class Options_Classifier {
public:
	int methodIndex =  0;
	string methodName =  "Normal Bayes (NBC)";
	int sampleCount =  200;
	void RunVB() {}
	Options_Classifier() {
	}
};
class Options_Derivative {
public:
	int channel =  0;
	int kernelSize =  3;
	double derivativeRange =  0.1;
	void RunVB() {}
	Options_Derivative() {
	}
};
class Options_LaplacianKernels {
public:
	int gaussiankernelSize =  1;
	int LaplaciankernelSize =  3;
	void RunVB() {}
	Options_LaplacianKernels() {
	}
};
class Options_Threshold {
public:
	ThresholdTypes thresholdMethod =  cv::ThresholdTypes::THRESH_BINARY;
	string thresholdName =  "";
	int threshold =  128;
	bool inputGray =  false;
	bool otsuOption =  false;
	void RunVB() {}
	Options_Threshold() {
	}
};
class Options_AdaptiveThreshold {
public:
	AdaptiveThresholdTypes method =  cv::AdaptiveThresholdTypes::ADAPTIVE_THRESH_GAUSSIAN_C;
	int blockSize =  5;
	int constantVal =  0;
	void RunVB() {}
	Options_AdaptiveThreshold() {
	}
};
class Options_Colors {
public:
	int redS =  180;
	int greenS =  180;
	int blueS =  180;
	void RunVB() {}
	Options_Colors() {
	}
};
class Options_Threshold_AdaptiveMin {
public:
	AdaptiveThresholdTypes adaptiveMethod =  cv::AdaptiveThresholdTypes::ADAPTIVE_THRESH_GAUSSIAN_C;
	void RunVB() {}
	Options_Threshold_AdaptiveMin() {
	}
};
class Options_ThresholdAll {
public:
	ThresholdTypes thresholdMethod =  cv::ThresholdTypes::THRESH_BINARY;
	int blockSize =  5;
	int constantVal =  0;
	int maxVal =  255;
	int threshold =  100;
	bool inputGray =  false;
	bool otsuOption =  false;
	AdaptiveThresholdTypes adaptiveMethod =  cv::AdaptiveThresholdTypes::ADAPTIVE_THRESH_GAUSSIAN_C;
	void RunVB() {}
	Options_ThresholdAll() {
	}
};
class Options_StdevGrid {
public:
	int minThreshold =  30;
	int maxThreshold =  230;
	int diffThreshold =  5;
	void RunVB() {}
	Options_StdevGrid() {
	}
};
class Options_DFT {
public:
	int radius =  120;
	int order =  2;
	int dftFlag =  DftFlags::DFT_COMPLEX_OUTPUT;
	void RunVB() {}
	Options_DFT() {
	}
};
class Options_DFTShape {
public:
	string dftShape =  "Draw Circle";
	void RunVB() {}
	Options_DFTShape() {
	}
};
class Options_FitEllipse {
public:
	int fitType =  0;
	int threshold =  70;
	void RunVB() {}
	Options_FitEllipse() {
	}
};
class Options_TopX {
public:
	int topX =  10;
	void RunVB() {}
	Options_TopX() {
	}
};
class Options_XNeighbors {
public:
	int xNeighbors =  5;
	void RunVB() {}
	Options_XNeighbors() {
	}
};
class Options_Sobel {
public:
	int kernelSize =  3;
	int threshold =  50;
	int distanceThreshold =  10;
	double derivativeRange =  0.1;
	bool horizontalDerivative =  true;
	bool verticalDerivative =  true;
	bool useBlur =  false;
	void RunVB() {}
	Options_Sobel() {
	}
};
class Options_EdgeOverlay {
public:
	int xDisp =  7;
	int yDisp =  11;
	void RunVB() {}
	Options_EdgeOverlay() {
	}
};
class Options_AddWeighted {
public:
	double addWeighted =  50 / 100;
	double accumWeighted =  10 / 100;
	void RunVB() {}
	Options_AddWeighted() {
	}
};
class Options_ApproxPoly {
public:
	double epsilon =  3;
	bool closedPoly =  true;
	void RunVB() {}
	Options_ApproxPoly() {
	}
};
class Options_Bin3WayRedCloud {
public:
	int startRegion =  0;
	int endRegion =  0;
	void RunVB() {}
	Options_Bin3WayRedCloud() {
	}
};
class Options_Bin2WayRedCloud {
public:
	int startRegion =  0;
	int endRegion =  0;
	void RunVB() {}
	Options_Bin2WayRedCloud() {
	}
};
class Options_GuidedBPDepth {
public:
	int bins =  1000;
	double maxClusters =  5;
	void RunVB() {}
	Options_GuidedBPDepth() {
	}
};
class Options_OpenGL_Duster {
public:
	bool useClusterColors =  false;
	bool useTaskPointCloud =  false;
	void RunVB() {}
	Options_OpenGL_Duster() {
	}
};
class Options_FeatureGather {
public:
	int featureSource =  0;
	void RunVB() {}
	Options_FeatureGather() {
	}
};
class Options_AsciiArt {
public:
	double hStep =  31;
	double wStep =  55;
	Size size =  Size(wStep, hStep);
	void RunVB() {}
	Options_AsciiArt() {
	}
};
class Options_MotionDetect {
public:
	Vec3i threadData =  Vec3i(0, 0, 0);
	double CCthreshold =  0;
	int pad =  0;
	int stdevThreshold =  0;
	void RunVB() {}
	Options_MotionDetect() {
	}
};
class Options_JpegQuality {
public:
	int quality =  90;
	void RunVB() {}
	Options_JpegQuality() {
	}
};
class Options_PNGCompression {
public:
	int compression =  90;
	void RunVB() {}
	Options_PNGCompression() {
	}
};
class Options_Binarize {
public:
	string binarizeLabel =  "Binary";
	void RunVB() {}
	Options_Binarize() {
	}
};
class Options_BlurTopo {
public:
	double savePercent =  0;
	double nextPercent =  20;
	int reduction =  20;
	int frameCycle =  50 / 100;
	double kernelSize =  101;
	void RunVB() {}
	Options_BlurTopo() {
	}
};
class Options_BoundaryRect {
public:
	double percentRect =  25;
	void RunVB() {}
	Options_BoundaryRect() {
	}
};
class Options_BrightnessContrast {
public:
	int contrast =  500;
	double brightness =  -100;
	double hsvBrightness =  100;
	double exponent =  30 / 100;
	void RunVB() {}
	Options_BrightnessContrast() {
	}
};
class Options_HistPointCloud {
public:
	int threshold =  60;
	int xBins =  30;
	int yBins =  30;
	int zBins =  100;
	void RunVB() {}
	Options_HistPointCloud() {
	}
};
class Options_Harris {
public:
	double threshold =  1 / 10000;
	int neighborhood =  3;
	int aperture =  21;
	double harrisParm =  1;
	void RunVB() {}
	Options_Harris() {
	}
};
class Options_HarrisCorners {
public:
	int quality =  50;
	int qualityMax =  100;
	int blockSize =  3;
	int aperture =  3;
	void RunVB() {}
	Options_HarrisCorners() {
	}
};
class Options_Databases {
public:
	string linkAddress =  "";
	bool downloadActive =  false;
	int downloadIndex =  0;
	void RunVB() {}
	Options_Databases() {
	}
};
class Options_EdgeMatching {
public:
	int searchDepth =  256;
	double threshold =  80;
	bool overlayChecked =  false;
	bool highlightChecked =  true;
	bool clearChecked =  false;
	void RunVB() {}
	Options_EdgeMatching() {
	}
};
class Options_EmaxInputClusters {
public:
	int samplesPerRegion =  10;
	int sigma =  10;
	void RunVB() {}
	Options_EmaxInputClusters() {
	}
};
class Options_CComp {
public:
	int light =  127;
	int dark =  50;
	int threshold =  0;
	void RunVB() {}
	Options_CComp() {
	}
};
class Options_CellAutomata {
public:
	int currentRule =  0;
	void RunVB() {}
	Options_CellAutomata() {
	}
};
class Options_BackProject2D {
public:
	bool backProjectRow =  true;
	void RunVB() {}
	Options_BackProject2D() {
	}
};
class Options_Kaze {
public:
	int pointsToMatch =  100;
	int maxDistance =  100;
	void RunVB() {}
	Options_Kaze() {
	}
};
class Options_Blob {
public:

	void RunVB() {}
	Options_Blob() {
	}
};
class Options_SLR {
public:
	double tolerance =  30 / 100;
	int halfLength =  10;
	void RunVB() {}
	Options_SLR() {
	}
};
class Options_KNN {
public:
	int knnDimension =  2;
	int numPoints =  10;
	int multiplier =  10;
	void RunVB() {}
	Options_KNN() {
	}
};
class Options_Clone {
public:
	double alpha =  2 / 10;
	double beta =  2 / 10;
	int lowThreshold =  10;
	int highThreshold =  50;
	double blueChange =  5 / 10;
	double greenChange =  5 / 10;
	double redChange =  15 / 10;
	int cloneFlag =  cv::MIXED_CLONE;
	void RunVB() {}
	Options_Clone() {
	}
};
class Options_Coherence {
public:
	int sigma =  9;
	double blend =  10;
	int str_sigma =  155;
	int eigenkernelsize =  1;
	void RunVB() {}
	Options_Coherence() {
	}
};
class Options_Color {
public:
	string colorFormat =  "BGR";
	void RunVB() {}
	Options_Color() {
	}
};
class Options_Grayscale8U {
public:
	bool useOpenCV =  true;
	void RunVB() {}
	Options_Grayscale8U() {
	}
};
class Options_Color8UTopX {
public:
	int topXcount =  16;
	void RunVB() {}
	Options_Color8UTopX() {
	}
};
class Options_Morphology {
public:
	int widthHeight =  20;
	int iterations =  1;
	double scaleFactor =  70;
	void RunVB() {}
	Options_Morphology() {
	}
};
class Options_Convex {
public:
	int hullCount =  10;
	void RunVB() {}
	Options_Convex() {
	}
};
class Options_Corners {
public:
	bool useNonMax =  true;
	void RunVB() {}
	Options_Corners() {
	}
};
class Options_PreCorners {
public:
	int kernelSize =  19;
	int subpixSize =  3;
	void RunVB() {}
	Options_PreCorners() {
	}
};
class Options_ShiTomasi {
public:
	bool useShiTomasi =  true;
	int threshold =  0;
	int aperture =  3;
	int blocksize =  3;
	void RunVB() {}
	Options_ShiTomasi() {
	}
};
class Options_FlatLand {
public:
	double reductionFactor =  10;
	void RunVB() {}
	Options_FlatLand() {
	}
};
class Options_Depth {
public:
	int millimeters =  8;
	double mmThreshold =  millimeters / 1000;
	double threshold =  250;
	void RunVB() {}
	Options_Depth() {
	}
};
class Options_DepthHoles {
public:
	int borderDilation =  1;
	int holeDilation =  0;
	void RunVB() {}
	Options_DepthHoles() {
	}
};
class Options_Uncertainty {
public:
	int uncertaintyThreshold =  100;
	void RunVB() {}
	Options_Uncertainty() {
	}
};
class Options_DepthColor {
public:
	double alpha =  5 / 100;
	double beta =  3;
	void RunVB() {}
	Options_DepthColor() {
	}
};
class Options_DNN {
public:
	string superResModelFileName =  "";
	string shortModelName =  "";
	int superResMultiplier =  0;
	double ScaleFactor =  78;
	double scaleMax =  255;
	double meanValue =  127;
	double confidenceThreshold =  80 / 100;
	void RunVB() {}
	Options_DNN() {
	}
};
class Options_DrawNoise {
public:
	int noiseCount =  100;
	int noiseWidth =  3;
	void RunVB() {}
	Options_DrawNoise() {
	}
};
class Options_Edges {
public:
	double scharrMultiplier =  50;
	double EP_Sigma_s =  10;
	double EP_Sigma_r =  40;
	bool recurseCheck =  true;
	void RunVB() {}
	Options_Edges() {
	}
};
class Options_Edges2 {
public:
	int removeFrequencies =  32;
	int dctThreshold =  20;
	int edgeRFthreshold =  35;
	void RunVB() {}
	Options_Edges2() {
	}
};
class Options_Edges3 {
public:
	double alpha =  100;
	double omega =  100;
	int gapDistance =  5;
	int gapdiff =  10;
	void RunVB() {}
	Options_Edges3() {
	}
};
class Options_DepthEdges {
public:
	int depthDiff =  200;
	double depthOffset =  1 / 1000;
	int depthDist =  5;
	int mmDepthDiff =  1000 / 1000;
	void RunVB() {}
	Options_DepthEdges() {
	}
};
class Options_Edges4 {
public:
	int vertPixels =  5;
	int horizPixels =  5;
	bool horizonCheck =  true;
	bool verticalCheck =  true;
	void RunVB() {}
	Options_Edges4() {
	}
};
class Options_Erode {
public:
	int kernelSize =  3;
	int iterations =  1;
	MorphShapes morphShape =  cv::MorphShapes::MORPH_CROSS;
	bool noshape =  false;
	double flatDepth =  100;
	void RunVB() {}
	Options_Erode() {
	}
};
class Options_Etch_ASketch {
public:
	bool demoMode =  false;
	bool cleanMode =  false;
	void RunVB() {}
	Options_Etch_ASketch() {
	}
};
class Options_Features {
public:
	double quality =  0.01;
	double minDistance =  1;
	int matchOption =  cv::TemplateMatchModes::TM_CCOEFF_NORMED;
	string matchText =  "";
	double k =  0.04;
	int blockSize =  3;
	int featurePoints =  400;
	int templatePad =  10;
	int templateSize =  0;
	double correlationMin =  0.75;
	double resyncThreshold =  0.95;
	int agastThreshold =  20;
	bool useVertical =  false;
	bool useBRISK =  false;
	void RunVB() {}
	Options_Features() {
	}
};
class Options_LineFinder {
public:
	int kernelSize =  5;
	int tolerance =  5;
	int kSize =  kernelSize - 1;
	void RunVB() {}
	Options_LineFinder() {
	}
};
class Options_PCA_NColor {
public:
	int desiredNcolors =  8;
	void RunVB() {}
	Options_PCA_NColor() {
	}
};
class Options_FPolyCore {
public:
	int maxShift =  50;
	int resyncThreshold =  4;
	int anchorMovement =  5;
	void RunVB() {}
	Options_FPolyCore() {
	}
};
class Options_FLANN {
public:
	bool reuseData =  false;
	int matchCount =  0;
	int queryCount =  0;
	int searchCheck =  0;
	double eps =  0;
	bool sorted =  false;
	void RunVB() {}
	Options_FLANN() {
	}
};
class Options_TrackerDepth {
public:
	bool displayRect =  true;
	int minRectSize =  10000;
	void RunVB() {}
	Options_TrackerDepth() {
	}
};
class Options_Gabor {
public:
	double ksize =  15;
	double Sigma =  4;
	double theta =  90;
	double lambda =  10;
	double gamma =  5;
	double phaseOffset =  0;
	void RunVB() {}
	Options_Gabor() {
	}
};
class Options_GrabCut {
public:
	bool clearAll =  false;
	bool fineTuning =  true;
	void RunVB() {}
	Options_GrabCut() {
	}
};
class Options_Gradient {
public:
	double exponent =  30;
	void RunVB() {}
	Options_Gradient() {
	}
};
class Options_Grid {
public:
	int desiredFPS =  2;
	int width =  32;
	int height =  32;
	void RunVB() {}
	Options_Grid() {
	}
};
class Options_Histogram {
public:
	int minGray =  50;
	int maxGray =  200;
	void RunVB() {}
	Options_Histogram() {
	}
};
class Options_Guess {
public:
	int MaxDistance =  50;
	void RunVB() {}
	Options_Guess() {
	}
};
class Options_Hist3D {
public:
	bool addCloud =  true;
	void RunVB() {}
	Options_Hist3D() {
	}
};
class Options_HOG {
public:
	int thresholdHOG =  0;
	int strideHOG =  1;
	double scaleHOG =  300 / 1000;
	void RunVB() {}
	Options_HOG() {
	}
};
class Options_Images {
public:
	int fileIndex =  0;
	string dirName =  "";
	bool imageSeries =  false;
	void RunVB() {}
	Options_Images() {
	}
};
class Options_VerticalVerify {
public:
	int angleThreshold =  80;
	void RunVB() {}
	Options_VerticalVerify() {
	}
};
class Options_IMUPlot {
public:
	bool setBlue =  true;
	bool setGreen =  true;
	bool setRed =  true;
	void RunVB() {}
	Options_IMUPlot() {
	}
};
class Options_Kalman_VB {
public:
	double kalmanInput =  0;
	int noisyInput =  0;
	double angle =  0;
	void RunVB() {}
	Options_Kalman_VB() {
	}
};
class Options_Kalman {
public:
	double delta =  5 / 100;
	double pdotEntry =  300 / 1000;
	double processCovar =  10 / 10000;
	int averageInputCount =  20;
	void RunVB() {}
	Options_Kalman() {
	}
};
class Options_LaneFinder {
public:
	string inputName =  "/Data/challenge.mp4";
	void RunVB() {}
	Options_LaneFinder() {
	}
};
class Options_LaPlacianPyramid {
public:
	void RunVB() {}
	Options_LaPlacianPyramid() {
	}
};
class Options_LeftRight {
public:
	int sliceY =  25;
	int sliceHeight =  20;
	void RunVB() {}
	Options_LeftRight() {
	}
};
class Options_LongLine {
public:
	int maxCount =  25;
	int pad =  3;
	void RunVB() {}
	Options_LongLine() {
	}
};
class Options_LUT_Create {
public:
	int lutThreshold =  10;
	void RunVB() {}
	Options_LUT_Create() {
	}
};
class Options_Mat {
public:
	int decompType =  DecompTypes::DECOMP_CHOLESKY;
	void RunVB() {}
	Options_Mat() {
	}
};
class Options_Match {
public:
	int maxDistance =  5;
	int stdevThreshold =  10;
	void RunVB() {}
	Options_Match() {
	}
};
class Options_Math {
public:
	bool showMean =  false;
	bool showStdev =  false;
	void RunVB() {}
	Options_Math() {
	}
};
class Options_MeanSubtraction {
public:
	double scaleVal =  1;
	void RunVB() {}
	Options_MeanSubtraction() {
	}
};
class Options_Mesh {
public:
	int nabeCount =  2;
	void RunVB() {}
	Options_Mesh() {
	}
};
class Options_OEX {
public:
	Scalar lows =  Scalar(90, 50, 50);
	Scalar highs =  Scalar(180, 150, 150);
	void RunVB() {}
	Options_OEX() {
	}
};
class Options_ORB {
public:
	int desiredCount =  100;
	void RunVB() {}
	Options_ORB() {
	}
};
class Options_Palette {
public:
	int transitions =  7;
	int convertScale =  45;
	string schemeName =  "schemeRandom";
	int radius =  0;
	void RunVB() {}
	Options_Palette() {
	}
};
class Options_PCA {
public:
	double retainedVariance =  95 / 100;
	void RunVB() {}
	Options_PCA() {
	}
};
class Options_Pendulum {
public:
	bool initialize =  false;
	int fps =  300;
	void RunVB() {}
	Options_Pendulum() {
	}
};
class Options_PhaseCorrelate {
public:
	int shiftThreshold =  30;
	void RunVB() {}
	Options_PhaseCorrelate() {
	}
};
class Options_PlaneFloor {
public:
	int countThreshold =  10;
	void RunVB() {}
	Options_PlaneFloor() {
	}
};
class Options_PlyFormat {
public:
	string playButton =  "";
	int allOptionsLeft =  0;
	string saveFileName =  "";
	void RunVB() {}
	Options_PlyFormat() {
	}
};
class Options_PointCloud {
public:
	double deltaThreshold =  5;
	void RunVB() {}
	Options_PointCloud() {
	}
};
class Options_PolyLines {
public:
	int polyCount =  100;
	bool polyClosed =  true;
	void RunVB() {}
	Options_PolyLines() {
	}
};
class Options_Projection {
public:
	bool topCheck =  true;
	int index =  0;
	int projectionThreshold =  2;
	void RunVB() {}
	Options_Projection() {
	}
};
class Options_Puzzle {
public:
	bool startPuzzle =  true;
	void RunVB() {}
	Options_Puzzle() {
	}
};
class Options_Pyramid {
public:
	int zoom =  0;
	void RunVB() {}
	Options_Pyramid() {
	}
};
class Options_PyrFilter {
public:
	int spatialRadius =  1;
	int colorRadius =  20;
	int maxPyramid =  3;
	void RunVB() {}
	Options_PyrFilter() {
	}
};
class Options_NormalDist {
public:
	int blueVal =  125;
	int greenVal =  25;
	int redVal =  180;
	int stdev =  50;
	bool grayChecked =  false;
	void RunVB() {}
	Options_NormalDist() {
	}
};
class Options_MonteCarlo {
public:
	int dimension =  91;
	void RunVB() {}
	Options_MonteCarlo() {
	}
};
class Options_StaticTV {
public:
	int rangeVal =  50;
	double threshPercent =  20;
	void RunVB() {}
	Options_StaticTV() {
	}
};
class Options_Clusters {
public:
	int numClusters =  9;
	int numPoints =  20;
	double stdev =  10;
	void RunVB() {}
	Options_Clusters() {
	}
};
class Options_Draw {
public:
	int proximity =  250;
	int drawCount =  3;
	int drawFilled =  2;
	bool drawRotated =  false;
	void RunVB() {}
	Options_Draw() {
	}
};
class Options_RBF {
public:
	int RBFCount =  2;
	void RunVB() {}
	Options_RBF() {
	}
};
class Options_RedCloudOther {
public:
	int range =  30;
	int reduceAmt =  250;
	double threshold =  95 / 100;
	void RunVB() {}
	Options_RedCloudOther() {
	}
};
class Options_RedCloudFeatures {
public:
	int selection =  3;
	string labelName =  "Correlation Y to Z";
	void RunVB() {}
	Options_RedCloudFeatures() {
	}
};
class Options_RedTrack {
public:
	int maxDistance =  10;
	void RunVB() {}
	Options_RedTrack() {
	}
};
class Options_Reduction {
public:
	bool reduceXYZ[3] = {true, true, true};
	void RunVB() {}
	Options_Reduction() {
	}
};
class Options_Retina {
public:
	bool useLogSampling =  false;
	int sampleFactor =  2;
	bool xmlCheck =  false;
	void RunVB() {}
	Options_Retina() {
	}
};
class Options_ROI {
public:
	double roiPercent =  25 / 100;
	void RunVB() {}
	Options_ROI() {
	}
};
class Options_Rotate {
public:
	double rotateAngle =  24;
	void RunVB() {}
	Options_Rotate() {
	}
};
class Options_Salience {
public:
	int numScales =  6;
	void RunVB() {}
	Options_Salience() {
	}
};
class Options_SLRImages {
public:
	string radioText =  "Grayscale input";
	void RunVB() {}
	Options_SLRImages() {
	}
};
class Options_StabilizerOther {
public:
	int fastThreshold =  0;
	int range =  8;
	void RunVB() {}
	Options_StabilizerOther() {
	}
};
class Options_Stabilizer {
public:
	double lostMax =  10 / 100;
	int width =  128;
	int height =  96;
	double minStdev =  10;
	double corrThreshold =  950 / 1000;
	int pad =  20;
	void RunVB() {}
	Options_Stabilizer() {
	}
};
class Options_Stitch {
public:
	int imageCount =  10;
	int width =  0;
	int height =  0;
	void RunVB() {}
	Options_Stitch() {
	}
};
class Options_StructuredFloor {
public:
	bool xCheck =  false;
	bool yCheck =  true;
	bool zCheck =  false;
	void RunVB() {}
	Options_StructuredFloor() {
	}
};
class Options_StructuredCloud {
public:
	int xLines =  50;
	int yLines =  50;
	int indexX =  50;
	int indexY =  50;
	int threshold =  10;
	bool xConstraint =  true;
	bool yConstraint =  true;
	void RunVB() {}
	Options_StructuredCloud() {
	}
};
class Options_StructuredMulti {
public:
	int maxSides =  4;
	void RunVB() {}
	Options_StructuredMulti() {
	}
};
class Options_Structured {
public:
	bool rebuilt =  true;
	int sliceSize =  1;
	int stepSize =  20;
	void RunVB() {}
	Options_Structured() {
	}
};
class Options_SuperPixels {
public:
	int numSuperPixels =  400;
	int numIterations =  4;
	int prior =  2;
	void RunVB() {}
	Options_SuperPixels() {
	}
};
class Options_Swarm {
public:
	int ptCount =  2;
	int border =  5;
	void RunVB() {}
	Options_Swarm() {
	}
};
class Options_SwarmPercent {
public:
	double percent =  80 / 100;
	void RunVB() {}
	Options_SwarmPercent() {
	}
};
class Options_Texture {
public:
	int TFdelta =  30;
	int TFblockSize =  50;
	int TFksize =  1;
	void RunVB() {}
	Options_Texture() {
	}
};
class Options_ThresholdDef {
public:
	int threshold =  127;
	void RunVB() {}
	Options_ThresholdDef() {
	}
};
class Options_Tracker {
public:
	int trackType =  1;
	void RunVB() {}
	Options_Tracker() {
	}
};
class Options_Transform {
public:
	double resizeFactor =  50 / 100;
	int angle =  30;
	double scale =  1;
	bool firstCheck =  false;
	bool secondCheck =  false;
	int centerX =  0;
	int centerY =  0;
	void RunVB() {}
	Options_Transform() {
	}
};
class Options_TransformationMatrix {
public:
	int mul =  500;
	void RunVB() {}
	Options_TransformationMatrix() {
	}
};
class Options_Vignetting {
public:
	double radius =  80;
	void RunVB() {}
	Options_Vignetting() {
	}
};
class Options_Video {
public:
	int maxFrames =  1000;
	int currFrame =  0;
	void RunVB() {}
	Options_Video() {
	}
};
class Options_WarpAffine {
public:
	int angle =  10;
	void RunVB() {}
	Options_WarpAffine() {
	}
};
class Options_WarpPerspective {
public:
	int width =  0;
	int height =  0;
	int angle =  0;
	void RunVB() {}
	Options_WarpPerspective() {
	}
};
class Options_XPhotoInpaint {
public:
	bool FSRFast =  false;
	bool shiftMap =  false;
	void RunVB() {}
	Options_XPhotoInpaint() {
	}
};
class Options_Density {
public:
	int zCount =  3;
	double distance =  0;
	void RunVB() {}
	Options_Density() {
	}
};
