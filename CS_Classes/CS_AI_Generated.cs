using cv = OpenCvSharp;
using System;
using System.Windows.Forms;
using VB_Classes;
using OpenCvSharp;
using OpenCvSharp.Extensions;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using static CS_Classes.CS_Externs;
using OpenCvSharp.XImgProc;
using System.IO;
using System.Security.Cryptography;
using System.Numerics;
using System.Diagnostics;
using OpenCvSharp.ML;
using System.Threading;
using OpenCvSharp.XFeatures2D;
using OpenCvSharp.XPhoto;
using System.Drawing;
using System.IO.MemoryMappedFiles;
using System.IO.Pipes;
using System.Runtime.Versioning;
using System.Diagnostics.Eventing.Reader;

namespace CS_Classes
{
    public class AddWeighted_Basics_CS : VB_Parent
    {
        public Mat src2;  // user normally provides src2! 
        public Options_AddWeighted options = new Options_AddWeighted();
        public double weight = 0.5;
        public AddWeighted_Basics_CS()
        {
            UpdateAdvice(traceName + ": use the local option slider 'Add Weighted %'");
            desc = "Add 2 images with specified weights.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standalone)
                src2 = vbc.task.depthRGB;
            if (src2.Type() != src.Type())
            {
                if (src.Type() != MatType.CV_8UC3 || src2.Type() != MatType.CV_8UC3)
                {
                    if (src.Type() == MatType.CV_32FC1)
                        src = Convert32f_To_8UC3(src);
                    if (src2.Type() == MatType.CV_32FC1)
                        src2 = Convert32f_To_8UC3(src2);
                    if (src.Type() != MatType.CV_8UC3)
                        src = src.CvtColor(ColorConversionCodes.GRAY2BGR);
                    if (src2.Type() != MatType.CV_8UC3)
                        src2 = src2.CvtColor(ColorConversionCodes.GRAY2BGR);
                }
            }
            double weight = options.addWeighted;
            Cv2.AddWeighted(src, weight, src2, 1.0 - weight, 0, dst2);
            labels[2] = $"Depth %: {100 - weight * 100} BGR %: {(int)(weight * 100)}";
        }
    }



    public class AddWeighted_Edges_CS : VB_Parent
    {
        Edge_Basics edges = new Edge_Basics();
        AddWeighted_Basics_CS addw;

        public AddWeighted_Edges_CS()
        {
            addw = new AddWeighted_Basics_CS();
            labels = new string[] { "", "", "Edges_BinarizedSobel output", "AddWeighted edges and BGR image" };
            desc = "Add in the edges separating light and dark to the color image";
        }

        public void RunAlg(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2;
            labels[2] = edges.labels[2];

            addw.src2 = edges.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.Run(src);
            dst3 = addw.dst2;
        }
    }




    public class AddWeighted_DepthAccumulate_CS : VB_Parent
    {
        Options_AddWeighted options = new Options_AddWeighted();
        public AddWeighted_DepthAccumulate_CS()
        {
            desc = "Update a running average of the image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                dst2 = vbc.task.pcSplit[2] * 1000;
            }
            cv.Cv2.AccumulateWeighted(vbc.task.pcSplit[2] * 1000, dst2, options.accumWeighted, new cv.Mat());
        }
    }





    public class AddWeighted_InfraRed_CS : VB_Parent
    {
        AddWeighted_Basics_CS addw = new AddWeighted_Basics_CS();
        Mat src2 = new Mat();

        public AddWeighted_InfraRed_CS()
        {
            desc = "Align the depth data with the left or right view. Oak-D is aligned with the right image. All cameras are aligned horizontally.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.toggleOnOff)
            {
                dst1 = vbc.task.leftView;
                labels[2] = "Left view combined with depthRGB";
            }
            else
            {
                dst1 = vbc.task.rightView;
                labels[2] = "Right view combined with depthRGB";
            }

            addw.src2 = dst1;
            addw.Run(vbc.task.depthRGB);
            dst2 = addw.dst2.Clone();
        }
    }


    public class CompareAllowIdenticalDoubleInverted : IComparer<double>
    {
        public int Compare(double a, double b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a <= b) return 1;
            return -1;
        }
    }
    public class CompareAllowIdenticalDouble : IComparer<double>
    {
        public int Compare(double a, double b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a >= b) return 1;
            return -1;
        }
    }
    public class CompareAllowIdenticalSingleInverted : IComparer<float>
    {
        public int Compare(float a, float b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a <= b) return 1;
            return -1;
        }
    }
    public class CompareAllowIdenticalSingle : IComparer<float>
    {
        public int Compare(float a, float b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a >= b) return 1;
            return -1;
        }
    }
    public class CompareAllowIdenticalIntegerInverted : IComparer<int>
    {
        public int Compare(int a, int b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a <= b) return 1;
            return -1;
        }
    }
    public class CompareByte : IComparer<byte>
    {
        public int Compare(byte a, byte b)
        {
            if (a <= b) return -1;
            return 1;
        }
    }
    public class CompareAllowIdenticalInteger : IComparer<int>
    {
        public int Compare(int a, int b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a >= b) return 1;
            return -1;
        }
    }

    public class CompareMaskSize : IComparer<int>
    {
        public int Compare(int a, int b)
        {
            if (a <= b) return 1;
            return -1;
        }
    }









    public class AlphaChannel_Basics_CS : VB_Parent
    {
        Form alpha = new Form();

        public AlphaChannel_Basics_CS()
        {
            alpha.Show();
            alpha.Width = dst2.Width + 10;
            alpha.Height = dst2.Height + 10;
            desc = "Use the Windows alpha channel to separate foreground and background";
        }

        public void RunAlg(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2BGRA);
            Mat[] split = Cv2.Split(src);
            split[3] = vbc.task.depthMask;
            Cv2.Merge(split, src);
            alpha.BackgroundImage = BitmapConverter.ToBitmap(src, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
        }
    }





    // https://stackoverflow.com/questions/22132510/opencv-approxpolydp-for-edge-maps-Not-contours
    // https://docs.opencv.org/4.x/js_contour_features_approxPolyDP.html
    public class ApproxPoly_Basics_CS : VB_Parent
    {
        Contour_Largest contour = new Contour_Largest();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        Options_ApproxPoly options = new Options_ApproxPoly();

        public ApproxPoly_Basics_CS()
        {
            labels = new string[] { "", "", "Input to the ApproxPolyDP", "Output of ApproxPolyDP" };
            desc = "Using the input contours, create ApproxPoly output";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                    rotatedRect.Run(src);
                dst2 = rotatedRect.dst2;
            }

            contour.Run(dst2);
            dst2 = contour.dst2;

            if (contour.allContours.Count() > 0)
            {
                cv.Point[] nextContour;
                nextContour = Cv2.ApproxPolyDP(contour.bestContour, options.epsilon, options.closedPoly);
                dst3.SetTo(Scalar.Black);
                DrawContour(dst3, new List<cv.Point>(nextContour), Scalar.Yellow);
            }
            else
            {
                labels[2] = "No contours found";
            }
        }
    }




    public class ApproxPoly_FindandDraw_CS : VB_Parent
    {
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        public cv.Point[][] allContours;
        public ApproxPoly_FindandDraw_CS()
        {
            labels[2] = "FindandDraw input";
            labels[3] = "FindandDraw output - note the change in line width where ApproxPoly differs from DrawContours";
            desc = "Demo the use of FindContours, ApproxPolyDP, and DrawContours.";
        }

        public void RunAlg(Mat src)
        {
            rotatedRect.Run(src);
            dst2 = rotatedRect.dst2;
            dst0 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst0 = dst0.Threshold(1, 255, ThresholdTypes.Binary);

            dst0.ConvertTo(dst1, MatType.CV_32SC1);
            Cv2.FindContours(dst1, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxSimple);
            dst3.SetTo(Scalar.Black);

            List<cv.Point[]> contours = new List<cv.Point[]>();
            for (int i = 0; i < allContours.Length; i++)
            {
                cv.Point[] nextContour = Cv2.ApproxPolyDP(allContours[i], 3, true);
                if (nextContour.Length > 2)
                {
                    contours.Add(nextContour);
                }
            }
            Cv2.DrawContours(dst3, contours, -1, new Scalar(0, 255, 255), vbc.task.lineWidth, vbc.task.lineType);
        }
    }




    public class ApproxPoly_Hull_CS : VB_Parent
    {
        Hull_Basics hull = new Hull_Basics();
        ApproxPoly_Basics aPoly = new ApproxPoly_Basics();
        public ApproxPoly_Hull_CS()
        {
            hull.useRandomPoints = true;
            labels = new string[] { "", "", "Original Hull", "Hull after ApproxPoly" };
            desc = "Use ApproxPolyDP on a hull to show impact of options (which appears to be minimal - what is wrong?)";
        }
        public void RunAlg(Mat src)
        {
            hull.Run(src);
            dst2 = hull.dst2;

            aPoly.Run(dst2);
            dst3 = aPoly.dst2;
        }
    }




    public class Area_MinTriangle_CPP_CS : VB_Parent
    {
        public Mat triangle;
        public Options_MinArea options = new Options_MinArea();
        public List<cv.Point2f> srcPoints;

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void MinTriangle_Run(IntPtr inputPtr, int numberOfPoints, IntPtr outputTriangle);

        public Area_MinTriangle_CPP_CS()
        {
            desc = "Find minimum containing triangle for a set of points.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                srcPoints = new List<cv.Point2f>(options.srcPoints);
            }
            else
            {
                if (srcPoints.Count < 3) return; // not enough points
            }

            float[] dataSrc = new float[srcPoints.Count * Marshal.SizeOf<int>() * 2];
            float[] dstData = new float[3 * Marshal.SizeOf<int>() * 2];

            dst2.SetTo(Scalar.White);

            Mat input = cv.Mat.FromPixelData(srcPoints.Count, 1, MatType.CV_32FC2, srcPoints.ToArray());
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            GCHandle srcHandle = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            GCHandle dstHandle = GCHandle.Alloc(dstData, GCHandleType.Pinned);
            MinTriangle_Run(srcHandle.AddrOfPinnedObject(), srcPoints.Count, dstHandle.AddrOfPinnedObject());
            srcHandle.Free();
            dstHandle.Free();
            triangle = cv.Mat.FromPixelData(3, 1, MatType.CV_32FC2, dstData);

            for (int i = 0; i <= 2; i++)
            {
                cv.Point2f pt = triangle.At<cv.Point2f>(i);
                cv.Point p1 = new cv.Point(pt.X, pt.Y);
                pt = triangle.At<cv.Point2f>((i + 1) % 3);
                cv.Point p2 = new cv.Point(pt.X, pt.Y);
                DrawLine(dst2, p1, p2, Scalar.Black, vbc.task.lineWidth);
            }

            foreach (var ptSrc in srcPoints)
            {
                var pt = new cv.Point(ptSrc.X, ptSrc.Y);
                DrawCircle(dst2, pt, vbc.task.DotSize + 1, Scalar.Red);
            }
        }
    }




    public class Annealing_Basics_CPP_CS : VB_Parent
    {
        public int numberOfCities = 25;
        public Point2f[] cityPositions;
        public int[] cityOrder;
        public float energy;
        public double energyLast;
        public bool circularPattern = true;

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Annealing_Basics_Open(IntPtr cityPositions, int numberOfCities);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Annealing_Basics_Close(IntPtr saPtr);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Annealing_Basics_Run(IntPtr saPtr, IntPtr cityOrder, int numberOfCities);
        public void drawMap()
        {
            dst2.SetTo(Scalar.Black);
            for (int i = 0; i < cityOrder.Length; i++)
            {
                DrawCircle(dst2, cityPositions[i], vbc.task.DotSize, Scalar.White);
                DrawLine(dst2, cityPositions[i], cityPositions[cityOrder[i]], Scalar.White);
            }
            SetTrueText("Energy" + "\n" + energy.ToString(vbc.fmt0), new cv.Point(10, 100), 2);
        }

        public void setup()
        {
            cityOrder = new int[numberOfCities];

            double radius = dst2.Rows * 0.45;
            cv.Point center = new cv.Point(dst2.Cols / 2, dst2.Rows / 2);
            if (circularPattern)
            {
                cityPositions = new cv.Point2f[numberOfCities];
                for (int i = 0; i < cityPositions.Length; i++)
                {
                    float theta = msRNG.Next(0, 360);
                    cityPositions[i].X = (float)(radius * Math.Cos(theta) + center.X);
                    cityPositions[i].Y = (float)(radius * Math.Sin(theta) + center.Y);
                    cityOrder[i] = (i + 1) % numberOfCities;
                }
            }
            for (int i = 0; i < cityOrder.Length; i++)
            {
                cityOrder[i] = (i + 1) % numberOfCities;
            }
            dst2 = new Mat(dst2.Size(), MatType.CV_8UC3, Scalar.Black);
        }

        public void Open()
        {
            GCHandle hCityPosition = GCHandle.Alloc(cityPositions, GCHandleType.Pinned);
            cPtr = Annealing_Basics_Open(hCityPosition.AddrOfPinnedObject(), numberOfCities);
            hCityPosition.Free();
        }

        public Annealing_Basics_CPP_CS()
        {
            energy = -1;
            setup();
            Open();
            desc = "Simulated annealing with traveling salesman.  NOTE: No guarantee simulated annealing will find the optimal solution.";
        }

        public void RunAlg(Mat src)
        {
            var saveCityOrder = (int[])cityOrder.Clone();
            GCHandle hCityOrder = GCHandle.Alloc(cityOrder, GCHandleType.Pinned);
            IntPtr outPtr = Annealing_Basics_Run(cPtr, hCityOrder.AddrOfPinnedObject(), cityPositions.Length);
            hCityOrder.Free();

            string msg = Marshal.PtrToStringAnsi(outPtr);
            string[] split = Regex.Split(msg, @"\W+");
            energy = float.Parse(split[split.Length - 2] + "." + split[split.Length - 1]);
            if (standaloneTest())
            {
                if (energyLast == energy || vbc.task.optionsChanged)
                {
                    Annealing_Basics_Close(cPtr);
                    setup();
                    Open();
                }
                energyLast = energy;
            }

            drawMap();
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Annealing_Basics_Close(cPtr);
        }
    }




    public class Annealing_MT_CPP_CS : VB_Parent
    {
        Options_Annealing options = new Options_Annealing();
        Random_Basics_CS random;
        Annealing_Basics_CPP_CS[] anneal;
        Mat_4to1_CS mats;
        DateTime startTime;
        void setup()
        {
            random.options.count = options.cityCount;
            random.Run(empty); // get the city positions (may or may not be used below.)

            for (int i = 0; i < anneal.Length; i++)
            {
                anneal[i] = new Annealing_Basics_CPP_CS();
                anneal[i].numberOfCities = options.cityCount;
                anneal[i].cityPositions = random.PointList.ToArray();
                anneal[i].circularPattern = options.circularFlag;
                anneal[i].setup();
                anneal[i].Open(); // this will initialize the C++ copy of the city positions.
            }

            TimeSpan timeSpent = DateTime.Now.Subtract(startTime);
            if (timeSpent.TotalSeconds < 10000)
            {
                Debug.WriteLine("time spent on last problem = " + timeSpent.TotalSeconds.ToString("0.00") + " seconds.");
            }
            startTime = DateTime.Now;
        }

        public Annealing_MT_CPP_CS()
        {
            mats = new Mat_4to1_CS();
            random = new Random_Basics_CS();
            anneal = new Annealing_Basics_CPP_CS[Environment.ProcessorCount / 2];
            labels = new string[] { "", "", "Top 2 are best solutions, bottom 2 are worst.", "Log of Annealing progress" };
            desc = "Setup and control finding the optimal route for a traveling salesman";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged) setup();

            Parallel.For(0, anneal.Length, i =>
            {
                anneal[i].Run(src);
            });

            // find the best result and start all the others with it.
            SortedList<double, int> bestList = new SortedList<double, int>(new compareAllowIdenticalDouble());
            strOut = "";
            for (int i = 0; i < anneal.Length; i++)
            {
                bestList.Add(anneal[i].energy, i);
                if (i % 2 == 0)
                {
                    strOut += "CPU=" + i.ToString("00") + " energy=" + anneal[i].energy.ToString("0") + "\t";
                }
                else
                {
                    strOut += "CPU=" + i.ToString("00") + " energy=" + anneal[i].energy.ToString("0") + "\n";
                }
            }
            SetTrueText(strOut, new cv.Point(10, 10), 3);

            mats.mat[0] = anneal[bestList.ElementAt(0).Value].dst2;
            if (bestList.Count >= 2)
            {
                mats.mat[1] = anneal[bestList.ElementAt(1).Value].dst2;
                mats.mat[2] = anneal[bestList.ElementAt(bestList.Count - 2).Value].dst2;
                mats.mat[3] = anneal[bestList.ElementAt(bestList.Count - 1).Value].dst2;
            }
            mats.Run(empty);
            dst2 = mats.dst2;

            // copy the top half of the solutions to the bottom half (worst solutions)
            if (options.copyBestFlag)
            {
                for (int i = 0; i < anneal.Length / 2; i++)
                {
                    anneal[bestList.ElementAt(bestList.Count - 1 - i).Value].cityOrder = anneal[bestList.ElementAt(i).Value].cityOrder;
                }
            }

            // if the top X are all the same energy, then we are done.
            int workingCount = 0, successCounter = 0;
            for (int i = 0; i < anneal.Length; i++)
            {
                int index = bestList.ElementAt(i).Value;
                if (anneal[index].energy != anneal[index].energyLast)
                {
                    anneal[index].energyLast = anneal[index].energy;
                    workingCount++;
                }
                else
                {
                    successCounter++;
                }
            }
            labels[3] = $"There are {workingCount} threads working in parallel.";
            if (successCounter >= options.successCount) setup();
        }
    }




    public class Area_MinMotionRect_CS : VB_Parent
    {
        BGSubtract_Basics bgSub = new BGSubtract_Basics();

        public Area_MinMotionRect_CS()
        {
            desc = "Use minRectArea to encompass detected motion";
            labels[2] = "MinRectArea of MOG motion";
        }

        Mat motionRectangles(Mat gray, Vec3b[] colors)
        {
            cv.Point[][] contours;
            contours = Cv2.FindContoursAsArray(gray, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);

            for (int i = 0; i < contours.Length; i++)
            {
                RotatedRect minRect = Cv2.MinAreaRect(contours[i]);
                Scalar nextColor = new Scalar(colors[i % 256].Item0, colors[i % 256].Item1, colors[i % 256].Item2);
                DrawRotatedRect(minRect, gray, nextColor);
            }
            return gray;
        }

        public void RunAlg(Mat src)
        {
            bgSub.Run(src);
            Mat gray;
            if (bgSub.dst2.Channels() == 1)
                gray = bgSub.dst2;
            else
                gray = bgSub.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            dst2 = motionRectangles(gray, vbc.task.vecColors);
            dst2.SetTo(Scalar.All(255), gray);
        }
    }




    public class Area_FindNonZero_CS : VB_Parent
    {
        public Mat nonZero;
        public Area_FindNonZero_CS()
        {
            labels[2] = "Coordinates of non-zero points";
            labels[3] = "Non-zero original points";
            desc = "Use FindNonZero API to get coordinates of non-zero points.";
        }

        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                src = new Mat(src.Size(), MatType.CV_8U, Scalar.All(0));
                cv.Point[] srcPoints = new cv.Point[100]; // doesn't really matter how many there are.
                Random msRNG = new Random();
                for (int i = 0; i < srcPoints.Length; i++)
                {
                    srcPoints[i].X = msRNG.Next(0, src.Width);
                    srcPoints[i].Y = msRNG.Next(0, src.Height);
                    src.Set<byte>(srcPoints[i].Y, srcPoints[i].X, 255);
                }
            }
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            nonZero = src.FindNonZero();

            dst3 = new Mat(src.Size(), MatType.CV_8U, Scalar.All(0));
            // mark the points so they are visible...
            for (int i = 0; i < nonZero.Rows; i++)
            {
                cv.Point pt = nonZero.At<cv.Point>(i);
                Cv2.Circle(dst3, pt, vbc.task.DotSize, Scalar.White);
            }

            string outstr = "Coordinates of the non-zero points (ordered by row - top to bottom): \n\n";
            for (int i = 0; i < nonZero.Rows; i++)
            {
                cv.Point pt = nonZero.At<cv.Point>(i);
                outstr += "X = \t" + pt.X + "\t y = \t" + pt.Y + "\n";
                if (i > 100) break; // for when there are way too many points found...
            }
            SetTrueText(outstr);
        }
    }




    public class Area_SoloPoints_CS : VB_Parent
    {
        BackProject_SoloTop hotTop = new BackProject_SoloTop();
        BackProject_SoloSide hotSide = new BackProject_SoloSide();
        Area_FindNonZero nZero = new Area_FindNonZero();
        public List<cv.Point> soloPoints = new List<cv.Point>();

        public Area_SoloPoints_CS()
        {
            desc = "Find the solo points in the pointcloud histograms for top and side views.";
        }

        public void RunAlg(Mat src)
        {
            hotTop.Run(src);
            dst2 = hotTop.dst3;

            hotSide.Run(src);
            dst2 = dst2 | hotSide.dst3;

            nZero.Run(dst2);
            soloPoints.Clear();
            for (int i = 0; i < nZero.nonZero.Rows; i++)
            {
                soloPoints.Add(nZero.nonZero.At<cv.Point>(i, 0));
            }

            if (vbc.task.heartBeat)
            {
                labels[2] = $"There were {soloPoints.Count} points found";
            }
        }
    }




    public class Area_MinRect_CS : VB_Parent
    {
        public RotatedRect minRect;
        Options_MinArea options = new Options_MinArea();
        public List<cv.Point2f> inputPoints = new List<cv.Point2f>();

        public Area_MinRect_CS()
        {
            desc = "Find minimum containing rectangle for a set of points.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (!vbc.task.heartBeat) return;
                options.RunOpt();
                inputPoints = quickRandomPoints(options.numPoints);
            }

            minRect = Cv2.MinAreaRect(inputPoints.ToArray());

            if (standaloneTest())
            {
                dst2.SetTo(Scalar.Black);
                foreach (var pt in inputPoints)
                {
                    DrawCircle(dst2, pt, vbc.task.DotSize + 2, Scalar.Red);
                }
                DrawRotatedOutline(minRect, dst2, Scalar.Yellow);
            }
        }
    }




    public class AsciiArt_Basics_CS : VB_Parent
    {
        string[] asciiChars = { "@", "%", "#", "*", "+", "=", "-", ":", ",", ".", " " };
        Options_AsciiArt options = new Options_AsciiArt();

        public AsciiArt_Basics_CS()
        {
            UpdateAdvice(traceName + ": use the local options for height and width.");
            labels = new string[] { "", "", "Ascii version", "Grayscale input to ascii art" };
            desc = "Build an ascii art representation of the input stream.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst3 = src.CvtColor(ColorConversionCodes.BGR2GRAY).Resize(options.size, 0, 0, InterpolationFlags.Nearest);
            for (int y = 0; y < dst3.Height; y++)
            {
                for (int x = 0; x < dst3.Width; x++)
                {
                    byte grayValue = dst3.At<byte>(y, x);
                    string asciiChar = asciiChars[grayValue * (asciiChars.Length - 1) / 255];
                    SetTrueText(asciiChar, new cv.Point(x * options.wStep, y * options.hStep), 2);
                }
            }
            labels[2] = "Ascii version using " + (dst3.Height * dst3.Width).ToString("N0") + " characters";
        }
    }




    public class AsciiArt_Color_CS : VB_Parent
    {
        public AsciiArt_Color_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "A palette'd version of the ascii art data";
        }

        public void RunAlg(Mat src)
        {
            int hStep = src.Height / 31 - 1;
            int wStep = src.Width / 55 - 1;
            cv.Size size = new cv.Size(55, 31);
            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY).Resize(size, 0, 0, InterpolationFlags.Nearest);
            double grayRatio = 12.0 / 255;

            for (int y = 0; y < dst1.Height; y++)
            {
                for (int x = 0; x < dst1.Width; x++)
                {
                    cv.Rect r = new cv.Rect(x * wStep, y * hStep, wStep - 1, hStep - 1);
                    int asciiChar = (int)(dst1.At<byte>(y, x) * grayRatio);
                    dst3[r].SetTo(asciiChar);
                }
            }

            dst2 = ShowPalette(dst3 / grayRatio);
        }
    }




    public class AsciiArt_Diff_CS : VB_Parent
    {
        AsciiArt_Color_CS colorAA;
        Diff_Basics_CS diff;

        public AsciiArt_Diff_CS()
        {
            labels = new string[] { "", "", "Ascii Art colorized", "Difference from previous frame" };
            diff = new Diff_Basics_CS();
            colorAA = new AsciiArt_Color_CS();
            desc = "Display the instability in image pixels.";
        }

        public void RunAlg(Mat src)
        {
            colorAA.Run(src);
            dst2 = colorAA.dst2;

            diff.Run(dst2.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst3 = diff.dst2;
        }
    }




    public class BackProject_Basics_CS : VB_Parent
    {
        public Hist_Kalman histK = new Hist_Kalman();
        public Scalar minRange, maxRange;

        public BackProject_Basics_CS()
        {
            labels[2] = "Move mouse to backproject a histogram column";
            UpdateAdvice(traceName + ": the global option 'Histogram Bins' controls the histogram.");
            desc = "Mouse over any bin to see the histogram backprojected.";
        }

        public void RunAlg(Mat src)
        {
            Mat input = src.Clone();
            if (input.Channels() != 1)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);

            histK.Run(input);
            if (histK.hist.mm.minVal == histK.hist.mm.maxVal)
            {
                SetTrueText("The input image is empty - mm.minVal and mm.maxVal are both zero...");
                return;
            }

            dst2 = histK.dst2;

            long totalPixels = dst2.Total(); // assume we are including zeros.
            if (histK.hist.plot.removeZeroEntry)
                totalPixels = input.CountNonZero();

            double brickWidth = dst2.Width / vbc.task.histogramBins;
            double incr = (histK.hist.mm.maxVal - histK.hist.mm.minVal) / vbc.task.histogramBins;
            int histIndex = (int)Math.Floor(vbc.task.mouseMovePoint.X / brickWidth);

            minRange = new Scalar(histIndex * incr);
            maxRange = new Scalar((histIndex + 1) * incr);
            if (histIndex + 1 == vbc.task.histogramBins)
                maxRange = new Scalar(255);

            // For single dimension histograms, backprojection is the same as inRange (and this works for backproject_FeatureLess below)
            dst0 = input.InRange(minRange, maxRange);

            int actualCount = dst0.CountNonZero();
            dst3 = vbc.task.color.Clone();
            dst3.SetTo(Scalar.Yellow, dst0);
            float count = histK.hist.histogram.Get<float>(histIndex, 0);
            mmData histMax = GetMinMax(histK.hist.histogram);
            labels[3] = $"Backprojecting {minRange.Val0} to {maxRange.Val0} with {count} of {totalPixels} compared to " +
                        $"mask pixels = {actualCount}.  Histogram max count = {histMax.maxVal}";
            dst2.Rectangle(new cv.Rect((int)(histIndex * brickWidth), 0, (int)brickWidth, dst2.Height), Scalar.Yellow, vbc.task.lineWidth);
        }
    }




    public class BackProject_Full_CS : VB_Parent
    {
        public int classCount;

        public BackProject_Full_CS()
        {
            labels = new string[] { "", "", "CV_8U format of the backprojection", "dst2 presented with a palette" };
            desc = "Create a color histogram, normalize it, and backproject it with a palette.";
        }

        public void RunAlg(Mat src)
        {
            classCount = vbc.task.histogramBins;
            if (src.Channels() == 3)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            src.ConvertTo(dst1, MatType.CV_32F);
            Mat histogram = new Mat();
            Rangef[] ranges = new Rangef[] { new Rangef(0, 255) };
            Cv2.CalcHist(new Mat[] { dst1 }, new int[] { 0 }, new Mat(), histogram, 1, new int[] { classCount }, ranges);
            histogram = histogram.Normalize(0, classCount, NormTypes.MinMax);

            Cv2.CalcBackProject(new Mat[] { dst1 }, new int[] { 0 }, histogram, dst2, ranges);

            dst2.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2 * 255 / classCount);
        }
    }




    public class BackProject_Reduction_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        BackProject_Basics backP = new BackProject_Basics();

        public BackProject_Reduction_CS()
        {
            vbc.task.redOptions.checkSimpleReduction(true);
            labels[3] = "Backprojection of highlighted histogram bin";
            desc = "Use the histogram of a reduced BGR image to isolate featureless portions of an image.";
        }

        public void RunAlg(Mat src)
        {
            reduction.Run(src);

            backP.Run(reduction.dst2);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
            int reductionValue = vbc.task.redOptions.SimpleReduction;
            labels[2] = "Reduction = " + reductionValue.ToString() + " and bins = " + vbc.task.histogramBins.ToString();
        }
    }




    public class BackProject_FeatureLess_CS : VB_Parent
    {
        BackProject_Basics backP = new BackProject_Basics();
        Reduction_Basics reduction = new Reduction_Basics();
        Edge_ColorGap_CPP_VB edges = new Edge_ColorGap_CPP_VB();

        public BackProject_FeatureLess_CS()
        {
            vbc.task.redOptions.checkBitReduction(true);
            labels = new string[] { "", "", "Histogram of the grayscale image at right",
                                "Move mouse over the histogram to backproject a column" };
            desc = "Create a histogram of the featureless regions";
        }

        public void RunAlg(Mat src)
        {
            edges.Run(src);
            reduction.Run(edges.dst3);
            backP.Run(reduction.dst2);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
            int reductionValue = vbc.task.redOptions.SimpleReduction;
            labels[2] = "Reduction = " + reductionValue.ToString() + " and bins = " + vbc.task.histogramBins.ToString();
        }
    }




    public class BackProject_BasicsKeyboard_CS : VB_Parent
    {
        Keyboard_Basics keys = new Keyboard_Basics();
        BackProject_Image backP = new BackProject_Image();
        public BackProject_BasicsKeyboard_CS()
        {
            labels[2] = "Move the mouse away from OpenCVB and use the left and right arrows to move between histogram bins.";
            desc = "Move the mouse off of OpenCVB and then use the left and right arrow keys move around in the backprojection histogram";
        }
        public void RunAlg(Mat src)
        {
            keys.Run(src);
            List<string> keyIn = new List<string>(keys.keyInput);
            int incrX = dst1.Width / vbc.task.histogramBins;

            if (keyIn.Count > 0)
            {
                vbc.task.mouseMovePointUpdated = true;
                for (int i = 0; i < keyIn.Count; i++)
                {
                    switch (keyIn[i])
                    {
                        case "Left":
                            vbc.task.mouseMovePoint.X -= incrX;
                            break;
                        case "Right":
                            vbc.task.mouseMovePoint.X += incrX;
                            break;
                    }
                }
            }

            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;

            // this is intended to provide a natural behavior for the left and right arrow keys.  The Keyboard_Basics Keyboard Options text box must be active.
            if (vbc.task.heartBeat)
            {
                IntPtr hwnd = FindWindow(null, "OpenCVB Algorithm Options");
                SetForegroundWindow(hwnd);
            }
        }

        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll", SetLastError = true)]
        static extern bool SetForegroundWindow(IntPtr hWnd);
    }




    public class BackProject_FullLines_CS : VB_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        Line_Basics lines = new Line_Basics();

        public BackProject_FullLines_CS()
        {
            labels = new string[] { "", "", "Lines found in the back projection", "Backprojection results" };
            desc = "Find lines in the back projection";
        }

        public void RunAlg(Mat src)
        {
            backP.Run(src);
            dst3 = backP.dst3;

            lines.Run(backP.dst2);
            dst2 = lines.dst2;
            labels[3] = lines.lpList.Count.ToString() + " lines were found";
        }
    }




    public class BackProject_PointCloud_CS : VB_Parent
    {
        public Hist_PointCloud hist = new Hist_PointCloud();
        public BackProject_PointCloud_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_32FC3, Scalar.All(0));
            labels = new string[] { "", "", "Backprojection after histogram binning X and Z values", "Backprojection after histogram binning Y and Z values" };
            desc = "Explore Backprojection of the cloud histogram.";
        }

        public void RunAlg(Mat src)
        {
            hist.Run(src);

            dst0 = hist.dst2.Threshold(hist.options.threshold, 255, ThresholdTypes.Binary);
            dst1 = hist.dst3.Threshold(hist.options.threshold, 255, ThresholdTypes.Binary);

            dst2 = new Mat(hist.dst2.Size(), MatType.CV_32F, Scalar.All(0));
            dst3 = new Mat(hist.dst3.Size(), MatType.CV_32F, Scalar.All(0));

            Mat mask = new Mat();
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, new int[] { 0, 2 }, dst0, mask, hist.rangesX);
            mask.ConvertTo(mask, MatType.CV_8U);
            vbc.task.pointCloud.CopyTo(dst2, mask);

            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, new int[] { 1, 2 }, dst1, mask, hist.rangesY);
            mask.ConvertTo(mask, MatType.CV_8U);
            vbc.task.pointCloud.CopyTo(dst3, mask);
        }
    }




    public class BackProject_Display_CS : VB_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        public BackProject_Display_CS()
        {
            labels = new string[] { "", "", "Back projection", "" };
            desc = "Display the back projected color image";
        }

        public void RunAlg(Mat src)
        {
            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
        }
    }




    public class BackProject_Unstable_CS : VB_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        Diff_Basics diff = new Diff_Basics();

        public BackProject_Unstable_CS()
        {
            vbc.task.gOptions.pixelDiffThreshold = 6;
            labels = new string[] { "", "", "Backprojection output", "Unstable pixels in the backprojection. If flashing, set 'Pixel Difference Threshold' higher." };
            desc = "Highlight the unstable pixels in the backprojection.";
        }

        public void RunAlg(Mat src)
        {
            backP.Run(src);
            dst2 = ShowPalette(backP.dst2 * 255 / backP.classCount);

            diff.Run(dst2);
            dst3 = diff.dst2;
        }
    }




    public class BackProject_FullEqualized_CS : VB_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        Hist_EqualizeColor equalize = new Hist_EqualizeColor();

        public BackProject_FullEqualized_CS()
        {
            labels = new string[] { "", "", "BackProject_Full output without equalization", "BackProject_Full with equalization" };
            desc = "Create a histogram from the equalized color and then backproject it.";
        }

        public void RunAlg(Mat src)
        {
            backP.Run(src);
            backP.dst2.ConvertTo(dst2, MatType.CV_8U);
            var mm = GetMinMax(dst2);
            dst2 = ShowPalette(dst2 * 255 / mm.maxVal);

            equalize.Run(src);
            backP.Run(equalize.dst2);

            backP.dst2.ConvertTo(dst3, MatType.CV_8U);
            mm = GetMinMax(dst3);
            dst3 = ShowPalette(dst3 * 255 / mm.maxVal);
        }
    }




    public class BackProject_MaskLines_CS : VB_Parent
    {
        BackProject_Masks_CS masks;
        Line_Basics_CS lines;
        public BackProject_MaskLines_CS()
        {
            masks = new BackProject_Masks_CS();
            lines = new Line_Basics_CS();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            labels = new string[] { "", "lines detected in the backProjection mask", "Histogram of pixels in a grayscale image.  Move mouse to see lines detected in the backprojection mask",
                                "Yellow is backProjection, lines detected are highlighted" };
            desc = "Inspect the lines from individual backprojection masks from a histogram";
        }

        public void RunAlg(Mat src)
        {
            masks.Run(src);
            dst2 = masks.dst2;
            dst3 = src.Clone();

            if (vbc.task.heartBeat)
                dst1.SetTo(Scalar.All(0));

            lines.Run(masks.mask);
            foreach (var lp in lines.lpList)
            {
                byte val = masks.dst3.At<byte>((int)lp.p1.Y, (int)lp.p1.X);
                if (val == 255)
                    DrawLine(dst1, lp.p1, lp.p2, Scalar.White, vbc.task.lineWidth);
            }
            dst3.SetTo(Scalar.Yellow, masks.mask);
            dst3.SetTo(vbc.task.HighlightColor, dst1);
        }
    }




    public class BackProject_Masks_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public int histIndex;
        public Mat mask = new Mat();

        public BackProject_Masks_CS()
        {
            labels[2] = "Histogram for the gray scale image.  Move mouse to see backprojection of each grayscale mask.";
            desc = "Create all the backprojection masks from a grayscale histogram";
        }

        public Mat maskDetect(Mat gray, int histIndex)
        {
            int brickWidth = dst2.Width / hist.histogram.Rows;
            float brickRange = 255f / hist.histogram.Rows;

            float minRange = (histIndex == hist.histogram.Rows - 1) ? 255 - brickRange : histIndex * brickRange;
            float maxRange = (histIndex == hist.histogram.Rows - 1) ? 255 : (histIndex + 1) * brickRange;

            if (float.IsNaN(minRange) || float.IsInfinity(minRange) || float.IsNaN(maxRange) || float.IsInfinity(maxRange))
            {
                SetTrueText("Input data has no values - exit " + traceName);
                return new Mat();
            }

            Rangef[] ranges = { new Rangef(minRange, maxRange) };

            Cv2.CalcBackProject(new[] { gray }, new[] { 0 }, hist.histogram, mask, ranges);
            return mask;
        }

        public void RunAlg(Mat src)
        {
            hist.Run(src);
            dst2 = hist.dst2;

            int brickWidth = dst2.Width / vbc.task.histogramBins;
            histIndex = (int)Math.Floor((double)(vbc.task.mouseMovePoint.X / brickWidth));

            Mat gray = (src.Channels() == 1) ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = vbc.task.color.Clone();
            dst1 = maskDetect(gray, histIndex);
            if (dst1.Width == 0) return;
            dst3.SetTo(Scalar.White, dst1);
            dst2.Rectangle(new cv.Rect(histIndex * brickWidth, 0, brickWidth, dst2.Height), Scalar.Yellow, vbc.task.lineWidth);
        }
    }




    public class BackProject_Side_CS : VB_Parent
    {
        OpAuto_YRange autoY = new OpAuto_YRange();
        Projection_HistSide histSide = new Projection_HistSide();

        public BackProject_Side_CS()
        {
            labels = new string[] { "", "", "Hotspots in the Side View", "Back projection of the hotspots in the Side View" };
            desc = "Display the back projection of the hotspots in the Side View";
        }

        public void RunAlg(Mat src)
        {
            histSide.Run(src);
            autoY.Run(histSide.histogram);

            dst2 = autoY.histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            Mat histogram = autoY.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, histogram, dst3, vbc.task.rangesSide);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class BackProject_Top_CS : VB_Parent
    {
        Projection_HistTop histTop = new Projection_HistTop();
        public BackProject_Top_CS()
        {
            labels = new string[] { "", "", "Hotspots in the Top View", "Back projection of the hotspots in the Top View" };
            desc = "Display the back projection of the hotspots in the Top View";
        }

        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            dst2 = histTop.dst2;

            Mat histogram = histTop.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, histogram, dst3, vbc.task.rangesTop);
            dst3 = ShowPalette(dst3.ConvertScaleAbs());
        }
    }




    public class BackProject_Horizontal_CS : VB_Parent
    {
        BackProject_Top bpTop = new BackProject_Top();
        BackProject_Side bpSide = new BackProject_Side();

        public BackProject_Horizontal_CS()
        {
            desc = "Use both the BackProject_Top to improve the results of the BackProject_Side for finding flat surfaces.";
        }

        public void RunAlg(Mat src)
        {
            bpTop.Run(src);
            vbc.task.pointCloud.SetTo(0, bpTop.dst3);

            bpSide.Run(src);
            dst2 = bpSide.dst3;
        }
    }




    public class BackProject_Vertical_CS : VB_Parent
    {
        BackProject_Top bpTop = new BackProject_Top();
        BackProject_Side bpSide = new BackProject_Side();

        public BackProject_Vertical_CS()
        {
            desc = "Use both the BackProject_Top to improve the results of the BackProject_Side for finding flat surfaces.";
        }

        public void RunAlg(Mat src)
        {
            bpSide.Run(src);
            vbc.task.pointCloud.SetTo(0, bpSide.dst3);

            bpTop.Run(src);
            dst2 = bpTop.dst3;
        }
    }




    public class BackProject_SoloSide_CS : VB_Parent
    {
        Projection_HistSide histSide = new Projection_HistSide();

        public BackProject_SoloSide_CS()
        {
            labels = new string[] { "", "", "Solo samples in the Side View", "Back projection of the solo samples in the Side View" };
            desc = "Display the back projection of the solo samples in the Side View";
        }

        public void RunAlg(Mat src)
        {
            histSide.Run(src);

            dst3 = histSide.histogram.Threshold(1, 255, ThresholdTypes.TozeroInv);
            dst3.ConvertTo(dst2, MatType.CV_8U, 255);

            histSide.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, histSide.histogram, dst3, vbc.task.rangesSide);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class BackProject_SoloTop_CS : VB_Parent
    {
        Projection_HistTop histTop = new Projection_HistTop();

        public BackProject_SoloTop_CS()
        {
            labels = new string[] { "", "", "Solo samples in the Top View", "Back projection of the solo samples in the Top View" };
            desc = "Display the back projection of the solo samples in the Top View";
        }

        public void RunAlg(Mat src)
        {
            histTop.Run(src);

            dst3 = histTop.histogram.Threshold(1, 255, ThresholdTypes.TozeroInv);
            dst3.ConvertTo(dst2, MatType.CV_8U, 255);

            histTop.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, histTop.histogram, dst3, vbc.task.rangesTop);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class BackProject_LineTop_CS : VB_Parent
    {
        Line_ViewTop line = new Line_ViewTop();
        public BackProject_LineTop_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Backproject the lines found in the top view.";
        }

        public void RunAlg(Mat src)
        {
            line.Run(src);

            dst2.SetTo(0);
            int w = vbc.task.lineWidth + 5;
            foreach (var lp in line.lines.lpList)
            {
                var lpNew = lp.edgeToEdgeLine(dst2.Size());
                cv.Point p1 = new cv.Point((int)lpNew.p1.X, (int)lpNew.p1.Y);
                cv.Point p2 = new cv.Point((int)lpNew.p2.X, (int)lpNew.p2.Y);
                dst2.Line(p1, p2, Scalar.White, w, vbc.task.lineType);
            }

            var histogram = line.autoX.histogram;
            histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new[] { vbc.task.pointCloud }, vbc.task.channelsTop, histogram, dst3, vbc.task.rangesTop);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class BackProject_LineSide_CS : VB_Parent
    {
        Line_ViewSide line = new Line_ViewSide();
        public List<PointPair> lpList = new List<PointPair>();

        public BackProject_LineSide_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Backproject the lines found in the side view.";
        }

        public void RunAlg(Mat src)
        {
            line.Run(src);

            dst2.SetTo(0);
            int w = vbc.task.lineWidth + 5;
            lpList.Clear();
            foreach (var lp in line.lines.lpList)
            {
                if (Math.Abs(lp.slope) < 0.1)
                {
                    var lpNew = lp.edgeToEdgeLine(dst2.Size());
                    cv.Point p1 = new cv.Point((int)lpNew.p1.X, (int)lpNew.p1.Y);
                    cv.Point p2 = new cv.Point((int)lpNew.p2.X, (int)lpNew.p2.Y);
                    dst2.Line(p1, p2, Scalar.White, w, vbc.task.lineType);
                    lpList.Add(lp);
                }
            }

            var histogram = line.autoY.histogram;
            histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new[] { vbc.task.pointCloud }, vbc.task.channelsSide, histogram, dst1, vbc.task.rangesSide);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst3 = src;
            dst3.SetTo(Scalar.White, dst1);
        }
    }




    public class BackProject_Image_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public Mat mask = new Mat();
        Kalman_Basics kalman = new Kalman_Basics();
        public bool useInrange;

        public BackProject_Image_CS()
        {
            labels[2] = "Move mouse to backproject each histogram column";
            desc = "Explore Backprojection of each element of a grayscale histogram.";
        }

        public void RunAlg(Mat src)
        {
            Mat input = src;
            if (input.Channels() != 1)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(input);
            if (hist.mm.minVal == hist.mm.maxVal)
            {
                SetTrueText("The input image is empty - mm.minval and mm.maxVal are both zero...");
                return; // the input image is empty...
            }
            dst2 = hist.dst2;

            if (kalman.kInput.Length != 2)
                Array.Resize(ref kalman.kInput, 2);
            kalman.kInput[0] = (float)hist.mm.minVal;
            kalman.kInput[1] = (float)hist.mm.maxVal;
            kalman.Run(empty);
            hist.mm.minVal = Math.Min(kalman.kOutput[0], kalman.kOutput[1]);
            hist.mm.maxVal = Math.Max(kalman.kOutput[0], kalman.kOutput[1]);

            double totalPixels = dst2.Total(); // assume we are including zeros.
            if (hist.plot.removeZeroEntry)
                totalPixels = input.CountNonZero();

            double brickWidth = dst2.Width / vbc.task.histogramBins;
            double incr = (hist.mm.maxVal - hist.mm.minVal) / vbc.task.histogramBins;
            int histIndex = (int)Math.Round(vbc.task.mouseMovePoint.X / brickWidth);

            Scalar minRange = new Scalar(histIndex * incr);
            Scalar maxRange = new Scalar((histIndex + 1) * incr + 1);
            if (histIndex + 1 == vbc.task.histogramBins)
            {
                minRange = new Scalar(254);
                maxRange = new Scalar(255);
            }
            if (useInrange)
            {
                if (histIndex == 0 && hist.plot.removeZeroEntry)
                    mask = new Mat(input.Size(), MatType.CV_8U, cv.Scalar.All(0));
                else
                    mask = input.InRange(minRange, maxRange);
            }
            else
            {
                Rangef bRange = new Rangef((float)minRange.Val0, (float)maxRange.Val0);
                Rangef[] ranges = { bRange };
                Cv2.CalcBackProject(new[] { input }, new[] { 0 }, hist.histogram, mask, ranges);
            }
            dst3 = src;
            if (mask.Type() != MatType.CV_8U)
                mask.ConvertTo(mask, MatType.CV_8U);
            dst3.SetTo(Scalar.Yellow, mask);
            int actualCount = mask.CountNonZero();
            float count = hist.histogram.Get<float>(histIndex, 0);
            mmData histMax = GetMinMax(hist.histogram);
            labels[3] = "Backprojecting " + ((int)minRange.Val0).ToString() + " to " + ((int)maxRange.Val0).ToString() + " with " +
                         count.ToString() + " histogram samples and " + actualCount.ToString() + " mask count.  Histogram max count = " +
                         ((int)histMax.maxVal).ToString();
            dst2.Rectangle(new cv.Rect((int)(histIndex * brickWidth), 0, (int)brickWidth, dst2.Height), Scalar.Yellow, vbc.task.lineWidth);
        }
    }




    public class BackProject_Mouse_CS : VB_Parent
    {
        BackProject_Image_CS backP;
        public BackProject_Mouse_CS()
        {
            backP = new BackProject_Image_CS();
            labels[2] = "Use the mouse to select what should be shown in the backprojection of the depth histogram";
            desc = "Use the mouse to select what should be shown in the backprojection of the depth histogram";
        }
        public void RunAlg(Mat src)
        {
            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
        }
    }




    public class BackProject_Depth_CS : VB_Parent
    {
        BackProject_Image_CS backp;
        public BackProject_Depth_CS()
        {
            backp = new BackProject_Image_CS();
            desc = "Allow review of the depth backprojection";
        }
        public void RunAlg(Mat src)
        {
            var depth = vbc.task.pcSplit[2].Threshold(vbc.task.MaxZmeters, 255, ThresholdTypes.TozeroInv);
            backp.Run(depth * 1000);
            dst2 = backp.dst2;
            dst3 = src;
            dst3.SetTo(Scalar.White, backp.mask);
        }
    }




    public class BackProject_MeterByMeter_CS : VB_Parent
    {
        Mat histogram = new Mat();
        public BackProject_MeterByMeter_CS()
        {
            desc = "Backproject the depth data at 1 meter intervals WITHOUT A HISTOGRAM.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.histogramBins < vbc.task.MaxZmeters) vbc.task.gOptions.setHistogramBins((int)vbc.task.MaxZmeters + 1);
            if (vbc.task.optionsChanged)
            {
                var incr = vbc.task.MaxZmeters / vbc.task.histogramBins;
                var histData = new List<float>();
                for (int i = 0; i < vbc.task.histogramBins; i++)
                {
                    histData.Add((float)Math.Round(i * incr));
                }

                histogram = cv.Mat.FromPixelData(vbc.task.histogramBins, 1, MatType.CV_32F, histData.ToArray());
            }
            var ranges = new[] { new Rangef(0, vbc.task.MaxZmeters) };
            Cv2.CalcBackProject(new[] { vbc.task.pcSplit[2] }, new[] { 0 }, histogram, dst1, ranges);

            //dst1.SetTo(vbc.task.MaxZmeters, vbc.task.maxDepthMask);
            dst1.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst1);
        }
    }




    public class BackProject_Hue_CS : VB_Parent
    {
        OEX_CalcBackProject_Demo1 hue = new OEX_CalcBackProject_Demo1();
        public int classCount;
        public BackProject_Hue_CS()
        {
            desc = "Create an 8UC1 image with a backprojection of the hue.";
        }
        public void RunAlg(Mat src)
        {
            hue.Run(src);
            classCount = hue.classCount;
            dst2 = hue.dst2;
            dst3 = ShowPalette(dst2 * 255 / classCount);
        }
    }




    public class Benford_Basics_CS : VB_Parent
    {
        public float[] expectedDistribution = new float[10];
        public float[] counts;
        Plot_Histogram plot = new Plot_Histogram();
        AddWeighted_Basics_CS addW;
        bool use99;

        public Benford_Basics_CS()
        {
            addW = new AddWeighted_Basics_CS();
            for (int i = 1; i < expectedDistribution.Length; i++)
            {
                expectedDistribution[i] = (float)Math.Log10(1 + 1.0 / i); // get the precise expected values.
            }

            labels[3] = "Actual distribution of input";
            desc = "Build the capability to perform a Benford analysis.";
        }

        public void setup99()
        {
            expectedDistribution = new float[100];
            for (int i = 1; i < expectedDistribution.Length; i++)
            {
                expectedDistribution[i] = (float)Math.Log10(1 + 1.0 / i);
            }
            counts = new float[expectedDistribution.Length];
            use99 = true;
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                dst2 = src.Channels() == 1 ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
                src = new Mat(dst2.Size(), MatType.CV_32F);
                dst2.ConvertTo(src, MatType.CV_32F);
            }

            src = src.Reshape(1, src.Width * src.Height);
            var indexer = src.GetGenericIndexer<float>();
            counts = new float[expectedDistribution.Length];

            if (!use99)
            {
                for (int i = 0; i < src.Rows; i++)
                {
                    string val = indexer[i].ToString();
                    if (val != "0" && !float.IsNaN(float.Parse(val)))
                    {
                        var firstInt = Regex.Match(val, "[1-9]{1}");
                        if (firstInt.Length > 0) counts[int.Parse(firstInt.Value)] += 1;
                    }
                }
            }
            else
            {
                // this is for the distribution 10-99
                for (int i = 0; i < src.Rows; i++)
                {
                    string val = indexer[i].ToString();
                    if (val != "0" && !float.IsNaN(float.Parse(val)))
                    {
                        var firstInt = Regex.Match(val, "[1-9]{1}").ToString();
                        int index = val.IndexOf(firstInt);
                        if (index < val.Length - 2 && index > 0)
                        {
                            string val99 = val.Substring(index + 1, 2);
                            if (int.TryParse(val99, out int result)) counts[result] += 1;
                        }
                    }
                }
            }

            Mat hist = cv.Mat.FromPixelData(counts.Length, 1, MatType.CV_32F, counts);
            plot.backColor = Scalar.Blue;
            plot.Run(hist);
            dst3 = plot.dst2.Clone();
            for (int i = 0; i < counts.Length; i++)
            {
                counts[i] = src.Rows * expectedDistribution[i];
            }

            hist = cv.Mat.FromPixelData(counts.Length, 1, MatType.CV_32F, counts);
            plot.backColor = Scalar.Gray;
            plot.Run(hist);

            addW.src2 = ~plot.dst2;
            addW.Run(dst3);
            dst2 = addW.dst2;

            double wt = addW.weight;
            labels[2] = "AddWeighted: " + wt.ToString("0.0") + " actual vs. " + (1 - wt).ToString("0.0") + " Benford distribution";
        }
    }




    public class Benford_NormalizedImage_CS : VB_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public Benford_NormalizedImage_CS()
        {
            desc = "Perform a Benford analysis of an image normalized to between 0 and 1";
        }
        public void RunAlg(Mat src)
        {
            dst3 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            dst3.ConvertTo(gray32f, MatType.CV_32F);

            benford.Run(gray32f.Normalize(1));
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }

    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law




    public class Benford_NormalizedImage99_CS : VB_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public Benford_NormalizedImage99_CS()
        {
            benford.setup99();
            desc = "Perform a Benford analysis for 10-99, not 1-9, of an image normalized to between 0 and 1";
        }
        public void RunAlg(Mat src)
        {
            dst3 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            dst3.ConvertTo(gray32f, MatType.CV_32F);

            benford.Run(gray32f.Normalize(1));
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }





    public class Benford_Depth_CS : VB_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public Benford_Depth_CS()
        {
            desc = "Apply Benford to the depth data";
        }
        public void RunAlg(Mat src)
        {
            benford.Run(vbc.task.pcSplit[2]);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
        }
    }





    public class Benford_Primes_CS : VB_Parent
    {
        Sieve_BasicsVB sieve = new Sieve_BasicsVB();
        Benford_Basics_CS benford;
        public Benford_Primes_CS()
        {
            benford = new Benford_Basics_CS();
            sieve.setMaxPrimes();
            labels = new string[] { "", "", "Actual Distribution of input", "" };
            desc = "Apply Benford to a list of primes";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
                sieve.Run(src); // only need to compute this once...
            SetTrueText($"Primes found: {sieve.primes.Count}", 3);

            var tmp = cv.Mat.FromPixelData(sieve.primes.Count, 1, MatType.CV_32S, sieve.primes.ToArray());
            tmp.ConvertTo(tmp, MatType.CV_32F);
            benford.Run(tmp);
            dst2 = benford.dst2;
        }
    }





    public class Bezier_Basics_CS : VB_Parent
    {
        public cv.Point[] points;

        public Bezier_Basics_CS()
        {
            points = new cv.Point[]
            {
            new cv.Point(100, 100),
            new cv.Point(150, 50),
            new cv.Point(250, 150),
            new cv.Point(300, 100),
            new cv.Point(350, 150),
            new cv.Point(450, 50)
            };
            UpdateAdvice(traceName + ": Update the public points array variable. No exposed options.");
            desc = "Use n points to draw a Bezier curve.";
        }

        public cv.Point nextPoint(cv.Point[] points, int i, float t)
        {
            double x = Math.Pow(1 - t, 3) * points[i].X +
                       3 * t * Math.Pow(1 - t, 2) * points[i + 1].X +
                       3 * Math.Pow(t, 2) * (1 - t) * points[i + 2].X +
                       Math.Pow(t, 3) * points[i + 3].X;

            double y = Math.Pow(1 - t, 3) * points[i].Y +
                       3 * t * Math.Pow(1 - t, 2) * points[i + 1].Y +
                       3 * Math.Pow(t, 2) * (1 - t) * points[i + 2].Y +
                       Math.Pow(t, 3) * points[i + 3].Y;

            return new cv.Point((int)x, (int)y);
        }

        public void RunAlg(Mat src)
        {
            cv.Point p1 = new cv.Point();
            for (int i = 0; i <= points.Length - 4; i += 3)
            {
                for (int j = 0; j <= 100; j++)
                {
                    cv.Point p2 = nextPoint(points, i, j / 100f);
                    if (j > 0) DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                    p1 = p2;
                }
            }
            labels[2] = "Bezier output";
        }
    }




    public class Bezier_Example_CS : VB_Parent
    {
        Bezier_Basics_CS bezier;
        public cv.Point[] points;

        public Bezier_Example_CS()
        {
            bezier = new Bezier_Basics_CS();
            points = new cv.Point[] { new cv.Point(vbc.task.DotSize, vbc.task.DotSize), new cv.Point(dst2.Width / 6, dst2.Width / 6),
                       new cv.Point(dst2.Width * 3 / 4, dst2.Height / 2), new cv.Point(dst2.Width - vbc.task.DotSize * 2,
                       dst2.Height - vbc.task.DotSize * 2)};
            desc = "Draw a Bezier curve based with the 4 input points.";
        }

        public void RunAlg(Mat src)
        {
            dst2.SetTo(Scalar.Black);
            cv.Point p1 = new cv.Point();
            for (int i = 0; i < 100; i++)
            {
                cv.Point p2 = bezier.nextPoint(points, 0, i / 100f);
                if (i > 0) DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                p1 = p2;
            }

            for (int i = 0; i < points.Length; i++)
            {
                DrawCircle(dst2, points[i], vbc.task.DotSize + 2, Scalar.White);
            }

            DrawLine(dst2, points[0], points[1], Scalar.White, vbc.task.lineWidth);
            DrawLine(dst2, points[2], points[3], Scalar.White, vbc.task.lineWidth);
        }
    }





    public class BGRPattern_Basics_CS : VB_Parent
    {
        Denoise_Pixels_CPP_VB denoise = new Denoise_Pixels_CPP_VB();
        Color_Basics colorFmt = new Color_Basics();
        public int classCount;

        public BGRPattern_Basics_CS()
        {
            cPtr = BGRPattern_Open();
            UpdateAdvice(traceName + ": local options 'Options_ColorFormat' selects color.");
            desc = "Classify each 3-channel input pixel according to their relative values";
        }

        public void RunAlg(Mat src)
        {
            colorFmt.Run(src);
            src = colorFmt.dst2;

            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = BGRPattern_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();

            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();

            classCount = BGRPattern_ClassCount(cPtr);
            denoise.classCount = classCount;
            denoise.Run(dst2);
            dst2 = denoise.dst2;

            if (standaloneTest())
            {
                dst2 = dst2 * 255 / classCount;
                dst3 = ShowPalette(dst2);
            }
        }

        public void Close()
        {
            BGRPattern_Close(cPtr);
        }
    }




    public class BGSubtract_Basics_CS : VB_Parent
    {
        public Options_BGSubtract options = new Options_BGSubtract();

        public BGSubtract_Basics_CS()
        {
            cPtr = BGSubtract_BGFG_Open(options.currMethod);
            UpdateAdvice(traceName + ": local options 'Correlation Threshold' controls how well the image matches.");
            desc = "Detect motion using background subtraction algorithms in OpenCV - some only available in C++";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                BGSubtract_BGFG_Close(cPtr);
                cPtr = BGSubtract_BGFG_Open(options.currMethod);
            }

            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = BGSubtract_BGFG_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels(), options.learnRate);
            handleSrc.Free();

            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
            labels[2] = options.methodDesc;
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
            {
                cPtr = BGSubtract_BGFG_Close(cPtr);
            }
        }
    }

    // https://github.com/opencv/opencv_contrib/blob/master/modules/bgsegm/samples/bgfg.cpp




    public class BGSubtract_Basics_QT_CS : VB_Parent
    {
        double learnRate;

        public BGSubtract_Basics_QT_CS()
        {
            learnRate = (dst2.Width >= 1280) ? 0.5 : 0.1; // learn faster with large images (slower frame rate)
            cPtr = BGSubtract_BGFG_Open(4); // MOG2 is the default method when running in QT mode.
            desc = "Detect motion using background subtraction algorithms in OpenCV - some only available in C++";
        }

        public void RunAlg(Mat src)
        {
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = BGSubtract_BGFG_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels(), learnRate);
            handleSrc.Free();

            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
            {
                cPtr = BGSubtract_BGFG_Close(cPtr);
            }
        }
    }




    public class BGSubtract_MOG2_CS : VB_Parent
    {
        BackgroundSubtractorMOG2 MOG2;
        Options_BGSubtract options = new Options_BGSubtract();

        public BGSubtract_MOG2_CS()
        {
            MOG2 = BackgroundSubtractorMOG2.Create();
            desc = "Subtract background using a mixture of Gaussians";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            MOG2.Apply(src, dst2, options.learnRate);
        }
    }





    public class BGSubtract_MOG2_QT_CS : VB_Parent
    {
        BackgroundSubtractorMOG2 MOG2;

        public BGSubtract_MOG2_QT_CS()
        {
            MOG2 = BackgroundSubtractorMOG2.Create();
            desc = "Subtract background using a mixture of Gaussians - the QT version";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            double learnRate = (dst2.Width >= 1280) ? 0.5 : 0.1; // learn faster with large images (slower frame rate)
            MOG2.Apply(src, dst2, learnRate);
        }
    }




    public class BGSubtract_MOG_CS : VB_Parent
    {
        BackgroundSubtractorMOG MOG;
        Options_BGSubtract options = new Options_BGSubtract();
        public BGSubtract_MOG_CS()
        {
            MOG = BackgroundSubtractorMOG.Create();
            desc = "Subtract background using a mixture of Gaussians";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            MOG.Apply(src, dst2, options.learnRate);
        }
    }




    public class BGSubtract_GMG_KNN_CS : VB_Parent
    {
        BackgroundSubtractorGMG gmg;
        BackgroundSubtractorKNN knn;
        Options_BGSubtract options = new Options_BGSubtract();
        public BGSubtract_GMG_KNN_CS()
        {
            gmg = BackgroundSubtractorGMG.Create();
            knn = BackgroundSubtractorKNN.Create();
            desc = "GMG and KNN API's to subtract background";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.frameCount < 120)
            {
                SetTrueText("Waiting to get sufficient frames to learn background.  frameCount = " + vbc.task.frameCount);
            }
            else
            {
                SetTrueText("");
            }

            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            gmg.Apply(dst2, dst2, options.learnRate);
            knn.Apply(dst2, dst2, options.learnRate);
        }
    }




    public class BGSubtract_MOG_RGBDepth_CS : VB_Parent
    {
        public Mat grayMat = new Mat();
        Options_BGSubtract options = new Options_BGSubtract();
        BackgroundSubtractorMOG MOGDepth;
        BackgroundSubtractorMOG MOGRGB;
        public BGSubtract_MOG_RGBDepth_CS()
        {
            MOGDepth = BackgroundSubtractorMOG.Create();
            MOGRGB = BackgroundSubtractorMOG.Create();
            labels = new string[] { "", "", "Unstable depth", "Unstable color (if there is motion)" };
            desc = "Isolate motion in both depth and color data using a mixture of Gaussians";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            grayMat = vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            MOGDepth.Apply(grayMat, grayMat, options.learnRate);
            dst2 = grayMat.CvtColor(ColorConversionCodes.GRAY2BGR);

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            MOGRGB.Apply(src, dst3, options.learnRate);
        }
    }




    public class BGSubtract_MotionDetect_CS : VB_Parent
    {
        Options_MotionDetect options = new Options_MotionDetect();

        public BGSubtract_MotionDetect_CS()
        {
            labels[3] = "Only Motion Added";
            desc = "Detect Motion for use with background subtraction";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged || vbc.task.frameCount < 10)
            {
                src.CopyTo(dst3);
            }

            int threadCount = options.threadData[0];
            int width = options.threadData[1], height = options.threadData[2];
            Task[] taskArray = new Task[threadCount];
            int xfactor = src.Width / width;
            int yfactor = Math.Max(src.Height / height, src.Width / width);
            dst2.SetTo(0);
            bool motionFound = false;

            for (int i = 0; i < threadCount; i++)
            {
                int section = i;
                taskArray[i] = System.Threading.Tasks.Task.Factory.StartNew(() =>
                {
                    cv.Rect roi = new cv.Rect((section % xfactor) * width, height * (int)Math.Floor((double)section / yfactor), width, height);
                    Mat correlation = new Mat();
                    if (roi.X + roi.Width > dst3.Width) roi.Width = dst3.Width - roi.X - 1;
                    if (roi.Y + roi.Height > dst3.Height) roi.Height = dst3.Height - roi.Y - 1;
                    Cv2.MatchTemplate(src[roi], dst3[roi], correlation, TemplateMatchModes.CCoeffNormed);
                    if (options.CCthreshold > correlation.At<float>(0, 0))
                    {
                        src[roi].CopyTo(dst2[roi]);
                        src[roi].CopyTo(dst3[roi]);
                        motionFound = true;
                    }
                });
            }

            System.Threading.Tasks.Task.WaitAll(taskArray);

            if (!motionFound)
            {
                SetTrueText("No motion detected in any of the regions");
            }
        }
    }

    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law




    public class Benford_JPEG_CS : VB_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        Options_JpegQuality options = new Options_JpegQuality();

        public Benford_JPEG_CS()
        {
            desc = "Perform a Benford analysis for 1-9 of a JPEG compressed image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            byte[] jpeg = src.ImEncode(".jpg", new int[] { (int)OpenCvSharp.ImwriteFlags.JpegQuality, options.quality });
            Mat tmp = cv.Mat.FromPixelData(jpeg.Length, 1, OpenCvSharp.MatType.CV_8U, jpeg);
            dst3 = cv.Cv2.ImDecode(tmp, OpenCvSharp.ImreadModes.Color);
            benford.Run(tmp);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }
    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law




    public class Benford_JPEG99_CS : VB_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public Options_JpegQuality options = new Options_JpegQuality();

        public Benford_JPEG99_CS()
        {
            benford.setup99();
            desc = "Perform a Benford analysis for 10-99, not 1-9, of a JPEG compressed image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            byte[] jpeg = src.ImEncode(".jpg", new int[] { (int)OpenCvSharp.ImwriteFlags.JpegQuality, options.quality });
            var tmp = cv.Mat.FromPixelData(jpeg.Length, 1, OpenCvSharp.MatType.CV_8U, jpeg);
            dst3 = OpenCvSharp.Cv2.ImDecode(tmp, OpenCvSharp.ImreadModes.Color);
            benford.Run(tmp);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }
    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law




    public class Benford_PNG_CS : VB_Parent
    {
        Options_PNGCompression options = new Options_PNGCompression();
        public Benford_Basics benford = new Benford_Basics();

        public Benford_PNG_CS()
        {
            desc = "Perform a Benford analysis for 1-9 of a JPEG compressed image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            byte[] png = src.ImEncode(".png", new int[] { (int)OpenCvSharp.ImwriteFlags.PngCompression, options.compression });
            var tmp = cv.Mat.FromPixelData(png.Length, 1, OpenCvSharp.MatType.CV_8U, png);
            dst3 = OpenCvSharp.Cv2.ImDecode(tmp, OpenCvSharp.ImreadModes.Color);
            benford.Run(tmp);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }




    public class BGSubtract_MOG_Retina_CS : VB_Parent
    {
        BGSubtract_MOG_CS bgSub;
        Retina_Basics_CPP_VB retina = new Retina_Basics_CPP_VB();

        public BGSubtract_MOG_Retina_CS()
        {
            bgSub = new BGSubtract_MOG_CS();
            labels = new string[] { "", "", "MOG results of depth motion", "Difference from retina depth motion." };
            desc = "Use the bio-inspired retina algorithm to create a background/foreground using depth.";
        }

        public void RunAlg(Mat src)
        {
            retina.Run(vbc.task.depthRGB);
            bgSub.Run(retina.dst3.Clone());
            dst2 = bgSub.dst2;
            Cv2.Subtract(bgSub.dst2, retina.dst3, dst3);
        }
    }




    public class BGSubtract_DepthOrColorMotion_CS : VB_Parent
    {
        public Diff_UnstableDepthAndColor motion = new Diff_UnstableDepthAndColor();

        public BGSubtract_DepthOrColorMotion_CS()
        {
            desc = "Detect motion with both depth and color changes";
        }
        public void RunAlg(Mat src)
        {
            motion.Run(src);
            dst2 = motion.dst2;
            dst3 = motion.dst3;
            var mask = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).ConvertScaleAbs();
            src.CopyTo(dst3, ~mask);
            labels[3] = "Image with instability filled with color data";
        }
    }




    public class BGSubtract_Video_CS : VB_Parent
    {
        BGSubtract_Basics_CS bgSub;
        Video_Basics video = new Video_Basics();

        public BGSubtract_Video_CS()
        {
            bgSub = new BGSubtract_Basics_CS();
            video.options.fileInfo = new FileInfo(vbc.task.HomeDir + "opencv/Samples/Data/vtest.avi");
            desc = "Demonstrate all background subtraction algorithms in OpenCV using a video instead of camera.";
        }

        public void RunAlg(Mat src)
        {
            video.Run(src);
            dst3 = video.dst2;
            bgSub.Run(dst3);
            dst2 = bgSub.dst2;
        }
    }





    public class BGSubtract_Synthetic_CS : VB_Parent
    {
        BGSubtract_Basics_CS bgSub;
        BGSubtract_Synthetic synth = new BGSubtract_Synthetic();

        public BGSubtract_Synthetic_CS()
        {
            bgSub = new BGSubtract_Basics_CS();
            desc = "Demonstrate background subtraction algorithms with synthetic images";
        }

        public void RunAlg(Mat src)
        {
            synth.Run(src);
            dst3 = synth.dst2;
            bgSub.Run(dst3);
            dst2 = bgSub.dst2;
        }
    }




    public class BGSubtract_Reduction_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        BGSubtract_Basics bgSub = new BGSubtract_Basics();

        public BGSubtract_Reduction_CS()
        {
            desc = "Use BGSubtract with the output of a reduction";
        }

        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            var mm = GetMinMax(reduction.dst2);
            dst2 = ShowPalette(reduction.dst2 * 255 / mm.maxVal);

            bgSub.Run(dst2);
            dst3 = bgSub.dst2.Clone();

            labels[3] = "Count nonzero = " + dst3.CountNonZero().ToString();
        }
    }




    public class Bin2Way_Basics_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public Mat_4Click_CS mats;
        public float fraction;

        public Bin2Way_Basics_CS()
        {
            mats = new Mat_4Click_CS();
            fraction = dst2.Total() / 2;
            vbc.task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "Image separated into 2 segments from darkest and lightest", "Histogram Of grayscale image" };
            desc = "Split an image into 2 parts - darkest and lightest,";
        }

        public void RunAlg(Mat src)
        {
            int halfSplit = 0;
            int bins = vbc.task.histogramBins;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst3 = hist.dst2;

            List<float> histArray = hist.histArray.ToList();
            float accum = 0;
            for (int i = 0; i < histArray.Count; i++)
            {
                accum += histArray[i];
                if (accum > fraction)
                {
                    halfSplit = i;
                    break;
                }
            }

            float offset = halfSplit / (float)bins * dst3.Width;
            Cv2.Line(dst3, new cv.Point((int)offset, 0), new cv.Point((int)offset, dst3.Height), Scalar.White);

            mats.mat[0] = src.InRange(0, halfSplit - 1); // darkest
            mats.mat[1] = src.InRange(halfSplit, 255);   // lightest

            if (standaloneTest())
            {
                mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
                dst2 = mats.dst2;
            }
        }
    }




    public class Bin2Way_KMeans_CS : VB_Parent
    {
        public Bin2Way_Basics bin2 = new Bin2Way_Basics();
        KMeans_Dimensions kmeans = new KMeans_Dimensions();
        Mat_4Click mats = new Mat_4Click();

        public Bin2Way_KMeans_CS()
        {
            kmeans.km.options.setK(2);
            labels = new string[] { "", "", "Darkest (upper left), lightest (upper right)", "Selected image from dst2" };
            desc = "Use kmeans with each of the 2-way split images";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            bin2.Run(src);

            kmeans.Run(src);
            for (int i = 0; i < 2; i++)
            {
                mats.mat[i].SetTo(0);
                kmeans.dst3.CopyTo(mats.mat[i], bin2.mats.mat[i]);
            }

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Bin2Way_RedCloudDarkest_CS : VB_Parent
    {
        Bin2Way_RecurseOnce bin2 = new Bin2Way_RecurseOnce();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public Bin2Way_RedCloudDarkest_CS()
        {
            desc = "Use RedCloud with the darkest regions";
        }

        public void RunAlg(Mat src)
        {
            if (standalone) bin2.Run(src);

            flood.inputMask = ~bin2.mats.mat[0];
            flood.Run(bin2.mats.mat[0]);
            dst2 = flood.dst2;
            if (vbc.task.heartBeat) labels[2] = vbc.task.redCells.Count + " cells were identified";
        }
    }




    public class Bin2Way_RedCloudLightest_CS : VB_Parent
    {
        Bin2Way_RecurseOnce bin2 = new Bin2Way_RecurseOnce();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public Bin2Way_RedCloudLightest_CS()
        {
            desc = "Use RedCloud with the lightest regions";
        }

        public void RunAlg(Mat src)
        {
            if (standalone) bin2.Run(src);

            flood.inputMask = ~bin2.mats.mat[3];
            flood.Run(bin2.mats.mat[3]);
            dst2 = flood.dst2;
            if (vbc.task.heartBeat) labels[2] = vbc.task.redCells.Count + " cells were identified";
        }
    }




    public class Bin2Way_RecurseOnce_CS : VB_Parent
    {
        Bin2Way_Basics bin2 = new Bin2Way_Basics();
        public Mat_4Click mats = new Mat_4Click();

        public Bin2Way_RecurseOnce_CS()
        {
            desc = "Keep splitting an image between light and dark";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }

            bin2.fraction = src.Total() / 2;
            bin2.hist.inputMask = new Mat();
            bin2.Run(src);
            Mat darkestMask = bin2.mats.mat[0].Clone();
            Mat lightestMask = bin2.mats.mat[1].Clone();

            bin2.fraction = src.Total() / 4;
            bin2.hist.inputMask = darkestMask;
            bin2.Run(src);

            mats.mat[0] = bin2.mats.mat[0];
            mats.mat[1] = bin2.mats.mat[1] & ~lightestMask;

            bin2.fraction = src.Total() / 4;
            bin2.hist.inputMask = lightestMask;
            bin2.Run(src);
            mats.mat[2] = bin2.mats.mat[0] & ~darkestMask;
            mats.mat[3] = bin2.mats.mat[1];

            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Bin2Way_RedCloud_CS : VB_Parent
    {
        Bin2Way_RecurseOnce bin2 = new Bin2Way_RecurseOnce();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();
        Mat[] cellMaps = new Mat[4];
        List<rcData>[] redCells = new List<rcData>[4];
        Options_Bin2WayRedCloud options = new Options_Bin2WayRedCloud();

        public Bin2Way_RedCloud_CS()
        {
            flood.showSelected = false;
            desc = "Identify the lightest, darkest, and other regions separately and then combine the rcData.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
                }
            }

            bin2.Run(src);

            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                vbc.task.cellMap = cellMaps[i];
                vbc.task.redCells = redCells[i];
                flood.inputMask = ~bin2.mats.mat[i];
                flood.Run(bin2.mats.mat[i]);
                cellMaps[i] = vbc.task.cellMap.Clone();
                redCells[i] = new List<rcData>(vbc.task.redCells);
                foreach (var rc in vbc.task.redCells)
                {
                    if (rc.index == 0) continue;
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (vbc.task.heartBeat)
            {
                labels[2] = $"{vbc.task.redCells.Count} cells were identified and matched to the previous image";
            }
        }
    }




    public class Bin3Way_Basics_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        public Mat_4Click mats = new Mat_4Click();
        int firstThird = 0, lastThird = 0;

        public Bin3Way_Basics_CS()
        {
            vbc.task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "Image separated into three segments from darkest to lightest and 'Other' (between)", "Histogram Of grayscale image" };
            desc = "Split an image into 3 parts - darkest, lightest, and in-between the 2";
        }

        public void RunAlg(Mat src)
        {
            int bins = vbc.task.histogramBins;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (vbc.task.heartBeat)
            {
                firstThird = 0;
                lastThird = 0;
                hist.Run(src);
                dst3 = hist.dst2;

                var histogram = hist.histArray.ToList();
                double third = src.Total() / 3;
                float accum = 0;
                for (int i = 0; i < histogram.Count; i++)
                {
                    accum += histogram[i];
                    if (accum > third)
                    {
                        if (firstThird == 0)
                        {
                            firstThird = i;
                            accum = 0;
                        }
                        else
                        {
                            lastThird = i;
                            break;
                        }
                    }
                }
            }

            double offset = firstThird / (double)bins * dst3.Width;
            Cv2.Line(dst3, new cv.Point(offset, 0), new cv.Point(offset, dst3.Height), Scalar.White);
            offset = lastThird / (double)bins * dst3.Width;
            Cv2.Line(dst3, new cv.Point(offset, 0), new cv.Point(offset, dst3.Height), Scalar.White);

            mats.mat[0] = src.InRange(0, firstThird - 1);         // darkest
            mats.mat[1] = src.InRange(lastThird, 255);            // lightest
            mats.mat[2] = src.InRange(firstThird, lastThird - 1); // other

            if (standaloneTest())
            {
                mats.Run(Mat.Zeros(src.Size(), MatType.CV_8U));
                dst2 = mats.dst2;
            }
        }
    }




    public class Bin3Way_KMeans_CS : VB_Parent
    {
        public Bin3Way_Basics bin3 = new Bin3Way_Basics();
        KMeans_Dimensions kmeans = new KMeans_Dimensions();
        Mat_4Click mats = new Mat_4Click();

        public Bin3Way_KMeans_CS()
        {
            kmeans.km.options.setK(2);
            labels = new string[] { "", "", "Darkest (upper left), mixed (upper right), lightest (bottom left)", "Selected image from dst2" };
            desc = "Use kmeans with each of the 3-way split images";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            bin3.Run(src);

            kmeans.Run(src);
            for (int i = 0; i < 2; i++)
            {
                mats.mat[i].SetTo(0);
                kmeans.dst3.CopyTo(mats.mat[i], bin3.mats.mat[i]);
            }

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Bin3Way_Color_CS : VB_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();

        public Bin3Way_Color_CS()
        {
            labels = new string[] { "", "", "CV_8U format of the image", "showPalette output of dst2" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Build the palette input that best separates the light and dark regions of an image";
        }

        public void RunAlg(Mat src)
        {
            bin3.Run(src);
            dst2.SetTo(4);
            dst2.SetTo(1, bin3.bin3.mats.mat[0]);
            dst2.SetTo(2, bin3.bin3.mats.mat[1]);
            dst2.SetTo(3, bin3.bin3.mats.mat[2]);
            dst3 = ShowPalette(dst2 * 255 / 3);
        }
    }




    public class Bin3Way_RedCloudDarkest_CS : VB_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public Bin3Way_RedCloudDarkest_CS()
        {
            desc = "Use RedCloud with the darkest regions";
        }

        public void RunAlg(Mat src)
        {
            if (standalone) bin3.Run(src);

            flood.inputMask = ~bin3.bin3.mats.mat[0];
            flood.Run(bin3.bin3.mats.mat[0]);
            dst2 = flood.dst2;
        }
    }




    public class Bin3Way_RedCloudLightest_CS : VB_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public Bin3Way_RedCloudLightest_CS()
        {
            desc = "Use RedCloud with the lightest regions";
        }

        public void RunAlg(Mat src)
        {
            if (standalone) bin3.Run(src);

            flood.inputMask = ~bin3.bin3.mats.mat[2];
            flood.Run(bin3.bin3.mats.mat[2]);
            dst2 = flood.dst2;
        }
    }




    public class Bin3Way_RedCloudOther_CS : VB_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();

        public Bin3Way_RedCloudOther_CS()
        {
            flood.inputMask = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Use RedCloud with the regions that are neither lightest or darkest";
        }

        public void RunAlg(Mat src)
        {
            if (standalone) bin3.Run(src);

            flood.inputMask = bin3.bin3.mats.mat[0] | bin3.bin3.mats.mat[1];

            color.Run(src);
            flood.Run(color.dst2);
            dst2 = flood.dst2;
        }
    }




    public class Bin3Way_RedCloud1_CS : VB_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();
        Mat[] cellMaps = new Mat[3];
        List<rcData>[] redCells = new List<rcData>[3];
        Options_Bin3WayRedCloud options = new Options_Bin3WayRedCloud();

        public Bin3Way_RedCloud1_CS()
        {
            desc = "Identify the lightest, darkest, and 'Other' regions separately and then combine the rcData.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
                }
            }

            bin3.Run(src);

            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                vbc.task.cellMap = cellMaps[i];
                vbc.task.redCells = redCells[i];
                if (i == 2)
                {
                    flood.inputMask = bin3.bin3.mats.mat[0] | bin3.bin3.mats.mat[1];
                    color.Run(src);
                    flood.Run(color.dst2);
                }
                else
                {
                    flood.inputMask = ~bin3.bin3.mats.mat[i];
                    flood.Run(bin3.bin3.mats.mat[i]);
                }
                cellMaps[i] = vbc.task.cellMap.Clone();
                redCells[i] = new List<rcData>(vbc.task.redCells);
            }

            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < 3; i++)
            {
                foreach (var rc in redCells[i])
                {
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (vbc.task.heartBeat) labels[2] = vbc.task.redCells.Count + " cells were identified and matched to the previous image";
        }
    }





    public class Bin3Way_RedCloud_CS : VB_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();
        Mat[] cellMaps = new Mat[3];
        List<rcData>[] redCells = new List<rcData>[3];
        Options_Bin3WayRedCloud options = new Options_Bin3WayRedCloud();

        public Bin3Way_RedCloud_CS()
        {
            flood.showSelected = false;
            desc = "Identify the lightest, darkest, and other regions separately and then combine the rcData.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
                }
            }

            bin3.Run(src);

            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                vbc.task.cellMap = cellMaps[i];
                vbc.task.redCells = redCells[i];
                flood.inputMask = ~bin3.bin3.mats.mat[i];
                flood.Run(bin3.bin3.mats.mat[i]);
                cellMaps[i] = vbc.task.cellMap.Clone();
                redCells[i] = new List<rcData>(vbc.task.redCells);
                foreach (var rc in redCells[i])
                {
                    if (rc.index == 0) continue;
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (vbc.task.heartBeat) labels[2] = vbc.task.redCells.Count + " cells were identified and matched to the previous image";
        }
    }




    public class Bin4Way_Basics_CS : VB_Parent
    {
        Mat_4to1_CS mats;
        Bin4Way_SplitMean_CS binary;
        Diff_Basics[] diff = new Diff_Basics[4];
        string[] labelStr = new string[4];
        cv.Point[] points = new cv.Point[4];
        int index = 0;
        public Bin4Way_Basics_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i] = new Diff_Basics();
            }
            binary = new Bin4Way_SplitMean_CS();
            mats = new Mat_4to1_CS();
            labels = new string[] { "", "Quartiles for selected roi.  Click in dst1 to see different roi.", "4 brightness levels - darkest to lightest",
                      "Quartiles for the selected grid element, darkest to lightest" };
            desc = "Highlight the contours for each grid element with stats for each.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.mousePicTag == 1) index = vbc.task.gridMap.At<int>(vbc.task.ClickPoint.Y, vbc.task.ClickPoint.X);
            cv.Rect roiSave = index < vbc.task.gridRects.Count ? vbc.task.gridRects[index] : new cv.Rect();

            if (vbc.task.optionsChanged) index = 0;

            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat[] matList = new Mat[4];
            for (int i = 0; i < matList.Length; i++)
            {
                mats.mat[i] = new Mat(mats.mat[i].Size(), MatType.CV_8U, Scalar.All(0));
                binary.mats.mat[i] = new Mat(binary.mats.mat[i].Size(), MatType.CV_8U, Scalar.All(0));
            }

            int quadrant;
            binary.Run(src);
            binary.mats.Run(new Mat());
            dst2 = binary.mats.dst2;
            dst1 = binary.mats.dst3 * 0.5;
            matList = binary.mats.mat;
            quadrant = binary.mats.quadrant;

            dst0.SetTo(Scalar.All(0));
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i].Run(binary.mats.mat[i]);
                dst0 = dst0 | diff[i].dst2;
            }

            int[,] counts = new int[4, vbc.task.gridRects.Count];
            List<List<int>> contourCounts = new List<List<int>>();
            List<List<float>> means = new List<List<float>>();

            cv.Point[][] allContours;
            for (int i = 0; i < counts.GetLength(0); i++)
            {
                for (int j = 0; j < vbc.task.gridRects.Count; j++)
                {
                    cv.Rect roi = vbc.task.gridRects[j];
                    Mat tmp = new Mat(matList[i], roi);
                    Cv2.FindContours(tmp, out allContours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
                    if (i == 0)
                    {
                        contourCounts.Add(new List<int>());
                        means.Add(new List<float>());
                    }
                    contourCounts[j].Add(allContours.Length);
                    means[j].Add((float)(src[roi].Mean(tmp)[0]));
                    if (i == quadrant) SetTrueText(allContours.Length.ToString(), roi.TopLeft, 1);
                    counts[i, j] = allContours.Length;
                }
            }

            int bump = 3;
            double ratio = (double)dst2.Height / vbc.task.gridRects[0].Height;
            for (int i = 0; i < matList.Length; i++)
            {
                Mat tmp = new Mat(matList[i], roiSave) * 0.5;
                int nextCount = Cv2.CountNonZero(tmp);
                Mat tmpVolatile = new Mat(dst0, roiSave) & tmp;
                tmp.SetTo(Scalar.All(255), tmpVolatile);
                new Mat(dst0, roiSave).CopyTo(tmp, tmpVolatile);
                cv.Rect r = new cv.Rect(0, 0, (int)(tmp.Width * ratio), (int)(tmp.Height * ratio));
                mats.mat[i][r] = tmp.Resize(new cv.Size(r.Width, r.Height));

                if (vbc.task.heartBeat)
                {
                    int plus = mats.mat[i][r].Width / 2;

                    if (i == 0) points[i] = new cv.Point(bump + plus, bump);
                    if (i == 1) points[i] = new cv.Point(bump + dst2.Width / 2 + plus, bump);
                    if (i == 2) points[i] = new cv.Point(bump + plus, bump + dst2.Height / 2);
                    if (i == 3) points[i] = new cv.Point(bump + dst2.Width / 2 + plus, bump + dst2.Height / 2);
                }
            }

            for (int i = 0; i < labelStr.Length; i++)
            {
                SetTrueText(labelStr[i], points[i], 3);
            }

            mats.Run(src);
            dst3 = mats.dst2;

            dst1.Rectangle(roiSave, Scalar.White, vbc.task.lineWidth);
            vbc.task.color.Rectangle(roiSave, Scalar.White, vbc.task.lineWidth);
        }
    }






    public class Bin4Way_BasicsColors_CS : VB_Parent
    {
        Bin4Way_Basics quart = new Bin4Way_Basics();
        Color8U_Basics color = new Color8U_Basics();
        public Bin4Way_BasicsColors_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Test Bin4Way_Basics with different src inputs.";
        }
        public void RunAlg(Mat src)
        {
            color.Run(src);
            if (color.dst3.Channels() == 1) 
                quart.Run(color.dst3);
            else
                quart.Run(color.dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst1 = quart.dst1;
            dst2 = quart.dst2;
            dst3 = quart.dst3;
            labels = quart.labels;
            trueData = quart.trueData;
        }
    }





    public class Bin4Way_Unstable_CS : VB_Parent
    {
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        Diff_Basics[] diff = new Diff_Basics[4];
        public Bin4Way_Unstable_CS()
        {
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i] = new Diff_Basics();
            }
            labels[2] = "Image separated into 4 levels - darkest to lightest";
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find the unstable pixels in the binary image";
        }
        public void RunAlg(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            dst3.SetTo(0);
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i].Run(binary.mats.mat[i]);
                dst3 = dst3 | diff[i].dst2;
            }
            if (vbc.task.heartBeat) labels[3] = "There are " + dst3.CountNonZero() + " unstable pixels";
        }
    }




    public class Bin4Way_BasicsRed_CS : VB_Parent
    {
        public Mat_4to1 mats = new Mat_4to1();
        Hist_Basics hist = new Hist_Basics();
        public Bin4Way_BasicsRed_CS()
        {
            vbc.task.gOptions.setHistogramBins(255);
            labels[3] = "Grayscale histogram of the image with markers showing where each quarter of the samples are.";
            desc = "Implement a 4-way split similar to the Bin3Way_Basics algorithm.";
        }
        public void RunAlg(Mat src)
        {
            int bins = vbc.task.histogramBins;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst3 = hist.dst2;
            List<float> histArray = new List<float>(hist.histArray);
            int fraction = (int)(dst2.Total() / 4);
            List<int> accums = new List<int> { 0, 0, 0, 0 };
            List<int> quartiles = new List<int> { 0, 0, 0, 0 };
            int index = 0;
            for (int i = 0; i < histArray.Count; i++)
            {
                accums[index] += (int)histArray[i];
                if (accums[index] >= fraction)
                {
                    quartiles[index] = i;
                    index++;
                }
            }
            for (int i = 0; i < quartiles.Count(); i++)
            {
                int offset = quartiles[i] / bins * dst3.Width;
                DrawLine(dst3, new cv.Point(offset, 0), new cv.Point(offset, dst3.Height), Scalar.White);
            }
            mats.mat[0] = src.InRange(0, quartiles[0] - 1);
            mats.mat[1] = src.InRange(quartiles[0], quartiles[1] - 1);
            mats.mat[2] = src.InRange(quartiles[1], quartiles[2] - 1);
            mats.mat[3] = src.InRange(quartiles[2], 255);
            if (standaloneTest())
            {
                mats.Run(empty);
                dst2 = mats.dst2;
            }
        }
    }








    public class Bin4Way_Canny_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        Mat_4Click mats = new Mat_4Click();

        public Bin4Way_Canny_CS()
        {
            labels[2] = "Edges between halves, lightest, darkest, and the combo";
            desc = "Find edges from each of the binarized images";
        }

        public void RunAlg(Mat src)
        {
            binary.Run(src);

            edges.Run(binary.mats.mat[0]);  // the light and dark halves
            mats.mat[0] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);

            edges.Run(binary.mats.mat[1]);  // the lightest of the light half
            mats.mat[1] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[1] | mats.mat[3];

            edges.Run(binary.mats.mat[3]);  // the darkest of the dark half
            mats.mat[2] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[2] | mats.mat[3];

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;

            if (mats.dst3.Channels() == 3)
            {
                labels[3] = "Combo of first 3 below.  Click quadrants in dst2.";
                dst3 = mats.mat[3];
            }
            else
            {
                dst3 = mats.dst3;
            }
        }
    }




    public class Bin4Way_Sobel_CS : VB_Parent
    {
        Edge_Sobel edges = new Edge_Sobel();
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        public Mat_4Click mats = new Mat_4Click();

        public Bin4Way_Sobel_CS()
        {
            FindSlider("Sobel kernel Size").Value = 5;
            labels[2] = "Edges between halves, lightest, darkest, and the combo";
            labels[3] = "Click any quadrant in dst2 to view it in dst3";
            desc = "Collect Sobel edges from binarized images";
        }

        public void RunAlg(Mat src)
        {
            binary.Run(src);

            edges.Run(binary.mats.mat[0]); // the light and dark halves
            mats.mat[0] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);

            edges.Run(binary.mats.mat[1]); // the lightest of the light half
            mats.mat[1] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[1] | mats.mat[3];

            edges.Run(binary.mats.mat[3]);  // the darkest of the dark half
            mats.mat[2] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[2] | mats.mat[3];

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }





    public class Bin4Way_Unstable1_CS : VB_Parent
    {
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        Diff_Basics diff = new Diff_Basics();

        public Bin4Way_Unstable1_CS()
        {
            desc = "Find the unstable pixels in the binary image";
        }

        public void RunAlg(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            diff.Run(binary.dst3);
            dst3 = diff.dst2;

            if (vbc.task.heartBeat)
            {
                labels[3] = "There are " + dst3.CountNonZero().ToString() + " unstable pixels";
            }
        }
    }





    public class Bin4Way_UnstableEdges_CS : VB_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        Blur_Basics blur = new Blur_Basics();
        Bin4Way_Unstable unstable = new Bin4Way_Unstable();

        public Bin4Way_UnstableEdges_CS()
        {
            if (standalone)
            {
                vbc.task.gOptions.setDisplay1();
            }
            desc = "Find unstable pixels but remove those that are also edges.";
        }

        public void RunAlg(Mat src)
        {
            canny.Run(src);
            blur.Run(canny.dst2);
            dst1 = blur.dst2.Threshold(0, 255, ThresholdTypes.Binary);

            unstable.Run(src);
            dst2 = unstable.dst2;
            dst3 = unstable.dst3;

            if (!vbc.task.gOptions.debugChecked)
            {
                dst3.SetTo(0, dst1);
            }
        }
    }




    public class Bin4Way_UnstablePixels_CS : VB_Parent
    {
        Bin4Way_UnstableEdges unstable = new Bin4Way_UnstableEdges();
        public List<byte> gapValues = new List<byte>();

        public Bin4Way_UnstablePixels_CS()
        {
            desc = "Identify the unstable grayscale pixel values ";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            unstable.Run(src);
            dst2 = unstable.dst3;

            var points = dst2.FindNonZero();
            if (points.Rows == 0) return;

            int[] pts = new int[points.Rows * 2];
            Marshal.Copy(points.Data, pts, 0, pts.Length);

            List<byte> pixels = new List<byte>();
            SortedList<byte, int> pixelSort = new SortedList<byte, int>(new compareByte());
            for (int i = 0; i < pts.Length; i += 2)
            {
                byte val = src.At<byte>(pts[i + 1], pts[i]);
                if (!pixels.Contains(val))
                {
                    pixelSort.Add(val, 1);
                    pixels.Add(val);
                }
            }

            int gapThreshold = 2;
            gapValues.Clear();
            strOut = "These are the ranges of grayscale bytes where there is fuzziness.\n";
            int lastIndex = 0, lastGap = 0;
            foreach (var index in pixelSort.Keys)
            {
                if (Math.Abs(lastIndex - index) > gapThreshold)
                {
                    strOut += "\n";
                    gapValues.Add((byte)((index + lastGap) / 2));
                    lastGap = index;
                    for (int i = index + 1; i < pixelSort.Keys.Count; i++)
                    {
                        if (pixelSort.Keys.ElementAt(i) - lastGap > gapThreshold) break;
                        lastGap = i;
                    }
                }
                strOut += index.ToString() + "\t";
                lastIndex = index;
            }
            if (gapValues.Count < 4)
            {
                gapValues.Add((byte)((255 + lastGap) / 2));
            }

            strOut += "\n\nThe best thresholds for this image to avoid fuzziness are: \n";
            foreach (var index in gapValues)
            {
                strOut += index.ToString() + "\t";
            }
            SetTrueText(strOut, 3);
            if (vbc.task.heartBeat) labels[3] = "There are " + dst2.CountNonZero().ToString() + " unstable pixels";
        }
    }





    public class Bin4Way_SplitValley_CS : VB_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        HistValley_Basics valley = new HistValley_Basics();
        public Mat_4Click mats = new Mat_4Click();

        public Bin4Way_SplitValley_CS()
        {
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Binarize an image using the valleys provided by HistValley_Basics";
        }

        public void RunAlg(Mat src)
        {
            Mat gray = src.Channels() == 1 ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            binary.Run(gray);
            Mat mask = binary.dst2.Clone();

            if (vbc.task.heartBeat) valley.Run(gray);

            mats.mat[0] = gray.InRange(0, valley.valleys[1] - 1);
            mats.mat[1] = gray.InRange(valley.valleys[1], valley.valleys[2] - 1);
            mats.mat[2] = gray.InRange(valley.valleys[2], valley.valleys[3] - 1);
            mats.mat[3] = gray.InRange(valley.valleys[3], 255);

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            labels[3] = mats.labels[3];
        }
    }





    public class Bin4Way_UnstablePixels1_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Bin4Way_UnstableEdges unstable = new Bin4Way_UnstableEdges();
        public List<byte> gapValues = new List<byte>();

        public Bin4Way_UnstablePixels1_CS()
        {
            vbc.task.gOptions.setHistogramBins(256);
            desc = "Identify the unstable grayscale pixel values ";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            hist.Run(src);

            unstable.Run(src);
            dst2 = unstable.dst3;

            var points = dst2.FindNonZero();
            if (points.Rows == 0) return;

            int[] pts = new int[points.Rows * 2];
            Marshal.Copy(points.Data, pts, 0, pts.Length);

            List<byte> pixels = new List<byte>();
            SortedList<byte, int> pixelSort = new SortedList<byte, int>(new compareByte());
            for (int i = 0; i < pts.Length; i += 2)
            {
                byte val = src.At<byte>(pts[i + 1], pts[i]);
                if (!pixels.Contains(val))
                {
                    pixelSort.Add(val, 1);
                    pixels.Add(val);
                }
            }

            byte[] boundaries = new byte[5];
            boundaries[0] = (byte)(0 * 255 / 4);
            boundaries[1] = (byte)(1 * 255 / 4);
            boundaries[2] = (byte)(2 * 255 / 4);
            boundaries[3] = (byte)(3 * 255 / 4);
            boundaries[4] = 255;

            int gapThreshold = 2, lastIndex = 0, bIndex = 1;
            strOut = "These are the ranges of grayscale bytes where there is fuzziness.\n";
            for (int i = 0; i < pixelSort.Keys.Count; i++)
            {
                byte index = pixelSort.ElementAt(i).Key;
                if (Math.Abs(lastIndex - index) > gapThreshold)
                {
                    strOut += "\n";
                    if (bIndex < boundaries.Length)
                    {
                        boundaries[bIndex] = index;
                        bIndex++;
                    }
                }
                strOut += index.ToString() + "\t";
                lastIndex = index;
            }

            gapValues.Clear();
            for (int i = 1; i < boundaries.Length; i++)
            {
                byte minVal = byte.MaxValue;
                int minIndex = 0;
                for (int j = boundaries[i - 1]; j < boundaries[i]; j++)
                {
                    if (hist.histArray[j] < minVal)
                    {
                        minVal = (byte)hist.histArray[j];
                        minIndex = j;
                    }
                }
                gapValues.Add((byte)minIndex);
            }
            strOut += "\n\nThe best thresholds for this image to avoid fuzziness are: \n";
            foreach (var index in gapValues)
            {
                strOut += index.ToString() + "\t";
            }
            SetTrueText(strOut, 3);
            if (vbc.task.heartBeat) labels[3] = "There are " + dst2.CountNonZero().ToString() + " unstable pixels";
        }
    }




    public class Bin4Way_Regions1_CS : VB_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        public Mat_4Click mats = new Mat_4Click();
        public int classCount = 4; // 4-way split

        public Bin4Way_Regions1_CS()
        {
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Binarize an image and split it into quartiles using peaks.";
        }

        public void RunAlg(Mat src)
        {
            Mat gray = (src.Channels() == 1) ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            binary.Run(gray);
            Mat mask = binary.dst2.Clone();

            double midColor = binary.meanScalar[0];
            double topColor = Cv2.Mean(gray, mask)[0];
            double botColor = Cv2.Mean(gray, ~mask)[0];
            mats.mat[0] = gray.InRange(0, botColor);
            mats.mat[1] = gray.InRange(botColor, midColor);
            mats.mat[2] = gray.InRange(midColor, topColor);
            mats.mat[3] = gray.InRange(topColor, 255);

            mats.Run(Mat.Zeros(dst1.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            labels[3] = mats.labels[3];
        }
    }




    public class Bin4Way_SplitGaps_CS : VB_Parent
    {
        Bin4Way_UnstablePixels unstable = new Bin4Way_UnstablePixels();
        public Mat_4Click mats = new Mat_4Click();
        Diff_Basics[] diff = new Diff_Basics[4];

        public Bin4Way_SplitGaps_CS()
        {
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i] = new Diff_Basics();
                mats.mat[i] = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            }
            if (standalone) vbc.task.gOptions.setDisplay1();
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Separate the quartiles of the image using the fuzzy grayscale pixel values";
        }

        public void RunAlg(Mat src)
        {
            Mat gray = (src.Channels() == 1) ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            unstable.Run(gray);

            int lastVal = 255;
            for (int i = Math.Min(mats.mat.Length, unstable.gapValues.Count) - 1; i >= 0; i--)
            {
                mats.mat[i] = gray.InRange(unstable.gapValues[i], lastVal);
                lastVal = unstable.gapValues[i];
            }

            dst1.SetTo(Scalar.All(0));
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i].Run(mats.mat[i]);
                dst1 = dst1 | diff[i].dst2;
            }
            mats.Run(Mat.Zeros(dst1.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            if (vbc.task.heartBeat) labels[1] = "There are " + dst1.CountNonZero().ToString() + " unstable pixels";
        }
    }




    public class Bin4Way_RegionsLeftRight_CS : VB_Parent
    {
        Bin4Way_SplitGaps binaryLeft = new Bin4Way_SplitGaps();
        Bin4Way_SplitGaps binaryRight = new Bin4Way_SplitGaps();
        public int classCount = 4; // 4-way split

        public Bin4Way_RegionsLeftRight_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            labels = new string[] { "", "", "Left in 4 colors", "Right image in 4 colors" };
            desc = "Add the 4-way split of left and right views.";
        }

        public void RunAlg(Mat src)
        {
            binaryLeft.Run(src);

            dst0.SetTo(Scalar.All(1), binaryLeft.mats.mat[0]);
            dst0.SetTo(Scalar.All(2), binaryLeft.mats.mat[1]);
            dst0.SetTo(Scalar.All(3), binaryLeft.mats.mat[2]);
            dst0.SetTo(Scalar.All(4), binaryLeft.mats.mat[3]);

            dst2 = ShowPalette((dst0 * 255 / classCount).ToMat());

            binaryRight.Run(vbc.task.rightView);

            dst1.SetTo(Scalar.All(1), binaryRight.mats.mat[0]);
            dst1.SetTo(Scalar.All(2), binaryRight.mats.mat[1]);
            dst1.SetTo(Scalar.All(3), binaryRight.mats.mat[2]);
            dst1.SetTo(Scalar.All(4), binaryRight.mats.mat[3]);

            dst3 = ShowPalette((dst1 * 255 / classCount).ToMat());
        }
    }




    public class Bin4Way_RedCloud_CS : VB_Parent
    {
        Bin4Way_BasicsRed bin2 = new Bin4Way_BasicsRed();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Mat[] cellMaps = new Mat[4];
        List<rcData>[] redCells = new List<rcData>[4];
        Options_Bin2WayRedCloud options = new Options_Bin2WayRedCloud();

        public Bin4Way_RedCloud_CS()
        {
            flood.showSelected = false;
            desc = "Identify the lightest and darkest regions separately and then combine the rcData.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
                }
            }

            bin2.Run(src);

            var sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                vbc.task.cellMap = cellMaps[i];
                vbc.task.redCells = redCells[i];
                flood.inputMask = ~bin2.mats.mat[i];
                flood.Run(bin2.mats.mat[i]);
                cellMaps[i] = vbc.task.cellMap.Clone();
                redCells[i] = new List<rcData>(vbc.task.redCells);
                foreach (var rc in vbc.task.redCells)
                {
                    if (rc.index == 0) continue;
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (vbc.task.heartBeat) labels[2] = $"{vbc.task.redCells.Count} cells were identified and matched to the previous image";
        }
    }




    public class Bin4Way_Regions_CS : VB_Parent
    {
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        public int classCount = 4; // 4-way split 

        public Bin4Way_Regions_CS()
        {
            rebuildMats(dst2.Size());
            labels = new string[] { "", "", "CV_8U version of dst3 with values ranging from 1 to 4", "Palettized version of dst2" };
            desc = "Add the 4-way split of images to define the different regions.";
        }

        void rebuildMats(cv.Size Size)
        {
            dst2 = new Mat(Size, MatType.CV_8U, cv.Scalar.All(0));
            for (int i = 0; i < binary.mats.mat.Count(); i++)
            {
                binary.mats.mat[i] = new Mat(Size, MatType.CV_8UC1, cv.Scalar.All(0));
            }
        }

        public void RunAlg(Mat src)
        {
            binary.Run(src);
            if (dst2.Width != binary.mats.mat[0].Width) rebuildMats(src.Size());

            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst2.SetTo(1, binary.mats.mat[0]);
            dst2.SetTo(2, binary.mats.mat[1]);
            dst2.SetTo(3, binary.mats.mat[2]);
            dst2.SetTo(4, binary.mats.mat[3]);

            dst3 = ShowPalette((dst2 * 255 / classCount).ToMat());
        }
    }




    public class Bin4Way_SplitMean_CS : VB_Parent
    {
        public Binarize_Simple_CS binary;
        public Mat_4Click_CS mats;
        Scalar botColor, midColor, topColor;

        public Bin4Way_SplitMean_CS()
        {
            mats = new Mat_4Click_CS();
            binary = new Binarize_Simple_CS();
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Binarize an image and split it into quartiles using peaks.";
        }

        public void RunAlg(Mat src)
        {
            Mat gray = (src.Channels() == 1) ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            binary.Run(gray);
            Mat mask = binary.dst2.Clone();

            if (vbc.task.heartBeat)
            {
                midColor = cv.Scalar.All(binary.meanScalar[0]);
                topColor = cv.Scalar.All(Cv2.Mean(gray, mask)[0]);
                botColor = cv.Scalar.All(Cv2.Mean(gray, ~mask)[0]);
            }

            mats.mat[0] = gray.InRange(new Scalar(0), botColor);
            mats.mat[1] = gray.InRange(botColor, midColor);
            mats.mat[2] = gray.InRange(midColor, topColor);
            mats.mat[3] = gray.InRange(topColor, new Scalar(255));

            mats.Run(Mat.Zeros(gray.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            labels[3] = mats.labels[3];
        }
    }




    public class Binarize_Basics_CS : VB_Parent
    {
        public ThresholdTypes thresholdType = ThresholdTypes.Otsu;
        public Mat histogram = new Mat();
        public Scalar meanScalar;
        public Mat mask = new Mat();
        Blur_Basics blur = new Blur_Basics();
        public bool useBlur;

        public Binarize_Basics_CS()
        {
            mask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(255));
            UpdateAdvice(traceName + ": use local options to control the kernel size and sigma.");
            desc = "Binarize an image using Threshold with OTSU.";
        }

        public void RunAlg(Mat src)
        {
            meanScalar = Cv2.Mean(src, mask);

            Mat input = src;
            if (input.Channels() == 3)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (useBlur)
            {
                blur.Run(input);
                dst2 = blur.dst2.Threshold(meanScalar.Val0, 255, thresholdType);
            }
            else
            {
                dst2 = input.Threshold(meanScalar.Val0, 255, thresholdType);
            }
        }
    }

    // https://docs.opencv.org/3.4/d7/d4d/tutorial_py_thresholding.html




    public class Binarize_OTSU_CS : VB_Parent
    {
        Binarize_Basics binarize;
        Options_Binarize options = new Options_Binarize();
        public Binarize_OTSU_CS()
        {
            binarize = new Binarize_Basics();
            labels[2] = "Threshold 1) binary 2) Binary+OTSU 3) OTSU 4) OTSU+Blur";
            labels[3] = "Histograms correspond to images on the left";
            desc = "Binarize an image using Threshold with OTSU.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat input = src;
            if (input.Channels() == 3)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);

            binarize.meanScalar = Cv2.Mean(input);

            binarize.useBlur = false;
            switch (labels[2])
            {
                case "Binary":
                    binarize.thresholdType = ThresholdTypes.Binary;
                    break;
                case "Binary + OTSU":
                    binarize.thresholdType = ThresholdTypes.Binary | ThresholdTypes.Otsu;
                    break;
                case "OTSU":
                    binarize.thresholdType = ThresholdTypes.Otsu;
                    break;
                case "OTSU + Blur":
                    binarize.useBlur = true;
                    binarize.thresholdType = ThresholdTypes.Binary | ThresholdTypes.Otsu;
                    break;
            }
            binarize.Run(input);
            dst2 = binarize.dst2;
        }
    }




    public class Binarize_KMeansMasks_CS : VB_Parent
    {
        KMeans_Image km = new KMeans_Image();
        Mat_4Click mats = new Mat_4Click();
        public Binarize_KMeansMasks_CS()
        {
            labels[2] = "Ordered from dark to light, top left darkest, bottom right lightest ";
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Display the top 4 masks from the BGR kmeans output";
        }
        public void RunAlg(Mat src)
        {
            km.Run(src);
            for (int i = 0; i < km.masks.Count; i++)
            {
                mats.mat[i] = km.masks[i];
                dst1.SetTo(i + 1, km.masks[i]);
                if (i >= 3) break;
            }

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Binarize_KMeansRGB_CS : VB_Parent
    {
        KMeans_Image km = new KMeans_Image();
        Mat_4Click mats = new Mat_4Click();

        public Binarize_KMeansRGB_CS()
        {
            labels[2] = "Ordered from dark to light, top left darkest, bottom right lightest ";
            desc = "Display the top 4 masks from the BGR kmeans output";
        }

        public void RunAlg(Mat src)
        {
            km.Run(src);
            dst1.SetTo(0);
            for (int i = 0; i < km.masks.Count; i++)
            {
                mats.mat[i] = new Mat(dst2.Size(), MatType.CV_8UC3, Scalar.All(0));
                src.CopyTo(mats.mat[i], km.masks[i]);
                if (i >= 3) break;
            }
            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC3));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }





    public class Binarize_FourPixelFlips_CS : VB_Parent
    {
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        Mat lastSubD;
        public Binarize_FourPixelFlips_CS()
        {
            desc = "Identify the marginal regions that flip between subdivisions based on brightness.";
        }

        public void RunAlg(Mat src)
        {
            binar4.Run(src);
            dst2 = ShowPalette(binar4.dst2 * 255 / 5);

            if (vbc.task.FirstPass) lastSubD = binar4.dst2.Clone();
            dst3 = lastSubD - binar4.dst2;
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary);
            lastSubD = binar4.dst2.Clone();
        }
    }





    public class Binarize_DepthTiers_CS : VB_Parent
    {
        Depth_Tiers tiers = new Depth_Tiers();
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        public int classCount = 200; // 4-way split with 50 depth levels at 10 cm's each.

        public Binarize_DepthTiers_CS()
        {
            vbc.task.redOptions.useColorOnlyChecked = true;
            desc = "Add the Depth_Tiers and Bin4Way_Regions output in preparation for RedCloud";
        }

        public void RunAlg(Mat src)
        {
            binar4.Run(src);
            tiers.Run(src);
            dst3 = tiers.dst3;

            dst0 = tiers.dst2 + binar4.dst2;

            if (vbc.task.heartBeat)
            {
                dst2 = dst0.Clone();
            }
            else if (vbc.task.motionDetected)
            {
                dst0[vbc.task.motionRect].CopyTo(dst2[vbc.task.motionRect]);
            }
            classCount = binar4.classCount + tiers.classCount;
        }
    }





    public class Binarize_Simple_CS : VB_Parent
    {
        public Scalar meanScalar;
        public int injectVal = 255;

        public Binarize_Simple_CS()
        {
            desc = "Binarize an image using Threshold with OTSU.";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            meanScalar = Cv2.Mean(src);
            dst2 = src.Threshold(meanScalar[0], injectVal, ThresholdTypes.Binary);
        }
    }






    public class Binarize_Niblack_Sauvola_CS : VB_Parent
    {
        Options_BinarizeNiBlack options = new Options_BinarizeNiBlack();
        //[InlineData(LocalBinarizationMethods.Niblack)]
        //[InlineData(LocalBinarizationMethods.Sauvola)]
        //[InlineData(LocalBinarizationMethods.Wolf)]
        //[InlineData(LocalBinarizationMethods.Nick)]
        public Binarize_Niblack_Sauvola_CS()
        {
            desc = "Binarize an image using Niblack and Sauvola";
            labels[2] = "Binarize Niblack";
            labels[3] = "Binarize Sauvola";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Niblack);
            dst2 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Sauvola);
            dst3 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }




    public class Binarize_Wolf_Nick_CS : VB_Parent
    {
        Options_BinarizeNiBlack options = new Options_BinarizeNiBlack();
        public Binarize_Wolf_Nick_CS()
        {
            desc = "Binarize an image using Wolf and Nick";
            labels[2] = "Binarize Wolf";
            labels[3] = "Binarize Nick";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Wolf);
            dst2 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Nick);
            dst3 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }




    public class Blob_Input_CS : VB_Parent
    {
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        Draw_Circles circles = new Draw_Circles();
        Draw_Ellipses ellipses = new Draw_Ellipses();
        Draw_Polygon poly = new Draw_Polygon();
        public Mat_4Click Mats = new Mat_4Click();
        public int updateFrequency = 30;

        public Blob_Input_CS()
        {
            FindSlider("DrawCount").Value = 5;
            FindCheckBox("Draw filled (unchecked draw an outline)").Checked = true;

            Mats.mats.lineSeparators = false;

            labels[2] = "Click any quadrant below to view it on the right";
            labels[3] = "Click any quadrant at left to view it below";
            desc = "Generate data to test Blob Detector.";
        }

        public void RunAlg(Mat src)
        {
            rotatedRect.Run(src);
            Mats.mat[0] = rotatedRect.dst2;

            circles.Run(src);
            Mats.mat[1] = circles.dst2;

            ellipses.Run(src);
            Mats.mat[2] = ellipses.dst2;

            poly.Run(src);
            Mats.mat[3] = poly.dst3;
            Mats.Run(empty);
            dst2 = Mats.dst2;
            dst3 = Mats.dst3;
        }
    }





    public class Blob_RenderBlobs_CS : VB_Parent
    {
        Blob_Input input = new Blob_Input();

        public Blob_RenderBlobs_CS()
        {
            labels[2] = "Input blobs";
            labels[3] = "Largest blob, centroid in yellow";
            desc = "Use connected components to find blobs.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                input.Run(src);
                dst2 = input.dst2;
                var gray = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
                var binary = gray.Threshold(0, 255, ThresholdTypes.Otsu | ThresholdTypes.Binary);
                var labelView = dst2.EmptyClone();
                var stats = new Mat();
                var centroids = new Mat();
                var cc = Cv2.ConnectedComponentsEx(binary);
                var labelCount = Cv2.ConnectedComponentsWithStats(binary, labelView, stats, centroids);
                cc.RenderBlobs(labelView);

                foreach (var b in cc.Blobs.Skip(1))
                {
                    dst2.Rectangle(b.Rect, Scalar.Red, vbc.task.lineWidth + 1, vbc.task.lineType);
                }

                var maxBlob = cc.GetLargestBlob();
                dst3.SetTo(0);
                cc.FilterByBlob(dst2, dst3, maxBlob);

                dst3.Circle(new cv.Point(maxBlob.Centroid.X, maxBlob.Centroid.Y), vbc.task.DotSize + 3, Scalar.Blue, -1, vbc.task.lineType);
                DrawCircle(dst3, new cv.Point(maxBlob.Centroid.X, maxBlob.Centroid.Y), vbc.task.DotSize, Scalar.Yellow);
            }
        }
    }




    public class BlockMatching_Basics_CS : VB_Parent
    {
        Depth_Colorizer_CPP_VB colorizer = new Depth_Colorizer_CPP_VB();
        Options_BlockMatching options = new Options_BlockMatching();

        public BlockMatching_Basics_CS()
        {
            if (standaloneTest())
            {
                vbc.task.gOptions.setDisplay1();
            }
            labels[2] = "Block matching disparity colorized like depth";
            labels[3] = "Right Image (used with left image)";
            UpdateAdvice(traceName + ": click 'Show All' to see all the available options.");
            desc = "Use OpenCV's block matching on left and right views";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.cameraName == "Azure Kinect 4K")
            {
                SetTrueText("For the K4A 4 Azure camera, the left and right views are the same.");
            }

            var blockMatch = StereoBM.Create();
            blockMatch.BlockSize = options.blockSize;
            blockMatch.MinDisparity = 0;
            blockMatch.ROI1 = new cv.Rect(0, 0, vbc.task.leftView.Width, vbc.task.leftView.Height);
            blockMatch.ROI2 = new cv.Rect(0, 0, vbc.task.leftView.Width, vbc.task.leftView.Height);
            blockMatch.PreFilterCap = 31;
            blockMatch.NumDisparities = options.numDisparity;
            blockMatch.TextureThreshold = 10;
            blockMatch.UniquenessRatio = 15;
            blockMatch.SpeckleWindowSize = 100;
            blockMatch.SpeckleRange = 32;
            blockMatch.Disp12MaxDiff = 1;

            Mat tmpLeft = vbc.task.leftView.Channels() == 3 ? vbc.task.leftView.CvtColor(ColorConversionCodes.BGR2GRAY) : vbc.task.leftView;
            Mat tmpRight = vbc.task.rightView.Channels() == 3 ? vbc.task.rightView.CvtColor(ColorConversionCodes.BGR2GRAY) : vbc.task.rightView;

            Mat disparity = new Mat();
            blockMatch.Compute(tmpLeft, tmpRight, disparity);
            disparity.ConvertTo(dst1, MatType.CV_32F, 1.0 / 16);
            dst1 = dst1.Threshold(0, 0, ThresholdTypes.Tozero);

            int topMargin = 10, sideMargin = 8;
            cv.Rect rect = new cv.Rect(options.numDisparity + sideMargin, topMargin, src.Width - options.numDisparity - sideMargin * 2, src.Height - topMargin * 2);
            Cv2.Divide(options.distance, dst1[rect], dst1[rect]); // this needs much more refinement. The trackbar value is just an approximation.
            dst1[rect] = dst1[rect].Threshold(10, 10, ThresholdTypes.Trunc);

            colorizer.Run(dst1);
            dst2[rect] = colorizer.dst2[rect];
            dst3 = vbc.task.rightView.Resize(src.Size());
        }
    }




    public class Blur_Basics_CS : VB_Parent
    {
        Options_Blur options = new Options_Blur();
        public Blur_Basics_CS()
        {
            UpdateAdvice(traceName + ": use local options to control the kernel size and sigma.");
            desc = "Smooth each pixel with a Gaussian kernel of different sizes.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Cv2.GaussianBlur(src, dst2, new cv.Size(options.kernelSize, options.kernelSize), options.sigma, options.sigma);
        }
    }





    public class Blur_Homogeneous_CS : VB_Parent
    {
        Blur_Basics blur = new Blur_Basics();
        public Blur_Homogeneous_CS()
        {
            desc = "Smooth each pixel with a kernel of 1's of different sizes.";
        }
        public void RunAlg(Mat src)
        {
            Cv2.Blur(src, dst2, new cv.Size(blur.Options.kernelSize, blur.Options.kernelSize), new cv.Point(-1, -1));
        }
    }




    public class Blur_Median_CS : VB_Parent
    {
        Blur_Basics blur = new Blur_Basics();
        public Blur_Median_CS()
        {
            desc = "Replace each pixel with the median of neighborhood of varying sizes.";
        }
        public void RunAlg(Mat src)
        {
            Cv2.MedianBlur(src, dst2, blur.Options.kernelSize);
        }
    }

    // https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=bilateralfilter
    // https://www.tutorialspoint.com/opencv/opencv_bilateral_filter.htm




    public class Blur_Bilateral_CS : VB_Parent
    {
        Blur_Basics blur = new Blur_Basics();
        public Blur_Bilateral_CS()
        {
            desc = "Smooth each pixel with a Gaussian kernel of different sizes but preserve edges";
        }
        public void RunAlg(Mat src)
        {
            Cv2.BilateralFilter(src, dst2, blur.Options.kernelSize, blur.Options.kernelSize * 2, blur.Options.kernelSize / 2);
        }
    }





    public class Blur_PlusHistogram_CS : VB_Parent
    {
        Mat_2to1 mat2to1 = new Mat_2to1();
        Blur_Bilateral blur = new Blur_Bilateral();
        Hist_EqualizeGray myhist = new Hist_EqualizeGray();

        public Blur_PlusHistogram_CS()
        {
            labels[2] = "Use Blur slider to see impact on histogram peak values";
            labels[3] = "Top is before equalize, Bottom is after Equalize";
            desc = "Compound algorithms Blur and Histogram";
        }

        public void RunAlg(Mat src)
        {
            myhist.Run(src);
            mat2to1.mat[0] = myhist.dst2.Clone();

            blur.Run(src);
            dst2 = blur.dst2.Clone();

            myhist.Run(blur.dst2);
            mat2to1.mat[1] = myhist.dst2.Clone();
            mat2to1.Run(src);
            dst3 = mat2to1.dst2;
        }
    }





    public class Blur_Detection_CS : VB_Parent
    {
        Laplacian_Basics laplace = new Laplacian_Basics();
        Blur_Basics blur = new Blur_Basics();

        public Blur_Detection_CS()
        {
            FindSlider("Laplacian Threshold").Value = 50;
            FindSlider("Blur Kernel Size").Value = 11;
            labels = new string[] { "", "", "Draw a rectangle to blur a region in alternating frames and test further", "Detected blur in the highlight regions - non-blur is white." };
            desc = "Detect blur in an image";
        }

        public void RunAlg(Mat src)
        {
            cv.Rect r = new cv.Rect(dst2.Width / 2 - 25, dst2.Height / 2 - 25, 50, 50);
            if (standaloneTest())
            {
                if (vbc.task.drawRect != new cv.Rect()) r = vbc.task.drawRect;
                if (vbc.task.frameCount % 2 == 1)
                {
                    blur.Run(src[r]);
                    src[r] = blur.dst2;
                }
            }

            dst2 = src;
            laplace.Run(src);
            dst3 = laplace.dst2;

            Scalar mean, stdev;
            Cv2.MeanStdDev(dst2, out mean, out stdev);
            SetTrueText("Blur variance is " + (stdev.Val0 * stdev.Val0).ToString(vbc.fmt3), 3);

            if (standaloneTest()) dst2.Rectangle(r, Scalar.White, vbc.task.lineWidth);
        }
    }





    public class Blur_Depth_CS : VB_Parent
    {
        Blur_Basics blur = new Blur_Basics();

        public Blur_Depth_CS()
        {
            desc = "Blur the depth results to help find the boundaries to large depth regions";
        }

        public void RunAlg(Mat src)
        {
            dst3 = vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(0, 255, ThresholdTypes.Binary);

            blur.Run(dst3);
            dst2 = blur.dst2;
        }
    }




    public class Blur_TopoMap_CS : VB_Parent
    {
        Gradient_CartToPolar gradient = new Gradient_CartToPolar();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        Options_BlurTopo options = new Options_BlurTopo();

        public Blur_TopoMap_CS()
        {
            labels[2] = "Image Gradient";
            desc = "Create a topo map from the blurred image";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            gradient.Run(src);
            dst2 = gradient.magnitude;

            if (options.kernelSize > 1)
            {
                Cv2.GaussianBlur(dst2, dst3, new cv.Size(options.kernelSize, options.kernelSize), 0, 0);
            }
            dst3 = dst3.Normalize(255);
            dst3 = dst3.ConvertScaleAbs(255);

            dst3 = (dst3 * 1 / options.reduction).ToMat();
            dst3 = (dst3 * options.reduction).ToMat();

            addw.src2 = ShowPalette(dst3);
            addw.Run(vbc.task.color);
            dst3 = addw.dst2;

            labels[3] = "Blur = " + options.nextPercent.ToString() + "% Reduction Factor = " + options.reduction.ToString();
            if (vbc.task.frameCount % options.frameCycle == 0)
            {
                options.nextPercent -= 1;
            }
            if (options.nextPercent <= 0)
            {
                options.nextPercent = options.savePercent;
            }
        }
    }




    public class BlurMotion_Basics_CS : VB_Parent
    {
        public Mat kernel;
        public Options_MotionBlur options = new Options_MotionBlur();

        public BlurMotion_Basics_CS()
        {
            desc = "Use Filter2D to create a motion blur";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest())
            {
                var blurSlider = FindSlider("Motion Blur Length");
                var blurAngleSlider = FindSlider("Motion Blur Angle");
                blurAngleSlider.Value = blurAngleSlider.Value < blurAngleSlider.Maximum ? blurAngleSlider.Value + 1 : blurAngleSlider.Minimum;
            }

            kernel = new Mat(options.kernelSize, options.kernelSize, MatType.CV_32F, Scalar.All(0));
            var pt1 = new cv.Point(0, (options.kernelSize - 1) / 2);
            var pt2 = new cv.Point(options.kernelSize * Math.Cos(options.theta) + pt1.X, options.kernelSize * Math.Sin(options.theta) + pt1.Y);
            kernel.Line(pt1, pt2, new Scalar(1.0 / options.kernelSize));
            dst2 = src.Filter2D(-1, kernel);

            pt1 += new cv.Point(src.Width / 2, src.Height / 2);
            pt2 += new cv.Point(src.Width / 2, src.Height / 2);

            if (options.showDirection)
            {
                dst2.Line(pt1, pt2, Scalar.Yellow, vbc.task.lineWidth + 3, vbc.task.lineType);
            }
        }
    }

    // https://docs.opencv.org/trunk/d1/dfd/tutorial_motion_deblur_filter.html




    public class BlurMotion_Deblur_CS : VB_Parent
    {
        BlurMotion_Basics_CS mblur;

        Mat calcPSF(cv.Size filterSize, int len, double theta)
        {
            var h = new Mat(filterSize, MatType.CV_32F, Scalar.All(0));
            var pt = new cv.Point(filterSize.Width / 2, filterSize.Height / 2);
            h.Ellipse(pt, new cv.Size(0, len / 2), 90 - theta, 0, 360, new Scalar(255), -1);
            var summa = Cv2.Sum(h);
            return h / summa[0];
        }

        Mat calcWeinerFilter(Mat input_h_PSF, double nsr)
        {
            var h_PSF_shifted = fftShift(input_h_PSF);
            var planes = new Mat[] { h_PSF_shifted.Clone(), new Mat(h_PSF_shifted.Size(), MatType.CV_32F, Scalar.All(0)) };
            var complexI = new Mat();
            Cv2.Merge(planes, complexI);
            Cv2.Dft(complexI, complexI);
            planes = Cv2.Split(complexI);
            var denom = new Mat();
            Cv2.Pow(Cv2.Abs(planes[0]), 2, denom);
            denom += cv.Scalar.All(nsr);
            var output_G = new Mat();
            Cv2.Divide(planes[0], denom, output_G);
            return output_G;
        }

        Mat fftShift(Mat inputImg)
        {
            var outputImg = inputImg.Clone();
            int cx = outputImg.Width / 2;
            int cy = outputImg.Height / 2;
            var q0 = new Mat(outputImg, new cv.Rect(0, 0, cx, cy));
            var q1 = new Mat(outputImg, new cv.Rect(cx, 0, cx, cy));
            var q2 = new Mat(outputImg, new cv.Rect(0, cy, cx, cy));
            var q3 = new Mat(outputImg, new cv.Rect(cx, cy, cx, cy));
            var tmp = q0.Clone();
            q3.CopyTo(q0);
            tmp.CopyTo(q3);
            q1.CopyTo(tmp);
            q2.CopyTo(q1);
            tmp.CopyTo(q2);
            return outputImg;
        }

        Mat edgeTaper(Mat inputImg, double gamma, double beta)
        {
            int nx = inputImg.Width;
            int ny = inputImg.Height;
            var w1 = new Mat(1, nx, MatType.CV_32F, Scalar.All(0));
            var w2 = new Mat(ny, 1, MatType.CV_32F, Scalar.All(0));

            float dx = (float)(2.0 * Math.PI / nx);
            float x = (float)-Math.PI;
            for (int i = 0; i < nx; i++)
            {
                w1.Set<float>(0, i, 0.5f * (float)(Math.Tanh((x + gamma / 2) / beta) - Math.Tanh((x - gamma / 2) / beta)));
                x += dx;
            }

            float dy = (float)(2.0 * Math.PI / ny);
            float y = (float)-Math.PI;
            for (int i = 0; i < ny; i++)
            {
                w2.Set<float>(i, 0, 0.5f * (float)(Math.Tanh((y + gamma / 2) / beta) - Math.Tanh((y - gamma / 2) / beta)));
                y += dy;
            }

            var w = w2 * w1;
            var outputImg = new Mat();
            Cv2.Multiply(inputImg, w, outputImg);
            return outputImg;
        }

        Mat filter2DFreq(Mat inputImg, Mat H)
        {
            var planes = new Mat[] { inputImg.Clone(), new Mat(inputImg.Size(), MatType.CV_32F, Scalar.All(0)) };
            var complexI = new Mat();
            Cv2.Merge(planes, complexI);
            Cv2.Dft(complexI, complexI, DftFlags.Scale);
            var planesH = new Mat[] { H.Clone(), new Mat(H.Size(), MatType.CV_32F, Scalar.All(0)) };
            var complexH = new Mat();
            Cv2.Merge(planesH, complexH);
            var complexIH = new Mat();
            Cv2.MulSpectrums(complexI, complexH, complexIH, 0);
            Cv2.Idft(complexIH, complexIH);
            planes = Cv2.Split(complexIH);
            return planes[0];
        }

        public BlurMotion_Deblur_CS()
        {
            mblur = new BlurMotion_Basics_CS();
            desc = "Deblur a motion blurred image";
            labels[2] = "Blurred Image Input";
            labels[3] = "Deblurred Image Output";
        }

        public void RunAlg(Mat src)
        {
            mblur.options.RunOpt();

            if (vbc.task.heartBeat)
            {
                mblur.options.redoCheckBox.Checked = true;
            }

            if (mblur.options.redoCheckBox.Checked)
            {
                mblur.Run(src);
                mblur.options.showDirection = false;
                mblur.options.redoCheckBox.Checked = false;
            }
            else
            {
                mblur.Run(src);
            }

            dst2 = mblur.dst2;
            double beta = 0.2;

            int width = src.Width;
            int height = src.Height;
            var roi = new cv.Rect(0, 0, width % 2 == 0 ? width : width - 1, height % 2 == 0 ? height : height - 1);

            var h = calcPSF(roi.Size, mblur.options.restoreLen, mblur.options.theta);
            var hW = calcWeinerFilter(h, 1.0 / mblur.options.SNR);

            var gray8u = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            var imgIn = new Mat();
            gray8u.ConvertTo(imgIn, MatType.CV_32F);
            imgIn = edgeTaper(imgIn, mblur.options.gamma, beta);

            var imgOut = filter2DFreq(imgIn[roi], hW);
            imgOut.ConvertTo(dst3, MatType.CV_8U);
            dst3.Normalize(0, 255, NormTypes.MinMax);
        }
    }




    public class Boundary_Basics_CS : VB_Parent
    {
        public RedCloud_CPP_VB redCPP = new RedCloud_CPP_VB();
        public List<cv.Rect> rects = new List<cv.Rect>();
        public List<Mat> masks = new List<Mat>();
        public List<List<cv.Point>> contours = new List<List<cv.Point>>();
        public bool runRedCPP = true;
        Color8U_Basics cvt;
        RedCloud_Reduce prep;
        GuidedBP_Depth guided;

        public Boundary_Basics_CS()
        {
            cvt = new Color8U_Basics();
            prep = new RedCloud_Reduce();
            guided = new GuidedBP_Depth();
            vbc.task.redOptions.setColorSource("Bin4Way_Regions");
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Create a mask of the RedCloud cell boundaries";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
            {
                if (vbc.task.redOptions.useColorOnlyChecked)
                {
                    cvt.Run(src);
                    dst1 = cvt.dst2;
                }
                else if (vbc.task.redOptions.useDepthChecked)
                {
                    prep.Run(src);
                    dst1 = prep.dst2;
                }
                else
                {
                    guided.Run(src);
                    dst1 = guided.dst2;
                }
            }

            if (runRedCPP)
            {
                redCPP.Run(dst1);

                dst2.SetTo(0);
                rects.Clear();
                masks.Clear();
                contours.Clear();
                for (int i = 1; i < redCPP.classCount; i++)
                {
                    var rect = redCPP.rectList[i - 1];
                    var mask = redCPP.dst2[rect].InRange(i, i);
                    var contour = ContourBuild(mask, ContourApproximationModes.ApproxNone);
                    DrawContour(dst2[rect], contour, cv.Scalar.All(255), vbc.task.lineWidth);
                    rects.Add(rect);
                    masks.Add(mask);
                    contours.Add(contour);
                }

                labels[2] = $"{redCPP.classCount} cells were found.";
            }
        }
    }





    public class Boundary_Tiers_CS : VB_Parent
    {
        Boundary_Basics cells = new Boundary_Basics();
        Contour_DepthTiers contours = new Contour_DepthTiers();

        public Boundary_Tiers_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Add the depth tiers to the cell boundaries";
        }

        public void RunAlg(Mat src)
        {
            cells.Run(src);
            dst3 = cells.dst2;

            contours.Run(src);
            dst2.SetTo(0);
            foreach (var tour in contours.contourlist)
            {
                DrawContour(dst2, tour.ToList(), cv.Scalar.All(255), 2);
            }
            labels[2] = $"{contours.contourlist.Count} depth tiers were found.";
            labels[3] = cells.labels[2];
        }
    }





    public class Boundary_Rectangles_CS : VB_Parent
    {
        public Boundary_Basics bounds = new Boundary_Basics();
        public List<cv.Rect> rects = new List<cv.Rect>();
        public List<cv.Rect> smallRects = new List<cv.Rect>();
        public List<List<cv.Point>> smallContours = new List<List<cv.Point>>();
        public Options_BoundaryRect options = new Options_BoundaryRect();
        public Boundary_Rectangles_CS()
        {
            desc = "Build the boundaries for redCells and remove interior rectangles";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            bounds.Run(src);

            dst2.SetTo(0);
            foreach (var r in bounds.rects)
            {
                dst2.Rectangle(r, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
            labels[2] = $"{bounds.rects.Count} rectangles before contain test";

            rects.Clear();
            smallRects.Clear();
            smallContours.Clear();
            for (int i = 0; i < bounds.rects.Count * options.percentRect; i++)
            {
                rects.Add(bounds.rects[i]);
            }
            for (int i = bounds.rects.Count - 1; i >= (int)(bounds.rects.Count * options.percentRect); i--)
            {
                var r = bounds.rects[i];
                bool contained = false;
                foreach (var rect in bounds.rects)
                {
                    if (r == rect) continue;
                    if (rect.Contains(r))
                    {
                        contained = true;
                        break;
                    }
                }

                if (contained)
                {
                    smallContours.Add(bounds.contours[i]);
                    smallRects.Add(r);
                }
                else
                {
                    rects.Add(r);
                }
            }

            dst3.SetTo(0);
            foreach (var r in rects)
            {
                dst3.Rectangle(r, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
            labels[3] = $"{rects.Count} rectangles after contain test";
        }
    }
     




    public class Boundary_RemovedRects_CS : VB_Parent
    {
        public Boundary_Rectangles bRects = new Boundary_Rectangles();

        public Boundary_RemovedRects_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Build the boundaries for redCells and remove interior rectangles";
        }

        public void RunAlg(Mat src)
        {
            bRects.Run(src);
            dst2 = bRects.bounds.dst2.Clone();
            dst3 = bRects.dst2;
            dst1 = bRects.dst3;
            labels[3] = $"{bRects.bounds.rects.Count} cells before contain test";

            for (int i = 0; i < bRects.smallRects.Count; i++)
            {
                DrawContour(dst2[bRects.smallRects[i]], bRects.smallContours[i], Scalar.Black, vbc.task.lineWidth);
            }
            labels[1] = labels[2];
            labels[2] = $"{bRects.bounds.rects.Count - bRects.smallRects.Count} cells after contain test";
        }
    }





    public class Boundary_Overlap_CS : VB_Parent
    {
        Boundary_Basics bounds = new Boundary_Basics();

        public Boundary_Overlap_CS()
        {
            dst2 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Determine if 2 contours overlap";
        }

        public void RunAlg(Mat src)
        {
            bounds.Run(src);
            dst3 = bounds.dst2;
            bool overlapping = false;
            for (int i = 0; i < bounds.contours.Count; i++)
            {
                var tour = bounds.contours[i];
                var rect = bounds.rects[i];
                for (int j = i + 1; j < bounds.contours.Count; j++)
                {
                    var r = bounds.rects[j];
                    if (r.IntersectsWith(rect))
                    {
                        dst2.SetTo(0);
                        int c1 = tour.Count;
                        int c2 = bounds.contours[j].Count;
                        DrawContour(dst2[rect], tour, cv.Scalar.All(127), vbc.task.lineWidth);
                        DrawContour(dst2[r], bounds.contours[j], cv.Scalar.All(255), vbc.task.lineWidth);
                        int count = dst2.CountNonZero();
                        if (count != c1 + c2)
                        {
                            overlapping = true;
                            break;
                        }
                    }
                }
                if (overlapping) break;
            }
        }
    }




    public class Brightness_Basics_CS : VB_Parent
    {
        Options_BrightnessContrast Options = new Options_BrightnessContrast();

        public Brightness_Basics_CS()
        {
            desc = "Implement a brightness effect";
        }

        public void RunAlg(Mat src)
        {
            Options.RunOpt();

            dst2 = src.ConvertScaleAbs(Options.brightness, Options.contrast);
            labels[3] = "Brightness level = " + Options.contrast.ToString();
        }
    }

    // https://github.com/spmallick/learnopencv/blob/master/Photoshop-Filters-in-OpenCV/brightness.cpp




    public class Brightness_HSV_CS : VB_Parent
    {
        Options_BrightnessContrast Options = new Options_BrightnessContrast();

        public Brightness_HSV_CS()
        {
            labels[3] = "HSV image";
            desc = "Implement the brightness effect for HSV images";
        }

        public void RunAlg(Mat src)
        {
            Options.RunOpt();

            dst3 = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Mat hsv64 = new Mat();
            dst3.ConvertTo(hsv64, MatType.CV_64F);
            Mat[] split = hsv64.Split();

            split[1] *= Options.hsvBrightness;
            split[1] = split[1].Threshold(255, 255, ThresholdTypes.Trunc);

            split[2] *= Options.hsvBrightness;
            split[2] = split[2].Threshold(255, 255, ThresholdTypes.Trunc);

            Cv2.Merge(split, hsv64);
            hsv64.ConvertTo(dst2, MatType.CV_8UC3);
            dst2 = dst2.CvtColor(ColorConversionCodes.HSV2BGR);
            labels[2] = "Brightness level = " + Options.hsvBrightness.ToString();
        }
    }




    public class BRISK_Basics_CS : VB_Parent
    {
        BRISK brisk;
        public List<cv.Point2f> features = new List<cv.Point2f>();
        Options_Features options = new Options_Features();

        public BRISK_Basics_CS()
        {
            brisk = BRISK.Create();
            UpdateAdvice(traceName + ": only the 'Min Distance' option affects the BRISK results.");
            desc = "Detect features with BRISK";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            src.CopyTo(dst2);

            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            KeyPoint[] keyPoints = brisk.Detect(src);

            features.Clear();
            foreach (var pt in keyPoints)
            {
                if (pt.Size > options.minDistance)
                {
                    features.Add(new cv.Point2f(pt.Pt.X, pt.Pt.Y));
                    DrawCircle(dst2, pt.Pt, vbc.task.DotSize + 1, vbc.task.HighlightColor);
                }
            }
            labels[2] = features.Count + " features found with BRISK";
        }
    }




    public class BackProject2D_Basics_CS : VB_Parent
    {
        public Hist2D_Basics hist2d = new Hist2D_Basics();
        public Color_Basics colorFmt = new Color_Basics();
        public bool backProjectByGrid;
        public int classCount;

        public BackProject2D_Basics_CS()
        {
            UpdateAdvice(traceName + ": the global option 'Histogram Bins' controls the histogram.");
            desc = "A 2D histogram is built from 2 channels of any 3-channel input and the results are displayed.";
        }

        public void RunAlg(Mat src)
        {
            int index = vbc.task.gridMap.At<int>(vbc.task.mouseMovePoint.Y, vbc.task.mouseMovePoint.X);
            var roi = vbc.task.gridRects[index];

            colorFmt.Run(src);
            hist2d.Run(colorFmt.dst2);
            dst2 = hist2d.dst2;

            if (standaloneTest())
            {
                dst2.Rectangle(roi, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            }

            Mat histogram = new Mat();
            if (backProjectByGrid)
            {
                vbc.task.gridMap.ConvertTo(histogram, MatType.CV_32F);
            }
            else
            {
                histogram = new Mat(hist2d.histogram.Size(), MatType.CV_32F, cv.Scalar.All(0));
                hist2d.histogram[roi].CopyTo(histogram[roi]);
            }
            Cv2.CalcBackProject(new[] { colorFmt.dst2 }, hist2d.channels, histogram, dst0, hist2d.ranges);

            int bpCount = hist2d.histogram[roi].CountNonZero();

            if (backProjectByGrid)
            {
                var mm = GetMinMax(dst0);
                classCount = (int)mm.maxVal;
                //vbc.task.palette.Run(dst0 * 255 / classCount);
                dst3 = ShowPalette(dst0 * 255 / classCount);
                //dst3 = vbc.task.palette.dst2;
            }
            else
            {
                dst3.SetTo(Scalar.All(0));
                dst3.SetTo(Scalar.Yellow, dst0);
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = colorFmt.options.colorFormat + " format " + (classCount > 0 ? classCount + " classes" : " ");
                int c1 = vbc.task.redOptions.channels[0], c2 = vbc.task.redOptions.channels[1];
                labels[3] = "That combination of channel " + c1 + "/" + c2 + " has " + bpCount +
                            " pixels while image total is " + dst0.Total().ToString("0");
            }
            SetTrueText("Use Global Algorithm Option 'grid Square Size' to control the 2D backprojection",
                        new cv.Point(10, dst3.Height - 20), 3);
        }
    }





    public class BackProject2D_BasicsOld_CS : VB_Parent
    {
        public Hist2D_Basics hist2d = new Hist2D_Basics();
        public int xRange = 255;
        public int yRange = 255;
        public float minX, maxX, minY, maxY;
        public Color_Basics colorFmt = new Color_Basics();
        public int bpCol, bpRow;
        public BackProject2D_BasicsOld_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setGridSize(5);
            UpdateAdvice(traceName + ": the global option 'Histogram Bins' controls the histogram.");
            desc = "A 2D histogram is built from 2 channels of any 3-channel input and the results are displayed.";
        }
        public void RunAlg(Mat src)
        {
            bpCol = (int)Math.Floor((double)(vbc.task.mouseMovePoint.X / vbc.task.gridCols));
            bpRow = (int)Math.Floor((double)(vbc.task.mouseMovePoint.Y / vbc.task.gridRows));
            colorFmt.Run(src);
            hist2d.Run(colorFmt.dst2);
            dst2 = hist2d.dst2;
            minX = bpRow * xRange / vbc.task.gridSize;
            maxX = (bpRow + 1) * xRange / vbc.task.gridSize;
            minY = bpCol * yRange / vbc.task.gridSize;
            maxY = (bpCol + 1) * yRange / vbc.task.gridSize;
            Rangef[] ranges = new Rangef[] { new Rangef(minX, maxX), new Rangef(minY, maxY) };
            Cv2.CalcBackProject(new Mat[] { src }, vbc.task.redOptions.channels, hist2d.histogram, dst0, ranges);
            float bpCount = hist2d.histogram.Get<float>(bpRow, bpCol);
            dst3.SetTo(0);
            dst3.SetTo(Scalar.Yellow, dst0);
            if (vbc.task.heartBeat)
            {
                labels[2] = colorFmt.options.colorFormat + ": Cell minX/maxX " + minX.ToString("0") + "/" + maxX.ToString("0") + " minY/maxY " +
                            minY.ToString("0") + "/" + maxY.ToString("0");
                int c1 = vbc.task.redOptions.channels[0], c2 = vbc.task.redOptions.channels[1];
                labels[3] = "That combination of channel " + c1.ToString() + "/" + c2.ToString() + " has " + bpCount.ToString() +
                            " pixels while image total is " + dst0.Total().ToString("0");
            }
            SetTrueText("Use Global Algorithm Option 'grid Square Size' to control the 2D histogram at left",
                        new cv.Point(10, dst3.Height - 20), 3);
        }
    }




    public class BackProject2D_RowCol_CS : VB_Parent
    {
        BackProject2D_Basics backp = new BackProject2D_Basics();
        Options_BackProject2D options = new Options_BackProject2D();
        public BackProject2D_RowCol_CS()
        {
            FindRadio("HSV").Checked = true;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setGridSize(10);
            desc = "Backproject the whole row or column of the 2D histogram";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst0 = src.Clone();
            var selection = options.backProjectRow ? "Row" : "Col";
            labels[2] = "Histogram 2D with Backprojection by " + selection;
            backp.Run(src);
            dst2 = Convert32f_To_8UC3(backp.dst2) * 255;
            var roi = vbc.task.gridRects[vbc.task.gridMap.Get<int>(vbc.task.mouseMovePoint.Y, vbc.task.mouseMovePoint.X)];
            cv.Rect rect;
            if (options.backProjectRow)
            {
                rect = new cv.Rect(0, roi.Y, dst2.Width, roi.Height);
            }
            else
            {
                rect = new cv.Rect(roi.X, 0, roi.Width, dst2.Height);
            }
            dst2.Rectangle(rect, vbc.task.HighlightColor, vbc.task.lineWidth);
            Mat histData = new Mat(backp.hist2d.histogram.Size(), MatType.CV_32F, cv.Scalar.All(0));
            backp.hist2d.histogram[rect].CopyTo(histData[rect]);
            var ranges = backp.hist2d.ranges;
            Cv2.CalcBackProject(new Mat[] { src }, backp.hist2d.channels, histData, dst1, ranges);
            dst3.SetTo(0);
            dst3.SetTo(Scalar.Yellow, dst1);
            dst0.SetTo(0, dst1);
            if (vbc.task.heartBeat)
            {
                var count = histData[rect].Sum();
                labels[3] = "Selected " + selection + " = " + histData[rect].CountNonZero() + " non-zero histogram entries representing total pixels of " + count;
            }
            if (vbc.task.heartBeat)
            {
                strOut = "Use Global Algorithm Option 'grid Square Size' to control the 2D histogram." + "\n" +
                         "Move mouse in 2D histogram to select a row or column to backproject.";
            }
            SetTrueText(strOut, 1);
        }
    }





    public class BackProject2D_Compare_CS : VB_Parent
    {
        PhotoShop_Hue hueSat = new PhotoShop_Hue();
        BackProject2D_Basics_CS backP;
        Mat_4Click mats = new Mat_4Click();

        public BackProject2D_Compare_CS()
        {
            backP = new BackProject2D_Basics_CS();
            labels[2] = "Hue (upper left), sat (upper right), highlighted backprojection (bottom left)";
            if (standaloneTest()) vbc.task.gOptions.setGridSize(10);
            desc = "Compare the hue and brightness images and the results of the Hist_backprojection2d";
        }

        public void RunAlg(Mat src)
        {
            hueSat.Run(src.Clone());
            mats.mat[0] = hueSat.dst2;
            mats.mat[1] = hueSat.dst3;

            backP.Run(src);
            mats.mat[2] = backP.dst3;

            if (vbc.task.FirstPass) mats.quadrant = 3;
            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC3));
            dst2 = mats.dst2;
            dst3 = mats.dst3;

            labels[3] = backP.labels[3];

            SetTrueText("Use Global Algorithm Option 'grid Square Size' to control this 2D histogram.\n" +
                        "Move mouse in 2D histogram to select a cell to backproject.\n" +
                        "Click any quadrant at left to display that quadrant here.\n",
                        new cv.Point(10, dst3.Height - dst3.Height / 4), 3);
        }
    }




    public class BackProject2D_Top_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();

        public BackProject2D_Top_CS()
        {
            labels = new string[] { "", "", "Top Down HeatMap", "BackProject2D for the top-down view" };
            desc = "Backproject the output of the Top View.";
        }

        public void RunAlg(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst2;

            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, heat.histogramTop, dst3, vbc.task.rangesTop);
            dst3 = Convert32f_To_8UC3(dst3);
            dst3 = ShowPalette(dst3);
        }
    }





    public class BackProject2D_Side_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();

        public BackProject2D_Side_CS()
        {
            labels = new string[] { "", "", "Side View HeatMap", "BackProject2D for the side view" };
            desc = "Backproject the output of the Side View.";
        }

        public void RunAlg(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst3;

            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, heat.histogramSide, dst3, vbc.task.rangesSide);
            dst3 = Convert32f_To_8UC3(dst3);
            dst3 = ShowPalette(dst3);
        }
    }





    public class BackProject2D_Filter_CS : VB_Parent
    {
        public int threshold;

        public BackProject2D_Filter_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            vbc.task.gOptions.setHistogramBins(100); // extra bins to help isolate the stragglers.
            desc = "Filter a 2D histogram for the backprojection.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesSide);
            }
            dst1.Col(0).SetTo(0);

            dst2 = dst1.Threshold(threshold, 255, cv.ThresholdTypes.Binary);
        }
    }




    public class BackProject2D_FilterSide_CS : VB_Parent
    {
        public BackProject2D_Filter filter = new BackProject2D_Filter();
        Options_HistXD options = new Options_HistXD();

        public BackProject2D_FilterSide_CS()
        {
            desc = "Backproject the output of the Side View after removing low sample bins.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat histogram = new Mat();
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesSide);

            filter.threshold = options.sideThreshold;
            filter.histogram = histogram;
            filter.Run(src);

            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, filter.dst2, dst1, vbc.task.rangesSide);
            dst1.ConvertTo(dst1, MatType.CV_8U);

            dst2.SetTo(0);
            vbc.task.pointCloud.CopyTo(dst2, dst1);
        }
    }





    public class BackProject2D_FilterTop_CS : VB_Parent
    {
        BackProject2D_Filter filter = new BackProject2D_Filter();
        Options_HistXD options = new Options_HistXD();

        public BackProject2D_FilterTop_CS()
        {
            desc = "Backproject the output of the Side View after removing low sample bins.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat histogram = new Mat();
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesSide);

            filter.threshold = options.topThreshold;
            filter.histogram = histogram;
            filter.Run(src);

            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, filter.dst2, dst1, vbc.task.rangesTop);
            dst1.ConvertTo(dst1, MatType.CV_8U);

            dst2.SetTo(0);
            vbc.task.pointCloud.CopyTo(dst2, dst1);
        }
    }





    public class BackProject2D_FilterBoth_CS : VB_Parent
    {
        BackProject2D_FilterSide filterSide = new BackProject2D_FilterSide();
        BackProject2D_FilterTop filterTop = new BackProject2D_FilterTop();

        public BackProject2D_FilterBoth_CS()
        {
            desc = "Backproject the output of the both the top and side views after removing low sample bins.";
        }

        public void RunAlg(Mat src)
        {
            filterSide.Run(src);
            filterTop.Run(src);

            dst2.SetTo(0);
            vbc.task.pointCloud.CopyTo(dst2, filterSide.dst1);
            vbc.task.pointCloud.CopyTo(dst3, filterTop.dst1);
        }
    }




    public class BackProject2D_Full_CS : VB_Parent
    {
        BackProject2D_Basics_CS backP;
        public int classCount;

        public BackProject2D_Full_CS()
        {
            backP = new BackProject2D_Basics_CS();
            backP.backProjectByGrid = true;
            desc = "Backproject the 2D histogram marking each grid element's backprojection";
        }

        public void RunAlg(Mat src)
        {
            backP.Run(src);
            dst2 = backP.dst0;
            dst3 = backP.dst3;
            classCount = backP.classCount;
            labels = backP.labels;
        }
    }




    public class CameraMotion_Basics_CS : VB_Parent
    {
        public int translationX;
        public int translationY;
        Gravity_Horizon gravity = new Gravity_Horizon();
        public bool secondOpinion;
        Swarm_Basics feat = new Swarm_Basics();
        PointPair gravityVec;
        PointPair horizonVec;
        public CameraMotion_Basics_CS()
        {
            dst2 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.gOptions.setDebugSlider(3);
            desc = "Merge with previous image using just translation of the gravity vector and horizon vector (if present)";
        }

        public void RunAlg(Mat src)
        {
            gravity.Run(src);

            if (vbc.task.FirstPass)
            {
                gravityVec = new PointPair(vbc.task.gravityVec.p1, vbc.task.gravityVec.p2);
                horizonVec = new PointPair(vbc.task.horizonVec.p1, vbc.task.horizonVec.p2);
            }

            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            translationX = vbc.task.gOptions.DebugSliderValue;
            translationY = vbc.task.gOptions.DebugSliderValue;

            if (Math.Abs(translationX) >= dst2.Width / 2)
                translationX = 0;

            if (horizonVec.p1.Y >= dst2.Height || horizonVec.p2.Y >= dst2.Height || Math.Abs(translationY) >= dst2.Height / 2)
            {
                horizonVec = new PointPair(new Point2f(), new Point2f(336, 0));
                translationY = 0;
            }

            cv.Rect r1, r2;
            if (translationX == 0 && translationY == 0)
            {
                dst2 = src;
                vbc.task.camMotionPixels = 0;
                vbc.task.camDirection = 0;
            }
            else
            {
                r1 = new cv.Rect(translationX, translationY, Math.Min(dst2.Width - translationX * 2, dst2.Width),
                              Math.Min(dst2.Height - translationY * 2, dst2.Height));
                if (r1.X < 0)
                {
                    r1.X = -r1.X;
                    r1.Width += translationX * 2;
                }
                if (r1.Y < 0)
                {
                    r1.Y = -r1.Y;
                    r1.Height += translationY * 2;
                }

                r2 = new cv.Rect(Math.Abs(translationX), Math.Abs(translationY), r1.Width, r1.Height);

                vbc.task.camMotionPixels = (float)Math.Sqrt(translationX * translationX + translationY * translationY);
                if (translationX == 0)
                {
                    if (translationY < 0)
                        vbc.task.camDirection = (float)Math.PI / 4;
                    else
                        vbc.task.camDirection = (float)Math.PI * 3 / 4;
                }
                else
                {
                    vbc.task.camDirection = (float)Math.Atan2(translationY, translationX);
                }

                if (secondOpinion)
                {
                    dst3.SetTo(0);
                    feat.Run(src);
                    strOut = "Swarm distance = " + feat.distanceAvg.ToString("F1") + " when camMotionPixels = " + vbc.task.camMotionPixels.ToString("F1");
                    if (feat.distanceAvg < vbc.task.camMotionPixels / 2 || vbc.task.heartBeat)
                    {
                        vbc.task.camMotionPixels = 0;
                        src.CopyTo(dst2);
                    }
                    dst3 = (src - dst2).ToMat().Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
                }
            }

            gravityVec = new PointPair(vbc.task.gravityVec.p1, vbc.task.gravityVec.p2);
            horizonVec = new PointPair(vbc.task.horizonVec.p1, vbc.task.horizonVec.p2);
            SetTrueText(strOut, 3);

            labels[2] = "Translation (X, Y) = (" + translationX.ToString() + ", " + translationY.ToString() + ")" +
                        (horizonVec.p1.Y == 0 && horizonVec.p2.Y == 0 ? " there is no horizon present" : "");
            labels[3] = "Camera direction (radians) = " + vbc.task.camDirection.ToString("F1") + " with distance = " + vbc.task.camMotionPixels.ToString("F1");
        }
    }




    public class CameraMotion_WithRotation_CS : VB_Parent
    {
        public float translationX;
        public float rotationX;
        public Point2f centerX;
        public float translationY;
        public float rotationY;
        public Point2f centerY;
        public Rotate_BasicsQT rotate = new Rotate_BasicsQT();
        PointPair gravityVec;
        PointPair horizonVec;
        public CameraMotion_WithRotation_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Merge with previous image using rotation AND translation of the camera motion - not as good as translation alone.";
        }
        public void translateRotateX(int x1, int x2)
        {
            rotationX = (float)(Math.Atan(Math.Abs(x1 - x2) / (double)dst2.Height) * 57.2958);
            centerX = new Point2f((vbc.task.gravityVec.p1.X + vbc.task.gravityVec.p2.X) / 2, (vbc.task.gravityVec.p1.Y + vbc.task.gravityVec.p2.Y) / 2);
            if (x1 >= 0 && x2 > 0)
            {
                translationX = x1 > x2 ? x1 - x2 : x2 - x1;
                centerX = vbc.task.gravityVec.p2;
            }
            else if (x1 <= 0 && x2 < 0)
            {
                translationX = x1 > x2 ? x1 - x2 : x2 - x1;
                centerX = vbc.task.gravityVec.p1;
            }
            else if (x1 < 0 && x2 > 0)
            {
                translationX = 0;
            }
            else
            {
                translationX = 0;
                rotationX *= -1;
            }
        }
        public void translateRotateY(int y1, int y2)
        {
            rotationY = (float)(Math.Atan(Math.Abs(y1 - y2) / (double)dst2.Width) * 57.2958);
            centerY = new Point2f((vbc.task.horizonVec.p1.X + vbc.task.horizonVec.p2.X) / 2, (vbc.task.horizonVec.p1.Y + vbc.task.horizonVec.p2.Y) / 2);
            if (y1 > 0 && y2 > 0)
            {
                translationY = y1 > y2 ? y1 - y2 : y2 - y1;
                centerY = vbc.task.horizonVec.p2;
            }
            else if (y1 < 0 && y2 < 0)
            {
                translationY = y1 > y2 ? y1 - y2 : y2 - y1;
                centerY = vbc.task.horizonVec.p1;
            }
            else if (y1 < 0 && y2 > 0)
            {
                translationY = 0;
            }
            else
            {
                translationY = 0;
                rotationY *= -1;
            }
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass)
            {
                gravityVec = vbc.task.gravityVec;
                horizonVec = vbc.task.horizonVec;
            }
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            int x1 = (int)(gravityVec.p1.X - vbc.task.gravityVec.p1.X);
            int x2 = (int)(gravityVec.p2.X - vbc.task.gravityVec.p2.X);
            int y1 = (int)(horizonVec.p1.Y - vbc.task.horizonVec.p1.Y);
            int y2 = (int)(horizonVec.p2.Y - vbc.task.horizonVec.p2.Y);
            translateRotateX(x1, x2);
            translateRotateY(y1, y2);
            dst1.SetTo(Scalar.All(0));
            dst3.SetTo(Scalar.All(0));
            if (Math.Abs(x1 - x2) > 0.5 || Math.Abs(y1 - y2) > 0.5)
            {
                cv.Rect r1 = new cv.Rect((int)translationX, (int)translationY, dst2.Width - (int)translationX, dst2.Height - (int)translationY);
                cv.Rect r2 = new cv.Rect(0, 0, r1.Width, r1.Height);
                src[r1].CopyTo(dst1[r2]);
                rotate.rotateAngle = rotationY;
                rotate.rotateCenter = centerY;
                rotate.Run(dst1);
                dst2 = rotate.dst2;
                dst3 = (src - dst2).ToMat().Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            }
            else
            {
                dst2 = src;
            }
            gravityVec = vbc.task.gravityVec;
            horizonVec = vbc.task.horizonVec;
            labels[2] = "Translation X = " + translationX.ToString(vbc.fmt1) + " rotation X = " + rotationX.ToString(vbc.fmt1) + " degrees " +
                        " center of rotation X = " + centerX.X.ToString(vbc.fmt0) + ", " + centerX.Y.ToString(vbc.fmt0);
            labels[3] = "Translation Y = " + translationY.ToString(vbc.fmt1) + " rotation Y = " + rotationY.ToString(vbc.fmt1) + " degrees " +
                        " center of rotation Y = " + centerY.X.ToString(vbc.fmt0) + ", " + centerY.Y.ToString(vbc.fmt0);
        }
    }




    public class CameraMotion_SceneMotion_CS : VB_Parent
    {
        CameraMotion_Basics cMotion = new CameraMotion_Basics();
        Motion_Basics motion = new Motion_Basics();
        public CameraMotion_SceneMotion_CS()
        {
            labels[2] = "Image after adjusting for camera motion.";
            desc = "Display both camera motion (on heartbeats) and scene motion.";
        }
        public void RunAlg(Mat src)
        {
            cMotion.Run(src);
            dst2 = cMotion.dst3;
            motion.Run(src);
            dst3 = motion.dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }




    public class CamShift_Basics_CS : VB_Parent
    {
        public RotatedRect trackBox = new RotatedRect();
        CamShift_RedHue redHue = new CamShift_RedHue();
        cv.Rect roi = new cv.Rect();
        Mat histogram = new Mat();
        public CamShift_Basics_CS()
        {
            UpdateAdvice(traceName + ": Draw on any available red hue area.");
            labels[2] = "Draw anywhere to create histogram and start camshift";
            labels[3] = "Histogram of targeted region (hue only)";
            UpdateAdvice(traceName + ": click 'Show All' to control camShift options.");
            desc = "CamShift Demo - draw on the images to define the object to track.";
        }
        public void RunAlg(Mat src)
        {
            redHue.RunAlg(src);
            dst2 = redHue.dst2;
            Mat hue = redHue.dst1;
            Mat mask = redHue.dst3;
            Rangef[] ranges = { new Rangef(0, 180) };
            int[] hsize = { vbc.task.histogramBins };
            vbc.task.drawRect = ValidateRect(vbc.task.drawRect);
            Cv2.CalcHist(new Mat[] { hue[vbc.task.drawRect] }, new int[] { 0 }, mask[vbc.task.drawRect], histogram, 1, hsize, ranges);
            histogram = histogram.Normalize(0, 255, NormTypes.MinMax);
            roi = vbc.task.drawRect;
            if (histogram.Rows != 0)
            {
                Cv2.CalcBackProject(new Mat[] { hue }, new int[] { 0 }, histogram, dst1, ranges);
                trackBox = Cv2.CamShift(dst1 & mask, ref roi, new TermCriteria(cv.CriteriaTypes.MaxIter, 10, 1));
                dst3 = Show_HSV_Hist(histogram);
                if (dst3.Channels() == 1) dst3 = src;
                dst3 = dst3.CvtColor(ColorConversionCodes.HSV2BGR);
            }
            if (trackBox.Size.Width > 0)
            {
                dst2.Ellipse(trackBox, Scalar.White, vbc.task.lineWidth + 1, vbc.task.lineType);
            }
        }
    }




    public class CamShift_RedHue_CS : VB_Parent
    {
        Options_CamShift options = new Options_CamShift();
        public CamShift_RedHue_CS()
        {
            labels = new string[] { "", "Hue", "Image regions with red hue", "Mask for hue regions" };
            desc = "Find that portion of the image where red dominates";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            dst3 = hsv.InRange(options.camSBins, new Scalar(180, 255, options.camMax));
            dst2.SetTo(0);
            src.CopyTo(dst2, dst3);
        }
    }




    public class Cartoonify_Basics_CS : VB_Parent
    {
        Options_Cartoonify options = new Options_Cartoonify();
        public Cartoonify_Basics_CS()
        {
            labels[2] = "Mask for Cartoon";
            labels[3] = "Cartoonify Result";
            UpdateAdvice(traceName + ": click 'Show All' to control cartoonify options.");
            desc = "Create a cartoon from a color image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat gray8u = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            gray8u = gray8u.MedianBlur(options.medianBlur);
            Mat edges = gray8u.Laplacian(MatType.CV_8U, options.kernelSize);
            Mat mask = edges.Threshold(options.threshold, 255, ThresholdTypes.Binary);
            dst2 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3 = src.MedianBlur(options.medianBlur2).MedianBlur(options.medianBlur2);
            src.CopyTo(dst3, mask);
        }
    }




    public class Pixel_Unstable_CS : VB_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        List<int> pixelCounts = new List<int>();
        int k = -1;
        List<Mat> unstable = new List<Mat>();
        Mat lastImage;
        public Mat unstablePixels = new Mat();
        TrackBar kSlider;
        public Pixel_Unstable_CS()
        {
            vbc.task.gOptions.setPixelDifference(2);
            kSlider = FindSlider("KMeans k");
            labels[2] = "KMeans_Basics output";
            desc = "Detect where pixels are unstable";
        }
        public void RunAlg(Mat src)
        {
            k = kSlider.Value;
            km.Run(src);
            dst2 = km.dst2;
            dst2.ConvertTo(dst2, MatType.CV_32F);
            if (lastImage == null) lastImage = dst2.Clone();
            Cv2.Subtract(dst2, lastImage, dst3);
            dst3 = dst3.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            unstable.Add(dst3);
            if (unstable.Count > vbc.task.frameHistoryCount) unstable.RemoveAt(0);
            unstablePixels = unstable[0];
            for (int i = 1; i < unstable.Count; i++)
            {
                unstablePixels = unstablePixels | unstable[i];
            }
            dst3 = unstablePixels;
            int unstableCount = dst3.CountNonZero();
            pixelCounts.Add(unstableCount);
            if (pixelCounts.Count > 100) pixelCounts.RemoveAt(0);
            // compute stdev from the list
            double avg = pixelCounts.Average();
            double sum = pixelCounts.Sum(d => Math.Pow(d - avg, 2));
            double stdev = Math.Sqrt(sum / pixelCounts.Count);
            labels[3] = "Unstable pixel count = " + avg.ToString("###,##0") + "    stdev = " + stdev.ToString("0.0");
            lastImage = dst2.Clone();
        }
    }




    public class CComp_Basics_CS : VB_Parent
    {
        public ConnectedComponents connectedComponents;
        public List<cv.Rect> rects = new List<cv.Rect>();
        public List<cv.Point2f> centroids = new List<cv.Point2f>();
        Mat lastImage;
        Options_CComp options = new Options_CComp();
        public CComp_Basics_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            UpdateAdvice(traceName + ": only the local options for threshold is used in CComp_Basics_CS.");
            labels[2] = "Input to ConnectedComponenetsEx";
            desc = "Draw bounding boxes around BGR binarized connected Components";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            rects.Clear();
            centroids.Clear();
            Mat input = src;
            if (input.Channels() == 3)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = input.Threshold(options.threshold, 255, ThresholdTypes.BinaryInv);
            connectedComponents = Cv2.ConnectedComponentsEx(dst2);
            connectedComponents.RenderBlobs(dst3);
            int count = 0;
            foreach (var blob in connectedComponents.Blobs)
            {
                var rect = ValidateRect(blob.Rect);
                var m = Cv2.Moments(dst2[rect], true);
                if (m.M00 == 0) continue; // avoid divide by zero...
                rects.Add(rect);
                centroids.Add(new Point2f((float)(m.M10 / m.M00 + rect.X), (float)(m.M01 / m.M00 + rect.Y)));
                count++;
            }
            lastImage = dst2;
            labels[3] = count + " items found ";
        }
    }




    public class CComp_Shapes_CS : VB_Parent
    {
        Mat shapes;
        Mat_4Click mats = new Mat_4Click();
        public CComp_Shapes_CS()
        {
            shapes = new Mat(vbc.task.HomeDir + "Data/Shapes.png", ImreadModes.Color);
            labels[2] = "Largest connected component";
            labels[3] = "RectView, LabelView, Binary, grayscale";
            desc = "Use connected components to isolate objects in image.";
        }
        public void RunAlg(Mat src)
        {
            var gray = shapes.CvtColor(ColorConversionCodes.BGR2GRAY);
            var binary = gray.Threshold(0, 255, ThresholdTypes.Otsu | ThresholdTypes.Binary);
            var labelview = shapes.EmptyClone();
            var rectView = binary.CvtColor(ColorConversionCodes.GRAY2BGR);
            var cc = Cv2.ConnectedComponentsEx(binary);
            if (cc.LabelCount <= 1) return;
            cc.RenderBlobs(labelview);
            foreach (var blob in cc.Blobs.Skip(1))
            {
                rectView.Rectangle(blob.Rect, Scalar.Red, 2);
            }
            var maxBlob = cc.GetLargestBlob();
            var filtered = new Mat();
            cc.FilterByBlob(shapes, filtered, maxBlob);
            mats.mat[0] = rectView;
            mats.mat[1] = labelview;
            mats.mat[2] = binary;
            mats.mat[3] = gray;
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class CComp_Both_CS : VB_Parent
    {
        CComp_Stats above = new CComp_Stats();
        CComp_Stats below = new CComp_Stats();
        public CComp_Both_CS()
        {
            labels = new string[] { "", "", "Connected components in both the lighter and darker halves", "Connected components in the darker half of the image" };
            desc = "Prepare the connected components for both above and below the threshold";
        }
        public void RunAlg(Mat src)
        {
            above.options.RunOpt();
            var light = src.Threshold(above.options.light, 255, ThresholdTypes.Binary);
            below.Run(light);
            dst2 = below.dst3;
            dst1 = below.dst1;
            labels[3] = above.labels[3];
        }
    }




    public class CComp_Hulls_CS : VB_Parent
    {
        CComp_Both ccomp = new CComp_Both();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public CComp_Hulls_CS()
        {
            desc = "Create connected components using RedCloud Hulls";
        }
        public void RunAlg(Mat src)
        {
            ccomp.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = ccomp.dst3;
            ccomp.dst1.ConvertTo(dst1, MatType.CV_8U);
            hulls.Run(dst1);
            dst2 = hulls.dst3;
            labels[2] = hulls.labels[3];
        }
    }
    // https://docs.opencv.org/master/de/d01/samples_2cpp_2connected_components_8cpp-example.html




    public class CComp_Stats_CS : VB_Parent
    {
        public List<Mat> masks = new List<Mat>();
        public List<cv.Rect> rects = new List<cv.Rect>();
        public List<int> areas = new List<int>();
        public List<cv.Point> centroids = new List<cv.Point>();
        public int numberOfLabels;
        public Options_CComp options = new Options_CComp();
        public CComp_Stats_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use a threshold slider on the CComp input";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            options.RunOpt();
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (standaloneTest())
                src = src.Threshold(options.light, 255, ThresholdTypes.BinaryInv);
            Mat stats = new Mat();
            Mat centroidRaw = new Mat();
            numberOfLabels = Cv2.ConnectedComponentsWithStats(src, dst1, stats, centroidRaw);
            rects.Clear();
            areas.Clear();
            centroids.Clear();
            List<Vec3b> colors = new List<Vec3b>();
            SortedList<float, int> maskOrder = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
            List<Mat> unsortedMasks = new List<Mat>();
            List<cv.Rect> unsortedRects = new List<cv.Rect>();
            List<cv.Point> unsortedCentroids = new List<cv.Point>();
            List<int> index = new List<int>();
            for (int i = 0; i < Math.Min(256, stats.Rows); i++)
            {
                int area = stats.Get<int>(i, 4);
                if (area < 10) continue;
                cv.Rect r1 = ValidateRect(stats.Get<cv.Rect>(i, 0));
                cv.Rect r = ValidateRect(new cv.Rect(r1.X, r1.Y, r1.Width, r1.Height));
                if ((r.Width == dst2.Width && r.Height == dst2.Height) || (r.Width == 1 && r.Height == 1)) continue;
                areas.Add(area);
                unsortedRects.Add(r);
                dst2.Rectangle(r, vbc.task.HighlightColor, vbc.task.lineWidth);
                index.Add(i);
                colors.Add(vbc.task.vecColors[colors.Count]);
                maskOrder.Add(area, unsortedMasks.Count);
                unsortedMasks.Add(dst1.InRange(i, i)[r]);
                cv.Point c = new cv.Point((int)centroidRaw.Get<double>(i, 0), (int)centroidRaw.Get<double>(i, 1));
                unsortedCentroids.Add(c);
            }
            masks.Clear();
            for (int i = 0; i < maskOrder.Count; i++)
            {
                int mIndex = maskOrder.ElementAt(i).Value;
                masks.Add(unsortedMasks[mIndex]);
                rects.Add(unsortedRects[mIndex]);
                centroids.Add(unsortedCentroids[mIndex]);
            }
            dst1.ConvertTo(dst0, MatType.CV_8U);
            dst3 = ShowPalette(dst0 * 255 / centroids.Count);
            labels[3] = masks.Count + " Connected Components";
        }
    }




    public class Cell_Basics_CS : VB_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        PCA_Basics pca = new PCA_Basics();
        Plane_Equation eq = new Plane_Equation();
        public bool runRedCloud;
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_Basics_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(20);
            desc = "Display the statistics for the selected cell.";
        }
        public void statsString()
        {
            if (vbc.task.heartBeat)
            {
                var rc = vbc.task.rc;
                var gridID = vbc.task.gridMap.Get<int>(rc.maxDist.Y, rc.maxDist.X);
                strOut = "rc.index = " + rc.index.ToString() + "\t" + " gridID = " + gridID.ToString() + "\r\n";
                strOut += "rc.rect: " + rc.rect.X.ToString() + ", " + rc.rect.Y.ToString() + ", ";
                strOut += rc.rect.Width.ToString() + ", " + rc.rect.Height.ToString() + "\r\n" + "rc.color = " + rc.color.ToString() + "\r\n";
                strOut += "rc.maxDist = " + rc.maxDist.X.ToString() + "," + rc.maxDist.Y.ToString() + "\r\n";
                strOut += rc.depthPixels > 0 ? "Cell is marked as depthCell \r\n" : "";
                if (rc.depthPixels > 0)
                {
                    strOut += "depth pixels " + rc.pixels.ToString() + "\r\n" + "rc.depthPixels = " + rc.depthPixels.ToString() +
                          " or " + (rc.depthPixels / (float)rc.pixels).ToString("0%") + " depth \r\n";
                }
                else
                {
                    strOut += "depth pixels " + rc.pixels.ToString() + " - no depth data\r\n";
                }
                strOut += "Depth Min/Max/Range: X = " + rc.minVec.X.ToString(vbc.fmt1) + "/" + rc.maxVec.X.ToString(vbc.fmt1);
                strOut += "/" + (rc.maxVec.X - rc.minVec.X).ToString(vbc.fmt1) + "\t";
                strOut += "Y = " + rc.minVec.Y.ToString(vbc.fmt1) + "/" + rc.maxVec.Y.ToString(vbc.fmt1);
                strOut += "/" + (rc.maxVec.Y - rc.minVec.Y).ToString(vbc.fmt1) + "\t";
                strOut += "Z = " + rc.minVec.Z.ToString(vbc.fmt2) + "/" + rc.maxVec.Z.ToString(vbc.fmt2);
                strOut += "/" + (rc.maxVec.Z - rc.minVec.Z).ToString(vbc.fmt2) + "\r\n\r\n";
                strOut += "Cell Mean in 3D: x/y/z = \t" + rc.depthMean[0].ToString(vbc.fmt2) + "\t";
                strOut += rc.depthMean[1].ToString(vbc.fmt2) + "\t" + rc.depthMean[2].ToString(vbc.fmt2) + "\r\n";
                strOut += "Color Mean  RGB: \t" + rc.colorMean[0].ToString(vbc.fmt1) + "\t" + rc.colorMean[1].ToString(vbc.fmt1) + "\t";
                strOut += rc.colorMean[2].ToString(vbc.fmt1) + "\r\n";
                strOut += "Color Stdev RGB: \t" + rc.colorStdev[0].ToString(vbc.fmt1) + "\t" + rc.colorStdev[1].ToString(vbc.fmt1) + "\t";
                strOut += rc.colorStdev[2].ToString(vbc.fmt1) + "\r\n";
                var tmp = new Mat(vbc.task.rc.mask.Rows, vbc.task.rc.mask.Cols, MatType.CV_32F, cv.Scalar.All(0));
                vbc.task.pcSplit[2][vbc.task.rc.rect].CopyTo(tmp, vbc.task.rc.mask);
                plot.rc = vbc.task.rc;
                plot.Run(tmp);
                dst1 = plot.dst2;
                // If rc.depthMean[2] == 0
                // {
                //     strOut += "\r\nNo depth data is available for that cell. ";
                // }
                // else
                // {
                //     eq.rc = rc;
                //     eq.Run(src);
                //     rc = eq.rc;
                //     strOut += "\r\n" + eq.strOut + "\r\n";
                //     pca.Run(empty);
                //     strOut += "\r\n" + pca.strOut;
                // }
            }
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || runRedCloud)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
            }

            statsString();
            SetTrueText(strOut, 3);
            labels[1] = "Histogram plot for the cell's depth data - X-axis varies from 0 to " + ((int)vbc.task.MaxZmeters).ToString() + " meters";
        }
    }




    public class Cell_PixelCountCompare_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_PixelCountCompare_CS()
        {
            vbc.task.gOptions.setDebugCheckBox(true);
            desc = "The rc.mask is filled and may completely contain depth pixels.  This alg finds cells that contain depth islands.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            int missCount = 0;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.depthPixels != 0)
                {
                    if (rc.pixels != rc.depthPixels)
                    {
                        dst3[rc.rect].SetTo(rc.color, rc.mask);
                        var pt = new cv.Point(rc.maxDist.X - 10, rc.maxDist.Y);
                        if (vbc.task.gOptions.getDebugCheckBox())
                        {
                            strOut = rc.pixels.ToString() + "/" + rc.depthPixels.ToString();
                        }
                        else
                        {
                            strOut = (rc.depthPixels / (float)rc.pixels).ToString("0%");
                        }
                        if (missCount < vbc.task.redOptions.identifyCount) SetTrueText(strOut, pt, 3);
                        missCount++;
                    }
                }
            }
            if (vbc.task.heartBeat) labels[3] = "There were " + missCount.ToString() + " cells containing depth - showing rc.pixels/rc.depthpixels";
        }
    }




    public class Cell_ValidateColorCells_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_ValidateColorCells_CS()
        {
            labels[3] = "Cells shown below have rc.depthPixels / rc.pixels < 50%";
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Validate that all the depthCells are correctly identified.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst1.SetTo(0);
            dst3.SetTo(0);
            List<float> percentDepth = new List<float>();
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.depthPixels > 0) dst1[rc.rect].SetTo(255, rc.mask);
                if (rc.depthPixels > 0 && rc.index > 0)
                {
                    float pc = rc.depthPixels / (float)rc.pixels;
                    percentDepth.Add(pc);
                    if (pc < 0.5f) dst3[rc.rect].SetTo(rc.color, rc.mask);
                }
            }
            int beforeCount = dst1.CountNonZero();
            dst1.SetTo(0, vbc.task.depthMask);
            int aftercount = dst1.CountNonZero();
            if (beforeCount != aftercount)
            {
                strOut = "There are color cells with depth in them - not good\r\n";
            }
            else
            {
                strOut = "There are no color cells with depth in them.\r\n";
            }
            if (percentDepth.Count > 0)
            {
                strOut += "Depth cell percentage average " + percentDepth.Average().ToString("0%") + "\r\n";
                strOut += "Depth cell percentage range " + percentDepth.Min().ToString("0%") + " to " + percentDepth.Max().ToString("0%");
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Cell_Distance_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_Distance_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            if (standalone) vbc.task.gOptions.setDisplay1();
            dst1 = new cv.Mat(dst1.Size(), cv.MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new cv.Mat(dst3.Size(), cv.MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "Depth distance to selected cell", "", "Color distance to selected cell" };
            desc = "Measure the color distance of each cell to the selected cell.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat || vbc.task.quarterBeat)
            {
                redC.Run(src);
                dst0 = vbc.task.color;
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                List<float> depthDistance = new List<float>();
                List<float> colorDistance = new List<float>();
                cv.Scalar selectedMean = src[vbc.task.rc.rect].Mean(vbc.task.rc.mask);
                foreach (var rc in vbc.task.redCells)
                {
                    colorDistance.Add(distance3D(selectedMean, new Mat(src, rc.rect).Mean(rc.mask)));
                    depthDistance.Add(distance3D(vbc.task.rc.depthMean, rc.depthMean));
                }
                dst1.SetTo(0);
                dst3.SetTo(0);
                float maxColorDistance = colorDistance.Max();
                for (int i = 0; i < vbc.task.redCells.Count; i++)
                {
                    var rc = vbc.task.redCells[i];
                    dst1[rc.rect].SetTo(new cv.Scalar(255 - depthDistance[i] * 255 / vbc.task.MaxZmeters), rc.mask);
                    dst3[rc.rect].SetTo(new cv.Scalar(255 - colorDistance[i] * 255 / maxColorDistance), rc.mask);
                }
            }
        }
    }




    public class Cell_Binarize_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_Binarize_CS()
        {
            if (standaloneTest())
                vbc.task.gOptions.setDisplay1();
            if (standaloneTest())
                vbc.task.gOptions.setDisplay1();
            dst1 = new cv.Mat(dst3.Size(), cv.MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new cv.Mat(dst3.Size(), cv.MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "Binarized image", "", "Relative gray image" };
            desc = "Separate the image into light and dark using RedCloud cells";
        }
        public void RunAlg(Mat src)
        {
            dst0 = src;
            if (vbc.task.heartBeat || vbc.task.quarterBeat)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                List<float> grayMeans = new List<float>();
                cv.Mat gray = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                foreach (var rc in vbc.task.redCells)
                {
                    cv.Scalar grayMean, grayStdev;
                    cv.Cv2.MeanStdDev(gray[rc.rect], out grayMean, out grayStdev, rc.mask);
                    grayMeans.Add((float)grayMean[0]);
                }
                float min = grayMeans.Min();
                float max = grayMeans.Max();
                float avg = grayMeans.Average();
                dst3.SetTo(0);
                foreach (var rc in vbc.task.redCells)
                {
                    float color = (grayMeans[rc.index] - min) * 255 / (max - min);
                    dst3[rc.rect].SetTo(new cv.Scalar(color), rc.mask);
                    dst1[rc.rect].SetTo(grayMeans[rc.index] > avg ? new cv.Scalar(255) : new cv.Scalar(0), rc.mask);
                }
            }
        }
    }




    public class Cell_Floodfill_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Cell_Basics stats = new Cell_Basics();
        public Cell_Floodfill_CS()
        {
            desc = "Provide cell stats on the flood_basics cells.";
        }
        public void RunAlg(Mat src)
        {
            flood.Run(src);
            stats.Run(src);
            dst0 = stats.dst0;
            dst1 = stats.dst1;
            dst2 = flood.dst2;
            labels = flood.labels;
            SetTrueText(stats.strOut, 3);
        }
    }




    public class Cell_BasicsPlot_CS : VB_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public bool runRedCloud;
        Cell_Basics stats = new Cell_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_BasicsPlot_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            if (standalone)
                vbc.task.gOptions.setDisplay1();
            if (standalone)
                vbc.task.gOptions.setHistogramBins(20);
            desc = "Display the statistics for the selected cell.";
        }
        public void statsString(cv.Mat src)
        {
            cv.Mat tmp = new cv.Mat(vbc.task.rc.mask.Rows, vbc.task.rc.mask.Cols, cv.MatType.CV_32F, cv.Scalar.All(0));
            vbc.task.pcSplit[2][vbc.task.rc.rect].CopyTo(tmp, vbc.task.rc.mask);
            plot.rc = vbc.task.rc;
            plot.Run(tmp);
            dst1 = plot.dst2;
            stats.statsString();
            strOut = stats.strOut;
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || runRedCloud)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                if (vbc.task.ClickPoint == new cv.Point())
                {
                    if (vbc.task.redCells.Count > 1)
                    {
                        vbc.task.rc = vbc.task.redCells[1];
                        vbc.task.ClickPoint = vbc.task.rc.maxDist;
                    }
                }
            }
            if (vbc.task.heartBeat)
                statsString(src);
            SetTrueText(strOut, 3);
            labels[1] = "Histogram plot for the cell's depth data - X-axis varies from 0 to " + ((int)vbc.task.MaxZmeters).ToString() + " meters";
        }
    }




    public class Cell_Stable_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cell_Stable_CS()
        {
            labels[3] = "Below are cells that were not exact matches.";
            desc = "Identify cells which were NOT present in the previous generation.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            if (vbc.task.heartBeat)
                return;
            int retained = 0;
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.exactMatch)
                    retained++;
                else
                    dst3[rc.rect].SetTo(rc.color, rc.mask);
            }
            labels[3] = (vbc.task.redCells.Count - retained).ToString() + " were not exact matches (shown below)";
        }
    }




    public class Cell_Generate_CS : VB_Parent
    {
        public int classCount;
        public List<cv.Rect> rectList = new List<cv.Rect>();
        public List<cv.Point> floodPoints = new List<cv.Point>();
        public bool removeContour;
        Diff_Basics diffLeft = new Diff_Basics();
        Diff_Basics diffRight = new Diff_Basics();
        public bool useLeftImage = true;
        Boundary_RemovedRects bounds = new Boundary_RemovedRects();
        RedCloud_CPP_VB redCPP;
        int saveRetained = -1;
        public Cell_Generate_CS()
        {
            vbc.task.cellMap = new cv.Mat(dst2.Size(), cv.MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.redCells = new List<rcData>();
            desc = "Generate the RedCloud cells from the rects, mask, and pixel counts.";
        }
        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                bounds.Run(src);
                vbc.task.cellMap = bounds.bRects.bounds.dst2;
                src = vbc.task.cellMap.BitwiseOr(bounds.dst2);
                if (vbc.task.FirstPass)
                    vbc.task.cellMap.SetTo(0);
                redCPP = bounds.bRects.bounds.redCPP;
                if (redCPP.classCount == 0)
                    return; // no data to process.
                classCount = redCPP.classCount;
                rectList = redCPP.rectList;
                floodPoints = redCPP.floodPoints;
                removeContour = false;
                src = redCPP.dst2;
            }
            if (useLeftImage)
                diffLeft.Run(vbc.task.leftView);
            else
                diffRight.Run(vbc.task.rightView);
            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            List<cv.Vec3b> usedColors = new List<cv.Vec3b> { black };
            int retained = 0;
            List<rcData> initList = new List<rcData> { new rcData() };
            for (int i = 1; i < classCount; i++)
            {
                rcData rc = new rcData();
                rc.rect = rectList[i - 1];
                if (rc.rect.Width == dst2.Width && rc.rect.Height == dst2.Height)
                    continue; // FeatureLess_RedCloud find a cell this big.  
                rc.floodPoint = floodPoints[i - 1];
                rc.mask = src[rc.rect].InRange(i, i);
                if (vbc.task.heartBeat || rc.indexLast == 0 || rc.indexLast >= vbc.task.redCells.Count)
                {
                    if (useLeftImage)
                        cv.Cv2.MeanStdDev(vbc.task.color[rc.rect], out rc.colorMean, out rc.colorStdev, rc.mask);
                    else
                        cv.Cv2.MeanStdDev(vbc.task.rightView[rc.rect], out rc.colorMean, out rc.colorStdev, rc.mask);
                }
                else
                {
                    rc.colorMean = vbc.task.redCells[rc.indexLast].colorMean;
                }
                rc.naturalColor = new cv.Vec3b((byte)rc.colorMean[0], (byte)rc.colorMean[1], (byte)rc.colorMean[2]);
                rc.naturalGray = (int)(rc.colorMean[2] * 0.299 + rc.colorMean[1] * 0.587 + rc.colorMean[0] * 0.114);
                rc.maxDist = GetMaxDist(ref rc);
                rc.indexLast = vbc.task.cellMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                if (useLeftImage)
                    rc.motionPixels = diffLeft.dst2[rc.rect].CountNonZero();
                else
                    rc.motionPixels = diffRight.dst2[rc.rect].CountNonZero();
                if (rc.indexLast > 0 && rc.indexLast < vbc.task.redCells.Count)
                {
                    var lrc = vbc.task.redCells[rc.indexLast];
                    if ((!vbc.task.heartBeat || vbc.task.FirstPass) && Math.Abs(lrc.naturalGray - rc.naturalGray) <= 1 && rc.motionPixels == 0)
                    {
                        rc = lrc;
                        rc.exactMatch = true;
                        retained++;
                    }
                }
                initList.Add(rc);
            }
            for (int i = 0; i < initList.Count; i++)
            {
                var rc = initList[i];
                if (!rc.exactMatch)
                {
                    rc.contour = ContourBuild(rc.mask, cv.ContourApproximationModes.ApproxNone); // .ApproxTC89L1
                    DrawContour(rc.mask, rc.contour, cv.Scalar.All(255), -1);
                    if (removeContour)
                        DrawContour(rc.mask, rc.contour, cv.Scalar.All(0), 2); // no overlap with neighbors.
                    rc.maxDStable = rc.maxDist; // assume it has to use the latest.
                    rc.indexLast = vbc.task.cellMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                    if (rc.indexLast > 0 && rc.indexLast < vbc.task.redCells.Count)
                    {
                        var lrc = vbc.task.redCells[rc.indexLast];
                        if (!vbc.task.heartBeat && Math.Abs(lrc.naturalGray - rc.naturalGray) <= 1 && rc.motionPixels == 0)
                        {
                            rc = lrc;
                            rc.exactMatch = true;
                        }
                        else
                        {
                            rc.color = lrc.color;
                            byte stableCheck = vbc.task.cellMap.Get<byte>(lrc.maxDist.Y, lrc.maxDist.X);
                            if (stableCheck == rc.indexLast)
                                rc.maxDStable = lrc.maxDStable; // keep maxDStable if cell matched to previous
                            byte val = vbc.task.cellMap.Get<byte>(rc.maxDStable.Y, rc.maxDStable.X);
                            if (val != rc.indexLast)
                                rc.maxDStable = rc.maxDist; // maxDist has finally hit the edges of the cell.
                            rc.pointMatch = true;
                        }
                    }
                    if (!rc.pointMatch && !rc.exactMatch)
                        rc.color = new cv.Vec3b((byte)msRNG.Next(40, 220), (byte)msRNG.Next(40, 220), (byte)msRNG.Next(40, 220));
                    if (usedColors.Contains(rc.color))
                        rc.color = vbc.task.vecColors[sortedCells.Count + 1];
                    usedColors.Add(rc.color);
                    rc.pixels = rc.mask.CountNonZero(); // the number of pixels may have changed with the infill or contour.
                    if (rc.pixels == 0)
                        continue;
                    rc.depthMask = rc.mask.Clone();
                    rc.depthMask.SetTo(0, new Mat(vbc.task.noDepthMask, rc.rect));
                    rc.depthPixels = rc.depthMask.CountNonZero();
                    if (rc.depthPixels != 0)
                    {
                        double minVal, maxVal;
                        vbc.task.pcSplit[0][rc.rect].MinMaxLoc(out minVal, out maxVal, out rc.minLoc, out rc.maxLoc, rc.depthMask);
                        rc.minVec.X = (float)minVal;
                        rc.maxVec.X = (float)maxVal;
                        vbc.task.pcSplit[1][rc.rect].MinMaxLoc(out minVal, out maxVal, out rc.minLoc, out rc.maxLoc, rc.depthMask);
                        rc.minVec.Y = (float)minVal;
                        rc.maxVec.Y = (float)maxVal;
                        vbc.task.pcSplit[2][rc.rect].MinMaxLoc(out minVal, out maxVal, out rc.minLoc, out rc.maxLoc, rc.depthMask);
                        rc.minVec.Z = (float)minVal;
                        rc.maxVec.Z = (float)maxVal;
                        cv.Cv2.MeanStdDev(vbc.task.pointCloud[rc.rect], out rc.depthMean, out rc.depthStdev, rc.depthMask);
                    }
                }
                sortedCells.Add(rc.pixels, rc);
            }
            vbc.task.redCells = new List<rcData>(sortedCells.Values);
            dst2 = RebuildCells(sortedCells);
            if (saveRetained < 0) saveRetained = retained;
            if (retained > 0)
                saveRetained = retained;
            if (vbc.task.heartBeat)
                labels[2] = vbc.task.redCells.Count.ToString() + " total cells with " + saveRetained.ToString() + " exact matches";
        }
    }
    // http://ptgmedia.pearsoncmg.com/images/0672320665/downloads/The%20Game%20of%20Life.html




    public class CellularAutomata_Life_CS : VB_Parent
    {
        public int lastPopulation;
        Random_Basics_CS random;
        Mat grid;
        Mat nextgrid;
        int factor = 8;
        int generation;
        public int population;
        public Scalar nodeColor = Scalar.White;
        public Scalar backColor = Scalar.Black;
        int savePointCount;
        const int countInit = 200;
        int countdown = countInit;

        int CountNeighbors(int cellX, int cellY)
        {
            int count = 0;
            if (cellX > 0 && cellY > 0)
            {
                if (grid.At<byte>(cellY - 1, cellX - 1) != 0) count++;
                if (grid.At<byte>(cellY - 1, cellX) != 0) count++;
                if (grid.At<byte>(cellY, cellX - 1) != 0) count++;
            }
            if (cellX < grid.Width - 1 && cellY < grid.Height - 1)
            {
                if (grid.At<byte>(cellY + 1, cellX + 1) != 0) count++;
                if (grid.At<byte>(cellY + 1, cellX) != 0) count++;
                if (grid.At<byte>(cellY, cellX + 1) != 0) count++;
            }
            if (cellX > 0 && cellY < grid.Height - 1)
            {
                if (grid.At<byte>(cellY + 1, cellX - 1) != 0) count++;
            }
            if (cellX < grid.Width - 1 && cellY > 0)
            {
                if (grid.At<byte>(cellY - 1, cellX + 1) != 0) count++;
            }
            return count;
        }

        public CellularAutomata_Life_CS()
        {
            random = new Random_Basics_CS();
            grid = new Mat(dst2.Height / factor, dst2.Width / factor, MatType.CV_8UC1, Scalar.All(0));
            nextgrid = grid.Clone();
            random.range = new cv.Rect(0, 0, grid.Width, grid.Height);
            FindSlider("Random Pixel Count").Value = (int)(grid.Width * grid.Height * 0.3); // we want about 30% of cells filled.
            desc = "Use OpenCV to implement the Game of Life";
        }

        public void RunAlg(Mat src)
        {
            if (random.options.count != savePointCount || generation == 0)
            {
                random.Run(empty);
                generation = 0;
                savePointCount = random.options.count;
                foreach (var point in random.PointList)
                {
                    grid.Set((int)point.Y, (int)point.X, 1);
                }
            }
            generation++;

            population = 0;
            dst2.SetTo(backColor);
            for (int y = 0; y < grid.Height; y++)
            {
                for (int x = 0; x < grid.Width; x++)
                {
                    int neighbors = CountNeighbors(x, y);
                    if (neighbors == 2 || neighbors == 3)
                    {
                        if (neighbors == 2)
                        {
                            nextgrid.Set(y, x, grid.At<byte>(y, x));
                        }
                        else
                        {
                            nextgrid.Set(y, x, 1);
                        }
                    }
                    else
                    {
                        nextgrid.Set(y, x, 0);
                    }
                    if (nextgrid.At<byte>(y, x) != 0)
                    {
                        cv.Point pt = new cv.Point(x, y) * factor;
                        Cv2.Circle(dst2, pt, factor / 2, nodeColor, -1);
                        population++;
                    }
                }
            }

            string countdownText = "";
            if (lastPopulation == population && countdown == -1) countdown = countInit;
            if (lastPopulation == population)
            {
                countdown--;
                countdownText = " Restart in " + countdown;
                if (countdown == 0)
                {
                    countdownText = "";
                    generation = 0;
                    countdown = countInit;
                }
            }
            else
            {
                countdown = -1;
            }
            lastPopulation = population;
            labels[2] = "Population " + population + " Generation = " + generation + countdownText;
            grid = nextgrid.Clone();
        }
    }




    public class CellularAutomata_LifeColor_CS : VB_Parent
    {
        CellularAutomata_Life_CS game;
        public CellularAutomata_LifeColor_CS()
        {
            game = new CellularAutomata_Life_CS();
            game.backColor = Scalar.White;
            game.nodeColor = Scalar.Black;

            labels[2] = "Births are blue, deaths are red";
            desc = "Game of Life but with color added";
        }

        public void RunAlg(Mat src)
        {
            Mat lastBoard = game.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            game.Run(src);
            dst1 = game.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            Mat deaths = new Mat(), births = new Mat();

            Cv2.Subtract(dst1, lastBoard, births);
            Cv2.Subtract(lastBoard, dst1, deaths);
            births = births.Threshold(0, 255, ThresholdTypes.Binary);
            deaths = deaths.Threshold(0, 255, ThresholdTypes.Binary);
            dst2 = game.dst2.Clone();
            dst2.SetTo(Scalar.Blue, births);
            dst2.SetTo(Scalar.Red, deaths);
        }
    }
    // http://ptgmedia.pearsoncmg.com/images/0672320665/downloads/The%20Game%20of%20Life.html




    public class CellularAutomata_LifePopulation_CS : VB_Parent
    {
        Plot_OverTimeSingle plot = new Plot_OverTimeSingle();
        CellularAutomata_Life_CS game;
        public CellularAutomata_LifePopulation_CS()
        {
            game = new CellularAutomata_Life_CS();
            desc = "Show Game of Life display with plot of population";
        }

        public void RunAlg(Mat src)
        {
            game.Run(src);
            dst2 = game.dst2;

            plot.plotData = game.population;
            plot.Run(empty);
            dst3 = plot.dst2;
        }
    }
    // https://mathworld.wolfram.com/ElementaryCellularAutomaton.html




    public class CellularAutomata_All256_CS : VB_Parent
    {
        CellularAutomata_Basics_CS cell;
        Options_CellAutomata options = new Options_CellAutomata();
        TrackBar ruleSlider;
        public CellularAutomata_All256_CS()
        {
            ruleSlider = FindSlider("Current Rule");
            cell = new CellularAutomata_Basics_CS();
            desc = "Run through all 256 combinations of outcomes";
        }

        string createOutcome(int val)
        {
            string outstr = "";
            for (int i = 0; i < 8; i++)
            {
                outstr = (val % 2).ToString() + outstr;
                val = (int)Math.Floor(val / 2.0);
            }
            return outstr;
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                cell.input = new Mat(new cv.Size(src.Width / 4, src.Height / 4), MatType.CV_8UC1, cv.Scalar.All(0));
                cell.input.Set<byte>(0, cell.input.Width / 2, 1);

                labels[2] = createOutcome(options.currentRule) + " options.currentRule = " + options.currentRule.ToString();
                dst2 = cell.createCells(labels[2]);

                options.RunOpt();

                if (vbc.task.heartBeat)
                {
                    labels[3] = createOutcome(options.currentRule) + " current rule = " + options.currentRule.ToString();
                    dst3 = cell.createCells(labels[3]);
                }
                if (ruleSlider.Value < ruleSlider.Maximum - 1) ruleSlider.Value += 1; else ruleSlider.Value = 0;
            }
        }
    }




    public class CellularAutomata_MultiPoint_CS : VB_Parent
    {
        CellularAutomata_Basics_CS cell;
        Options_CellAutomata options = new Options_CellAutomata();
        int val1 = 0; int val2 = 0;

        public CellularAutomata_MultiPoint_CS()
        {
            cell = new CellularAutomata_Basics_CS();
            val2 = dst2.Width / 2;
            FindSlider("Current Rule").Value = 4;
            desc = "All256 above starts with just one point. Here we start with multiple points.";
        }

        public void RunAlg(Mat src)
        {
            Mat tmp = new Mat(new cv.Size(src.Width / 4, src.Height / 4), MatType.CV_8UC1, cv.Scalar.All(0));
            tmp.Set(0, val1, 1);
            tmp.Set(0, val2, 1);
            cell.Run(tmp);

            dst2 = cell.dst2;
            val1++;
            if (val1 > tmp.Width) val1 = 0;
            if (val2 >= src.Width) val2 = 0;
        }
    }




    public class CellularAutomata_Basics_CS : VB_Parent
    {
        string[] i18 = {"00011110 Rule 30 (chaotic)", "00110110 Rule 54", "00111100 Rule 60", "00111110 Rule 62",
                                  "01011010 Rule 90", "01011110 Rule 94", "01100110 Rule 102", "01101110 Rule 110",
                                  "01111010 Rule 122", "01111110 Rule 126", "10010110 Rule 150", "10011110 Rule 158",
                                  "10110110 Rule 182", "10111100 Rule 188", "10111110 Rule 190", "11011100 Rule 220",
                                  "11011110 Rule 222", "11111010 Rule 250"};
        string inputCombo = "111,110,101,100,011,010,001,000";
        int[,] cellInput = { { 1, 1, 1 }, { 1, 1, 0 }, { 1, 0, 1 }, { 1, 0, 0 }, { 0, 1, 1 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 0 } };
        public Mat input = new Mat();
        int myIndex = 0;
        public CellularAutomata_Basics_CS()
        {
            string label = "The 18 most interesting automata from the first 256 in 'New Kind of Science'\nThe input combinations are: " + inputCombo;
            desc = "Visualize the 30 interesting examples from the first 256 in 'New Kind of Science'";
        }

        public Mat createCells(string outStr)
        {
            byte[] outcomes = new byte[8];
            for (int i = 0; i < outcomes.Length; i++)
            {
                outcomes[i] = byte.Parse(outStr.Substring(i, 1));
            }

            Mat dst = input.Clone();
            for (int y = 0; y < dst.Height - 2; y++)
            {
                for (int x = 0; x < dst.Width - 2; x++)
                {
                    byte x1 = dst.At<byte>(y, x - 1);
                    byte x2 = dst.At<byte>(y, x);
                    byte x3 = dst.At<byte>(y, x + 1);
                    for (int i = 0; i <= cellInput.GetUpperBound(0); i++)
                    {
                        if (x1 == cellInput[i, 0] && x2 == cellInput[i, 1] && x3 == cellInput[i, 2])
                        {
                            dst.Set(y + 1, x, outcomes[i]);
                            break;
                        }
                    }
                }
            }
            return dst.ConvertScaleAbs(255).CvtColor(ColorConversionCodes.GRAY2BGR);
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                labels[2] = i18[myIndex];
                myIndex += 1;
                if (myIndex >= i18.Length) myIndex = 0;
            }

            if (standalone)
            {
                input = new Mat(new cv.Size(src.Width, src.Height), MatType.CV_8UC1, Scalar.All(0));
                input.Set<byte>(0, src.Width / 2, 1);
                dst2 = createCells(labels[2]);
            }
            else
            {
                input = src.Clone();
                dst2 = createCells(labels[2]);
            }
        }
    }




    public class Classifier_Basics_CS : VB_Parent
    {
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_Open();
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void OEX_Points_Classifier_Close(IntPtr cPtr);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_ShowPoints(IntPtr cPtr, int imgRows, int imgCols, int DotSize);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_RunCPP(IntPtr cPtr, int count, int methodIndex, int imgRows, int imgCols, int resetInput);
        Options_Classifier options = new Options_Classifier();

        public Classifier_Basics_CS()
        {
            cPtr = OEX_Points_Classifier_Open();
            desc = "OpenCV Example Points_Classifier";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged) vbc.task.gOptions.setDebugCheckBox(true);
            IntPtr imagePtr = OEX_Points_Classifier_RunCPP(cPtr, options.sampleCount, options.methodIndex, dst2.Rows, dst2.Cols,
                                                           vbc.task.gOptions.getDebugCheckBox() ? 1 : 0);
            vbc.task.gOptions.setDebugCheckBox(false);
            dst1 = cv.Mat.FromPixelData(dst0.Rows, dst0.Cols, MatType.CV_32S, imagePtr);

            dst1.ConvertTo(dst0, MatType.CV_8U);
            dst2 = ShowPalette(dst0 * 255 / 2);
            imagePtr = OEX_ShowPoints(cPtr, dst2.Rows, dst2.Cols, vbc.task.DotSize);
            dst3 = cv.Mat.FromPixelData(dst2.Rows, dst2.Cols, MatType.CV_8UC3, imagePtr);

            SetTrueText("Click the global DebugCheckBox to get another set of points.", 3);
        }

        public void Close()
        {
            OEX_Points_Classifier_Close(cPtr);
        }
    }




    public class Classifier_Bayesian_CS : VB_Parent
    {
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_Open();
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void OEX_Points_Classifier_Close(IntPtr cPtr);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_ShowPoints(IntPtr cPtr, int imgRows, int imgCols, int DotSize);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_RunCPP(IntPtr cPtr, int count, int methodIndex, int imgRows, int imgCols, int resetInput);
        Options_Classifier options = new Options_Classifier();

        public Classifier_Bayesian_CS()
        {
            cPtr = OEX_Points_Classifier_Open();
            desc = "Run the Bayesian classifier with the input.";
        }

        public void RunAlg(Mat src)
        {
            int sampleCount, methodIndex = 0;
            if (src.Type() != MatType.CV_32FC2)
            {
                options.RunOpt();
                sampleCount = options.sampleCount;
                methodIndex = options.methodIndex;
            }
            else
            {
                sampleCount = src.Rows;
            }

            if (vbc.task.heartBeat) vbc.task.gOptions.setDebugCheckBox(true);
            IntPtr imagePtr = OEX_Points_Classifier_RunCPP(cPtr, sampleCount, methodIndex, dst2.Rows, dst2.Cols,
                                                           vbc.task.gOptions.getDebugCheckBox() ? 1 : 0);
            vbc.task.gOptions.setDebugCheckBox(false);
            dst1 = cv.Mat.FromPixelData(dst1.Rows, dst1.Cols, MatType.CV_32S, imagePtr);
            dst1.ConvertTo(dst0, MatType.CV_8U);
            dst2 = ShowPalette(dst0 * 255 / 2);
            imagePtr = OEX_ShowPoints(cPtr, dst2.Rows, dst2.Cols, vbc.task.DotSize);
        }
    }




    public class Classifier_BayesianTest_CS : VB_Parent
    {
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr Classifier_Bayesian_Open();
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void Classifier_Bayesian_Close(IntPtr cPtr);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void Classifier_Bayesian_Train(IntPtr cPtr, IntPtr trainInput, IntPtr response, int count);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr Classifier_Bayesian_RunCPP(IntPtr cPtr, IntPtr trainInput, int count);

        RedCloud_Basics redC = new RedCloud_Basics();
        Neighbors_Precise nabs = new Neighbors_Precise();

        public Classifier_BayesianTest_CS()
        {
            vbc.task.redOptions.useColorOnlyChecked = true;
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "Mask of the neighbors to the selected cell", "RedCloud_Basics output", "Classifier_Bayesian output" };
            if (standalone) vbc.task.gOptions.setDisplay1();
            cPtr = Classifier_Bayesian_Open();
            desc = "Classify the neighbor cells to be similar to the selected cell or not.";
        }

        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;

            SetTrueText("Review the neighbors_Precise algorithm");
            // nabs.redCells = vbc.task.redCells;
            // nabs.Run(vbc.task.cellMap);

            // List<Scalar> trainList = new List<Scalar>();
            // List<int> responseList = new List<int>();
            // foreach (var rc in vbc.task.redCells)
            // {
            //     trainList.Add(rc.depthMean);
            //     responseList.Add(0);
            // }

            // dst1.SetTo(0);
            // foreach (var index in nabs.nabList(vbc.task.rc.index))
            // {
            //     var rc = vbc.task.redCells[index];
            //     dst1[rc.rect].SetTo(255, rc.mask);
            //     strOut += index + ",";
            //     responseList[index] = -1;
            // }

            // responseList[vbc.task.rc.index] = 1;

            // List<Scalar> queryList = new List<Scalar>();
            // List<int> maskList = new List<int>();
            // for (int i = responseList.Count - 1; i >= 0; i--)
            // {
            //     if (responseList[i] == -1)
            //     {
            //         responseList.RemoveAt(i);
            //         queryList.Add(trainList[i]);
            //         trainList.RemoveAt(i);
            //         maskList.Add(i);
            //     }
            // }

            // var vecs = trainList.ToArray();
            // var resp = responseList.ToArray();
            // var handleTrainInput = GCHandle.Alloc(vecs, GCHandleType.Pinned);
            // var handleResponse = GCHandle.Alloc(resp, GCHandleType.Pinned);
            // Classifier_Bayesian_Train(cPtr, handleTrainInput.AddrOfPinnedObject(), handleResponse.AddrOfPinnedObject(), responseList.Count);
            // handleResponse.Free();
            // handleTrainInput.Free();

            // int[] results = new int[queryList.Count];
            // if (queryList.Count > 0)
            // {
            //     var queries = queryList.ToArray();
            //     var handleQueryInput = GCHandle.Alloc(queries, GCHandleType.Pinned);
            //     IntPtr resultsPtr = Classifier_Bayesian_RunCPP(cPtr, handleQueryInput.AddrOfPinnedObject(), queries.Length);
            //     handleQueryInput.Free();

            //     Marshal.Copy(resultsPtr, results, 0, results.Length);
            // }

            // dst3.SetTo(0);
            // bool zeroOutput = true;
            // for (int i = 0; i < maskList.Count; i++)
            // {
            //     if (results[i] > 0)
            //     {
            //         var rc = vbc.task.redCells[maskList[i]];
            //         dst3[rc.rect].SetTo(rc.color, rc.mask);
            //         zeroOutput = false;
            //     }
            // }
            // if (zeroOutput) SetTrueText("None of the neighbors were as similar to the selected cell.", 3);
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) Classifier_Bayesian_Close(cPtr);
        }
    }




    public class Clone_Basics_CS : VB_Parent
    {
        public Vec3f colorChangeValues;
        public Vec2f illuminationChangeValues;
        public Vec2f textureFlatteningValues;
        public int cloneSpec; // 0 is colorchange, 1 is illuminationchange, 2 is textureflattening
        public Clone_Basics_CS()
        {
            labels[2] = "Clone result - draw anywhere to clone a region";
            labels[3] = "Clone Region Mask";
            desc = "Clone a portion of one image into another. Draw on any image to change selected area.";
            vbc.task.drawRect = new cv.Rect(dst2.Width / 4, dst2.Height / 4, dst2.Width / 2, dst2.Height / 2);
        }

        public void RunAlg(Mat src)
        {
            Mat mask = new Mat(src.Size(), MatType.CV_8U, Scalar.All(0));
            if (vbc.task.drawRect == new cv.Rect())
            {
                mask.SetTo(Scalar.All(255));
            }
            else
            {
                Cv2.Rectangle(mask, vbc.task.drawRect, Scalar.White, -1);
            }
            dst3 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);

            if (standaloneTest() && vbc.task.frameCount % 10 == 0) cloneSpec += 1;
            switch (cloneSpec % 3)
            {
                case 0:
                    Cv2.ColorChange(src, mask, dst2, colorChangeValues.Item0, colorChangeValues.Item1, colorChangeValues.Item2);
                    break;
                case 1:
                    Cv2.IlluminationChange(src, mask, dst2, illuminationChangeValues.Item0, illuminationChangeValues.Item1);
                    break;
                case 2:
                    Cv2.TextureFlattening(src, mask, dst2, textureFlatteningValues.Item0, textureFlatteningValues.Item1);
                    break;
            }
        }
    }




    public class Clone_ColorChange_CS : VB_Parent
    {
        Clone_Basics clone = new Clone_Basics();
        Options_Clone options = new Options_Clone();
        public Clone_ColorChange_CS()
        {
            labels[2] = "Draw anywhere to select different clone region";
            labels[3] = "Mask used for clone";
            desc = "Clone a portion of one image into another controlling rgb. Draw on any image to change selected area.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            clone.cloneSpec = 0;
            clone.colorChangeValues = new Vec3f((float)options.blueChange, (float)options.greenChange, (float)options.redChange);
            clone.Run(src);
            dst2 = clone.dst2;
            dst3 = clone.dst3;
        }
    }





    public class Clone_IlluminationChange_CS : VB_Parent
    {
        Clone_Basics clone = new Clone_Basics();
        Options_Clone options = new Options_Clone();
        public Clone_IlluminationChange_CS()
        {
            labels[2] = "Draw anywhere to select different clone region";
            labels[3] = "Mask used for clone";
            desc = "Clone a portion of one image into another controlling illumination. Draw on any image to change selected area.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            clone.cloneSpec = 1;
            clone.illuminationChangeValues = new Vec2f((float)options.alpha, (float)options.beta);
            clone.Run(src);
            dst2 = clone.dst2;
            dst3 = clone.dst3;
        }
    }




    public class Clone_TextureFlattening_CS : VB_Parent
    {
        Clone_Basics clone = new Clone_Basics();
        Options_Clone options = new Options_Clone();
        public Clone_TextureFlattening_CS()
        {
            labels[2] = "Draw anywhere to select different clone region";
            labels[3] = "mask used for clone";
            desc = "Clone a portion of one image into another controlling texture. Draw on any image to change selected area.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            clone.cloneSpec = 2;
            clone.textureFlatteningValues = new Vec2f(options.lowThreshold, options.highThreshold);
            clone.Run(src);
            dst2 = clone.dst2;
            dst3 = clone.dst3;
        }
    }




    public class Clone_Eagle_CS : VB_Parent
    {
        Mat sourceImage;
        Mat mask;
        cv.Rect srcROI;
        cv.Rect maskROI;
        cv.Point pt;
        Options_Clone options = new Options_Clone();

        public Clone_Eagle_CS()
        {
            sourceImage = Cv2.ImRead(vbc.task.HomeDir + "Data/CloneSource.png");
            sourceImage = sourceImage.Resize(new cv.Size(sourceImage.Width * dst2.Width / 1280, sourceImage.Height * dst2.Height / 720));
            srcROI = new cv.Rect(0, 40, sourceImage.Width, sourceImage.Height);

            mask = Cv2.ImRead(vbc.task.HomeDir + "Data/Clonemask.png");
            mask = mask.Resize(new cv.Size(mask.Width * dst2.Width / 1280, mask.Height * dst2.Height / 720));
            maskROI = new cv.Rect(srcROI.Width, 40, mask.Width, mask.Height);

            dst3.SetTo(0);
            dst3[srcROI] = sourceImage;
            dst3[maskROI] = mask;

            pt = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            labels[2] = "Move Eagle by clicking in any location.";
            labels[3] = "Source image and source mask.";
            desc = "Clone an eagle into the video stream.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = src.Clone();
            if (vbc.task.mouseClickFlag)
            {
                pt = vbc.task.ClickPoint;  // pt corresponds to the center of the source image.  Roi can't be outside image boundary.
                if (pt.X + srcROI.Width / 2 >= src.Width) pt.X = src.Width - srcROI.Width / 2;
                if (pt.X - srcROI.Width / 2 < 0) pt.X = srcROI.Width / 2;
                if (pt.Y + srcROI.Height >= src.Height) pt.Y = src.Height - srcROI.Height / 2;
                if (pt.Y - srcROI.Height < 0) pt.Y = srcROI.Height / 2;
            }

            Cv2.SeamlessClone(sourceImage, dst2, mask, pt, dst2, options.cloneFlag);
        }
    }

    // https://www.csharpcodi.com/csharp-examples/OpenCvSharp.Cv2.SeamlessClone(OpenCvSharp.InputArray,%20OpenCvSharp.InputArray,%20OpenCvSharp.InputArray,%20OpenCvSharp.Point,%20OpenCvSharp.OutputArray,%20OpenCvSharp.SeamlessCloneMethods)/




    public class Clone_Seamless_CS : VB_Parent
    {
        Options_Clone options = new Options_Clone();
        public Clone_Seamless_CS()
        {
            labels[2] = "Results for SeamlessClone";
            labels[3] = "Mask for Clone";
            desc = "Use the seamlessclone API to merge color and depth...";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            cv.Point center = new cv.Point(src.Width / 2, src.Height / 2);
            int radius = 100;
            if (vbc.task.drawRect == new cv.Rect())
            {
                dst3.SetTo(0);
                DrawCircle(dst3, center, radius, Scalar.White);
            }
            else
            {
                Cv2.Rectangle(dst3, vbc.task.drawRect, Scalar.White, -1);
            }

            dst2 = src.Clone();
            Cv2.SeamlessClone(vbc.task.depthRGB, src, dst3, center, dst2, options.cloneFlag);
            DrawCircle(dst2, center, radius, Scalar.White);
        }
    }




    public class Cluster_Basics_CS : VB_Parent
    {
        KNN_Basics knn = new KNN_Basics();
        public List<cv.Point> ptInput = new List<cv.Point>();
        public List<cv.Point> ptList = new List<cv.Point>();
        public List<int> clusterID = new List<int>();
        public SortedList<int, List<cv.Point>> clusters = new SortedList<int, List<cv.Point>>();
        Feature_Stable feat = new Feature_Stable();

        public Cluster_Basics_CS()
        {
            FindSlider("Min Distance to next").Value = 10;
            desc = "Group the points based on their proximity to each other.";
        }

        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            if (standalone)
            {
                feat.Run(src);
                ptInput = vbc.task.featurePoints;
            }

            if (ptInput.Count <= 3) return;

            knn.queries = vbc.task.features;
            knn.trainInput = knn.queries;
            knn.Run(empty);

            ptList.Clear();
            clusterID.Clear();
            clusters.Clear();
            int groupID;
            for (int i = 0; i < knn.queries.Count; i++)
            {
                cv.Point p1 = new cv.Point(knn.queries[i].X, knn.queries[i].Y);
                cv.Point p2 = new cv.Point(knn.queries[knn.result[i, 1]].X, knn.queries[knn.result[i, 1]].Y);
                int index1 = ptList.IndexOf(p1);
                int index2 = ptList.IndexOf(p2);
                if (index1 >= 0 && index2 >= 0) continue;
                if (index1 < 0 && index2 < 0)
                {
                    ptList.Add(p1);
                    ptList.Add(p2);
                    groupID = clusters.Count;
                    List<cv.Point> newList = new List<cv.Point> { p1, p2 };
                    clusters.Add(groupID, newList);
                    clusterID.Add(groupID);
                    clusterID.Add(groupID);
                }
                else
                {
                    cv.Point pt = index1 < 0 ? p1 : p2;
                    int index = index1 < 0 ? index2 : index1;
                    groupID = clusterID[index];
                    ptList.Add(pt);
                    clusterID.Add(groupID);
                    clusters.ElementAt(groupID).Value.Add(pt);
                }
            }

            foreach (var group in clusters)
            {
                for (int i = 0; i < group.Value.Count; i++)
                {
                    for (int j = 0; j < group.Value.Count; j++)
                    {
                        Cv2.Line(dst2, group.Value[i], group.Value[j], Scalar.White);
                    }
                }
            }
            dst3.SetTo(0);
            for (int i = 0; i < knn.queries.Count; i++)
            {
                Cv2.Circle(dst2, new cv.Point(knn.queries[i].X, knn.queries[i].Y), vbc.task.DotSize, Scalar.Red);
                Cv2.Circle(dst3, new cv.Point(knn.queries[i].X, knn.queries[i].Y), vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = $"{clusters.Count} groups built from {ptInput.Count} by combining each input point and its nearest neighbor.";
        }
    }


    public class Cluster_RedCloud_CS : VB_Parent
    {
        Cluster_Basics cluster = new Cluster_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Cluster_RedCloud_CS()
        {
            desc = "Cluster the center points of the RedCloud cells";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            cluster.ptInput.Clear();
            var smallCellThreshold = src.Total() / 1000;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.pixels < smallCellThreshold && rc.pixels > 0) break;
                if (rc.exactMatch) cluster.ptInput.Add(rc.maxDist);
            }
            cluster.Run(src);
            dst3 = cluster.dst2;
            if (vbc.task.heartBeat) labels[3] = cluster.labels[2];
        }
    }





    public class Cluster_Hulls_CS : VB_Parent
    {
        Cluster_Basics cluster = new Cluster_Basics();
        public List<List<cv.Point>> hulls = new List<List<cv.Point>>();
        Feature_Stable feat = new Feature_Stable();

        public Cluster_Hulls_CS()
        {
            desc = "Create hulls for each cluster of feature points found in Cluster_Basics";
        }

        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();

            feat.Run(src);
            cluster.ptInput = vbc.task.featurePoints;
            cluster.Run(src);
            dst2 = cluster.dst2;
            dst3 = cluster.dst3;

            hulls.Clear();
            foreach (var group in cluster.clusters)
            {
                cv.Point[] hullPoints = Cv2.ConvexHull(group.Value.ToArray(), true);
                List<cv.Point> hull = new List<cv.Point>();
                if (hullPoints.Length > 2)
                {
                    hull.AddRange(hullPoints.Select(pt => new cv.Point(pt.X, pt.Y)));
                }
                else if (hullPoints.Length == 2)
                {
                    Cv2.Line(dst3, hullPoints[0], hullPoints[1], Scalar.White);
                }

                hulls.Add(hull);
                if (hull.Count > 0) Cv2.DrawContours(dst3, new[] { hull }, 0, Scalar.White, vbc.task.lineWidth);
            }
        }
    }




    public class Coherence_Basics_CS : VB_Parent
    {
        Options_Coherence options = new Options_Coherence();
        public Coherence_Basics_CS()
        {
            labels[2] = "Coherence - draw rectangle to apply";
            desc = "Find lines that are artistically coherent in the image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            int side;
            switch (src.Height)
            {
                case 120:
                case 180:
                    side = 64;
                    break;
                case 360:
                case 480:
                    side = 256;
                    break;
                case 720:
                    side = 512;
                    break;
                default:
                    side = 50;
                    break;
            }

            int xoffset = src.Width / 2 - side / 2;
            int yoffset = src.Height / 2 - side / 2;
            cv.Rect srcRect = new cv.Rect(xoffset, yoffset, side, side);
            if (vbc.task.drawRect.Width != 0) srcRect = vbc.task.drawRect;

            dst2 = src.Clone();
            src = new Mat(src, srcRect);

            Mat gray = new Mat();
            Mat eigen = new Mat();
            Mat[] split;

            for (int i = 0; i < 4; i++)
            {
                gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                eigen = gray.CornerEigenValsAndVecs(options.str_sigma, options.eigenkernelsize);
                split = eigen.Split();
                Mat x = split[2], y = split[3];

                Mat gxx = gray.Sobel(MatType.CV_32F, 2, 0, options.sigma);
                Mat gxy = gray.Sobel(MatType.CV_32F, 1, 1, options.sigma);
                Mat gyy = gray.Sobel(MatType.CV_32F, 0, 2, options.sigma);

                Mat tmpX = new Mat(), tmpXY = new Mat(), tmpY = new Mat();
                Cv2.Multiply(x, x, tmpX);
                Cv2.Multiply(tmpX, gxx, tmpX);
                Cv2.Multiply(x, y, tmpXY);
                Cv2.Multiply(tmpXY, gxy, tmpXY);
                tmpXY = tmpXY * 2;

                Cv2.Multiply(y, y, tmpY);
                Cv2.Multiply(tmpY, gyy, tmpY);

                Mat gvv = tmpX + tmpXY + tmpY;

                Mat mask = gvv.Threshold(0, 255, ThresholdTypes.BinaryInv).ConvertScaleAbs();

                Mat erode = src.Erode(new Mat());
                Mat dilate = src.Dilate(new Mat());

                Mat imgl = erode;
                dilate.CopyTo(imgl, mask);
                src = src * (1 - options.blend) + imgl * options.blend;
            }

            src.CopyTo(new Mat(dst2, srcRect));
            Cv2.Rectangle(dst2, srcRect, Scalar.Yellow, 2);
            dst3.SetTo(0);
        }
    }




    public class Coherence_Depth_CS : VB_Parent
    {
        Coherence_Basics coherent = new Coherence_Basics();
        public Coherence_Depth_CS()
        {
            desc = "Find coherent lines in the depth image";
        }
        public void RunAlg(Mat src)
        {
            coherent.Run(vbc.task.depthRGB);
            dst2 = coherent.dst2;
        }
    }




    public class Color_Basics_CS : VB_Parent
    {
        public Options_Color options = new Options_Color();
        public Color_Basics_CS()
        {
            desc = "Choose a color source";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (options.colorFormat == null) options.colorFormat = "BGR"; // multiple invocations cause this to be necessary but how to fix?

            switch (options.colorFormat)
            {
                case "BGR":
                    dst2 = src.Clone();
                    break;
                case "LAB":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2Lab);
                    break;
                case "HSV":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2HSV);
                    break;
                case "XYZ":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2XYZ);
                    break;
                case "HLS":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2HLS);
                    break;
                case "YUV":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2YUV);
                    break;
                case "YCrCb":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2YCrCb);
                    break;
            }
        }
    }




    public class Color8U_Basics_CS : VB_Parent
    {
        public int classCount;
        public object classifier;
        object[] colorMethods = new object[10];
        public Color8U_Basics_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U);
            labels[3] = "vbPalette output of dst2 at left";
            UpdateAdvice(traceName + ": redOptions 'Color Source' control which color source is used.");
            desc = "Classify pixels by color using a variety of techniques";
        }
        public void RunAlg(Mat src)
        {
            int index = vbc.task.redOptions.colorInputIndex;
            if (vbc.task.optionsChanged || classifier == null)
            {
                switch (index)
                {
                    case 0:
                        if (colorMethods[index] == null) colorMethods[index] = new BackProject_Full();
                        break;
                    case 1:
                        if (colorMethods[index] == null) colorMethods[index] = new BackProject2D_Full();
                        break;
                    case 2:
                        if (colorMethods[index] == null) colorMethods[index] = new Bin4Way_Regions();
                        break;
                    case 3:
                        if (colorMethods[index] == null) colorMethods[index] = new Binarize_DepthTiers();
                        break;
                    case 4:
                        if (colorMethods[index] == null) colorMethods[index] = new FeatureLess_Groups();
                        break;
                    case 5:
                        if (colorMethods[index] == null) colorMethods[index] = new Hist3Dcolor_Basics();
                        break;
                    case 6:
                        if (colorMethods[index] == null) colorMethods[index] = new KMeans_Basics();
                        break;
                    case 7:
                        if (colorMethods[index] == null) colorMethods[index] = new LUT_Basics();
                        break;
                    case 8:
                        if (colorMethods[index] == null) colorMethods[index] = new Reduction_Basics();
                        break;
                    case 9:
                        if (colorMethods[index] == null) colorMethods[index] = new PCA_NColor_CPP_VB();
                        break;
                }
                classifier = colorMethods[index];
            }
            if (vbc.task.redOptions.colorInputName == "BackProject2D_Full")
            {
                ((dynamic)classifier).Run(src);
            }
            else
            {
                if (vbc.task.redOptions.colorInputName != "PCA_NColor_CPP")
                {
                    dst1 = src.Channels() == 3 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
                    ((dynamic)classifier).Run(dst1);
                }
                else
                {
                    ((dynamic)classifier).Run(src);
                }
            }
            if (vbc.task.heartBeat)
            {
                dst2 = ((dynamic)classifier).dst2.Clone();
            }
            else if (vbc.task.motionDetected)
            {
                ((dynamic)classifier).dst2[vbc.task.motionRect].CopyTo(dst2[vbc.task.motionRect]);
            }
            classCount = ((dynamic)classifier).classCount;
            // If vbc.task.maxDepthMask.Rows > 0 Then
            //     classCount += 1
            //     dst2.SetTo(classCount, vbc.task.maxDepthMask)
            // End If
            dst3 = ((dynamic)classifier).dst3;
            labels[2] = "Color_Basics: method = " + ((dynamic)classifier).traceName + " produced " + classCount.ToString() + " pixel classifications";
        }
    }




    public class Color8U_Grayscale_CS : VB_Parent
    {
        Options_Grayscale8U options = new Options_Grayscale8U();

        public Color8U_Grayscale_CS()
        {
            labels = new string[] { "", "", "Color_Grayscale", "" };
            desc = "Manually create a grayscale image. The only reason for this example is to show how slow it can be to do the work manually in C#";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (options.useOpenCV)
            {
                dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            else
            {
                dst2 = new Mat(src.Size(), MatType.CV_8U, cv.Scalar.All(0));
                Parallel.For(0, src.Rows, y =>
                {
                    for (int x = 0; x < src.Cols; x++)
                    {
                        Vec3b cc = src.Get<Vec3b>(y, x);
                        dst2.Set<byte>(y, x, (byte)((cc[0] * 1140 + cc[1] * 5870 + cc[2] * 2989) / 10000));
                    }
                });
            }
        }
    }





    public class Color8U_Depth_CS : VB_Parent
    {
        public Reduction_Basics reduction = new Reduction_Basics();
        public Depth_InRange_CS depth;
        public int classCount;

        public Color8U_Depth_CS()
        {
            depth = new Depth_InRange_CS();
            vbc.task.gOptions.setLineType(1); // linetype = link4
            labels = new string[] { "", "", "Color Reduction Edges", "Depth Range Edges" };
            desc = "Add depth regions edges to the color Reduction image.";
        }

        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2;
            classCount = reduction.classCount;

            depth.Run(src);
            dst2.SetTo(0, depth.dst3);
            dst3.SetTo(0);
            dst3.SetTo(Scalar.White, depth.dst3);
        }
    }





    public class Color8U_KMeans_CS : VB_Parent
    {
        public KMeans_Basics km0 = new KMeans_Basics();
        public KMeans_Basics km1 = new KMeans_Basics();
        public KMeans_Basics km2 = new KMeans_Basics();
        public Color_Basics colorFmt = new Color_Basics();

        public Color8U_KMeans_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels[0] = "Recombined channels in other images.";
            desc = "Run KMeans on each of the 3 color channels";
        }

        public void RunAlg(Mat src)
        {
            colorFmt.Run(src);
            dst0 = colorFmt.dst2;

            Mat[] split = dst0.Split();

            km0.Run(split[0]);
            dst1 = km0.dst2 * 255 / km0.classCount;

            km1.Run(split[1]);
            dst2 = km1.dst2 * 255 / km0.classCount;

            km2.Run(split[2]);
            dst3 = km2.dst2 * 255 / km0.classCount;

            for (int i = 1; i <= 3; i++)
            {
                labels[i] = $"{colorFmt.options.colorFormat} channel {i - 1}";
            }
        }
    }




    public class Color8U_RedHue_CS : VB_Parent
    {
        Options_CamShift options = new Options_CamShift();

        public Color8U_RedHue_CS()
        {
            UpdateAdvice(traceName + ": This mask of red hue areas is available for use.");
            labels = new string[] { "", "", "Pixels with Red Hue", "" };
            desc = "Find all the reddish pixels in the image - indicate some life form.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Mat mask = hsv.InRange(options.camSBins, new Scalar(180, 255, options.camMax));
            dst2.SetTo(0);
            src.CopyTo(dst2, mask);
        }
    }





    public class Color8U_Complementary_CS : VB_Parent
    {
        public Color8U_Complementary_CS()
        {
            labels = new string[] { "", "", "Current image in complementary colors", "HSV version of the current image but hue is flipped to complementary value." };
            desc = "Display the current image in complementary colors";
        }

        public void RunAlg(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Mat[] split = hsv.Split();
            split[0] += cv.Scalar.All(90 % 180);
            Cv2.Merge(split, dst3);
            dst2 = dst3.CvtColor(ColorConversionCodes.HSV2BGR);
        }
    }





    public class Color8U_ComplementaryTest_CS : VB_Parent
    {
        Image_Basics images = new Image_Basics();
        Color8U_Complementary comp = new Color8U_Complementary();

        public Color8U_ComplementaryTest_CS()
        {
            labels = new string[] { "", "", "Original Image", "Color_Complementary version looks identical to the correct version at the link above " };
            desc = "Create the complementary images for Gilles Tran's 'Glasses' image for comparison";
        }

        public void RunAlg(Mat src)
        {
            images.options.fileNameForm.setFileName(vbc.task.HomeDir + "Data/Glasses by Gilles Tran.png");
            images.Run(new Mat());
            dst2 = images.dst2;

            comp.Run(dst2);
            dst3 = comp.dst2;
        }
    }





    public class Color8U_InRange_CS : VB_Parent
    {
        public Color8U_InRange_CS()
        {
            labels = new string[] { "", "", "Original", "After InRange processing" };
            desc = "Use inRange to isolate colors from the background";
        }

        public void RunAlg(Mat src)
        {
            dst2 = Cv2.ImRead(vbc.task.HomeDir + "Data/1.jpg", ImreadModes.Grayscale);
            dst1 = dst2.InRange(105, 165); // should make this a slider and experiment further...
            dst3 = dst2.Clone();
            dst3.SetTo(0, dst1);
        }
    }





    public class Color8U_TopX_CS : VB_Parent
    {
        Hist3Dcolor_TopXColors topX = new Hist3Dcolor_TopXColors();
        Options_Color8UTopX options = new Options_Color8UTopX();

        public Color8U_TopX_CS()
        {
            desc = "Classify every BGR pixel into some common colors";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat input = src;
            input = input.Resize(vbc.task.lowRes, 0, 0, InterpolationFlags.Nearest);

            topX.mapTopX = options.topXcount;
            topX.Run(input);

            List<Vec3b> top = new List<Vec3b>();
            foreach (var pt in topX.topXPixels)
            {
                top.Add(new Vec3b((byte)pt.X, (byte)pt.Y, (byte)pt.Z));
            }

            dst2 = input.Clone();
            for (int y = 0; y < input.Rows; y++)
            {
                for (int x = 0; x < input.Cols; x++)
                {
                    List<float> distances = new List<float>();
                    Vec3b vec = input.Get<Vec3b>(y, x);
                    foreach (var pt in top)
                    {
                        distances.Add(distance3D(pt, new Vec3b(vec.Item0, vec.Item1, vec.Item2)));
                    }
                    Vec3b best = top[distances.IndexOf(distances.Min())];
                    dst2.Set(y, x, new Vec3b(best.Item0, best.Item1, best.Item2));
                }
            }
            labels[2] = "The BGR image mapped to " + topX.mapTopX + " colors";
        }
    }





    public class Color8U_Common_CS : VB_Parent
    {
        List<Vec3b> common = new List<Vec3b>();
        List<Scalar> commonScalar = new List<Scalar> { Scalar.Blue, Scalar.Green, Scalar.Red, Scalar.Yellow, Scalar.Pink, Scalar.Purple, Scalar.Brown,
                                                           Scalar.Gray, Scalar.Black, Scalar.White };

        public Color8U_Common_CS()
        {
            foreach (var c in commonScalar)
            {
                common.Add(new Vec3b((byte)c[0], (byte)c[1], (byte)c[2]));
            }
            desc = "Classify every BGR pixel into some common colors";
        }

        public void RunAlg(Mat src)
        {
            for (int y = 0; y < src.Rows; y++)
            {
                for (int x = 0; x < src.Cols; x++)
                {
                    List<float> distances = new List<float>();
                    Vec3b vec = src.Get<Vec3b>(y, x);
                    foreach (var pt in common)
                    {
                        distances.Add(distance3D(pt, new Vec3b(vec.Item0, vec.Item1, vec.Item2)));
                    }
                    Vec3b best = common[distances.IndexOf(distances.Min())];
                    dst2.Set(y, x, new Vec3b(best.Item0, best.Item1, best.Item2));
                }
            }
            labels[2] = "The BGR image mapped to " + common.Count + " common colors";
        }
    }





    public class Color8U_Smoothing_CS : VB_Parent
    {
        History_Basics frames = new History_Basics();

        public Color8U_Smoothing_CS()
        {
            labels = new string[] { "", "", "Averaged BGR image over the last X frames", "" };
            dst0 = new Mat(dst0.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            desc = "Merge that last X BGR frames to smooth out differences.";
        }

        public void RunAlg(Mat src)
        {
            frames.Run(src);
            dst2 = frames.dst2;
            labels[2] = "The image below is the average of " + frames.saveFrames.Count + " the last BGR frames";
        }
    }





    public class Color8U_Denoise_CS : VB_Parent
    {
        Denoise_Pixels_CPP_VB denoise = new Denoise_Pixels_CPP_VB();

        public Color8U_Denoise_CS()
        {
            denoise.standalone = true;
            desc = "Remove single pixels between identical pixels for all color classifiers.";
        }

        public void RunAlg(Mat src)
        {
            denoise.Run(src);
            dst2 = denoise.dst2;
            dst3 = denoise.dst3;
            SetTrueText(denoise.strOut, 2);
        }
    }





    public class Color8U_MotionFiltered_CS : VB_Parent
    {
        Color8U_Basics colorClass = new Color8U_Basics();
        public int classCount;
        Motion_Basics motion = new Motion_Basics();

        public Color8U_MotionFiltered_CS()
        {
            desc = "Prepare a Color8U_Basics image using the vbc.task.motionRect";
        }

        public void RunAlg(Mat src)
        {
            motion.Run(src);

            dst3 = motion.dst2;
            colorClass.Run(motion.dst2);
            dst2 = colorClass.dst3;
            classCount = colorClass.classCount;
        }
    }





    public class Color8U_Hue_CS : VB_Parent
    {
        public Color8U_Hue_CS()
        {
            desc = "Isolate those regions in the image that have a reddish hue.";
        }

        public void RunAlg(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Scalar loBins = new Scalar(0, 40, 32);
            Scalar hiBins = new Scalar(180, 255, 255);
            dst2 = hsv.InRange(loBins, hiBins);
        }
    }





    public class Color8U_BlackAndWhite_CS : VB_Parent
    {
        Options_StdevGrid options = new Options_StdevGrid();

        public Color8U_BlackAndWhite_CS()
        {
            labels = new string[] { "", "", "Mask to identify all 'black' regions", "Mask identifies all 'white' regions" };
            desc = "Create masks for black and white";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = dst1.Threshold(options.minThreshold, 255, ThresholdTypes.BinaryInv);
            dst3 = dst1.Threshold(options.maxThreshold, 255, ThresholdTypes.Binary);
        }
    }







    public class Complexity_Basics_CS : VB_Parent
    {
        Complexity_Dots complex = new Complexity_Dots();
        public Complexity_Basics_CS()
        {
            desc = "Plot all the available complexity runs.";
        }
        public void RunAlg(Mat src)
        {
            complex.options.RunOpt();

            string saveLatestFile = complex.options.filename.FullName;

            complex.maxTime = 0;
            for (int i = 0; i < complex.options.filenames.Count; i++)
            {
                complex.fileName = complex.options.filenames[i];
                complex.Run(src);
            }

            complex.initialize = true;
            for (int i = 0; i < complex.options.filenames.Count; i++)
            {
                complex.fileName = complex.options.filenames[i];
                complex.plotColor = complex.options.setPlotColor();
                complex.Run(src);
                complex.initialize = false;
            }

            dst3 = complex.dst2.Clone();

            SetTrueText(">>>>>> Increasing input data >>>>>>" + "\n" + "All available complexity runs",
                        new cv.Point(dst2.Width / 4, 10), 3);
            SetTrueText(" TIME " + "(Max = " + complex.maxTime.ToString(vbc.fmt0) + ")", new cv.Point(0, dst2.Height / 2), 3);

            complex.initialize = true;
            complex.fileName = saveLatestFile;
            complex.plotColor = complex.options.setPlotColor();
            complex.Run(src);
            dst2 = complex.dst2;

            SetTrueText(" >>>>>> Increasing input data >>>>>>" + "\n" + complex.options.filename.Name,
                        new cv.Point(dst2.Width / 4, 10));
            SetTrueText(" TIME " + "(Max = " + complex.maxTime.ToString(vbc.fmt0) + ")", new cv.Point(0, dst2.Height / 2));
            labels[2] = complex.labels[2];
            labels[3] = "Plots For all available complexity runs";
        }
    }





    public class Complexity_PlotOpenCV_CS : VB_Parent
    {
        public Plot_Basics_CPP_VB plot = new Plot_Basics_CPP_VB();
        public int maxFrameCount;
        public SortedList<int, int> sortData = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public Options_Complexity options = new Options_Complexity();
        public float sessionTime;
        public Complexity_PlotOpenCV_CS()
        {
            desc = "Plot the algorithm's input data rate (X) vs. time to complete work on that input (Y).";
        }
        public void prepareSortedData(string filename)
        {
            string contents = File.ReadAllText(filename);
            string[] lines = contents.Split(new[] { "\n" }, StringSplitOptions.RemoveEmptyEntries);
            int nextSize = 0, myFrameCount = 0;
            List<float> times = new List<float>();
            sortData.Clear();

            foreach (string line in lines)
            {
                string trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("Image"))
                {
                    string[] split = trimmedLine.Split('\t');
                    nextSize = int.Parse(split[2]) * int.Parse(split[1]);
                }
                else if (trimmedLine.StartsWith("Ending"))
                {
                    string[] split = trimmedLine.Split('\t');
                    myFrameCount = int.Parse(split[1]);
                    if (myFrameCount > maxFrameCount) maxFrameCount = myFrameCount;
                    times.Add(float.Parse(split[2].Split()[0]));
                }

                if (trimmedLine.StartsWith("-") && nextSize > 0)
                {
                    sortData.Add(nextSize, myFrameCount);
                }
            }

            sessionTime = times.Average();
        }
        public float plotData(float maxTime)
        {
            foreach (var el in sortData)
            {
                plot.srcX.Add(el.Key);
                float nextTime = sessionTime * maxFrameCount / el.Value;
                plot.srcY.Add(nextTime);
                if (nextTime > maxTime) maxTime = nextTime;
            }
            plot.Run(new Mat());
            dst2 = plot.dst2.Clone();
            return maxTime;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            maxFrameCount = 0;
            plot.srcX.Clear();
            plot.srcY.Clear();
            prepareSortedData(options.filename.FullName);

            float maxTime = plotData(0);

            SetTrueText(">>>>>> Increasing input data >>>>>>", new cv.Point(dst2.Width / 4, 10));
            SetTrueText(" TIME", new cv.Point(0, dst2.Height / 2));
            SetTrueText("Max Time = " + maxTime.ToString(vbc.fmt0), new cv.Point(10, 10));
            labels[2] = "Complexity plot for " + Path.GetFileNameWithoutExtension(options.filename.Name);
        }
    }




    public class Complexity_Dots_CS : VB_Parent
    {
        public Options_Complexity options = new Options_Complexity();
        public bool initialize = true;
        public float maxTime;
        public string fileName;
        public Scalar plotColor;
        Mat dst;
        public Complexity_Dots_CS()
        {
            dst = new Mat(new cv.Size(vbc.task.lowRes.Width * 2, vbc.task.lowRes.Height * 2), MatType.CV_8UC3, Scalar.Black);
            desc = "Plot the results of multiple runs at various resolutions.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (!string.IsNullOrEmpty(fileName)) options.filename = new FileInfo(fileName);
            string contents = File.ReadAllText(options.filename.FullName);
            string[] lines = contents.Split(new[] { "\n" }, StringSplitOptions.RemoveEmptyEntries);

            SortedList<int, int> sortData = new SortedList<int, int>(new compareAllowIdenticalInteger());
            int nextSize = 0, myFrameCount = 0;
            List<float> times = new List<float>();
            float maxFrameCount = 0;
            List<double> srcX = new List<double>(), srcY = new List<double>();

            foreach (string line in lines)
            {
                string trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("Image"))
                {
                    string[] split = trimmedLine.Split('\t');
                    nextSize = int.Parse(split[2]) * int.Parse(split[1]);
                }
                else if (trimmedLine.StartsWith("Ending"))
                {
                    string[] split = trimmedLine.Split('\t');
                    myFrameCount = int.Parse(split[1]);
                    if (myFrameCount > maxFrameCount) maxFrameCount = myFrameCount;
                    times.Add(float.Parse(split[2].Split()[0]));
                }

                if (trimmedLine.StartsWith("-") && nextSize > 0)
                {
                    int index = srcX.IndexOf(nextSize);
                    if (index != -1)
                    {
                        srcY[index] = (myFrameCount + srcY[index]) / 2;
                    }
                    else
                    {
                        srcX.Add(nextSize);
                        srcY.Add(myFrameCount);
                    }
                }
            }

            float sessionTime = times.Average();

            for (int i = 0; i < srcX.Count; i++)
            {
                float nextTime = sessionTime * maxFrameCount / (float)srcY[i];
                if (maxTime < nextTime) maxTime = nextTime;
                sortData.Add((int)srcX[i], (int)nextTime);
            }

            double maxX = srcX.Max();
            List<cv.Point> pointSet = new List<cv.Point>();
            if (initialize) dst.SetTo(Scalar.Black);

            for (int i = 0; i < sortData.Count; i++)
            {
                cv.Point pt = new cv.Point(dst.Width * sortData.ElementAt(i).Key / maxX,
                                     dst.Height - dst.Height * sortData.ElementAt(i).Value / maxTime);
                Cv2.Circle(dst, pt, vbc.task.DotSize, plotColor, -1);
                pointSet.Add(pt);
            }

            for (int i = 1; i < pointSet.Count; i++)
            {
                Cv2.Line(dst, pointSet[i - 1], pointSet[i], plotColor);
            }

            SetTrueText(">>>>>> Increasing input data >>>>>>" + "\n" + options.filename.Name,
                        new cv.Point(dst2.Width / 4, 10));
            SetTrueText(" TIME " + "(Max = " + maxTime.ToString(vbc.fmt0) + ")", new cv.Point(0, dst2.Height / 2));
            labels[2] = "Complexity plot for " + Path.GetFileNameWithoutExtension(options.filename.Name);
            dst2 = dst.Resize(dst2.Size());
        }
    }




    public class Concat_Basics_CS : VB_Parent
    {
        public Concat_Basics_CS()
        {
            labels[2] = "Horizontal concatenation";
            labels[3] = "Vertical concatenation";
            desc = "Concatenate 2 images - horizontally and vertically";
        }
        public void RunAlg(Mat src)
        {
            Mat tmp = new Mat();
            Cv2.HConcat(src, vbc.task.depthRGB, tmp);
            dst2 = tmp.Resize(src.Size());
            Cv2.VConcat(src, vbc.task.depthRGB, tmp);
            dst3 = tmp.Resize(src.Size());
        }
    }





    public class Concat_4way_CS : VB_Parent
    {
        public Mat[] img = new Mat[4];
        public Concat_4way_CS()
        {
            for (int i = 0; i < img.Length; i++)
            {
                img[i] = new Mat();
            }
            labels[2] = "Color/RGBDepth/Left/Right views";
            desc = "Concatenate 4 images - horizontally and vertically";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                img[0] = src;
                img[1] = vbc.task.depthRGB;
                img[2] = vbc.task.leftView.Channels() == 1 ? vbc.task.leftView.CvtColor(ColorConversionCodes.GRAY2BGR) : vbc.task.leftView;
                img[3] = vbc.task.rightView.Channels() == 1 ? vbc.task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : vbc.task.rightView;
            }

            Mat tmp1 = new Mat();
            Mat tmp2 = new Mat();
            Mat tmp3 = new Mat();

            Cv2.HConcat(img[0], img[1], tmp1);
            Cv2.HConcat(img[2], img[3], tmp2);
            Cv2.VConcat(tmp1, tmp2, tmp3);
            dst2 = tmp3.Resize(src.Size());
        }
    }




    public class Contour_Basics_CS : VB_Parent
    {
        Color8U_Basics colorClass = new Color8U_Basics();
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        public SortedList<int, int> sortedList = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());

        public Contour_Basics_CS()
        {
            FindRadio("FloodFill").Checked = true;
            UpdateAdvice(traceName + ": redOptions color class determines the input. Use local options in 'Options_Contours' to further control output.");
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            colorClass.Run(src);
            dst2 = colorClass.dst2;

            if (options.retrievalMode == RetrievalModes.FloodFill)
            {
                dst2.ConvertTo(dst1, MatType.CV_32SC1);
                Cv2.FindContours(dst1, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxSimple);
            }
            else
            {
                Cv2.FindContours(dst2, out allContours, out _, options.retrievalMode, options.ApproximationMode);
            }
            if (allContours.Length <= 1) return;

            sortedList.Clear();
            for (int i = 0; i < allContours.Length; i++)
            {
                if (allContours[i].Length < 4) continue;
                double count = Cv2.ContourArea(allContours[i]);
                if (count > 2) sortedList.Add((int)count, i);
            }

            dst3.SetTo(0);
            contourlist.Clear();
            dst2 = colorClass.dst3;
            for (int i = 0; i < sortedList.Count; i++)
            {
                cv.Point[] tour = allContours[sortedList.ElementAt(i).Value];
                contourlist.Add(tour);
                Scalar color = vecToScalar(dst2.Get<Vec3b>(tour[0].Y, tour[0].X));
                DrawContour(dst3, tour.ToList(), color, -1);
            }
            labels[3] = $"Top {sortedList.Count} contours found";
        }
    }




    public class Contour_General_CS : VB_Parent
    {
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        int minLengthContour = 4; // use any contour With enough points To make a contour!

        public Contour_General_CS()
        {
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                if (!vbc.task.heartBeat) return;
                rotatedRect.Run(src);
                dst2 = rotatedRect.dst2;
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            else
            {
                dst2 = src.Channels() == 3 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
            }

            if (dst2.Type() == MatType.CV_8U)
            {
                Cv2.FindContours(dst2, out allContours, out _, RetrievalModes.External, ContourApproximationModes.ApproxTC89KCOS);
            }
            else
            {
                if (dst2.Type() != MatType.CV_32S) dst2.ConvertTo(dst2, MatType.CV_32S);
                Cv2.FindContours(dst2, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxTC89KCOS);
            }

            contourlist.Clear();
            foreach (var c in allContours)
            {
                double area = Cv2.ContourArea(c);
                if (area >= options.minPixels && c.Length >= minLengthContour) contourlist.Add(c);
            }

            dst3.SetTo(0);
            foreach (var ctr in allContours)
            {
                DrawContour(dst3, ctr.ToList(), Scalar.Yellow);
            }
        }
    }





    public class Contour_GeneralWithOptions_CS : VB_Parent
    {
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        int minLengthContour = 4; // use any contour With enough points To make a contour!
        public Contour_GeneralWithOptions_CS()
        {
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest())
            {
                if (!vbc.task.heartBeat) return;
                rotatedRect.Run(src);
                dst2 = rotatedRect.dst2;
                if (dst2.Channels() == 3)
                {
                    dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).ConvertScaleAbs(255);
                }
                else
                {
                    dst2 = dst2.ConvertScaleAbs(255);
                }
            }
            else
            {
                dst2 = src.Channels() == 3 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
            }

            if (options.retrievalMode == RetrievalModes.FloodFill) dst2.ConvertTo(dst2, MatType.CV_32SC1);
            Cv2.FindContours(dst2, out allContours, out _, options.retrievalMode, options.ApproximationMode);

            contourlist.Clear();
            foreach (var c in allContours)
            {
                double area = Cv2.ContourArea(c);
                if (area >= options.minPixels && c.Length >= minLengthContour) contourlist.Add(c);
            }

            dst3.SetTo(0);
            foreach (var ctr in allContours)
            {
                DrawContour(dst3, ctr.ToList(), Scalar.Yellow);
            }
        }
    }




    public class Contour_RedCloudEdges_CS : VB_Parent
    {
        RedCloud_Cells redC = new RedCloud_Cells();
        EdgeDraw_Basics edges = new EdgeDraw_Basics();
        public Contour_RedCloudEdges_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "EdgeDraw_Basics output", "", "Pixels below are both cell boundaries and edges." };
            desc = "Intersect the cell contours and the edges in the image.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            labels[2] = redC.redC.labels[2] + " - Contours only.  Click anywhere to select a cell";
            dst2.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                DrawContour(dst2[rc.rect], rc.contour, cv.Scalar.All(255), vbc.task.lineWidth);
            }
            edges.Run(src);
            dst1 = edges.dst2;
            dst3 = dst1 & dst2;
        }
    }
    public class Contour_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Contour_RedCloud_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Show all the contours found in the RedCloud output";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                DrawContour(dst3[rc.rect], rc.contour, cv.Scalar.All(255), vbc.task.lineWidth);
            }
        }
    }
    public class Contour_CompareToFeatureless_CS : VB_Parent
    {
        Contour_WholeImage contour = new Contour_WholeImage();
        FeatureLess_Basics fLess = new FeatureLess_Basics();
        public Contour_CompareToFeatureless_CS()
        {
            labels = new string[] { "", "", "Contour_WholeImage output", "FeatureLess_Basics output" };
            desc = "Compare Contour_WholeImage and FeatureLess_Basics.";
        }
        public void RunAlg(Mat src)
        {
            contour.Run(src);
            dst2 = contour.dst2;
            fLess.Run(src);
            dst3 = fLess.dst2;
        }
    }
    public class Contour_Smoothing_CS : VB_Parent
    {
        Options_Contours2 options = new Options_Contours2();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Contour_Smoothing_CS()
        {
            labels[3] = "The white outline is the truest contour while the red is the selected approximation.";
            desc = "Compare contours of the selected cell. Cells are offset to help comparison.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            var rc = vbc.task.rc;
            dst1.SetTo(0);
            dst3.SetTo(0);
            var bestContour = ContourBuild(rc.mask, ContourApproximationModes.ApproxNone);
            DrawContour(dst3[rc.rect], bestContour, Scalar.White, vbc.task.lineWidth + 3);
            var approxContour = ContourBuild(rc.mask, options.ApproximationMode);
            DrawContour(dst3[rc.rect], approxContour, Scalar.Red);
            if (vbc.task.heartBeat) labels[2] = "Contour points count reduced from " + bestContour.Count() +
                                               " to " + approxContour.Count();
        }
    }
    public class Contour_RC_AddContour_CS : VB_Parent
    {
        public List<cv.Point> contour = new List<cv.Point>();
        public Options_Contours options = new Options_Contours();
        int myFrameCount = 0;
        Reduction_Basics reduction = new Reduction_Basics();
        public Contour_RC_AddContour_CS()
        {
            desc = "Find the contour for the src.";
        }
        public void RunAlg(Mat src)
        {
            if (myFrameCount != vbc.task.frameCount)
            {
                options.RunOpt(); // avoid running options more than once per frame.
                myFrameCount = vbc.task.frameCount;
            }
            if (standalone)
            {
                reduction.Run(src);
                src = reduction.dst2;
            }
            cv.Point[][] allContours;
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            Cv2.FindContours(src, out allContours, out _, RetrievalModes.External, options.ApproximationMode);
            int maxCount = 0, maxIndex = 0;
            for (int i = 0; i < allContours.Length; i++)
            {
                int len = allContours[i].Length;
                if (len > maxCount)
                {
                    maxCount = len;
                    maxIndex = i;
                }
            }
            dst2 = src;
            if (allContours.Length == 0) return;
            var contour = new List<cv.Point>(allContours[maxIndex]);
            DrawContour(dst2, contour, cv.Scalar.All(255), vbc.task.lineWidth);
        }
    }




    public class Contour_RotatedRects_CS : VB_Parent
    {
        public Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        Contour_General basics = new Contour_General();

        public Contour_RotatedRects_CS()
        {
            labels[3] = "Find contours of several rotated rects";
            desc = "Demo options on FindContours.";
        }

        public void RunAlg(Mat src)
        {
            Mat imageInput = new Mat();
            rotatedRect.Run(src);
            imageInput = rotatedRect.dst2;
            if (imageInput.Channels() == 3)
            {
                dst2 = imageInput.CvtColor(ColorConversionCodes.BGR2GRAY).ConvertScaleAbs(255);
            }
            else
            {
                dst2 = imageInput.ConvertScaleAbs(255);
            }

            basics.Run(dst2);
            dst2 = basics.dst2;
            dst3 = basics.dst3;
        }
    }



    public class Contour_RemoveLines_CS : VB_Parent
    {
        Options_Morphology options = new Options_Morphology();
        Mat image;
        public Contour_RemoveLines_CS()
        {
            UpdateAdvice(traceName + ": use the local options in 'Morphology width/height to show impact'");
            labels = new string[] { "", "", "Identified horizontal lines - why is scale factor necessary?", "Identified vertical lines" };
            image = Cv2.ImRead(vbc.task.HomeDir + "Data/invoice.jpg");
            var dstSize = new cv.Size(dst2.Height * dst2.Width / image.Height, dst2.Height);
            var dstRect = new cv.Rect(0, 0, image.Width, dst2.Height);
            image = image.Resize(dstSize);
            desc = "Remove the lines from an invoice image";
        }
        cv.Point[][] scaleTour(cv.Point[][] tour)
        {
            for (int i = 0; i < tour.Length; i++)
            {
                var tmpTour = new List<cv.Point>();
                foreach (var pt in tour[i])
                {
                    tmpTour.Add(new cv.Point(pt.X * options.scaleFactor, pt.Y));
                }
                tour[i] = tmpTour.ToArray();
            }
            return tour;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = image.Resize(dst2.Size());
            dst3 = dst2.Clone();
            var gray = image.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            var thresh = gray.Threshold(0, 255, ThresholdTypes.BinaryInv | ThresholdTypes.Otsu);
            // remove horizontal lines
            var hkernel = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(options.widthHeight, 1));
            var removedH = new Mat();
            Cv2.MorphologyEx(thresh, removedH, MorphTypes.Open, hkernel, iterations: options.iterations);
            var tour = Cv2.FindContoursAsArray(removedH, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
            tour = scaleTour(tour);
            for (int i = 0; i < tour.Length; i++)
            {
                Cv2.DrawContours(dst2, tour, i, Scalar.Black, vbc.task.lineWidth);
            }
            var vkernel = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(1, options.widthHeight));
            var removedV = new Mat();
            thresh = gray.Threshold(0, 255, ThresholdTypes.BinaryInv | ThresholdTypes.Otsu);
            Cv2.MorphologyEx(thresh, removedV, MorphTypes.Open, vkernel, iterations: options.iterations);
            tour = Cv2.FindContoursAsArray(removedV, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
            tour = scaleTour(tour);
            for (int i = 0; i < tour.Length; i++)
            {
                Cv2.DrawContours(dst3, tour, i, Scalar.Black, vbc.task.lineWidth);
            }
        }
    }






    public class Contour_Edges_CS : VB_Parent
    {
        Edge_ResizeAdd edges = new Edge_ResizeAdd();
        Contour_General contour = new Contour_General();
        Mat lastImage;
        int minLengthContour = 4; // use any contour With enough points To make a contour!
        public Contour_Edges_CS()
        {
            lastImage = new Mat(vbc.task.dst2.Width, vbc.task.dst2.Height, MatType.CV_8UC3, cv.Scalar.All(0));
            desc = "Create contours for motion";
        }

        public void RunAlg(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2;

            contour.Run(dst2);

            dst3.SetTo(0);
            List<Vec3b> colors = new List<Vec3b>();
            Scalar color;
            foreach (var c in contour.allContours)
            {
                if (c.Length > minLengthContour)
                {
                    Vec3b vec = lastImage.Get<Vec3b>(c[0].Y, c[0].X);
                    if (vec == black || colors.Contains(vec))
                    {
                        color = new Scalar(msRNG.Next(10, 240), msRNG.Next(10, 240), msRNG.Next(10, 240)); // trying to avoid extreme colors... 
                    }
                    else
                    {
                        color = new Scalar(vec[0], vec[1], vec[2]);
                    }
                    colors.Add(vec);
                    DrawContour(dst3, c.ToList(), color, -1);
                }
            }
            lastImage = dst3.Clone();
        }
    }





    public class Contour_SidePoints_CS : VB_Parent
    {
        public Vec3f vecLeft, vecRight, vecTop, vecBot;
        public cv.Point ptLeft, ptRight, ptTop, ptBot;
        public Profile_Basics sides = new Profile_Basics();

        public Contour_SidePoints_CS()
        {
            desc = "Find the left/right and top/bottom sides of a contour";
        }

        string Vec3fToString(Vec3f v)
        {
            return string.Format("{0:F3}\t{1:F3}\t{2:F3}", v[0], v[1], v[2]);
        }

        public void RunAlg(Mat src)
        {
            sides.Run(src);
            dst2 = sides.dst2;
            var rc = vbc.task.rc;

            if (sides.corners.Count > 0 && vbc.task.heartBeat)
            {
                ptLeft = sides.corners[1];
                ptRight = sides.corners[2];
                ptTop = sides.corners[3];
                ptBot = sides.corners[4];

                vecLeft = sides.corners3D[1];
                vecRight = sides.corners3D[2];

                vecTop = sides.corners3D[3];
                vecBot = sides.corners3D[4];

                if (rc.contour.Count > 0)
                {
                    dst3.SetTo(0);
                    DrawContour(dst3[rc.rect], rc.contour, Scalar.Yellow);
                    Cv2.Line(dst3, ptLeft, ptRight, Scalar.White);
                    Cv2.Line(dst3, ptTop, ptBot, Scalar.White);
                }
                if (vbc.task.heartBeat)
                {
                    strOut = "X     \tY     \tZ \t 3D location (units=meters)\n";
                    strOut += Vec3fToString(vecLeft) + "\t Left side average (blue)\n";
                    strOut += Vec3fToString(vecRight) + "\t Right side average (red)\n";
                    strOut += Vec3fToString(vecTop) + "\t Top side average (green)\n";
                    strOut += Vec3fToString(vecBot) + "\t Bottom side average (white)\n\n";
                    strOut += "The contour may show points further away but they don't have depth.";
                }
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Contour_Foreground_CS : VB_Parent
    {
        Foreground_KMeans km = new Foreground_KMeans();
        Contour_General contour = new Contour_General();

        public Contour_Foreground_CS()
        {
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Kmeans foreground output", "Contour of foreground" };
            desc = "Build a contour for the foreground";
        }

        public void RunAlg(Mat src)
        {
            km.Run(vbc.task.pcSplit[2]);
            dst2 = km.dst2;

            contour.Run(dst2);
            dst3.SetTo(0);
            foreach (var ctr in contour.contourlist)
            {
                Cv2.DrawContours(dst3, new[] { ctr }, 0, new Scalar(255), -1);
            }
        }
    }





    public class Contour_Sorted_CS : VB_Parent
    {
        Contour_GeneralWithOptions contours = new Contour_GeneralWithOptions();
        SortedList<int, cv.Point[]> sortedContours = new SortedList<int, cv.Point[]>(new compareAllowIdenticalIntegerInverted());
        SortedList<int, int> sortedByArea = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
        Diff_Basics diff = new Diff_Basics();
        Erode_Basics erode = new Erode_Basics();
        Dilate_Basics dilate = new Dilate_Basics();
        Options_Contours options = new Options_Contours();
        int minLengthContour = 4; // use any contour With enough points To make a contour!
        public Contour_Sorted_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Contours in the detected motion", "Diff output - detected motion" };
            vbc.task.gOptions.pixelDiffThreshold = 25;
            desc = "Display the contours from largest to smallest in the motion output";
        }

        public void RunAlg(Mat src)
        {
            diff.Run(src);
            erode.Run(diff.dst2); // remove solo points.

            contours.Run(diff.dst2);
            dst2 = contours.dst2;
            dst1 = contours.dst2.Clone();

            sortedByArea.Clear();
            sortedContours.Clear();
            dst3.SetTo(0);
            for (int i = 0; i < contours.contourlist.Count; i++)
            {
                double area = Cv2.ContourArea(contours.contourlist[i]);
                if (area > options.minPixels && contours.contourlist[i].Length > minLengthContour)
                {
                    sortedByArea.Add((int)area, i);
                    sortedContours.Add((int)area, Cv2.ApproxPolyDP(contours.contourlist[i], contours.options.epsilon, true));
                    Cv2.DrawContours(dst3, new[] { contours.contourlist[i] }, 0, Scalar.White, -1);
                }
            }

            dilate.Run(dst3);
            dst3 = dilate.dst2;

            int beforeCount = Cv2.CountNonZero(dst1);
            dst1.SetTo(0, dst3);
            int afterCount = Cv2.CountNonZero(dst1);
            SetTrueText($"Before dilate: {beforeCount}\nAfter dilate {afterCount}\nRemoved = {beforeCount - afterCount}", 1);

            SetTrueText($"The motion detected produced {sortedContours.Count} contours after filtering for length and area.", 3);
        }
    }





    public class Contour_Outline_CS : VB_Parent
    {
        public rcData rc = new rcData();
        RedCloud_Basics redC = new RedCloud_Basics();

        public Contour_Outline_CS()
        {
            desc = "Create a simplified contour of the selected cell";
        }

        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            List<cv.Point> ptList = rc.contour;

            dst3.SetTo(0);

            List<cv.Point> newContour = new List<cv.Point>();
            rc = vbc.task.rc;
            if (rc.contour.Count == 0) return;
            cv.Point p1 = new cv.Point(0, 0), p2;
            newContour.Add(p1);
            for (int i = 0; i < rc.contour.Count - 1; i++)
            {
                p1 = rc.contour[i];
                p2 = rc.contour[i + 1];
                Cv2.Line(dst3[rc.rect], p1, p2, Scalar.White, vbc.task.lineWidth + 1);
                newContour.Add(p2);
            }
            rc.contour = new List<cv.Point>(newContour);
            Cv2.Line(dst3[rc.rect], rc.contour[rc.contour.Count - 1], rc.contour[0], Scalar.White, vbc.task.lineWidth + 1);

            labels[2] = $"Input points = {rc.contour.Count}";
        }
    }





    public class Contour_SelfIntersect_CS : VB_Parent
    {
        public rcData rc = new rcData();
        RedCloud_Basics redC = new RedCloud_Basics();

        public Contour_SelfIntersect_CS()
        {
            desc = "Search the contour points for duplicates indicating the contour is self-intersecting.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                rc = vbc.task.rc;
                DrawContour(dst2[rc.rect], rc.contour, cv.Scalar.White);
                labels[2] = redC.labels[2];
            }

            bool selfInt = false;
            HashSet<string> ptSet = new HashSet<string>();
            dst3 = rc.mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            for (int i = 0; i < rc.contour.Count; i++)
            {
                cv.Point pt = rc.contour[i];
                string ptStr = $"{pt.X:0000}{pt.Y:0000}";
                if (ptSet.Contains(ptStr))
                {
                    double pct = (double)i / rc.contour.Count;
                    if (pct > 0.1 && pct < 0.9)
                    {
                        selfInt = true;
                        Cv2.Circle(dst3, pt, vbc.task.DotSize, Scalar.Red, -1);
                    }
                }
                ptSet.Add(ptStr);
            }
            labels[3] = selfInt ? "Self intersecting - red shows where" : "Not self-intersecting";
        }
    }




    public class Contour_Largest_CS : VB_Parent
    {
        public List<cv.Point> bestContour = new List<cv.Point>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();

        public Contour_Largest_CS()
        {
            UpdateAdvice(traceName + ": use the local options in 'Options_Contours'");
            labels = new string[] { "", "", "Input to FindContours", "Largest single contour in the input image." };
            desc = "Create a mask from the largest contour of the input.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    rotatedRect.Run(src);
                    dst2 = rotatedRect.dst2;
                }
            }
            else
            {
                dst2 = src;
            }

            if (dst2.Channels() != 1)
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (options.retrievalMode == RetrievalModes.FloodFill)
            {
                dst2.ConvertTo(dst1, MatType.CV_32SC1);
                Cv2.FindContours(dst1, out allContours, out _, options.retrievalMode, options.ApproximationMode);
                dst1.ConvertTo(dst3, MatType.CV_8UC1);
            }
            else
            {
                Cv2.FindContours(dst2, out allContours, out _, options.retrievalMode, options.ApproximationMode);
            }

            int maxCount = 0, maxIndex = -1;
            if (allContours.Length == 0) return;

            for (int i = 0; i < allContours.Length; i++)
            {
                int len = allContours[i].Length;
                if (len > maxCount)
                {
                    maxCount = len;
                    maxIndex = i;
                }
            }

            bestContour = allContours[maxIndex].ToList();

            if (standaloneTest())
            {
                dst3.SetTo(0);
                if (maxIndex >= 0 && maxCount >= 2)
                {
                    DrawContour(dst3, allContours[maxIndex].ToList(), Scalar.White);
                }
            }
        }
    }





    public class Contour_Compare_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Options_Contours options = new Options_Contours();

        public Contour_Compare_CS()
        {
            desc = "Compare findContours options - ApproxSimple, ApproxNone, etc.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];

            Mat tmp = vbc.task.rc.mask.Clone();

            cv.Point[][] allContours;
            if (options.retrievalMode == RetrievalModes.FloodFill)
                tmp.ConvertTo(tmp, MatType.CV_32SC1);

            Cv2.FindContours(tmp, out allContours, out _, RetrievalModes.External, options.ApproximationMode);

            dst3.SetTo(0);
            Cv2.DrawContours(dst3[vbc.task.rc.rect], allContours, -1, Scalar.Yellow);
        }
    }





    public class Contour_RedCloudCorners_CS : VB_Parent
    {
        public cv.Point[] corners = new cv.Point[4];
        public rcData rc = new rcData();
        RedCloud_Basics redC = new RedCloud_Basics();

        public Contour_RedCloudCorners_CS()
        {
            labels[2] = "The RedCloud Output with the highlighted contour to smooth";
            desc = "Find the point farthest from the center in each cell.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                rc = vbc.task.rc;
            }

            dst3.SetTo(0);
            Cv2.Circle(dst3, rc.maxDist, vbc.task.DotSize, Scalar.White, -1);
            cv.Point center = new cv.Point(rc.maxDist.X - rc.rect.X, rc.maxDist.Y - rc.rect.Y);
            float[] maxDistance = new float[4];

            for (int i = 0; i < corners.Length; i++)
            {
                corners[i] = center; // default is the center - a triangle shape can omit a corner
            }

            if (rc.contour == null) return;

            foreach (cv.Point pt in rc.contour)
            {
                int quad;
                if (pt.X - center.X >= 0 && pt.Y - center.Y <= 0) quad = 0; // upper right quadrant
                else if (pt.X - center.X >= 0 && pt.Y - center.Y >= 0) quad = 1; // lower right quadrant
                else if (pt.X - center.X <= 0 && pt.Y - center.Y >= 0) quad = 2; // lower left quadrant
                else quad = 3; // upper left quadrant

                float dist = (float)Math.Sqrt(Math.Pow(center.X - pt.X, 2) + Math.Pow(center.Y - pt.Y, 2));
                if (dist > maxDistance[quad])
                {
                    maxDistance[quad] = dist;
                    corners[quad] = pt;
                }
            }

            DrawContour(dst3[rc.rect], rc.contour, Scalar.White);
            for (int i = 0; i < corners.Length; i++)
            {
                Cv2.Line(dst3[rc.rect], center, corners[i], Scalar.White);
            }
        }
    }




    public class Contour_Gray_CS : VB_Parent
    {
        public List<cv.Point> contour = new List<cv.Point>();
        public Options_Contours options = new Options_Contours();
        int myFrameCount;
        Reduction_Basics reduction = new Reduction_Basics();

        public Contour_Gray_CS()
        {
            myFrameCount = vbc.task.frameCount;
            desc = "Find the contour for the src.";
        }

        public void RunAlg(Mat src)
        {
            if (myFrameCount != vbc.task.frameCount)
            {
                options.RunOpt(); // avoid running options more than once per frame.
                myFrameCount = vbc.task.frameCount;
            }

            if (standalone)
            {
                vbc.task.redOptions.setColorSource("Reduction_Basics");
                reduction.Run(src);
                src = reduction.dst2;
            }

            cv.Point[][] allContours;
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            Cv2.FindContours(src, out allContours, out _, RetrievalModes.External, options.ApproximationMode);
            if (allContours.Length == 0)
                return;

            dst2 = src;
            foreach (var tour in allContours)
            {
                DrawContour(dst2, tour.ToList(), Scalar.White, vbc.task.lineWidth);
            }
            labels[2] = $"There were {allContours.Length} contours found.";
        }
    }





    public class Contour_WholeImage_CS : VB_Parent
    {
        Contour_Basics contour = new Contour_Basics();

        public Contour_WholeImage_CS()
        {
            FindSlider("Max contours").Value = 20;
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find the top X contours by size and display them.";
        }

        public void RunAlg(Mat src)
        {
            contour.Run(src);
            var sortedContours = new SortedList<int, List<cv.Point>>(new compareAllowIdenticalIntegerInverted());
            foreach (var tour in contour.contourlist)
            {
                sortedContours.Add(tour.Length, tour.ToList());
            }

            dst2.SetTo(0);
            for (int i = 0; i < sortedContours.Count; i++)
            {
                var tour = sortedContours.ElementAt(i).Value;
                DrawContour(dst2, tour, cv.Scalar.All(255), vbc.task.lineWidth);
            }
        }
    }





    public class Contour_DepthTiers_CS : VB_Parent
    {
        public Options_Contours options = new Options_Contours();
        public Options_DepthTiers optionsTiers = new Options_DepthTiers();
        public int classCount;
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();

        public Contour_DepthTiers_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            FindRadio("FloodFill").Checked = true;
            UpdateAdvice(traceName + ": redOptions color class determines the input.  Use local options in 'Options_Contours' to further control output.");
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsTiers.RunOpt();

            vbc.task.pcSplit[2].ConvertTo(dst1, MatType.CV_32S, 100 / optionsTiers.cmPerTier, 1);

            cv.Point[][] allContours;
            Cv2.FindContours(dst1, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxSimple);
            if (allContours.Length <= 1)
                return;

            var sortedList = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < allContours.Length; i++)
            {
                if (allContours[i].Length < 4)
                    continue;
                int count = (int)Cv2.ContourArea(allContours[i]);
                if (count < options.minPixels)
                    continue;
                if (count > 2)
                    sortedList.Add(count, i);
            }

            dst2.SetTo(0);
            contourlist.Clear();
            for (int i = 0; i < sortedList.Count; i++)
            {
                var tour = allContours[sortedList.ElementAt(i).Value];
                byte val = dst2.Get<byte>(tour[0].Y, tour[0].X);
                if (val == 0)
                {
                    int index = dst1.Get<int>(tour[0].Y, tour[0].X);
                    contourlist.Add(tour);
                    DrawContour(dst2, tour.ToList(), cv.Scalar.All(index), -1);
                }
            }

            dst2.SetTo(1, dst2.Threshold(0, 255, ThresholdTypes.BinaryInv));
            classCount = (int)(vbc.task.MaxZmeters * 100 / optionsTiers.cmPerTier);

            if (standaloneTest())
                dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[3] = $"All depth pixels are assigned a tier with {classCount} contours.";
        }
    }





    public class Contour_FromPoints_CS : VB_Parent
    {
        Contour_Basics contour = new Contour_Basics();
        Random_Basics random = new Random_Basics();

        public Contour_FromPoints_CS()
        {
            FindSlider("Random Pixel Count").Value = 3;
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Create a contour from some random points";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                random.Run(src);
                dst2.SetTo(0);
                foreach (var p1 in random.PointList)
                {
                    foreach (var p2 in random.PointList)
                    {
                        DrawLine(dst2, p1, p2, Scalar.White, vbc.task.lineWidth);
                    }
                }
            }

            var hullPoints = Cv2.ConvexHull(random.PointList.ToArray(), true).ToList();

            var hull = new List<cv.Point>();
            foreach (var pt in hullPoints)
            {
                hull.Add(new cv.Point(pt.X, pt.Y));
            }

            dst3.SetTo(0);
            DrawContour(dst3, hull, Scalar.White, -1);
        }
    }







    public class Contrast_POW_CS : VB_Parent
    {
        Options_BrightnessContrast options = new Options_BrightnessContrast();
        public Contrast_POW_CS()
        {
            labels = new string[] { "", "", "Original Image", "Contrast reduced with POW function" };
            desc = "Reduce contrast with POW function";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2.ConvertTo(dst3, MatType.CV_32FC3);
            dst3 = dst3.Normalize();
            dst3 = dst3.Pow(options.exponent);
        }
    }





    public class Contrast_Basics_CS : VB_Parent
    {
        Options_BrightnessContrast options = new Options_BrightnessContrast();

        public Contrast_Basics_CS()
        {
            labels[2] = "Brightness/Contrast";
            UpdateAdvice(traceName + ": use the local options to control brightness and contrast.");
            desc = "Show image with varying contrast and brightness.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = src.ConvertScaleAbs(options.brightness, options.contrast);
        }
    }






    public class Convex_Basics_CS : VB_Parent
    {
        public cv.Point[] hull;
        Options_Convex options = new Options_Convex();

        public Convex_Basics_CS()
        {
            UpdateAdvice(traceName + ": use the local options to control the number of points.");
            desc = "Surround a set of random points with a convex hull";
            labels = new string[] { "", "", "Convex Hull - red dot is center and the black dots are the input points", "" };
        }

        public List<cv.Point> BuildRandomHullPoints()
        {
            int pad = 4;
            int w = dst2.Width - dst2.Width / pad;
            int h = dst2.Height - dst2.Height / pad;

            var hullList = new List<cv.Point>();
            for (int i = 0; i < options.hullCount; i++)
            {
                hullList.Add(new cv.Point(msRNG.Next(dst2.Width / pad, w), msRNG.Next(dst2.Height / pad, h)));
            }
            return hullList;
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            List<cv.Point> hullList = vbc.task.rc.contour;
            if (standaloneTest())
            {
                if (!vbc.task.heartBeat) return;
                hullList = BuildRandomHullPoints();
            }

            if (hullList.Count == 0)
            {
                SetTrueText("No points were provided. Update hullList before running.");
                return;
            }

            hull = Cv2.ConvexHull(hullList.ToArray(), true);

            dst2.SetTo(0);

            using (var pMat = cv.Mat.FromPixelData(hull.Length, 1, MatType.CV_32SC2, hull))
            {
                Scalar sum = pMat.Sum();
                DrawContour(dst2, hullList, Scalar.White, -1);

                for (int i = 0; i < hull.Length; i++)
                {
                    Cv2.Line(dst2, hull[i], hull[(i + 1) % hull.Length], Scalar.White);
                }
            }
        }
    }




    public class Convex_RedCloud_CS : VB_Parent
    {
        Convex_Basics_CS convex;
        public RedCloud_Basics redC = new RedCloud_Basics();

        public Convex_RedCloud_CS()
        {
            convex = new Convex_Basics_CS();
            labels = new string[] { "", "", "Selected contour - line shows hull with white is contour. Click to select another contour.", "RedCloud cells" };
            desc = "Get lots of odd shapes from the RedCloud_Basics output and use ConvexHull to simplify them.";
        }

        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;

            if (vbc.task.rc.contour != null)
            {
                convex.Run(src);

                dst3.SetTo(0);
                convex.dst2[new cv.Rect(0, 0, vbc.task.rc.rect.Width, vbc.task.rc.rect.Height)].CopyTo(dst3[vbc.task.rc.rect]);
                Cv2.Circle(dst3, vbc.task.rc.maxDist, vbc.task.DotSize, Scalar.White, -1);
            }
        }
    }





    public class Convex_Defects_CS : VB_Parent
    {
        Contour_Largest_CS contours;

        public Convex_Defects_CS()
        {
            contours = new Contour_Largest_CS();
            dst2 = Cv2.ImRead(vbc.task.HomeDir + "Data/star2.png").Threshold(200, 255, ThresholdTypes.Binary)
                              .Resize(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height));
            dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            labels = new string[] { "", "", "Input to the ConvexHull and ConvexityDefects", "Yellow = ConvexHull, Red = ConvexityDefects, Yellow dots are convexityDefect 'Far' points" };
            desc = "Find the convexityDefects in the image";
        }

        public void RunAlg(Mat src)
        {
            contours.Run(dst2.Clone());
            cv.Point[] c = contours.bestContour.ToArray();
            dst3 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            cv.Point[] hull = Cv2.ConvexHull(c, false);
            int[] hullIndices = Cv2.ConvexHullIndices(c, false);
            DrawContour(dst3, hull.ToList(), vbc.task.HighlightColor);

            Vec4i[] defects = Cv2.ConvexityDefects(contours.bestContour, hullIndices.ToList());
            foreach (Vec4i v in defects)
            {
                Cv2.Line(dst3, c[v[0]], c[v[2]], Scalar.Red, vbc.task.lineWidth + 1, LineTypes.Link8);
                Cv2.Line(dst3, c[v[1]], c[v[2]], Scalar.Red, vbc.task.lineWidth + 1, LineTypes.Link8);
                Cv2.Circle(dst3, c[v[2]], vbc.task.DotSize + 2, vbc.task.HighlightColor, -1);
            }
        }
    }





    public class Convex_RedCloudDefects_CS : VB_Parent
    {
        Convex_RedCloud_CS convex;
        Contour_Largest_CS contours;

        public Convex_RedCloudDefects_CS()
        {
            convex = new Convex_RedCloud_CS();
            contours = new Contour_Largest_CS();

            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Hull outline in green, lines show defects.", "Output of RedCloud_Basics" };
            desc = "Find the convexityDefects in the selected RedCloud cell";
        }

        public List<cv.Point> BetterContour(List<cv.Point> c, Vec4i[] defects)
        {
            int lastV = -1;
            var newC = new List<cv.Point>();
            foreach (Vec4i v in defects)
            {
                if (v[0] != lastV && lastV >= 0)
                {
                    for (int i = lastV; i < v[0]; i++)
                    {
                        newC.Add(c[i]);
                    }
                }
                newC.Add(c[v[0]]);
                newC.Add(c[v[2]]);
                newC.Add(c[v[1]]);
                lastV = v[1];
            }
            if (defects.Length > 0)
            {
                if (lastV != defects[0][0])
                {
                    for (int i = lastV; i < c.Count; i++)
                    {
                        newC.Add(c[i]);
                    }
                }
                newC.Add(c[defects[0][0]]);
            }
            return newC;
        }

        public void RunAlg(Mat src)
        {
            convex.Run(src);
            dst1 = convex.redC.dst2;
            labels[1] = convex.redC.labels[2];
            dst3 = convex.dst3;

            var rc = vbc.task.rc;
            if (rc.mask == null) return;

            dst2 = rc.mask.Resize(dst2.Size(), 0, 0, InterpolationFlags.Nearest);
            contours.Run(dst2);
            var c = contours.bestContour;

            cv.Point[] hull = Cv2.ConvexHull(c, false);
            int[] hullIndices = Cv2.ConvexHullIndices(c, false);
            dst2.SetTo(0);
            DrawContour(dst2, hull.ToList(), vecToScalar(rc.color), -1);

            try
            {
                Vec4i[] defects = Cv2.ConvexityDefects(contours.bestContour, hullIndices.ToList());
                rc.contour = BetterContour(c, defects);
            }
            catch (Exception)
            {
                SetTrueText("Convexity defects failed due to self-intersection.", 3);
            }

            DrawContour(dst2, rc.contour, Scalar.Red);
        }
    }




    public class Corners_Basics_CS : VB_Parent
    {
        public List<cv.Point2f> features = new List<cv.Point2f>();
        public Options_Features options = new Options_Features();
        public Options_Corners optionCorner = new Options_Corners();

        public Corners_Basics_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U);
            desc = "Find interesting points with the FAST (Features from Accelerated Segment Test) algorithm";
        }

        public void RunAlg(Mat src)
        {
            optionCorner.RunOpt();
            options.RunOpt();

            dst2 = src.Clone();
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            KeyPoint[] kpoints = Cv2.FAST(src, vbc.task.FASTthreshold, optionCorner.useNonMax);

            features.Clear();
            foreach (KeyPoint kp in kpoints)
            {
                features.Add(new cv.Point2f(kp.Pt.X, kp.Pt.Y));
            }

            if (standaloneTest())
            {
                dst3.SetTo(new Scalar(0));
                foreach (KeyPoint kp in kpoints)
                {
                    DrawCircle(dst2, kp.Pt, vbc.task.DotSize, Scalar.Yellow, -1);
                    dst3.Set((int)kp.Pt.Y, (int)kp.Pt.X, (byte)255);
                }
            }
            labels[2] = $"There were {features.Count} key points detected using FAST";
        }
    }





    public class Corners_Harris_CS : VB_Parent
    {
        public Options_HarrisCorners options = new Options_HarrisCorners();
        public Mat gray, mc;
        public mmData mm;

        public Corners_Harris_CS()
        {
            desc = "Find corners using Eigen values and vectors";
            labels[3] = "Corner Eigen values";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            mc = new Mat(gray.Size(), MatType.CV_32FC1, new Scalar(0));
            dst2 = new Mat(gray.Size(), MatType.CV_8U, new Scalar(0));
            Cv2.CornerEigenValsAndVecs(gray, dst2, options.blockSize, options.aperture, BorderTypes.Default);

            for (int y = 0; y < gray.Rows - 1; y++)
            {
                for (int x = 0; x < gray.Cols - 1; x++)
                {
                    float lambda_1 = dst2.Get<Vec6f>(y, x)[0];
                    float lambda_2 = dst2.Get<Vec6f>(y, x)[1];
                    mc.Set(y, x, (float)(lambda_1 * lambda_2 - 0.04f * Math.Pow(lambda_1 + lambda_2, 2)));
                }
            }

            mm = GetMinMax(mc);

            src.CopyTo(dst2);
            int count = 0;
            for (int y = 0; y < gray.Rows - 1; y++)
            {
                for (int x = 0; x < gray.Cols - 1; x++)
                {
                    if (mc.Get<float>(y, x) > mm.minVal + (mm.maxVal - mm.minVal) * options.quality / options.qualityMax)
                    {
                        Cv2.Circle(dst2, new cv.Point(x, y), vbc.task.DotSize, vbc.task.HighlightColor, -1);
                        count += 1;
                    }
                }
            }

            labels[2] = $"Corners_Harris found {count} corners in the image.";
            Mat McNormal = new Mat();
            Cv2.Normalize(mc, McNormal, 127, 255, NormTypes.MinMax);
            McNormal.ConvertTo(dst3, MatType.CV_8U);
        }
    }





    public class Corners_PreCornerDetect_CS : VB_Parent
    {
        public Math_Median_CDF median = new Math_Median_CDF();
        public Options_PreCorners options = new Options_PreCorners();

        public Corners_PreCornerDetect_CS()
        {
            desc = "Use PreCornerDetect to find features in the image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat prob = new Mat();
            Cv2.PreCornerDetect(gray, prob, options.kernelSize);

            Cv2.Normalize(prob, prob, 0, 255, NormTypes.MinMax);
            prob.ConvertTo(gray, MatType.CV_8U);
            median.Run(gray.Clone());
            dst2 = gray.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3 = gray.Threshold(160, 255, ThresholdTypes.BinaryInv).CvtColor(ColorConversionCodes.GRAY2BGR);
            labels[3] = $"median = {median.medianVal}";
        }
    }





    public class Corners_ShiTomasi_CPP_CS : VB_Parent
    {
        public Options_ShiTomasi options = new Options_ShiTomasi();

        public Corners_ShiTomasi_CPP_CS()
        {
            desc = "Find corners using Eigen values and vectors";
            labels[3] = "Corner Eigen values using ShiTomasi which is also what is used in GoodFeatures.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            byte[] data = new byte[src.Total() * src.Channels()];
            GCHandle handle = GCHandle.Alloc(data, GCHandleType.Pinned);
            Marshal.Copy(src.Data, data, 0, data.Length);
            IntPtr imagePtr = Corners_ShiTomasi(handle.AddrOfPinnedObject(), src.Rows, src.Cols, options.blocksize, options.aperture);
            handle.Free();

            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_32F, imagePtr).Clone();

            dst3 = Convert32f_To_8UC3(dst2);
            dst3 = dst3.Threshold(options.threshold, 255, ThresholdTypes.Binary);
        }

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Corners_ShiTomasi(IntPtr grayPtr, int rows, int cols, int blocksize, int aperture);
    }





    public class Corners_BasicsCentroid_CS : VB_Parent
    {
        public Corners_Basics fast = new Corners_Basics();
        public Kalman_Basics kalman = new Kalman_Basics();

        public Corners_BasicsCentroid_CS()
        {
            kalman.kInput = new float[2];
            desc = "Find interesting points with the FAST and smooth the centroid with kalman";
        }

        public void RunAlg(Mat src)
        {
            fast.Run(src);
            dst2 = fast.dst2;
            foreach (Point2f pt in fast.features)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize + 2, Scalar.White, -1);
            }
            Mat gray = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            Moments m = Cv2.Moments(gray, true);
            if (m.M00 > 5000)
            {
                kalman.kInput[0] = (float)(m.M10 / m.M00);
                kalman.kInput[1] = (float)(m.M01 / m.M00);
                kalman.Run(src);
                Cv2.Circle(dst3, new cv.Point((int)kalman.kOutput[0], (int)kalman.kOutput[1]), 10, Scalar.Red, -1);
            }
        }
    }





    public class Corners_BasicsStablePoints_CS : VB_Parent
    {
        public List<cv.Point> features = new List<cv.Point>();
        public Corners_Basics fast = new Corners_Basics();

        public Corners_BasicsStablePoints_CS()
        {
            labels = new string[] { "", "", "", "FAST stable points without context" };
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, new Scalar(0));
            desc = "Find and save only the stable points in the FAST output.";
        }

        public void RunAlg(Mat src)
        {
            fast.Run(src);

            if (vbc.task.motionFlag || vbc.task.optionsChanged)
            {
                foreach (Point2f pt in fast.features)
                {
                    features.Add(new cv.Point((int)pt.X, (int)pt.Y));
                }
            }
            List<cv.Point> newPts = new List<cv.Point>();
            dst2 = src.Clone();
            dst3.SetTo(new Scalar(0));
            foreach (Point2f pt in fast.features)
            {
                cv.Point test = new cv.Point((int)pt.X, (int)pt.Y);
                if (features.Contains(test))
                {
                    Cv2.Circle(dst2, test, vbc.task.DotSize, Scalar.Yellow, -1);
                    newPts.Add(test);
                    dst3.Set(test.Y, test.X, (byte)255);
                }
            }

            features = newPts;
            labels[2] = $"{features.Count.ToString("000")} identified FAST stable points - slider adjusts threshold";
        }
    }





    public class Corners_BasicsCentroids_CS : VB_Parent
    {
        public Corners_Basics fast = new Corners_Basics();
        public Point2f[] fastCenters;

        public Corners_BasicsCentroids_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setGridSize(16);
            desc = "Use a thread grid to find the centroids in each grid element";
        }

        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();

            fast.Run(src);
            fastCenters = new Point2f[vbc.task.gridRects.Count];
            for (int i = 0; i < vbc.task.gridRects.Count; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                Mat tmp = fast.dst3[roi];
                var nonZero = tmp.FindNonZero();
                if (nonZero.Rows > 0)
                {
                    Scalar mean = Cv2.Mean(tmp, null);
                    fastCenters[i] = new Point2f((float)(roi.X + mean.Val0), (float)(roi.Y + mean.Val1));
                }
            }

            foreach (Point2f center in fastCenters)
            {
                DrawCircle(dst2, center, vbc.task.DotSize, Scalar.Yellow);
            }
            dst2.SetTo(new Scalar(255), vbc.task.gridMask);
        }
    }





    public class Corners_Harris_CPP_CS : VB_Parent
    {
        public AddWeighted_Basics addw = new AddWeighted_Basics();
        public Options_Harris options = new Options_Harris();

        public Corners_Harris_CPP_CS()
        {
            cPtr = Harris_Features_Open();
            desc = "Use Harris feature detectors to identify interesting points.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] dataSrc = new byte[src.Total() * src.Channels()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Harris_Features_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, (float)options.threshold,
                                                  (short)options.neighborhood, (short)options.aperture, (float)options.harrisParm);
            handleSrc.Free();

            Mat gray32f = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_32F, imagePtr);
            // gray32f = Convert32f_To_8UC3(gray32f);
            gray32f.ConvertTo(dst2, MatType.CV_8U);
            addw.src2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.Run(vbc.task.color);
            dst3 = addw.dst2;
            labels[3] = "RGB overlaid with Harris result.";
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Harris_Features_Close(cPtr);
        }

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Features_Open();

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Features_Close(IntPtr Harris_FeaturesPtr);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Features_Run(IntPtr Harris_FeaturesPtr, IntPtr inputPtr, int rows, int cols, float threshold, short neighborhood, short aperture, float HarrisParm);
    }





    public class Corners_HarrisDetector_CPP_CS : VB_Parent
    {
        public List<cv.Point2f> features = new List<cv.Point2f>();
        public Options_Features options = new Options_Features();

        public Corners_HarrisDetector_CPP_CS()
        {
            cPtr = Harris_Detector_Open();
            desc = "Use Harris detector to identify interesting points.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = src.Clone();

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] dataSrc = new byte[src.Total() * src.Channels()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Harris_Detector_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.quality);
            handleSrc.Free();
            int ptCount = Harris_Detector_Count(cPtr);
            if (ptCount > 1)
            {
                Mat ptMat = cv.Mat.FromPixelData(ptCount, 2, MatType.CV_32S, imagePtr).Clone();
                features.Clear();
                for (int i = 0; i < ptCount; i++)
                {
                    features.Add(new Point2f(ptMat.Get<int>(i, 0), ptMat.Get<int>(i, 1)));
                    DrawCircle(dst2, features[i], vbc.task.DotSize, Scalar.Yellow, -1);
                }
            }
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Harris_Detector_Close(cPtr);
        }

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern int Harris_Detector_Count(IntPtr cPtr);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Detector_Open();

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Detector_Close(IntPtr Harris_FeaturesPtr);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Detector_Run(IntPtr Harris_FeaturesPtr, IntPtr inputPtr, int rows, int cols, double qualityLevel);
    }





    public class Corners_RedCloud_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Neighbors_Intersects corners = new Neighbors_Intersects();

        public Corners_RedCloud_CS()
        {
            labels = new string[] { "", "", "Grayscale", "Highlighted points show where more than 2 cells intersect." };
            desc = "Find the corners for each RedCloud cell.";
        }

        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];

            corners.Run(vbc.task.cellMap);

            dst3 = new Mat();
            src.CopyTo(dst3);
            foreach (Point2f pt in corners.nPoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.Yellow, -1);
            }
        }
    }





    public class Corners_SubPix_CS : VB_Parent
    {
        public Feature_Stable feat = new Feature_Stable();
        public Options_PreCorners options = new Options_PreCorners();

        public Corners_SubPix_CS()
        {
            labels[2] = "Output of PreCornerDetect";
            desc = "Use PreCornerDetect to refine the feature points to sub-pixel accuracy.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = src.Clone();
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            feat.Run(src);
            cv.TermCriteria term = new cv.TermCriteria((cv.CriteriaTypes)((int)cv.CriteriaTypes.Eps + (int)cv.CriteriaTypes.Count), 10, 1.0);
            Cv2.CornerSubPix(src, vbc.task.features, new cv.Size(options.subpixSize, options.subpixSize), new cv.Size(-1, -1), term);

            List<cv.Point> featurePoints = new List<cv.Point>();
            for (int i = 0; i < vbc.task.features.Count; i++)
            {
                Point2f pt = vbc.task.features[i];
                featurePoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1);
            }
        }
    }




    public class Correlation_Basics_CS : VB_Parent
    {
        KMeans_Edges kFlood = new KMeans_Edges();
        Options_FeatureMatch options = new Options_FeatureMatch();

        public Correlation_Basics_CS()
        {
            labels[3] = "Plot of z (vertical scale) to x with ranges shown on the plot.";
            UpdateAdvice(traceName + ": there are several local options panels.");
            desc = "Compute a correlation for src rows (See also: Match.cs";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            kFlood.Run(src);
            dst1 = kFlood.dst2;
            dst2 = kFlood.dst3;

            int row = vbc.task.mouseMovePoint.Y;
            if (row == 0)
                SetTrueText("Move mouse across image to see the relationship between X and Z\n" +
                            "A linear relationship is a useful correlation", new cv.Point(0, 10), 3);

            Mat dataX = new Mat(src.Size(), MatType.CV_32F, Scalar.All(0));
            Mat dataY = new Mat(src.Size(), MatType.CV_32F, Scalar.All(0));
            Mat dataZ = new Mat(src.Size(), MatType.CV_32F, Scalar.All(0));

            Mat mask = kFlood.dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            vbc.task.pcSplit[0].CopyTo(dataX, mask);
            vbc.task.pcSplit[1].CopyTo(dataY, mask);
            vbc.task.pcSplit[2].CopyTo(dataZ, mask);

            Mat row1 = dataX.Row(row);
            Mat row2 = dataZ.Row(row);
            Cv2.Line(dst2, new cv.Point(0, row), new cv.Point(dst2.Width, row), Scalar.Yellow, vbc.task.lineWidth + 1);

            Mat correlationMat = new Mat();
            Cv2.MatchTemplate(row1, row2, correlationMat, options.matchOption);
            float correlation = correlationMat.Get<float>(0, 0);
            labels[2] = $"Correlation of X to Z = {correlation:F2}";

            dst3.SetTo(Scalar.All(0));
            List<float> plotX = new List<float>();
            List<float> plotZ = new List<float>();
            for (int i = 0; i < row1.Cols; i++)
            {
                float x = row1.Get<float>(0, i);
                float z = row2.Get<float>(0, i);
                if (x != 0 && z != 0)
                {
                    plotX.Add(x);
                    plotZ.Add(z);
                }
            }

            if (plotX.Count > 0)
            {
                float minx = plotX.Min(), maxx = plotX.Max();
                float minZ = plotZ.Min(), maxZ = plotZ.Max();
                for (int i = 0; i < plotX.Count; i++)
                {
                    float x = dst3.Width * (plotX[i] - minx) / (maxx - minx);
                    float y = dst3.Height * (plotZ[i] - minZ) / (maxZ - minZ);
                    Cv2.Circle(dst3, new cv.Point(x, y), vbc.task.DotSize, Scalar.Yellow, -1);
                }
                SetTrueText($"Z-min {minZ:F2}", new cv.Point(10, 5), 3);
                SetTrueText($"Z-max {maxZ:F2}\n\tX-min {minx:F2}", new cv.Point(0, dst3.Height - 20), 3);
                SetTrueText($"X-max {maxx:F2}", new cv.Point(dst3.Width - 40, dst3.Height - 10), 3);
            }
        }
    }




    public class Covariance_Basics_CS : VB_Parent
    {
        Random_Basics_CS random;
        public Mat mean = new Mat();
        public Mat covariance = new Mat();
        cv.Point2f lastCenter;
        public Covariance_Basics_CS()
        {
            random = new Random_Basics_CS();
            UpdateAdvice(traceName + ": use the local options to control the number of points.");
            desc = "Calculate the covariance of random depth data points.";
        }

        public void RunAlg(Mat src)
        {
            dst3.SetTo(0);
            if (standaloneTest())
            {
                random.Run(empty);
                src = cv.Mat.FromPixelData(random.PointList.Count, 2, MatType.CV_32F, random.PointList.ToArray());
                for (int i = 0; i < random.PointList.Count; i++)
                {
                    DrawCircle(dst3, random.PointList[i], 3, Scalar.White);
                }
            }

            Mat samples2 = src.Reshape(2);
            Cv2.CalcCovarMatrix(src, covariance, mean, CovarFlags.Cols);

            strOut = "The Covariance Mat:\n";
            for (int j = 0; j < covariance.Rows; j++)
            {
                for (int i = 0; i < covariance.Cols; i++)
                {
                    strOut += string.Format(vbc.fmt3, covariance.Get<double>(j, i)) + ", ";
                }
                strOut += "\n";
            }
            strOut += "\n";

            Scalar overallMean = Cv2.Mean(samples2);
            cv.Point2f center = new Point2f((float)overallMean[0], (float)overallMean[1]);
            strOut += $"Mean (img1, img2) = ({center.X.ToString(vbc.fmt0)}, {center.Y.ToString(vbc.fmt0)})\n";

            if (standaloneTest())
            {
                if (vbc.task.FirstPass) lastCenter = center;
                DrawCircle(dst3, center, 5, Scalar.Red);
                DrawCircle(dst3, lastCenter, 5, Scalar.Yellow, vbc.task.lineWidth + 1);
                DrawLine(dst3, center, lastCenter, Scalar.Red, vbc.task.lineWidth + 1);
                lastCenter = center;
                strOut += "Yellow is last center, red is the current center";
            }
            SetTrueText(strOut);
        }
    }





    public class Covariance_Test_CS : VB_Parent
    {
        Covariance_Basics covar = new Covariance_Basics();

        public Covariance_Test_CS()
        {
            desc = "Test the covariance basics algorithm.";
        }

        public void RunAlg(Mat src)
        {
            double[] testInput = { 1.5, 2.3, 3.0, 1.7, 1.2, 2.9, 2.1, 2.2, 3.1, 3.1, 1.3, 2.7, 2.0, 1.7, 1.0, 2.0, 0.5, 0.6, 1.0, 0.9 };
            Mat samples = cv.Mat.FromPixelData(10, 2, MatType.CV_64F, testInput);
            covar.Run(samples);
            SetTrueText(covar.strOut, new cv.Point(20, 60));
            SetTrueText("Results should be a symmetric array with 2.1 and -2.1", new cv.Point(20, 150));
        }
    }





    public class Covariance_Images_CS : VB_Parent
    {
        Covariance_Basics covar = new Covariance_Basics();
        public Mat mean;
        public Mat covariance;
        Mat last32f = new Mat();

        public Covariance_Images_CS()
        {
            desc = "Calculate the covariance of 2 images";
        }

        public void RunAlg(Mat src)
        {
            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.optionsChanged) gray.ConvertTo(last32f, MatType.CV_32F);
            dst2 = gray;

            Mat gray32f = new Mat();
            gray.ConvertTo(gray32f, MatType.CV_32F);
            Cv2.Merge(new[] { gray32f, last32f }, dst0);
            Mat samples = dst0.Reshape(1, dst0.Rows * dst0.Cols);
            covar.Run(samples);

            last32f = gray32f;

            SetTrueText(covar.strOut, new cv.Point(10, 10), 3);

            mean = covar.mean;
            covariance = covar.covariance;
        }
    }






    public class Crypto_Hash_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        List<Mat> images = new List<Mat>();
        List<string> guids = new List<string>();

        public Crypto_Hash_CS()
        {
            flow.parentData = this;
            desc = "Experiment with hashing algorithm and guid";
        }

        public void RunAlg(Mat src)
        {
            int iSize = (int)(src.Total() * src.ElemSize());
            int maxImages = 10;
            images.Add(src);

            if (images.Count >= maxImages)
            {
                byte[] bytes = new byte[iSize * maxImages];
                images.RemoveAt(0);

                int index = 0;
                foreach (Mat mat in images)
                {
                    Marshal.Copy(mat.Data, bytes, iSize * index, iSize);
                    index++;
                }

                using (MD5 algorithm = MD5.Create())
                {
                    bytes = algorithm.ComputeHash(bytes);
                }

                guids.Add(new Guid(bytes).ToString());
                flow.flowText.Clear();

                for (int i = 0; i < guids.Count; i++)
                {
                    flow.flowText.Add(guids[i]);
                }

                if (guids.Count >= flow.maxLines)
                {
                    guids.RemoveAt(0);
                }


                flow.Run(empty);
            }
        }
    }




    public class CSV_Basics_CS : VB_Parent
    {
        public string InputFile { get; set; }
        public string[,] Array { get; set; }
        public List<List<string>> ArrayList { get; set; }

        public CSV_Basics_CS()
        {
            var fileInput = new FileInfo(Path.Combine(vbc.task.HomeDir, "Data/agaricus-lepiota.data"));
            InputFile = fileInput.FullName;
            desc = "Read and prepare a .csv file";
            ArrayList = new List<List<string>>();
        }

        public void RunAlg(Mat src)
        {
            string[] readText = File.ReadAllLines(InputFile);
            string[] variables = readText[0].Split(',');
            Array = new string[readText.Length, variables.Length];

            for (int i = 0; i < Array.GetLength(0); i++)
            {
                variables = readText[i].Split(',');
                for (int j = 0; j < Array.GetLength(1); j++)
                {
                    Array[i, j] = variables[j];
                }
            }

            for (int i = 0; i < Array.GetLength(1); i++)
            {
                ArrayList.Add(new List<string>());
                for (int j = 0; j < Array.GetLength(0); j++)
                {
                    ArrayList[i].Add(Array[j, i]);
                }
            }

            if (standaloneTest())
            {
                SetTrueText($"{InputFile} is now loaded into the csv.array");
            }
        }
    }




    public class DCT_Basics_CS : VB_Parent
    {
        public Options_DCT options = new Options_DCT();

        public DCT_Basics_CS()
        {
            labels[3] = "Difference from original";
            UpdateAdvice(traceName + ": local options control the Discrete Cosine Transform'");
            desc = "Apply OpenCV's Discrete Cosine Transform to a grayscale image and use slider to remove the highest frequencies.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            Mat src32f = new Mat();
            src.ConvertTo(src32f, MatType.CV_32F, 1.0 / 255);

            Mat frequencies = new Mat();
            Cv2.Dct(src32f, frequencies, (cv.DctFlags)options.removeFrequency);

            cv.Rect roi = new cv.Rect(0, 0, options.removeFrequency, src32f.Height);
            if (roi.Width > 0)
                frequencies[roi].SetTo(0);
            labels[2] = "Frequencies below " + options.removeFrequency.ToString() + " removed";

            Cv2.Dct(frequencies, src32f, DctFlags.Inverse);
            src32f.ConvertTo(dst2, MatType.CV_8UC1, 255);

            Cv2.Subtract(src, dst2, dst3);
        }
    }





    public class DCT_RGB_CS : VB_Parent
    {
        public DCT_Basics dct = new DCT_Basics();

        public DCT_RGB_CS()
        {
            labels[3] = "Difference from original";
            desc = "Apply OpenCV's Discrete Cosine Transform to a BGR image and use slider to remove the highest frequencies.";
        }

        public void RunAlg(Mat src)
        {
            dct.options.RunOpt();

            Mat[] srcPlanes = Cv2.Split(src);

            Mat[] freqPlanes = new Mat[3];
            for (int i = 0; i < srcPlanes.Length; i++)
            {
                Mat src32f = new Mat();
                srcPlanes[i].ConvertTo(src32f, MatType.CV_32FC3, 1.0 / 255);
                freqPlanes[i] = new Mat();
                Cv2.Dct(src32f, freqPlanes[i], DctFlags.None);

                cv.Rect roi = new cv.Rect(0, 0, dct.options.removeFrequency, src32f.Height);
                if (roi.Width > 0)
                    freqPlanes[i][roi].SetTo(0);

                Cv2.Dct(freqPlanes[i], src32f, dct.options.dctFlag);
                src32f.ConvertTo(srcPlanes[i], MatType.CV_8UC1, 255);
            }
            labels[2] = dct.labels[2];

            Cv2.Merge(srcPlanes, dst2);

            Cv2.Subtract(src, dst2, dst3);
        }
    }





    public class DCT_Depth_CS : VB_Parent
    {
        DCT_Basics dct = new DCT_Basics();

        public DCT_Depth_CS()
        {
            labels[3] = "Subtract DCT inverse from Grayscale depth";
            desc = "Find featureless surfaces in the depth data - expected to be useful only on the K4A for Azure camera.";
        }

        public void RunAlg(Mat src)
        {
            Mat gray = vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat frequencies = new Mat();
            Mat src32f = new Mat();
            gray.ConvertTo(src32f, MatType.CV_32F, 1.0 / 255);
            Cv2.Dct(src32f, frequencies, dct.options.dctFlag);

            cv.Rect roi = new cv.Rect(0, 0, dct.options.removeFrequency, src32f.Height);
            if (roi.Width > 0)
                frequencies[roi].SetTo(0);
            labels[2] = dct.labels[2];

            Cv2.Dct(frequencies, src32f, DctFlags.Inverse);
            src32f.ConvertTo(dst2, MatType.CV_8UC1, 255);

            Cv2.Subtract(gray, dst2, dst3);
        }
    }





    public class DCT_FeatureLess_CS : VB_Parent
    {
        public DCT_Basics dct = new DCT_Basics();

        public DCT_FeatureLess_CS()
        {
            desc = "Find surfaces that lack any texture. Remove just the highest frequency from the DCT to get horizontal lines through the image.";
            labels[3] = "FeatureLess BGR regions";
        }

        public void RunAlg(Mat src)
        {
            dct.Run(src);

            dst2.SetTo(0);
            for (int i = 0; i < dct.dst2.Rows; i++)
            {
                int runLen = 0;
                int runStart = 0;
                for (int j = 1; j < dct.dst2.Cols; j++)
                {
                    if (dct.dst2.Get<byte>(i, j) == dct.dst2.Get<byte>(i, j - 1))
                    {
                        runLen++;
                    }
                    else
                    {
                        if (runLen > dct.options.runLengthMin)
                        {
                            cv.Rect roi = new cv.Rect(runStart, i, runLen, 1);
                            dst2[roi].SetTo(255);
                        }
                        runStart = j;
                        runLen = 1;
                    }
                }
            }

            dst3.SetTo(0);
            if (dst2.Channels() == 3)
            {
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(1, 255, ThresholdTypes.Binary);
            }
            else
            {
                dst2 = dst2.Threshold(1, 255, ThresholdTypes.Binary);
            }
            src.CopyTo(dst3, ~dst2);
            labels[2] = "Mask of DCT with highest frequency removed";
        }
    }





    public class DCT_Surfaces_debug_CS : VB_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        DCT_FeatureLess dct = new DCT_FeatureLess();
        Font_FlowText flow = new Font_FlowText();
        Plane_CellColor plane = new Plane_CellColor();

        public DCT_Surfaces_debug_CS()
        {
            flow.parentData = this;
            labels = new string[] { "", "", "Stats on the largest region below DCT threshold", "Various views of regions with DCT below threshold" };
            vbc.task.gOptions.setDisplay0();
            desc = "Find plane equation for a featureless surface - debugging one region for now.";
        }

        public void RunAlg(Mat src)
        {
            mats.mat[0] = src.Clone();
            mats.mat[0].SetTo(Scalar.White, vbc.task.gridMask);

            dct.Run(src);
            mats.mat[1] = dct.dst2.CvtColor(ColorConversionCodes.GRAY2BGR).Clone();
            mats.mat[2] = dct.dst3.Clone();

            Mat mask = dct.dst2.Clone();
            vbc.task.pcSplit[2].SetTo(0, ~mask);

            int maxIndex = 0;
            int[] roiCounts = new int[vbc.task.gridRects.Count];
            for (int i = 0; i < vbc.task.gridRects.Count; i++)
            {
                roiCounts[i] = mask[vbc.task.gridRects[i]].CountNonZero();
                if (roiCounts[i] > roiCounts[maxIndex])
                    maxIndex = i;
            }

            mats.mat[3] = new Mat(src.Size(), MatType.CV_8UC3, cv.Scalar.All(0));
            src[vbc.task.gridRects[maxIndex]].CopyTo(mats.mat[3][vbc.task.gridRects[maxIndex]], mask[vbc.task.gridRects[maxIndex]]);
            mats.Run(new Mat());
            dst3 = mats.dst2;

            cv.Rect roi = vbc.task.gridRects[maxIndex];
            if (roi.X == vbc.task.gridRects[maxIndex].X && roi.Y == vbc.task.gridRects[maxIndex].Y)
            {
                if (roiCounts[maxIndex] > roi.Width * roi.Height / 4)
                {
                    List<cv.Point3f> fitPoints = new List<cv.Point3f>();
                    float minDepth = float.MaxValue, maxDepth = float.MinValue;
                    for (int j = 0; j < roi.Height; j++)
                    {
                        for (int i = 0; i < roi.Width; i++)
                        {
                            float nextD = vbc.task.pcSplit[2][roi].Get<float>(j, i);
                            if (nextD != 0)
                            {
                                if (minDepth > nextD) minDepth = nextD;
                                if (maxDepth < nextD) maxDepth = nextD;
                                Point3f wpt = new Point3f(roi.X + i, roi.Y + j, nextD);
                                fitPoints.Add(getWorldCoordinates(wpt));
                            }
                        }
                    }
                    if (fitPoints.Count > 0)
                    {
                        var eq = fitDepthPlane(fitPoints);
                        if (!float.IsNaN(eq[0]))
                        {
                            flow.nextMsg = $"a={eq[0]:F2} b={eq[1]:F2} c={Math.Abs(eq[2]):F2}\t" +
                                          $"depth={-eq[3]:F2}m roi(x,y) = {roi.X:000},{roi.Y:000}\t" +
                                          $"Min={minDepth:F1}m Max={maxDepth:F1}m";
                        }
                    }
                }
            }
            flow.Run(empty);
        }
    }




    public class Delaunay_Basics_CS : VB_Parent
    {
        public List<cv.Point2f> inputPoints;
        public List<List<cv.Point>> facetList = new List<List<cv.Point>>();
        public Mat facet32s;
        Random_Enumerable randEnum = new Random_Enumerable();
        Subdiv2D subdiv = new Subdiv2D();

        public Delaunay_Basics_CS()
        {
            facet32s = new Mat(dst2.Size(), MatType.CV_32SC1, cv.Scalar.All(0));
            labels[3] = "CV_8U map of Delaunay cells";
            desc = "Subdivide an image based on the points provided.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat && standalone)
            {
                randEnum.Run(null);
                inputPoints = randEnum.points.ToList();
            }

            subdiv.InitDelaunay(new cv.Rect(0, 0, dst2.Width, dst2.Height));
            subdiv.Insert(inputPoints.ToArray());

            cv.Point2f[][] facets = null;
            var facetIndices = new List<int>();
            var facetCenters = new Point2f[1];
            subdiv.GetVoronoiFacetList(facetIndices, out facets, out facetCenters);

            facetList.Clear();
            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var ptList = new List<cv.Point>();
                for (int j = 0; j < facets[i].Length - 1; j++)
                {
                    ptList.Add(new cv.Point(facets[i][j].X, facets[i][j].Y));
                }

                facet32s.FillConvexPoly(ptList.ToArray(), cv.Scalar.All(i), vbc.task.lineType);
                facetList.Add(ptList);
            }
            facet32s.ConvertTo(dst3, MatType.CV_8U);
            dst2 = ShowPalette(dst3);
            labels[2] = traceName + ": " + inputPoints.Count.ToString("000") + " cells were present.";
        }
    }





    public class Delaunay_SubDiv_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();

        public Delaunay_SubDiv_CS()
        {
            FindSlider("Random Pixel Count").Value = 100;
            desc = "Use Delaunay to subdivide an image into triangles.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (!vbc.task.heartBeat) return;
            }

            var subdiv = new Subdiv2D(new cv.Rect(0, 0, dst2.Width, dst2.Height));
            random.Run(null);
            dst2.SetTo(new Scalar(0));

            foreach (var pt in random.PointList)
            {
                subdiv.Insert(pt);
                var edgeList = subdiv.GetEdgeList();
                foreach (var e in edgeList)
                {
                    var p0 = new cv.Point(Math.Round(e[0]), Math.Round(e[1]));
                    var p1 = new cv.Point(Math.Round(e[2]), Math.Round(e[3]));
                    DrawLine(dst2, p0, p1, new Scalar(255), vbc.task.lineWidth);
                }
            }

            foreach (var pt in random.PointList)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize + 1, new Scalar(255, 0, 0), -1);
            }

            cv.Point2f[][] facets = null;
            var centers = new Point2f[1];
            subdiv.GetVoronoiFacetList(null, out facets, out centers);

            var ifacet = new cv.Point[1];
            var ifacets = new cv.Point[1][];

            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                Array.Resize(ref ifacet, facets[i].Length - 1);
                for (int j = 0; j < facets[i].Length - 1; j++)
                {
                    ifacet[j] = new cv.Point(Math.Round(facets[i][j].X), Math.Round(facets[i][j].Y));
                }
                ifacets[0] = ifacet;
                dst3.FillConvexPoly(ifacet, vbc.task.scalarColors[i % vbc.task.scalarColors.Length], vbc.task.lineType);
                Cv2.Polylines(dst3, ifacets, true, new Scalar(0, 0, 0), vbc.task.lineWidth, LineTypes.AntiAlias, 0);
            }
        }
    }





    public class Delaunay_Subdiv2D_CS : VB_Parent
    {
        public Delaunay_Subdiv2D_CS()
        {
            labels[3] = "Voronoi facets for the same subdiv2D";
            desc = "Generate random points and divide the image around those points.";
        }

        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            dst2.SetTo(new Scalar(0));
            var points = Enumerable.Range(0, 100)
                .Select(i => new Point2f(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height)))
                .ToArray();

            foreach (var p in points)
            {
                DrawCircle(dst2, p, vbc.task.DotSize + 1, cv.Scalar.All(255), -1);
            }
            dst3 = dst2.Clone();

            var subdiv = new Subdiv2D(new cv.Rect(0, 0, dst3.Width, dst3.Height));
            subdiv.Insert(points);

            cv.Point2f[][] facets = null;
            var facetCenters = new Point2f[1];
            subdiv.GetVoronoiFacetList(null, out facets, out facetCenters);

            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var before = facets[i][facets[i].Length - 1];
                foreach (var p in facets[i])
                {
                    DrawLine(dst2, before, p, new Scalar(0, 255, 0), 1);
                    before = p;
                }
            }

            var edgelist = subdiv.GetEdgeList();
            foreach (var edge in edgelist)
            {
                var p1 = new Point2f(edge[0], edge[1]);
                var p2 = new Point2f(edge[2], edge[3]);
                DrawLine(dst2, p1, p2, new Scalar(0, 255, 0), 1);
            }
        }
    }





    public class Delaunay_GenerationsNoKNN_CS : VB_Parent
    {
        public List<cv.Point2f> inputPoints;
        public Delaunay_Basics facet = new Delaunay_Basics();
        Random_Basics random = new Random_Basics();

        public Delaunay_GenerationsNoKNN_CS()
        {
            FindSlider("Random Pixel Count").Value = 10;
            dst3 = new Mat(dst3.Size(), MatType.CV_32S, cv.Scalar.All(0));
            labels = new string[] { "", "Mask of unmatched regions - generation set to 0", "Facet Image with index of each region", "Generation counts for each region." };
            desc = "Create a region in an image for each cv.Point provided without using KNN.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest() && vbc.task.heartBeat)
            {
                random.Run(null);
                inputPoints = random.PointList.ToList();
            }

            facet.inputPoints = inputPoints;
            facet.Run(src);
            dst2 = facet.dst2;

            var generationMap = dst3.Clone();
            dst3.SetTo(new Scalar(0));
            var usedG = new List<int>();
            var g = 0;
            foreach (var pt in inputPoints)
            {
                var index = facet.facet32s.Get<int>((int)pt.Y, (int)pt.X);
                if (index >= facet.facetList.Count) continue;
                var nextFacet = facet.facetList[index];
                // insure that each facet has a unique generation number
                if (vbc.task.FirstPass)
                {
                    g = usedG.Count;
                }
                else
                {
                    g = generationMap.Get<int>((int)pt.Y, (int)pt.X) + 1;
                    while (usedG.Contains(g))
                    {
                        g++;
                    }
                }
                dst3.FillConvexPoly(nextFacet.ToArray(), cv.Scalar.All(g), vbc.task.lineType);
                usedG.Add(g);
                SetTrueText(g.ToString(), new cv.Point((int)pt.X, (int)pt.Y), 2);
            }
            generationMap = dst3.Clone();
        }
    }





    public class Delaunay_Generations_CS : VB_Parent
    {
        public List<cv.Point2f> inputPoints;
        public Delaunay_Basics facet = new Delaunay_Basics();
        KNN_NoDups knn = new KNN_NoDups();
        Random_Basics random = new Random_Basics();

        public Delaunay_Generations_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32S, cv.Scalar.All(0));
            labels = new string[] { "", "Mask of unmatched regions - generation set to 0", "Facet Image with count for each region", "Generation counts in CV_32SC1 format" };
            FindSlider("Random Pixel Count").Value = 10;
            desc = "Create a region in an image for each cv.Point provided";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    random.Run(null);
                }
                inputPoints = random.PointList.ToList();
            }

            knn.queries = inputPoints;
            knn.Run(null);

            facet.inputPoints = inputPoints;
            facet.Run(src);
            dst2 = facet.dst2;

            var generationMap = dst0.Clone();
            dst0.SetTo(new Scalar(0));
            var usedG = new List<int>();
            var g = 0;
            foreach (var mp in knn.matches)
            {
                var index = facet.facet32s.Get<int>((int)mp.p2.Y, (int)mp.p2.X);
                if (index >= facet.facetList.Count) continue;
                var nextFacet = facet.facetList[index];
                // insure that each facet has a unique generation number
                if (vbc.task.FirstPass)
                {
                    g = usedG.Count;
                }
                else
                {
                    g = generationMap.Get<int>((int)mp.p2.Y, (int)mp.p2.X) + 1;
                    while (usedG.Contains(g))
                    {
                        g++;
                    }
                }
                dst0.FillConvexPoly(nextFacet.ToArray(), cv.Scalar.All(g), vbc.task.lineType);
                usedG.Add(g);
                SetTrueText(g.ToString(), new cv.Point(mp.p2.X, mp.p2.Y), 2);
            }
        }
    }





    public class Delaunay_ConsistentColor_CS : VB_Parent
    {
        public List<cv.Point2f> inputPoints;
        public List<List<cv.Point>> facetList = new List<List<cv.Point>>();
        public Mat facet32s;
        Random_Enumerable randEnum = new Random_Enumerable();
        Subdiv2D subdiv = new Subdiv2D();

        public Delaunay_ConsistentColor_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            facet32s = new Mat(dst2.Size(), MatType.CV_32SC1, cv.Scalar.All(0));
            UpdateAdvice(traceName + ": use local options to control the number of points");
            labels[1] = "Input points to subdiv";
            labels[3] = "Inconsistent colors in dst2 are duplicate randomCellColor output.";
            desc = "Subdivide an image based on the points provided.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat && standalone)
            {
                randEnum.Run(null);
                inputPoints = randEnum.points.ToList();
            }

            subdiv.InitDelaunay(new cv.Rect(0, 0, dst2.Width, dst2.Height));
            subdiv.Insert(inputPoints.ToArray());

            cv.Point2f[][] facets = null;
            var facetCenters = new Point2f[1];
            subdiv.GetVoronoiFacetList(new List<int>(), out facets, out facetCenters);

            var usedColors = new List<Vec3b>();
            usedColors.Add(new Vec3b(0, 0, 0));
            facetList.Clear();
            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var nextFacet = new List<cv.Point>();
                for (int j = 0; j < facets[i].Length - 1; j++)
                {
                    nextFacet.Add(new cv.Point(facets[i][j].X, facets[i][j].Y));
                }

                var pt = inputPoints[i];
                var nextColor = dst3.Get<Vec3b>((int)pt.Y, (int)pt.X);
                if (usedColors.Contains(nextColor))
                {
                    nextColor = randomCellColor();
                }
                usedColors.Add(nextColor);

                dst2.FillConvexPoly(nextFacet.ToArray(), vecToScalar(nextColor));
                facet32s.FillConvexPoly(nextFacet.ToArray(), cv.Scalar.All(i), vbc.task.lineType);
                facetList.Add(nextFacet);
            }
            dst3 = dst2.Clone();
            dst1.SetTo(0);
            foreach (var pt in inputPoints)
            {
                dst1.Circle(new cv.Point((int)pt.X, (int)pt.Y), vbc.task.DotSize, vbc.task.HighlightColor, -1, vbc.task.lineType);
            }
            dst1 = dst3.Clone();
            labels[2] = traceName + ": " + inputPoints.Count.ToString("000") + " cells were present.";
        }
    }





    public class Delaunay_Contours_CS : VB_Parent
    {
        public List<cv.Point2f> inputPoints;
        Random_Enumerable randEnum = new Random_Enumerable();
        Subdiv2D subdiv = new Subdiv2D();

        public Delaunay_Contours_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[3] = "CV_8U map of Delaunay cells";
            desc = "Subdivide an image based on the points provided.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat && standalone)
            {
                randEnum.Run(null);
                inputPoints = randEnum.points.ToList();
            }

            subdiv.InitDelaunay(new cv.Rect(0, 0, dst2.Width, dst2.Height));
            subdiv.Insert(inputPoints.ToArray());

            cv.Point2f[][] facets = null;
            cv.Point2f[] facetCenters = null;
            subdiv.GetVoronoiFacetList(new List<int>(), out facets, out facetCenters);
            dst2.SetTo(0);
            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var ptList = new List<cv.Point>();
                for (int j = 0; j < facets[i].Length; j++)
                {
                    ptList.Add(new cv.Point(facets[i][j].X, facets[i][j].Y));
                }

                DrawContour(dst2, ptList, cv.Scalar.All(255), 1);
            }
            labels[2] = traceName + ": " + inputPoints.Count.ToString("000") + " cells were present.";
        }
    }






    public class Denoise_Basics_CPP_CS : VB_Parent
    {
        Diff_Basics diff = new Diff_Basics();

        public Denoise_Basics_CPP_CS()
        {
            cPtr = Denoise_Basics_Open(3);
            labels = new string[] { "", "", "Input image", "Output: Use PixelViewer to see changes" };
            desc = "Denoise example.";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY) - cv.Scalar.All(1);

            byte[] dataSrc = new byte[src.Total()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Denoise_Basics_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();

            if (imagePtr != IntPtr.Zero)
            {
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();
                diff.Run(dst2);
                dst3 = diff.dst2;
            }
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Denoise_Basics_Close(cPtr);
        }
    }





    public class Denoise_Pixels_CPP_CS : VB_Parent
    {
        public int classCount;
        Options_Denoise options = new Options_Denoise();
        Reduction_Basics reduction = new Reduction_Basics();

        public Denoise_Pixels_CPP_CS()
        {
            cPtr = Denoise_Pixels_Open();
            labels = new string[] { "", "", "Before removing single pixels", "After removing single pixels" };
            desc = "Remove single pixels between identical pixels";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest())
            {
                reduction.Run(src);
                src = reduction.dst2;
                classCount = reduction.classCount;
            }

            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (options.removeSinglePixels)
            {
                byte[] cppData = new byte[src.Total()];
                Marshal.Copy(src.Data, cppData, 0, cppData.Length);
                GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
                IntPtr imagePtr = Denoise_Pixels_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
                handleSrc.Free();
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();
            }
            else
            {
                dst2 = src;
            }

            if (standaloneTest())
            {
                dst2 *= 255.0 / classCount;
                dst3 = ShowPalette(dst2);
            }

            if (vbc.task.heartBeat)
            {
                strOut = $"{classCount} pixel classes\n";
                strOut += $"{Denoise_Pixels_EdgeCountBefore(cPtr)} edges before\n";
                strOut += $"{Denoise_Pixels_EdgeCountAfter(cPtr)} edges after";
            }

            SetTrueText(strOut, 2);
        }

        public void Close()
        {
            Denoise_Pixels_Close(cPtr);
        }
    }







    public class Depth_Basics_CS : VB_Parent
    {
        Depth_Colorizer_CPP_VB colorizer = new Depth_Colorizer_CPP_VB();

        public Depth_Basics_CS()
        {
            UpdateAdvice(traceName + ": use global option to control 'Max Depth'.");
            desc = "Colorize the depth data into vbc.task.depthRGB";
        }

        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.pcSplit[2];

            vbc.task.pcSplit[2] = vbc.task.pcSplit[2].Threshold(vbc.task.MaxZmeters, vbc.task.MaxZmeters, ThresholdTypes.Trunc);
            if (vbc.task.FirstPass)
            {
                vbc.task.maxDepthMask = vbc.task.pcSplit[2].ConvertScaleAbs().InRange(vbc.task.MaxZmeters, vbc.task.MaxZmeters);
                vbc.task.maxDepthMask.SetTo(0);
            }
            if (standalone) dst3 = vbc.task.maxDepthMask;
            SetTrueText(vbc.task.gMat.strOut, 3);

            colorizer.Run(vbc.task.pcSplit[2]);
            vbc.task.depthRGB = colorizer.dst2;
        }
    }





    public class Depth_MinMaxToVoronoi_CS : VB_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        public Depth_MinMaxToVoronoi_CS()
        {
            kalman.kInput = new float[vbc.task.gridRects.Count() * 4];
            labels = new string[] { "", "", "Red is min distance, blue is max distance", "Voronoi representation of min and max points for each cell." };
            desc = "Find min and max depth in each roi and create a voronoi representation using the min and max points.";
        }
        Point2f ValidatePoint2f(Point2f p)
        {
            if (p.X < 0) p.X = 0;
            if (p.Y < 0) p.Y = 0;
            if (p.X >= dst2.Width) p.X = dst2.Width - 1;
            if (p.Y >= dst2.Height) p.Y = dst2.Height - 1;
            return p;
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) kalman.kInput = new float[vbc.task.gridRects.Count() * 4];
            dst2 = src.Clone();
            dst2.SetTo(Scalar.White, vbc.task.gridMask);
            Mat depthmask = vbc.task.depthMask;
            Parallel.For(0, vbc.task.gridRects.Count(), i =>
            {
                var roi = vbc.task.gridRects[i];
                mmData mm = GetMinMax(vbc.task.pcSplit[2][roi], depthmask[roi]);
                if (mm.minLoc.X < 0 || mm.minLoc.Y < 0) mm.minLoc = new cv.Point(0, 0);
                kalman.kInput[i * 4] = mm.minLoc.X;
                kalman.kInput[i * 4 + 1] = mm.minLoc.Y;
                kalman.kInput[i * 4 + 2] = mm.maxLoc.X;
                kalman.kInput[i * 4 + 3] = mm.maxLoc.Y;
            });
            kalman.Run(src);
            Subdiv2D subdiv = new Subdiv2D(new cv.Rect(0, 0, src.Width, src.Height));
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                Point2f ptmin = new Point2f(kalman.kOutput[i * 4] + roi.X, kalman.kOutput[i * 4 + 1] + roi.Y);
                Point2f ptmax = new Point2f(kalman.kOutput[i * 4 + 2] + roi.X, kalman.kOutput[i * 4 + 3] + roi.Y);
                ptmin = ValidatePoint2f(ptmin);
                ptmax = ValidatePoint2f(ptmax);
                subdiv.Insert(ptmin);
                DrawCircle(dst2, ptmin, vbc.task.DotSize, Scalar.Red);
                DrawCircle(dst2, ptmax, vbc.task.DotSize, Scalar.Blue);
            }
            cv.Point2f[][] facets = new Point2f[1][];
            cv.Point2f[] centers;
            subdiv.GetVoronoiFacetList(new List<int>(), out facets, out centers);
            cv.Point[] ifacet;
            cv.Point[][] ifacets = new cv.Point[1][];
            for (int i = 0; i < facets.Length; i++)
            {
                ifacet = new cv.Point[facets[i].Length];
                for (int j = 0; j < facets[i].Length; j++)
                {
                    ifacet[j] = new cv.Point((int)Math.Round(facets[i][j].X), (int)Math.Round(facets[i][j].Y));
                }
                ifacets[0] = ifacet;
                dst3.FillConvexPoly(ifacet, vbc.task.scalarColors[i % vbc.task.scalarColors.Length], vbc.task.lineType);
                Cv2.Polylines(dst3, ifacets, true, Scalar.Black, vbc.task.lineWidth, vbc.task.lineType, 0);
            }
        }
    }
    public class Depth_ColorMap_CS : VB_Parent
    {
        Options_DepthColor options = new Options_DepthColor();
        public Depth_ColorMap_CS()
        {
            desc = "Display the depth as a color map";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Cv2.ConvertScaleAbs(vbc.task.pcSplit[2] * 1000, dst1, options.alpha, options.beta);
            dst1 += cv.Scalar.All(1);
            dst2 = ShowPalette(dst1);
            dst2.SetTo(0, vbc.task.noDepthMask);
            dst3 = vbc.task.palette.dst3;
        }
    }
    public class Depth_NotMissing_CS : VB_Parent
    {
        public BGSubtract_Basics bgSub = new BGSubtract_Basics();
        public Depth_NotMissing_CS()
        {
            labels[3] = "Stable (non-zero) Depth";
            desc = "Collect X frames, compute stable depth using the BGR and Depth image.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest()) src = vbc.task.depthRGB;
            bgSub.Run(src);
            dst2 = bgSub.dst2;
            dst3 = ~bgSub.dst2;
            labels[2] = "Unstable Depth using " + bgSub.options.methodDesc + " method";
            dst3.SetTo(0, vbc.task.noDepthMask);
        }
    }






    public class Depth_Display_CS : VB_Parent
    {
        public Depth_Display_CS()
        {
            vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setDisplay1();
            labels = new string[] { "vbc.task.pcSplit[2]", "vbc.task.pointcloud", "vbc.task.depthMask", "vbc.task.noDepthMask" };
            desc = "Display the vbc.task.pcSplit[2], vbc.task.pointcloud, vbc.task.depthMask, and vbc.task.noDepthMask";
        }

        public void RunAlg(Mat src)
        {
            dst0 = vbc.task.pcSplit[2];
            dst1 = vbc.task.pointCloud;
            dst2 = vbc.task.depthMask;
            dst3 = vbc.task.noDepthMask;
        }
    }




    public class Density_Basics_CS : VB_Parent
    {
        Options_Density options = new Options_Density();
        public Density_Basics_CS()
        {
            cPtr = Density_2D_Open();
            UpdateAdvice(traceName + ": use local options to control separation of points in 3D.");
            desc = "Isolate points in 3D using the distance to the 8 neighboring points in the pointcloud";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Density_2D_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.distance);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
        }
        public void Close()
        {
            Density_2D_Close(cPtr);
        }
    }
    public class Density_Phase_CS : VB_Parent
    {
        Density_Basics dense = new Density_Basics();
        Gradient_Depth gradient = new Gradient_Depth();
        public Density_Phase_CS()
        {
            desc = "Display gradient phase and 2D density side by side.";
        }
        public void RunAlg(Mat src)
        {
            gradient.Run(empty);
            dst3 = Convert32f_To_8UC3(gradient.dst3);
            dense.Run(src);
            dst2 = dense.dst2;
        }
    }
    public class Density_Count_CPP_CS : VB_Parent
    {
        Options_Density options = new Options_Density();
        public Density_Count_CPP_CS()
        {
            cPtr = Density_Count_Open();
            desc = "Isolate points in 3D by counting 8 neighboring Z points in the pointcloud";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Density_Count_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.zCount);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
        }
        public void Close()
        {
            Density_Count_Close(cPtr);
        }
    }
    public class Density_Mask_CS : VB_Parent
    {
        public List<cv.Point> pointList = new List<cv.Point>();
        public Density_Mask_CS()
        {
            desc = "Measure a mask's size in any image and track the biggest regions.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            src.SetTo(0, vbc.task.noDepthMask);
            var threshold = vbc.task.gridSize * vbc.task.gridSize / 2;
            bool[] activeList = new bool[vbc.task.gridRects.Count()];
            dst3.SetTo(0);
            Parallel.For(0, vbc.task.gridRects.Count(), i =>
            {
                var roi = vbc.task.gridRects[i];
                var count = src[roi].CountNonZero();
                if (count > threshold)
                {
                    dst3[roi].SetTo(Scalar.White);
                    activeList[i] = true;
                }
            });
            pointList.Clear();
            for (int i = 0; i < activeList.Length; i++)
            {
                if (activeList[i])
                {
                    var roi = vbc.task.gridRects[i];
                    pointList.Add(new cv.Point(roi.X + roi.Width / 2, roi.Y + roi.Height / 2));
                }
            }
        }
    }






    public class Depth_FirstLastDistance_CS : VB_Parent
    {
        public Depth_FirstLastDistance_CS()
        {
            desc = "Monitor the first and last depth distances";
        }

        void identifyMinMax(cv.Point pt, string text)
        {
            Cv2.Circle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            SetTrueText(text, pt, 2);

            Cv2.Circle(dst3, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            SetTrueText(text, pt, 3);
        }

        public void RunAlg(Mat src)
        {
            var mm = GetMinMax(vbc.task.pcSplit[2], vbc.task.depthMask);
            vbc.task.depthRGB.CopyTo(dst2);

            if (vbc.task.heartBeat) dst3.SetTo(0);
            labels[2] = $"Min Depth {mm.minVal:F1}m";
            identifyMinMax(mm.minLoc, labels[2]);

            labels[3] = $"Max Depth {mm.maxVal:F1}m";
            identifyMinMax(mm.maxLoc, labels[3]);
        }
    }





    public class Depth_HolesRect_CS : VB_Parent
    {
        Depth_Holes shadow = new Depth_Holes();

        public Depth_HolesRect_CS()
        {
            labels[2] = "The 10 largest contours in the depth holes.";
            desc = "Identify the minimum rectangles of contours of the depth shadow";
        }

        public void RunAlg(Mat src)
        {
            shadow.Run(src);

            cv.Point[][] contours;
            if (shadow.dst3.Channels() == 3)
                shadow.dst3 = shadow.dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            Cv2.FindContours(shadow.dst3, out contours, out _, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);

            var sortContours = new SortedList<int, List<cv.Point>>(new compareAllowIdenticalIntegerInverted());
            foreach (var c in contours)
            {
                sortContours.Add(c.Length, c.ToList());
            }
            dst3.SetTo(0);
            for (int i = 0; i < Math.Min(sortContours.Count, 10); i++)
            {
                var contour = sortContours.ElementAt(i).Value;
                var minRect = Cv2.MinAreaRect(contour);
                var nextColor = new Scalar(vbc.task.vecColors[i % 256][0], vbc.task.vecColors[i % 256][1], vbc.task.vecColors[i % 256][2]);
                DrawRotatedRect(minRect, dst2, nextColor);
                Cv2.DrawContours(dst3, new[] { contour }, 0, Scalar.White, vbc.task.lineWidth);
            }
            Cv2.AddWeighted(dst2, 0.5, vbc.task.depthRGB, 0.5, 0, dst2);
        }
    }





    public class Depth_MeanStdev_MT_CS : VB_Parent
    {
        Mat meanSeries;
        float maxMeanVal, maxStdevVal;

        public Depth_MeanStdev_MT_CS()
        {
            dst2 = new cv.Mat(dst2.Rows, dst2.Cols, MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new cv.Mat(dst3.Rows, dst3.Cols, MatType.CV_8U, cv.Scalar.All(0));
            desc = "Collect a time series of depth mean and stdev to highlight where depth is unstable.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
                meanSeries = new cv.Mat(vbc.task.gridRects.Count, vbc.task.frameHistoryCount, MatType.CV_32F, cv.Scalar.All(0));

            int index = vbc.task.frameCount % vbc.task.frameHistoryCount;
            float[] meanValues = new float[vbc.task.gridRects.Count];
            float[] stdValues = new float[vbc.task.gridRects.Count];

            Parallel.For(0, vbc.task.gridRects.Count, i =>
            {
                var roi = vbc.task.gridRects[i];
                Cv2.MeanStdDev(vbc.task.pcSplit[2][roi], out Scalar mean, out Scalar stdev, vbc.task.depthMask[roi]);
                meanSeries.Set(i, index, (float)mean.Val0);
                if (vbc.task.frameCount >= vbc.task.frameHistoryCount - 1)
                {
                    Cv2.MeanStdDev(meanSeries.Row(i), out mean, out stdev);
                    meanValues[i] = (float)mean.Val0;
                    stdValues[i] = (float)stdev.Val0;
                }
            });

            if (vbc.task.frameCount >= vbc.task.frameHistoryCount)
            {
                var means = cv.Mat.FromPixelData(vbc.task.gridRects.Count, 1, MatType.CV_32F, meanValues);
                var stdevs = cv.Mat.FromPixelData(vbc.task.gridRects.Count, 1, MatType.CV_32F, stdValues);
                var meanmask = means.Threshold(1, vbc.task.MaxZmeters, ThresholdTypes.Binary).ConvertScaleAbs();
                var mm = GetMinMax(means, meanmask);
                var stdMask = stdevs.Threshold(0.001, vbc.task.MaxZmeters, ThresholdTypes.Binary).ConvertScaleAbs();
                var mmStd = GetMinMax(stdevs, stdMask);

                maxMeanVal = Math.Max(maxMeanVal, (float)mm.maxVal);
                maxStdevVal = Math.Max(maxStdevVal, (float)mmStd.maxVal);

                Parallel.For(0, vbc.task.gridRects.Count, i =>
                {
                    var roi = vbc.task.gridRects[i];
                    dst3[roi].SetTo(255 * stdevs.Get<float>(i, 0) / maxStdevVal);
                    dst3[roi].SetTo(0, vbc.task.noDepthMask[roi]);

                    dst2[roi].SetTo(255 * means.Get<float>(i, 0) / maxMeanVal);
                    dst2[roi].SetTo(0, vbc.task.noDepthMask[roi]);
                });

                if (vbc.task.heartBeat)
                {
                    maxMeanVal = 0;
                    maxStdevVal = 0;
                }

                if (standaloneTest())
                {
                    for (int i = 0; i < vbc.task.gridRects.Count; i++)
                    {
                        var roi = vbc.task.gridRects[i];
                        SetTrueText($"{meanValues[i]:F3}\n{stdValues[i]:F3}", new cv.Point(roi.X, roi.Y), 3);
                    }
                }

                dst3 = dst3 | vbc.task.gridMask;
                labels[2] = $"The regions where the depth is volatile are brighter.  Stdev min {mmStd.minVal:F3} Stdev Max {mmStd.maxVal:F3}";
                labels[3] = $"Mean/stdev for each ROI: Min {mm.minVal:F3} Max {mm.maxVal:F3}";
            }
        }
    }







    public class Depth_MeanStdevPlot_CS : VB_Parent
    {
        Plot_OverTimeSingle plot1 = new Plot_OverTimeSingle();
        Plot_OverTimeSingle plot2 = new Plot_OverTimeSingle();

        public Depth_MeanStdevPlot_CS()
        {
            desc = "Plot the mean and stdev of the depth image";
        }

        public void RunAlg(Mat src)
        {
            Scalar mean, stdev;
            Mat depthMask = vbc.task.depthMask;
            Cv2.MeanStdDev(vbc.task.pcSplit[2], out mean, out stdev, depthMask);

            plot1.plotData = (float)mean[0];
            plot1.Run(src);
            dst2 = plot1.dst2;

            plot2.plotData = (float)stdev[0];
            plot2.Run(src);
            dst3 = plot2.dst2;

            labels[2] = $"Plot of mean depth = {mean[0].ToString(vbc.fmt1)} min = {plot1.min.ToString(vbc.fmt2)} max = {plot1.max.ToString(vbc.fmt2)}";
            labels[3] = $"Plot of depth stdev = {stdev[0].ToString(vbc.fmt1)} min = {plot2.min.ToString(vbc.fmt2)} max = {plot2.max.ToString(vbc.fmt2)}";
        }
    }





    public class Depth_Uncertainty_CS : VB_Parent
    {
        Retina_Basics_CPP_VB retina = new Retina_Basics_CPP_VB();
        Options_Uncertainty options = new Options_Uncertainty();

        public Depth_Uncertainty_CS()
        {
            labels[3] = "Mask of areas with stable depth";
            desc = "Use the bio-inspired retina algorithm to determine depth uncertainty.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            retina.Run(vbc.task.depthRGB);
            dst2 = retina.dst2;
            Cv2.Threshold(retina.dst3, dst3, options.uncertaintyThreshold, 255, ThresholdTypes.Binary);
        }
    }





    public class Depth_Palette_CS : VB_Parent
    {
        Mat customColorMap = new Mat();
        Gradient_Color gColor = new Gradient_Color();

        public Depth_Palette_CS()
        {
            desc = "Use a palette to display depth from the raw depth data.";
        }

        public void RunAlg(Mat src)
        {
            gColor.gradientWidth = 255;
            gColor.Run(empty);
            customColorMap = gColor.gradient;

            double mult = 255 / vbc.task.MaxZmeters;
            Mat depthNorm = (vbc.task.pcSplit[2] * mult).ToMat();
            depthNorm.ConvertTo(depthNorm, MatType.CV_8U);
            Mat ColorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, customColorMap.Data);
            Cv2.ApplyColorMap(src, dst2, ColorMap);
        }
    }





    public class Depth_Colorizer_CPP_CS : VB_Parent
    {
        public Depth_Colorizer_CPP_CS()
        {
            cPtr = Depth_Colorizer_Open();
            desc = "Display depth data with InRange. Higher contrast than others - yellow to blue always present.";
        }

        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F)
                src = vbc.task.pcSplit[2];

            byte[] depthData = new byte[src.Total() * src.ElemSize()];
            GCHandle handleSrc = GCHandle.Alloc(depthData, GCHandleType.Pinned);
            Marshal.Copy(src.Data, depthData, 0, depthData.Length);
            IntPtr imagePtr = Depth_Colorizer_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, vbc.task.MaxZmeters);
            handleSrc.Free();

            if (imagePtr != IntPtr.Zero)
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr);
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Depth_Colorizer_Close(cPtr);
        }
    }





    public class Depth_LocalMinMax_MT_CS : VB_Parent
    {
        public Point2f[] minPoint = new Point2f[1];
        public Point2f[] maxPoint = new Point2f[1];

        public Depth_LocalMinMax_MT_CS()
        {
            labels = new string[] { "", "", "Highlight (usually yellow) is min distance, red is max distance",
                                "Highlight is min, red is max. Lines would indicate planes are present." };
            desc = "Find min and max depth in each segment.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                src.CopyTo(dst2);
                dst2.SetTo(Scalar.White, vbc.task.gridMask);
            }

            if (minPoint.Length != vbc.task.gridRects.Count)
            {
                Array.Resize(ref minPoint, vbc.task.gridRects.Count);
                Array.Resize(ref maxPoint, vbc.task.gridRects.Count);
            }

            if (vbc.task.heartBeat)
                dst3.SetTo(0);

            Parallel.For(0, vbc.task.gridRects.Count, i =>
            {
                cv.Rect roi = vbc.task.gridRects[i];
                mmData mm = GetMinMax(vbc.task.pcSplit[2][roi], vbc.task.depthMask[roi]);
                if (mm.minLoc.X < 0 || mm.minLoc.Y < 0)
                    mm.minLoc = new cv.Point(0, 0);
                minPoint[i] = new cv.Point(mm.minLoc.X + roi.X, mm.minLoc.Y + roi.Y);
                maxPoint[i] = new cv.Point(mm.maxLoc.X + roi.X, mm.maxLoc.Y + roi.Y);

                Cv2.Circle(dst2[roi], mm.minLoc, vbc.task.DotSize, vbc.task.HighlightColor);
                Cv2.Circle(dst2[roi], mm.maxLoc, vbc.task.DotSize, Scalar.Red);

                cv.Point p1 = new cv.Point(mm.minLoc.X + roi.X, mm.minLoc.Y + roi.Y);
                cv.Point p2 = new cv.Point(mm.maxLoc.X + roi.X, mm.maxLoc.Y + roi.Y);
                Cv2.Circle(dst3, p1, vbc.task.DotSize, vbc.task.HighlightColor);
                Cv2.Circle(dst3, p2, vbc.task.DotSize, Scalar.Red);
            });
        }
    }







    public class Depth_Median_CS : VB_Parent
    {
        Math_Median_CDF median;
        public Depth_Median_CS()
        {
            median = new Math_Median_CDF();
            median.rangeMax = (int)vbc.task.MaxZmeters;
            median.rangeMin = 0;
            desc = "Divide the depth image ahead and behind the median.";
        }
        public void RunAlg(Mat src)
        {
            median.Run(vbc.task.pcSplit[2]);

            Mat mask = vbc.task.pcSplit[2].LessThan(median.medianVal);
            vbc.task.pcSplit[2].CopyTo(dst2, mask);

            dst2.SetTo(0, vbc.task.noDepthMask);

            labels[2] = "Median Depth < " + median.medianVal.ToString("F1");

            dst3.SetTo(0);
            vbc.task.depthRGB.CopyTo(dst3, ~mask);
            dst3.SetTo(0, vbc.task.noDepthMask);
            labels[3] = "Median Depth > " + median.medianVal.ToString("F1");
        }
    }





    public class Depth_SmoothingMat_CS : VB_Parent
    {
        Options_Depth options = new Options_Depth();
        Mat lastDepth;
        public Depth_SmoothingMat_CS()
        {
            labels[3] = "Depth pixels after smoothing";
            desc = "Use depth rate of change to smooth the depth values in close range";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            cv.Rect rect = vbc.task.drawRect.Width != 0 ? vbc.task.drawRect : new cv.Rect(0, 0, src.Width, src.Height);

            if (vbc.task.FirstPass) lastDepth = vbc.task.pcSplit[2].Clone();
            Cv2.Subtract(lastDepth, vbc.task.pcSplit[2], dst2);

            dst2 = dst2.Threshold(options.mmThreshold, 0, ThresholdTypes.TozeroInv).Threshold(-options.mmThreshold, 0, ThresholdTypes.Tozero);
            Cv2.Add(vbc.task.pcSplit[2], dst2, dst3);
            lastDepth = vbc.task.pcSplit[2];

            labels[2] = "Smoothing Mat: range to " + vbc.task.MaxZmeters.ToString() + " meters";
        }
    }





    public class Depth_Smoothing_CS : VB_Parent
    {
        Depth_SmoothingMat smooth = new Depth_SmoothingMat();
        Reduction_Basics reduction = new Reduction_Basics();
        public Mat reducedDepth = new Mat();
        Mat_4to1 mats = new Mat_4to1();
        Depth_ColorMap colorize = new Depth_ColorMap();
        public Depth_Smoothing_CS()
        {
            vbc.task.redOptions.checkBitReduction(true);
            labels[3] = "Mask of depth that is smooth";
            desc = "This attempt to get the depth data to 'calm' down is not working well enough to be useful - needs more work";
        }
        public void RunAlg(Mat src)
        {
            smooth.Run(vbc.task.pcSplit[2]);
            Mat input = smooth.dst2.Normalize(0, 255, NormTypes.MinMax);
            input.ConvertTo(mats.mat[0], MatType.CV_8UC1);
            Mat tmp = new Mat();
            Cv2.Add(smooth.dst3, smooth.dst2, tmp);
            mats.mat[1] = tmp.Normalize(0, 255, NormTypes.MinMax).ConvertScaleAbs();

            reduction.Run(vbc.task.pcSplit[2]);
            reduction.dst2.ConvertTo(reducedDepth, MatType.CV_32F);
            colorize.Run(reducedDepth);
            dst2 = colorize.dst2;
            mats.Run(new Mat());
            dst3 = mats.dst2;
            labels[2] = smooth.labels[2];
        }
    }





    public class Depth_HolesOverTime_CS : VB_Parent
    {
        List<Mat> images = new List<Mat>();
        public Depth_HolesOverTime_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            dst1 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            labels[3] = "Latest hole mask";
            desc = "Integrate memory holes over time to identify unstable depth";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
            {
                images.Clear();
                dst0.SetTo(0);
            }

            dst3 = vbc.task.noDepthMask;
            dst1 = dst3.Threshold(0, 1, ThresholdTypes.Binary);
            images.Add(dst1);

            dst0 += dst1;
            dst2 = dst0.Threshold(0, 255, ThresholdTypes.Binary);

            labels[2] = "Depth holes integrated over the past " + images.Count.ToString() + " images";
            if (images.Count >= vbc.task.frameHistoryCount)
            {
                dst0 -= images[0];
                images.RemoveAt(0);
            }
        }
    }





    public class Depth_Holes_CS : VB_Parent
    {
        Mat element;
        Options_DepthHoles options = new Options_DepthHoles();
        public Depth_Holes_CS()
        {
            labels[3] = "Shadow Edges (use sliders to expand)";
            element = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(5, 5));
            desc = "Identify holes in the depth image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = vbc.task.pcSplit[2].Threshold(0.01, 255, ThresholdTypes.BinaryInv).ConvertScaleAbs(255);
            dst2 = dst2.Dilate(element, null, options.holeDilation);
            dst3 = dst2.Dilate(element, null, options.borderDilation);
            dst3 = dst3.Xor(dst2);
            if (standaloneTest()) vbc.task.depthRGB.CopyTo(dst3, dst3);
        }
    }





    public class Depth_Dilate_CS : VB_Parent
    {
        Dilate_Basics dilate = new Dilate_Basics();
        public Depth_Dilate_CS()
        {
            desc = "Dilate the depth data to fill holes.";
        }
        public void RunAlg(Mat src)
        {
            dilate.Run(vbc.task.pcSplit[2]);
            dst2 = dilate.dst2;
        }
    }





    public class Depth_ForegroundHead_CS : VB_Parent
    {
        Depth_ForegroundBlob fgnd = new Depth_ForegroundBlob();
        Kalman_Basics kalman = new Kalman_Basics();
        //Rect trustedRect;
        public bool trustworthy = false;
        public Depth_ForegroundHead_CS()
        {
            labels[2] = "Blue is current, red is kalman, green is trusted";
            desc = "Use Depth_ForeGround to find the foreground blob.  Then find the probable head of the person in front of the camera.";
        }
        public void RunAlg(Mat src)
        {
            fgnd.Run(src);

            //trustworthy = false;
            //if (fgnd.dst2.CountNonZero() > 0 && fgnd.maxIndex >= 0)
            //{
            //    int rectSize = 50;
            //    if (src.Width > 1000) rectSize = 250;
            //    int xx = fgnd.blobLocation[fgnd.maxIndex].X - rectSize / 2;
            //    int yy = fgnd.blobLocation[fgnd.maxIndex].Y;
            //    if (xx < 0) xx = 0;
            //    if (xx + rectSize / 2 > src.Width) xx = src.Width - rectSize;
            //    dst2 = fgnd.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);

            //    kalman.kInput = new float[] { xx, yy, rectSize, rectSize };
            //    kalman.Run(src);
            //    cv.Rect nextRect = new cv.Rect(xx, yy, rectSize, rectSize);
            //    cv.Rect kRect = new cv.Rect((int)kalman.kOutput[0], (int)kalman.kOutput[1], (int)kalman.kOutput[2], (int)kalman.kOutput[3]);
            //    dst2.Rectangle(kRect, Scalar.Red, 2);
            //    dst2.Rectangle(nextRect, Scalar.Blue, 2);
            //    if (Math.Abs(kRect.X - nextRect.X) < rectSize / 4 && Math.Abs(kRect.Y - nextRect.Y) < rectSize / 4)
            //    {
            //        trustedRect = ValidateRect(kRect);
            //        trustworthy = true;
            //        dst2.Rectangle(trustedRect, Scalar.Green, 5);
            //    }
            //}
        }
        cv.Rect ValidateRect(cv.Rect rect)
        {
            throw new NotImplementedException();
        }
    }





    public class Depth_RGBShadow_CS : VB_Parent
    {
        public Depth_RGBShadow_CS()
        {
            desc = "Merge the BGR and Depth Shadow";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            dst2.SetTo(0, vbc.task.noDepthMask);
        }
    }





    public class Depth_BGSubtract_CS : VB_Parent
    {
        BGSubtract_Basics bgSub = new BGSubtract_Basics();
        public Depth_BGSubtract_CS()
        {
            labels = new string[] { "", "", "Latest vbc.task.noDepthMask", "BGSubtract output for the vbc.task.noDepthMask" };
            desc = "Create a mask for the missing depth across multiple frame";
        }
        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.noDepthMask;

            bgSub.Run(dst2);
            dst3 = bgSub.dst2;
        }
    }





    public class Depth_Averaging_CS : VB_Parent
    {
        Math_ImageAverage avg = new Math_ImageAverage();
        Depth_Colorizer_CPP_VB colorize = new Depth_Colorizer_CPP_VB();
        public Depth_Averaging_CS()
        {
            labels[3] = "32-bit format depth data";
            desc = "Take the average depth at each pixel but eliminate any pixels that had zero depth.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            avg.Run(src);

            dst3 = avg.dst2;
            colorize.Run(dst3);
            dst2 = colorize.dst2;
        }
    }





    public class Depth_MaxMask_CS : VB_Parent
    {
        Contour_General contour = new Contour_General();
        public Depth_MaxMask_CS()
        {
            labels = new string[] { "", "", "Depth that is too far", "Contour of depth that is too far..." };
            desc = "Display the vbc.task.maxDepthMask and its contour containing depth that is greater than maxdepth (global setting)";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;

            vbc.task.maxDepthMask = vbc.task.pcSplit[2].InRange(vbc.task.MaxZmeters, vbc.task.MaxZmeters).ConvertScaleAbs();
            if (vbc.task.maxDepthMask.Width == 0) vbc.task.maxDepthMask = vbc.task.pcSplit[2].InRange(vbc.task.MaxZmeters, vbc.task.MaxZmeters).ConvertScaleAbs();
            dst2.SetTo(Scalar.White, vbc.task.maxDepthMask);
            contour.Run(vbc.task.maxDepthMask);
            dst3.SetTo(0);
            foreach (var c in contour.allContours)
            {
                List<cv.Point> hull = Cv2.ConvexHull(c.ToArray(), true).ToList();
                DrawContour(dst3, hull, Scalar.White, -1);
            }
        }
    }





    public class Depth_ForegroundOverTime_CS : VB_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        Depth_Foreground fore = new Depth_Foreground();
        Contour_Largest contours = new Contour_Largest();
        List<Mat> lastFrames = new List<Mat>();
        public Depth_ForegroundOverTime_CS()
        {
            labels = new string[] { "", "", "Foreground objects", "Edges for the Foreground Objects" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            vbc.task.frameHistoryCount = 5;
            desc = "Create a fused foreground mask over x number of frames (vbc.task.frameHistoryCount)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged) lastFrames.Clear();

            fore.Run(src);
            lastFrames.Add(fore.dst3);
            dst2.SetTo(Scalar.All(0));
            foreach (Mat m in lastFrames)
            {
                dst2 += m;
            }
            if (lastFrames.Count >= vbc.task.frameHistoryCount) lastFrames.RemoveAt(0);

            contours.Run(dst2);
            dst2.SetTo(Scalar.All(0));
            dst3.SetTo(Scalar.All(0));
            foreach (var ctr in contours.allContours)
            {
                if (ctr.Length >= options.minSizeContour)
                {
                    DrawContour(dst2, ctr.ToList(), Scalar.White, -1);
                    DrawContour(dst3, ctr.ToList(), Scalar.White, 1);
                }
            }
        }
    }








    public class Depth_ForegroundBlob_CS : VB_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        List<cv.Point> blobLocation = new List<cv.Point>();
        int maxIndex;

        public Depth_ForegroundBlob_CS()
        {
            labels[2] = "Mask for the largest foreground blob";
            desc = "Use InRange to define foreground and find the largest blob in the foreground";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Cv2.InRange(vbc.task.pcSplit[2], 0.01, options.maxForegroundDepthInMeters, dst2);
            dst3 = dst2.Clone();

            List<int> blobSize = new List<int>();
            blobLocation.Clear();

            for (int y = 0; y < dst2.Rows; y++)
            {
                for (int x = 0; x < dst2.Cols; x++)
                {
                    byte nextByte = dst2.At<byte>(y, x);
                    if (nextByte != 0)
                    {
                        int count = Cv2.FloodFill(dst2, new cv.Point(x, y), cv.Scalar.All(0), out _, new Scalar(0), new Scalar(0));
                        if (count > 10)
                        {
                            blobSize.Add(count);
                            blobLocation.Add(new cv.Point(x, y));
                        }
                    }
                }
            }

            if (blobSize.Count > 0)
            {
                int maxBlob = blobSize.Max();
                maxIndex = blobSize.IndexOf(maxBlob);
                Cv2.FloodFill(dst3, blobLocation[maxIndex], cv.Scalar.All(250), out _, new Scalar(0), new Scalar(0));
                Cv2.InRange(dst3, 250, 250, dst2);
                Cv2.BitwiseAnd(dst2, vbc.task.noDepthMask, dst2);
                labels[3] = "Mask of all depth pixels < " + options.maxForegroundDepthInMeters.ToString("0.0") + "m";
            }
        }
    }





    public class Depth_Foreground_CS : VB_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        Contour_Largest contours = new Contour_Largest();

        public Depth_Foreground_CS()
        {
            labels[2] = "Foreground objects";
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Create a mask for the objects in the foreground";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Cv2.Threshold(vbc.task.pcSplit[2], dst1, options.maxForegroundDepthInMeters, 255, cv.ThresholdTypes.BinaryInv);
            dst1 = dst1.ConvertScaleAbs();

            Cv2.BitwiseAnd(dst1, vbc.task.noDepthMask, dst1);

            contours.Run(dst1);
            dst2.SetTo(Scalar.All(0));
            dst3.SetTo(Scalar.All(0));

            foreach (var ctr in contours.allContours)
            {
                if (ctr.Length >= options.minSizeContour)
                {
                    DrawContour(dst2, ctr.ToList(), Scalar.White, -1);
                    DrawContour(dst3, ctr.ToList(), Scalar.White, -1);
                }
            }
        }
    }





    public class Depth_Grid_CS : VB_Parent
    {
        public Depth_Grid_CS()
        {
            vbc.task.gOptions.setGridSize(4);
            labels = new string[] { "", "", "White regions below are likely depth edges where depth changes rapidly", "Depth 32f display" };
            desc = "Find boundaries in depth to separate featureless regions.";
        }

        public void RunAlg(Mat src)
        {
            dst3 = vbc.task.pcSplit[2];
            dst2 = vbc.task.gridMask.Clone();

            foreach (cv.Rect roi in vbc.task.gridRects)
            {
                double minVal, maxVal;
                Cv2.MinMaxLoc(dst3[roi], out minVal, out maxVal);
                if (Math.Abs(minVal - maxVal) > 0.1)
                {
                    dst2[roi].SetTo(Scalar.White);
                }
            }
        }
    }





    public class Depth_InRange_CS : VB_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        Contour_Largest contours = new Contour_Largest();
        int classCount = 1;

        public Depth_InRange_CS()
        {
            labels = new string[] { "", "", "Looks empty! But the values are there - 0 to classcount.  Run standaloneTest() to see the palette output for this", "Edges between the depth regions." };
            if (standaloneTest()) { vbc.task.gOptions.setDisplay1(); }
            dst3 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Create the selected number of depth ranges ";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            List<Mat> regMats = new List<Mat>();
            for (int i = 0; i < options.numberOfRegions; i++)
            {
                double upperBound = (i + 1) * options.depthPerRegion;
                if (i == options.numberOfRegions - 1) { upperBound = 1000; }
                Mat tmp = new Mat();
                Cv2.InRange(vbc.task.pcSplit[2], i * options.depthPerRegion, upperBound, tmp);
                regMats.Add(tmp);
                if (i == 0) { regMats[0].SetTo(0, vbc.task.noDepthMask); }
            }

            dst2 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            dst3.SetTo(0);
            classCount = 1;
            foreach (Mat regMat in regMats)
            {
                contours.Run(regMat);
                foreach (var ctr in contours.allContours)
                {
                    if (ctr.Length >= options.minSizeContour)
                    {
                        DrawContour(dst2, ctr.ToList(), Scalar.White, -1);
                        classCount++;
                        DrawContour(dst3, ctr.ToList(), Scalar.White, -1);
                    }
                }
            }

            dst0 = src.Clone();
            dst0.SetTo(cv.Scalar.White, dst3);

            if (standaloneTest())
            {
                dst2 = ShowPalette(dst2 * 255 / classCount);
            }

            if (vbc.task.heartBeat) { labels[2] = classCount.ToString("000") + " regions were found"; }
        }
    }










    public class Depth_Regions_CS : VB_Parent
    {
        int classCount = 5;

        public Depth_Regions_CS()
        {
            desc = "Separate the scene into a specified number of regions by depth";
        }

        public void RunAlg(Mat src)
        {
            Cv2.Threshold(vbc.task.pcSplit[2], dst1, vbc.task.gOptions.maxDepth, 255, ThresholdTypes.Binary);
            dst0 = (vbc.task.pcSplit[2] / vbc.task.gOptions.maxDepth) * 255 / classCount;
            Cv2.ConvertScaleAbs(dst0, dst2);
            Cv2.BitwiseAnd(dst2, vbc.task.noDepthMask, dst2);

            if (standaloneTest()) { dst3 = ShowPalette(dst2); }
            labels[2] = classCount.ToString() + " regions defined in the depth data";
        }
    }






    public class Depth_PunchIncreasing_CS : VB_Parent
    {
        Depth_PunchDecreasing depth = new Depth_PunchDecreasing();

        public Depth_PunchIncreasing_CS()
        {
            depth.Increasing = true;
            desc = "Identify where depth is increasing - retreating from the camera.";
        }

        public void RunAlg(Mat src)
        {
            depth.Run(src);
            dst2 = depth.dst2;
        }
    }





    public class Depth_PunchDecreasing_CS : VB_Parent
    {
        public bool Increasing { get; set; }
        Depth_Foreground fore = new Depth_Foreground();
        Mat lastDepth;
        Options_Depth options = new Options_Depth();
        public Depth_PunchDecreasing_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_32F, Scalar.All(0));
            desc = "Identify where depth is decreasing - coming toward the camera.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            fore.Run(src);
            dst1.SetTo(0);
            Cv2.CopyTo(dst1, fore.dst2, vbc.task.noDepthMask);

            if (vbc.task.FirstPass) lastDepth = dst1.Clone();
            if (Increasing)
            {
                dst2 = new Mat();
                Cv2.Subtract(dst1, lastDepth, dst2);
            }
            else
            {
                dst2 = new Mat();
                Cv2.Subtract(lastDepth, dst1, dst2);
            }
            Cv2.Threshold(dst2, dst2, options.mmThreshold, 0, cv.ThresholdTypes.Tozero);
            Cv2.Threshold(dst2, dst2, 0, 255, cv.ThresholdTypes.Binary);
            lastDepth = dst1.Clone();
        }
    }





    public class Depth_PunchBlob_CS : VB_Parent
    {
        Depth_PunchDecreasing depthDec = new Depth_PunchDecreasing();
        Depth_PunchIncreasing depthInc = new Depth_PunchIncreasing();
        Contour_General contours = new Contour_General();
        int lastContoursCount;
        int punchCount;
        int showMessage;
        int showWarningInfo;

        public Depth_PunchBlob_CS()
        {
            desc = "Identify the punch with a rectangle around the largest blob";
        }

        public void RunAlg(Mat src)
        {
            depthInc.Run(src);
            dst1 = depthInc.dst2;

            double minVal, maxVal;
            Cv2.MinMaxLoc(dst1, out minVal, out maxVal);
            Cv2.ConvertScaleAbs(dst1, dst2);
            contours.Run(dst2);
            dst3 = contours.dst3;

            if (contours.contourlist.Count > 0) { showMessage = 30; }

            if (showMessage == 30 && lastContoursCount == 0) { punchCount++; }
            lastContoursCount = contours.contourlist.Count;
            labels[3] = punchCount.ToString() + " Punches Thrown";

            if (showMessage > 0)
            {
                SetTrueText("Punched!!!", new cv.Point(10, 100), 3);
                showMessage--;
            }

            if (contours.contourlist.Count > 3) { showWarningInfo = 100; }

            if (showWarningInfo > 0)
            {
                showWarningInfo--;
                SetTrueText("Too many contours!  Reduce the Max Depth.", new cv.Point(10, 130), 3);
            }
        }
    }





    public class Depth_PunchBlobNew_CS : VB_Parent
    {
        Depth_PunchDecreasing depthDec = new Depth_PunchDecreasing();
        Depth_PunchIncreasing depthInc = new Depth_PunchIncreasing();
        Contour_General contours = new Contour_General();
        Mat lastColor;
        Options_Depth options = new Options_Depth();
        public Depth_PunchBlobNew_CS()
        {
            desc = "Identify a punch using both depth and color";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.FirstPass) lastColor = vbc.task.color.Clone();
            dst2 = vbc.task.color.Clone();

            Cv2.Absdiff(dst2, lastColor, dst2);
            Cv2.Threshold(dst2, dst3, 0, options.threshold, ThresholdTypes.Binary);
            Cv2.ConvertScaleAbs(dst3, dst3);

            Cv2.Threshold(dst2, dst2, 0, 255, ThresholdTypes.Binary);

            lastColor = vbc.task.color.Clone();
        }
    }





    public class Depth_Contour_CS : VB_Parent
    {
        Contour_General contour = new Contour_General();

        public Depth_Contour_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            labels[2] = "vbc.task.depthMask contour";
            desc = "Create and display the vbc.task.depthMask output as a contour.";
        }

        public void RunAlg(Mat src)
        {
            contour.Run(vbc.task.depthMask);

            dst2.SetTo(0);
            foreach (var tour in contour.contourlist)
            {
                DrawContour(dst2, tour.ToList(), Scalar.All(255), -1);
            }
        }
    }





    public class Depth_Outline_CS : VB_Parent
    {
        Contour_General contour = new Contour_General();

        public Depth_Outline_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            labels[2] = "Contour separating depth from no depth";
            desc = "Provide a line that separates depth from no depth throughout the image.";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest()) { src = vbc.task.depthMask; }
            contour.Run(src);

            dst2.SetTo(0);
            foreach (var tour in contour.contourlist)
            {
                DrawContour(dst2, tour.ToList(), Scalar.All(255), vbc.task.lineWidth);
            }

            if (standaloneTest())
            {
                if (vbc.task.heartBeat) { dst3.SetTo(0); }
                Cv2.BitwiseOr(dst3, dst2, dst3);
            }
        }
    }





    public class Depth_StableAverage_CS : VB_Parent
    {
        Depth_Averaging dAvg = new Depth_Averaging();
        Depth_StableMinMax extrema = new Depth_StableMinMax();

        public Depth_StableAverage_CS()
        {
            FindRadio("Use farthest distance").Checked = true;
            desc = "Use Depth_StableMax to remove the artifacts from the Depth_Averaging";
        }

        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F) { src = vbc.task.pcSplit[2]; }
            extrema.Run(src);

            if (extrema.options.useNone)
            {
                dst2 = extrema.dst2;
                dst3 = extrema.dst3;
            }
            else
            {
                dAvg.Run(extrema.dst3);
                dst2 = dAvg.dst2;
                dst3 = dAvg.dst3;
            }
        }
    }





    public class Depth_MinMaxNone_CS : VB_Parent
    {
        Options_MinMaxNone options = new Options_MinMaxNone();
        int filtered;

        public Depth_MinMaxNone_CS()
        {
            desc = "To reduce z-Jitter, use the closest or farthest point as long as the camera is stable";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat[] split = src.Type() == MatType.CV_32FC3 ? src.Split() : vbc.task.pcSplit;

            if (vbc.task.heartBeat)
            {
                dst3 = split[2];
                filtered = 0;
            }
            labels[2] = "Point cloud unchanged";
            if (options.useMax)
            {
                labels[2] = "Point cloud maximum values at each pixel";
                Cv2.Max(split[2], dst3, split[2]);
            }
            if (options.useMin)
            {
                labels[2] = "Point cloud minimum values at each pixel";
                Mat saveMat = split[2].Clone();
                Cv2.Min(split[2], dst3, split[2]);
                Mat mask = new Mat();
                Cv2.InRange(split[2], 0, 0.1, mask);
                Cv2.CopyTo(saveMat, split[2], mask);
            }
            Cv2.Merge(split, dst2);
            dst3 = split[2];
            filtered++;
            labels[2] += " after " + filtered.ToString() + " images";
        }
    }





    public class Depth_StableMin_CS : VB_Parent
    {
        Mat stableMin;
        Depth_Colorizer_CPP_VB colorize = new Depth_Colorizer_CPP_VB();

        public Depth_StableMin_CS()
        {
            vbc.task.gOptions.setUnfiltered(true);
            labels = new string[] { "", "", "InRange depth with low quality depth removed.", "Motion in the BGR image. Depth updated in rectangle." };
            desc = "To reduce z-Jitter, use the closest depth value at each pixel as long as the camera is stable";
        }

        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1) { src = vbc.task.pcSplit[2]; }

            if (vbc.task.heartBeat)
            {
                stableMin = src.Clone();
                dst3.SetTo(0);
            }
            else if (vbc.task.motionDetected)
            {
                Cv2.CopyTo(stableMin[vbc.task.motionRect], src[vbc.task.motionRect]);
                if (src.Type() != stableMin.Type()) { Cv2.ConvertScaleAbs(src, stableMin); }
                Cv2.CopyTo(src[vbc.task.motionRect], stableMin[vbc.task.motionRect], vbc.task.noDepthMask);
                Cv2.Min(src, stableMin, stableMin);
            }

            colorize.Run(stableMin);
            dst2 = colorize.dst2;
        }
    }





    public class Depth_StableMax_CS : VB_Parent
    {
        Mat stableMax;
        Depth_Colorizer_CPP_VB colorize = new Depth_Colorizer_CPP_VB();

        public Depth_StableMax_CS()
        {
            vbc.task.gOptions.setUnfiltered(true);
            labels = new string[] { "", "", "InRange depth with low quality depth removed.", "Motion in the BGR image. Depth updated in rectangle." };
            desc = "To reduce z-Jitter, use the farthest depth value at each pixel as long as the camera is stable";
        }

        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1) { src = vbc.task.pcSplit[2]; }

            if (vbc.task.heartBeat)
            {
                stableMax = src.Clone();
                dst3.SetTo(0);
            }
            else if (vbc.task.motionDetected)
            {
                Cv2.CopyTo(stableMax[vbc.task.motionRect], src[vbc.task.motionRect]);
                if (src.Type() != stableMax.Type()) { Cv2.ConvertScaleAbs(src, stableMax); }
                Cv2.CopyTo(src[vbc.task.motionRect], stableMax[vbc.task.motionRect], vbc.task.noDepthMask);
                Cv2.Max(src, stableMax, stableMax);
            }

            colorize.Run(stableMax);
            dst2 = colorize.dst2;
        }
    }





    public class Depth_StableMinMax_CS : VB_Parent
    {
        Depth_Colorizer_CPP_VB colorize = new Depth_Colorizer_CPP_VB();
        Depth_StableMin dMin = new Depth_StableMin();
        Depth_StableMax dMax = new Depth_StableMax();
        Options_MinMaxNone options = new Options_MinMaxNone();

        public Depth_StableMinMax_CS()
        {
            vbc.task.gOptions.setUnfiltered(true);
            labels[2] = "Depth map colorized";
            labels[3] = "32-bit StableDepth";
            desc = "To reduce z-Jitter, use the closest or farthest point as long as the camera is stable";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Type() != MatType.CV_32FC1) { src = vbc.task.pcSplit[2]; }
            if (vbc.task.optionsChanged) { dst3 = vbc.task.pcSplit[2]; }

            if (options.useMax)
            {
                dMax.Run(src);
                dst3 = dMax.stableMax;
                dst2 = dMax.dst2;
            }
            else if (options.useMin)
            {
                dMin.Run(src);
                dst3 = dMin.stableMin;
                dst2 = dMin.dst2;
            }
            else if (options.useNone)
            {
                dst3 = vbc.task.pcSplit[2];
                dst2 = vbc.task.depthRGB;
            }
        }
    }





    public class Depth_WorldXYMT_CS : VB_Parent
    {
        bool depthUnitsMeters = false;

        public Depth_WorldXYMT_CS()
        {
            labels[3] = "dst3 = pointcloud";
            desc = "Create OpenGL point cloud from depth data (slow)";
        }

        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1) { src = vbc.task.pcSplit[2]; }

            dst3 = new Mat(src.Size(), MatType.CV_32FC3, Scalar.All(0));
            if (!depthUnitsMeters) { src = src * 0.001; }
            double multX = vbc.task.pointCloud.Width / src.Width;
            double multY = vbc.task.pointCloud.Height / src.Height;

            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                Point3f xy = new Point3f();
                for (int y = roi.Y; y < roi.Y + roi.Height; y++)
                {
                    for (int x = roi.X; x < roi.X + roi.Width; x++)
                    {
                        xy.X = x * (float)multX;
                        xy.Y = y * (float)multY;
                        xy.Z = src.At<float>(y, x);
                        if (xy.Z != 0)
                        {
                            Point3f xyz = getWorldCoordinates(xy);
                            dst3.Set<cv.Point3f>(y, x, xyz);
                        }
                    }
                }
            });

            SetTrueText("OpenGL data prepared.");
        }
    }






    public class Depth_WorldXYZ_CS : VB_Parent
    {
        public bool depthUnitsMeters = false;

        public Depth_WorldXYZ_CS()
        {
            labels[3] = "dst3 = pointcloud";
            desc = "Create 32-bit XYZ format from depth data (too slow to be useful.)";
        }

        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1)
                src = vbc.task.pcSplit[2];

            if (!depthUnitsMeters)
                src = (src * 0.001).ToMat();

            dst2 = new Mat(src.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            Point3f xy = new Point3f();

            for (xy.Y = 0; xy.Y < dst2.Height; xy.Y++)
            {
                for (xy.X = 0; xy.X < dst2.Width; xy.X++)
                {
                    xy.Z = src.Get<float>((int)xy.Y, (int)xy.X);
                    if (xy.Z != 0)
                    {
                        Point3f xyz = getWorldCoordinates(xy);
                        dst2.Set((int)xy.Y, (int)xy.X, xyz);
                    }
                }
            }

            SetTrueText("OpenGL data prepared and in dst2.", 3);
        }
    }





    public class Depth_World_CS : VB_Parent
    {
        Math_Template template = new Math_Template();

        public Depth_World_CS()
        {
            labels = new string[] { "", "", "Merged templates and depth32f - should be similar to upper right image", "" };
            desc = "Build the (approximate) point cloud using camera intrinsics - see CameraOakD.cs for comparable calculations";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass)
                template.Run(empty);

            if (src.Type() != MatType.CV_32F)
                src = vbc.task.pcSplit[2];

            Cv2.Multiply(template.dst2, src, dst0);
            dst0 *= 1 / vbc.task.calibData.fx;

            Cv2.Multiply(template.dst3, src, dst1);
            dst1 *= 1 / vbc.task.calibData.fy;

            Cv2.Merge(new Mat[] { dst0, dst1, src }, dst2);

            if (standaloneTest())
            {
                var colorizer = new Depth_Colorizer_CPP_VB();
                colorizer.Run(dst2);
                dst2 = colorizer.dst2;
            }
        }
    }





    public class Depth_Tiers_CS : VB_Parent
    {
        public int classCount;
        Options_DepthTiers options = new Options_DepthTiers();

        public Depth_Tiers_CS()
        {
            UpdateAdvice(traceName + ": gOptions 'Max Depth (meters)' and local options for cm's per tier.");
            desc = "Create a reduced image of the depth data to define tiers of similar values";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];

            dst1 = (src * 100 / options.cmPerTier).ToMat();
            dst1.ConvertTo(dst2, MatType.CV_8U);

            classCount = (int)(vbc.task.MaxZmeters * 100 / options.cmPerTier) + 1;

            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = $"{classCount} regions found.";
        }
    }





    public class Depth_TierCount_CS : VB_Parent
    {
        public HistValley_Depth1 valley = new HistValley_Depth1();
        public int classCount;
        List<int> kValues = new List<int>();

        public Depth_TierCount_CS()
        {
            labels = new string[] { "", "Histogram of the depth data with instantaneous valley lines", "", "" };
            desc = "Determine the 'K' value for the best number of clusters for the depth";
        }

        public void RunAlg(Mat src)
        {
            valley.Run(src);
            dst2 = valley.dst2;

            kValues.Add(valley.valleyOrder.Count);

            classCount = (int)kValues.Average();
            if (kValues.Count > vbc.task.frameHistoryCount * 10)
                kValues.RemoveAt(0);

            SetTrueText($"'K' value = {classCount} after averaging. Instantaneous value = {valley.valleyOrder.Count}", 3);
            labels[2] = $"There are {classCount}";
        }
    }





    public class Depth_Flatland_CS : VB_Parent
    {
        Options_FlatLand options = new Options_FlatLand();

        public Depth_Flatland_CS()
        {
            labels[3] = "Grayscale version";
            desc = "Attempt to stabilize the depth image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = vbc.task.depthRGB / options.reductionFactor;
            dst2 *= options.reductionFactor;
            dst3 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }






    public class Derivative_Basics_CS : VB_Parent
    {
        public Options_Derivative options = new Options_Derivative();
        BackProject_Image backp = new BackProject_Image();
        public Plot_Histogram plot = new Plot_Histogram();

        public Derivative_Basics_CS()
        {
            backp.hist.plot.removeZeroEntry = false;
            UpdateAdvice(traceName + ": gOptions histogram Bins and several local options are important.");
            desc = "Display a first or second derivative of the selected depth dimension and direction.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Type() != MatType.CV_32F)
            {
                src = vbc.task.pcSplit[options.channel].Sobel(MatType.CV_32F, 1, 0, options.kernelSize);
            }

            Rangef[] ranges = { new Rangef((float)-options.derivativeRange, (float)options.derivativeRange) };
            Mat histogram = new Mat();
            Cv2.CalcHist(new[] { src }, new[] { 0 }, vbc.task.depthMask, histogram, 1, new[] { vbc.task.histogramBins }, ranges);

            plot.Run(histogram);
            histogram = plot.histogram; // reflect any updates to the 0 entry...
            dst2 = plot.dst2;

            int index = 1;
            for (int i = 0; i < plot.histArray.Length; i++)
            {
                if (plot.histArray[i] != 0)
                {
                    plot.histArray[i] = index;
                    index++;
                }
            }
            histogram = cv.Mat.FromPixelData(plot.histArray.Length, 1, MatType.CV_32F, plot.histArray.ToArray());

            int brickWidth = dst2.Width / vbc.task.histogramBins;
            int histIndex = (int)(vbc.task.mouseMovePoint.X / brickWidth);

            Mat mask = new Mat();
            Cv2.CalcBackProject(new[] { src }, new[] { 0 }, histogram, mask, ranges);
            mask.ConvertTo(mask, MatType.CV_8U);
            dst0 = mask;
            mask = mask.InRange(histIndex, histIndex);

            dst3 = vbc.task.color.Clone();
            dst3.SetTo(Scalar.White, mask);
            dst3.SetTo(0, vbc.task.noDepthMask);
            Cv2.Rectangle(dst2, new cv.Rect(histIndex * brickWidth, 0, brickWidth, dst2.Height), Scalar.Yellow, vbc.task.lineWidth);
            string deriv = string.Format(vbc.fmt2, options.derivativeRange);
            labels[2] = "Histogram of first or second derivatives.  Range -" + deriv + " to " + deriv;
            labels[3] = "Backprojection into the image for the selected histogram entry - move mouse over dst2.";
        }
    }





    public class Derivative_Sobel_CS : VB_Parent
    {
        Derivative_Basics_CS deriv;

        public Derivative_Sobel_CS()
        {
            deriv = new Derivative_Basics_CS();
            if (standalone) vbc.task.gOptions.setDisplay1();
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Display the derivative of the selected depth dimension.";
        }

        public void RunAlg(Mat src)
        {
            int channel = deriv.options.channel;
            string chanName = "X";
            if (channel != 0)
            {
                chanName = channel == 1 ? "Y" : "Z";
            }
            int kern = deriv.options.kernelSize;
            src = vbc.task.pcSplit[channel].Sobel(MatType.CV_32F, 1, 0, kern);
            deriv.Run(src);
            dst0 = deriv.dst2.Clone();
            dst1 = deriv.dst3.Clone();
            labels[0] = "Horizontal derivatives for " + chanName + " dimension of the point cloud";
            labels[1] = "Backprojection of horizontal derivatives indicated - move mouse in the image at left";

            src = vbc.task.pcSplit[channel].Sobel(MatType.CV_32F, 0, 1, kern);
            deriv.Run(src);
            dst2 = deriv.dst2;
            dst3 = deriv.dst3;
            labels[2] = "Vertical derivatives for " + chanName + " dimension of the point cloud";
            labels[3] = "Backprojection of vertical derivatives indicated - move mouse in the image at left";
        }
    }





    public class Derivative_Laplacian_CS : VB_Parent
    {
        Options_LaplacianKernels options = new Options_LaplacianKernels();
        Derivative_Basics_CS deriv;

        public Derivative_Laplacian_CS()
        {
            deriv = new Derivative_Basics_CS();
            desc = "Create a histogram and backprojection for the second derivative of depth in the selected dimension.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            int channel = deriv.options.channel;
            cv.Size gausskern = new cv.Size((int)options.gaussiankernelSize, (int)options.gaussiankernelSize);
            dst1 = vbc.task.pcSplit[channel].GaussianBlur(gausskern, 0, 0);
            dst1 = dst1.Laplacian(MatType.CV_32F, options.LaplaciankernelSize, 1, 0);

            deriv.Run(dst1);
            dst2 = deriv.dst2;
            dst3 = deriv.dst3;
            labels[2] = deriv.labels[2];
            labels[3] = deriv.labels[3];
        }
    }





    public class Derivative_Classes_CS : VB_Parent
    {
        Derivative_Basics_CS deriv;
        public int classCountX;
        public int classCountY;

        public Derivative_Classes_CS()
        {
            deriv = new Derivative_Basics_CS();
            desc = "Display the X and Y derivatives for the whole image.";
        }

        int derivClassCount(ref Mat dst)
        {
            int count = 0;
            for (int i = 0; i < deriv.plot.histArray.Length; i++)
            {
                if (deriv.plot.histArray[i] > 0) count++;
            }
            dst = ShowPalette(deriv.dst0 * 255 / count);
            dst.SetTo(0, vbc.task.noDepthMask);
            return count;
        }

        public void RunAlg(Mat src)
        {
            deriv.Run(vbc.task.pcSplit[deriv.options.channel].Sobel(MatType.CV_32F, 1, 0, deriv.options.kernelSize));
            classCountX = derivClassCount(ref dst2);
            labels[2] = $"Backprojection of X dimension of vbc.task.pcSplit({deriv.options.channel})";

            deriv.Run(vbc.task.pcSplit[deriv.options.channel].Sobel(MatType.CV_32F, 0, 1, deriv.options.kernelSize));
            classCountY = derivClassCount(ref dst3);
            labels[3] = $"Backprojection of Y dimension of vbc.task.pcSplit({deriv.options.channel})";
        }
    }






    public class DFT_Basics_CS : VB_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        public Mat magnitude = new Mat();
        public Mat spectrum = new Mat();
        public Mat complexImage = new Mat();
        public Mat grayMat;
        public int rows;
        public int cols;

        public DFT_Basics_CS()
        {
            mats.lineSeparators = false;

            desc = "Explore the Discrete Fourier Transform.";
            labels[2] = "Image after inverse DFT";
            labels[3] = "DFT_Basics Spectrum Magnitude";
        }

        public Mat InverseDFT(Mat complexImage)
        {
            Mat invDFT = new Mat();
            Cv2.Dft(complexImage, invDFT, DftFlags.Inverse | DftFlags.RealOutput);
            invDFT = invDFT.Normalize(0, 255, NormTypes.MinMax);
            invDFT.ConvertTo(invDFT, MatType.CV_8U);
            return invDFT;
        }
        public void RunAlg(Mat src)
        {
            grayMat = src;
            if (src.Channels() == 3)
                grayMat = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            rows = Cv2.GetOptimalDFTSize(grayMat.Rows);
            cols = Cv2.GetOptimalDFTSize(grayMat.Cols);
            Mat padded = new Mat(grayMat.Width, grayMat.Height, MatType.CV_8UC3);
            Cv2.CopyMakeBorder(grayMat, padded, 0, rows - grayMat.Rows, 0, cols - grayMat.Cols, BorderTypes.Constant, Scalar.All(0));
            Mat padded32 = new Mat();
            padded.ConvertTo(padded32, MatType.CV_32F);
            Mat[] planes = { padded32, new Mat(padded.Size(), MatType.CV_32F, cv.Scalar.All(0)) };
            Cv2.Merge(planes, complexImage);
            Cv2.Dft(complexImage, complexImage);

            planes = complexImage.Split();

            Cv2.Magnitude(planes[0], planes[1], magnitude);
            magnitude += Scalar.All(1);
            Cv2.Log(magnitude, magnitude);

            spectrum = magnitude[new cv.Rect(0, 0, magnitude.Cols & -2, magnitude.Rows & -2)];
            spectrum = spectrum.Normalize(0, 255, NormTypes.MinMax);
            spectrum.ConvertTo(padded, MatType.CV_8U);

            int cx = padded.Cols / 2;
            int cy = padded.Rows / 2;

            mats.mat[3] = padded[new cv.Rect(0, 0, cx, cy)].Clone();
            mats.mat[2] = padded[new cv.Rect(cx, 0, cx, cy)].Clone();
            mats.mat[1] = padded[new cv.Rect(0, cy, cx, cy)].Clone();
            mats.mat[0] = padded[new cv.Rect(cx, cy, cx, cy)].Clone();
            mats.Run(empty);
            dst3 = mats.dst2;

            dst2 = InverseDFT(complexImage);
        }
    }




    public class DFT_ButterworthFilter_MT_CS : VB_Parent
    {
        public DFT_Basics_CS dft; 
        Options_DFT options = new Options_DFT();
        public DFT_ButterworthFilter_MT_CS()
        {
            dft = new DFT_Basics_CS();
            desc = "Use the Butterworth filter on a DFT image - color image input.";
            labels[2] = "Image with Butterworth Low Pass Filter Applied";
            labels[3] = "Same filter with radius / 2";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dft.RunAlg(src);
            if (vbc.task.optionsChanged)
            {
                Parallel.For(0, 2, k =>
                {
                    double r = options.radius / (k + 1);
                    options.butterworthFilter[k] = new Mat(dft.complexImage.Size(), MatType.CV_32FC2);
                    Mat tmp = new Mat(options.butterworthFilter[k].Size(), MatType.CV_32F, Scalar.All(0));
                    cv.Point center = new cv.Point(options.butterworthFilter[k].Rows / 2, options.butterworthFilter[k].Cols / 2);
                    for (int i = 0; i < options.butterworthFilter[k].Rows; i++)
                    {
                        for (int j = 0; j < options.butterworthFilter[k].Cols; j++)
                        {
                            double rNext = Math.Sqrt(Math.Pow(i - center.X, 2) + Math.Pow(j - center.Y, 2));
                            tmp.Set<float>(i, j, (float)(1 / (1 + Math.Pow(rNext / r, 2 * options.order))));
                        }
                    }
                    Mat[] tmpMerge = { tmp, tmp };
                    Cv2.Merge(tmpMerge, options.butterworthFilter[k]);
                });
            }
            Parallel.For(0, 2, k =>
            {
                Mat complex = new Mat();
                Cv2.MulSpectrums(options.butterworthFilter[k], dft.complexImage, complex, options.dftFlag);
                if (k == 0)
                    dst2 = dft.InverseDFT(complex);
                else
                    dst3 = dft.InverseDFT(complex);
            });
        }
    }





    public class DFT_Inverse_CS : VB_Parent
    {
        Mat_2to1 mats = new Mat_2to1();
        DFT_Basics_CS dft;

        public DFT_Inverse_CS()
        {
            dft = new DFT_Basics_CS();
            labels[2] = "Image after Inverse DFT";
            desc = "Take the inverse of the Discrete Fourier Transform.";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            src.ConvertTo(gray32f, MatType.CV_32F);
            Mat[] planes = { gray32f, new Mat(gray32f.Size(), MatType.CV_32F, cv.Scalar.All(0)) };
            Mat complex = new Mat();
            Mat complexImage = new Mat();
            Cv2.Merge(planes, complex);
            Cv2.Dft(complex, complexImage);

            dst2 = dft.InverseDFT(complexImage);

            Mat diff = new Mat();
            Cv2.Absdiff(src, dst2, diff);
            mats.mat[0] = diff.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[1] = (diff * 50).ToMat();
            mats.Run(empty);
            if (mats.mat[0].CountNonZero() > 0)
            {
                dst3 = mats.dst2;
                labels[3] = "Mask of difference (top) and relative diff (bot)";
            }
            else
            {
                labels[3] = "InverseDFT reproduced original";
                dst3.SetTo(0);
            }
        }
    }








    public class DFT_ButterworthDepth_CS : VB_Parent
    {
        DFT_ButterworthFilter_MT bfilter = new DFT_ButterworthFilter_MT();

        public DFT_ButterworthDepth_CS()
        {
            desc = "Use the Butterworth filter on a DFT image - RGBDepth as input.";
            labels[2] = "Image with Butterworth Low Pass Filter Applied";
            labels[3] = "Same filter with radius / 2";
        }

        public void RunAlg(Mat src)
        {
            bfilter.Run(vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = bfilter.dst2;
            dst3 = bfilter.dst3;
        }
    }





    public class DFT_Shapes_CS : VB_Parent
    {
        DFT_Basics_CS dft;
        Draw_Circles circle = new Draw_Circles();
        Draw_Ellipses ellipse = new Draw_Ellipses();
        Draw_Polygon polygon = new Draw_Polygon();
        Rectangle_Basics rectangle = new Rectangle_Basics();
        Draw_Lines lines = new Draw_Lines();
        Draw_SymmetricalShapes symShapes = new Draw_SymmetricalShapes();
        Options_Draw options = new Options_Draw();
        Options_DFTShape optionsDFT = new Options_DFTShape();

        public DFT_Shapes_CS()
        {
            dft = new DFT_Basics_CS();
            FindSlider("DrawCount").Value = 1;
            labels = new string[] { "Inverse of the DFT - the same grayscale input.", "", "Input to the DFT", "Discrete Fourier Transform Output" };
            desc = "Show the spectrum magnitude for some standard shapes";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsDFT.RunOpt();

            switch (optionsDFT.dftShape)
            {
                case "Draw Circle":
                    circle.Run(src);
                    dst2 = circle.dst2;
                    break;
                case "Draw Ellipse":
                    ellipse.Run(src);
                    dst2 = ellipse.dst2;
                    break;
                case "Draw Line":
                    lines.Run(src);
                    dst2 = lines.dst2;
                    break;
                case "Draw Rectangle":
                    rectangle.Run(src);
                    dst2 = rectangle.dst2;
                    break;
                case "Draw Polygon":
                    polygon.Run(src);
                    dst2 = polygon.dst2;
                    break;
                case "Draw Symmetrical Shapes":
                    symShapes.Run(src);
                    dst2 = symShapes.dst2;
                    break;
                case "Draw Point":
                    if (vbc.task.heartBeat)
                    {
                        dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
                        var pt1 = new cv.Point(msRNG.Next(0, dst2.Width / 10), msRNG.Next(0, dst2.Height / 10));
                        var pt2 = new cv.Point(msRNG.Next(0, dst2.Width / 10), msRNG.Next(0, dst2.Height / 10));
                        dst2.Set<byte>(pt1.Y, pt1.X, 255);
                        dst2.Set<byte>(pt2.Y, pt2.X, 255);
                        labels[2] = $"pt1 = ({pt1.X},{pt1.Y})  pt2 = ({pt2.X},{pt2.Y})";
                    }
                    break;
            }

            dft.Run(dst2);
            dst3 = dft.dst3;

            // the following line to view the inverse of the DFT transform.
            // It is the grayscale image of the input - no surprise.  It works!
            dst2 = dft.InverseDFT(dft.complexImage);
        }
    }












    public class Diff_Basics_CS : VB_Parent
    {
        public int changedPixels;
        public Mat lastFrame;

        public Diff_Basics_CS()
        {
            labels = new string[] { "", "", "Unstable mask", "" };
            UpdateAdvice(traceName + ": use goption 'Pixel Difference Threshold' to control changed pixels.");
            desc = "Capture an image and compare it to previous frame using absDiff and threshold";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (vbc.task.FirstPass) lastFrame = src.Clone();
            if (vbc.task.optionsChanged || lastFrame.Size() != src.Size())
                lastFrame = src.Clone();

            Cv2.Absdiff(src, lastFrame, dst0);
            dst2 = dst0.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            changedPixels = dst2.CountNonZero();

            if (changedPixels > 0)
            {
                lastFrame = src.Clone();
                int pixelD = vbc.task.gOptions.pixelDiffThreshold;
                strOut = "Motion detected - " + changedPixels.ToString() + " pixels changed with threshold " + pixelD.ToString();
                if (vbc.task.heartBeat)
                    labels[3] = strOut;
            }
            else
            {
                strOut = "No motion detected";
            }

            SetTrueText(strOut, 3);
        }
    }





    public class Diff_Identical_CS : VB_Parent
    {
        Diff_Color diffColor = new Diff_Color();
        int noMotionFrames;
        List<string> flowText = new List<string>();
        public Diff_Identical_CS()
        {
            desc = "Count frames that are identical to the previous - a driver issue. The interrupt is triggered by something other than an RGB image.";
        }
        public void RunAlg(Mat src)
        {
            diffColor.Run(src);
            dst2 = diffColor.dst2;
            if (diffColor.diff.changedPixels == 0)
                noMotionFrames++;
            if (vbc.task.heartBeat)
            {
                labels[2] = $"{noMotionFrames} frames since the last heartbeat with no motion or {noMotionFrames / vbc.task.fpsRate:P0}";
                flowText.Add(labels[2]);
                noMotionFrames = 0;
                if (flowText.Count() > 20)
                    flowText.RemoveAt(0);
                string strOut = string.Join("\n", flowText);
                SetTrueText(strOut, 3);
            }
        }
    }







    public class Diff_Color_CS : VB_Parent
    {
        public Diff_Basics_CS diff;

        public Diff_Color_CS()
        {
            diff = new Diff_Basics_CS();
            labels = new string[] { "", "", "Each channel displays the channel's difference", "Mask with all differences" };
            desc = "Use Diff_Basics with a color image.";
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass)
                diff.lastFrame = src.Reshape(1, src.Rows * 3);

            diff.Run(src.Reshape(1, src.Rows * 3));
            dst2 = diff.dst2.Reshape(3, src.Rows);
            dst3 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
        }
    }





    public class Diff_UnstableDepthAndColor_CS : VB_Parent
    {
        public Diff_Basics_CS diff;
        public Depth_NotMissing depth = new Depth_NotMissing();

        public Diff_UnstableDepthAndColor_CS()
        {
            diff = new Diff_Basics_CS();
            labels = new string[] { "", "", "Stable depth and color", "Unstable depth/color mask" };
            desc = "Build a mask for any pixels that have either unstable depth or color";
        }

        public void RunAlg(Mat src)
        {
            diff.Run(src);
            Mat unstableGray = diff.dst2.Clone();
            depth.Run(vbc.task.depthRGB);
            Mat unstableDepth = new Mat();
            Mat mask = new Mat();
            Cv2.BitwiseNot(depth.dst3, unstableDepth);

            if (unstableGray.Channels() == 3)
                unstableGray = unstableGray.CvtColor(ColorConversionCodes.BGR2GRAY);

            Cv2.BitwiseOr(unstableGray, unstableDepth, mask);
            dst2 = src.Clone();
            dst2.SetTo(Scalar.Black, mask);
            dst3 = mask;
        }
    }





    public class Diff_RGBAccum_CS : VB_Parent
    {
        public Diff_Basics_CS diff;
        List<Mat> history = new List<Mat>();

        public Diff_RGBAccum_CS()
        {
            diff = new Diff_Basics_CS();
            labels = new string[] { "", "", "Accumulated BGR image", "Mask of changed pixels" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.Black);
            desc = "Run Diff_Basics and accumulate BGR diff data.";
        }

        public void RunAlg(Mat src)
        {
            diff.Run(src);
            if (vbc.task.optionsChanged)
                history.Clear();

            history.Add(diff.dst2);
            if (history.Count > vbc.task.frameHistoryCount)
                history.RemoveAt(0);

            dst2.SetTo(Scalar.Black);
            foreach (Mat m in history)
            {
                Cv2.BitwiseOr(dst2, m, dst2);
            }
        }
    }





    public class Diff_Lines_CS : VB_Parent
    {
        Diff_RGBAccum diff = new Diff_RGBAccum();
        Line_Basics lines = new Line_Basics();

        public Diff_Lines_CS()
        {
            labels = new string[] { "", "", "Add motion to see Diff output and lines input", "Lines output" };
            desc = "identify lines in the diff output";
        }

        public void RunAlg(Mat src)
        {
            diff.Run(src);
            dst2 = diff.dst2;

            lines.Run(dst2);
            dst3 = src.Clone();
            foreach (var lp in lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, Scalar.Yellow, vbc.task.lineWidth);
            }
        }
    }







    public class Diff_Heartbeat_CS : VB_Parent
    {
        public int cumulativePixels;

        public Diff_Heartbeat_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Unstable mask", "Pixel difference" };
            desc = "Diff an image with one from the last heartbeat.";
        }

        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (vbc.task.heartBeat)
            {
                dst1 = src.Clone();
                dst2.SetTo(0);
            }

            Cv2.Absdiff(src, dst1, dst3);
            cumulativePixels = Cv2.CountNonZero(dst3);
            dst2 = dst2 | dst3.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
        }
    }





    public class Diff_Depth32f_CS : VB_Parent
    {
        public Mat lastDepth32f;
        Options_Depth options = new Options_Depth();

        public Diff_Depth32f_CS()
        {
            lastDepth32f = dst0.Clone();
            desc = "Where is the depth difference between frames greater than X centimeters.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
                lastDepth32f = vbc.task.pcSplit[2].Clone();

            Cv2.Absdiff(vbc.task.pcSplit[2], lastDepth32f, dst1);
            var mm = GetMinMax(dst1);

            dst2 = dst1.Threshold(options.mmThreshold, 255, ThresholdTypes.Binary);

            lastDepth32f = vbc.task.pcSplit[2].Clone();
            if (vbc.task.heartBeat)
            {
                labels[2] = $"Mask where depth difference between frames is more than {options.mmThreshold} mm's";
                int count = Cv2.CountNonZero(dst2);
                labels[3] = $"{count} pixels ({(double)count / Cv2.CountNonZero(vbc.task.depthMask):P0} of all depth pixels) were different by more than {options.mmThreshold} mm's";
            }
        }
    }






    public class Dilate_Basics_CS : VB_Parent
    {
        public Options_Dilate options = new Options_Dilate();

        public Dilate_Basics_CS()
        {
            desc = "Dilate the image provided.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (options.noshape || options.iterations == 0)
                dst2 = src;
            else
                dst2 = src.Dilate(options.element, null, options.iterations);

            if (standaloneTest())
            {
                dst3 = vbc.task.depthRGB.Dilate(options.element, null, options.iterations);
                labels[3] = $"Dilated Depth {options.iterations} times";
            }
            labels[2] = $"Dilated BGR {options.iterations} times";
        }
    }





    public class Dilate_OpenClose_CS : VB_Parent
    {
        Options_Dilate options = new Options_Dilate();

        public Dilate_OpenClose_CS()
        {
            desc = "Erode and dilate with MorphologyEx on the BGR and Depth image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            MorphTypes openClose = options.iterations > 0 ? MorphTypes.Open : MorphTypes.Close;
            Cv2.MorphologyEx(vbc.task.depthRGB, dst3, openClose, options.element);
            Cv2.MorphologyEx(src, dst2, openClose, options.element);
        }
    }





    public class Dilate_Erode_CS : VB_Parent
    {
        Options_Dilate options = new Options_Dilate();

        public Dilate_Erode_CS()
        {
            desc = "Erode and dilate with MorphologyEx on the input image.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Cv2.MorphologyEx(src, dst2, MorphTypes.Open, options.element);
            Cv2.MorphologyEx(dst2, dst2, MorphTypes.Close, options.element);
        }
    }






    public class DisparityFunction_Basics_CS : VB_Parent
    {
        FeatureLeftRight_Basics match = new FeatureLeftRight_Basics();
        string depthStr;
        string dispStr;

        public DisparityFunction_Basics_CS()
        {
            labels = new string[] { "", "", "AddWeighted output: lines show disparity between left and right images",
                                "Disparity as a function of depth" };
            desc = "Using FeatureMatch results build a function for disparity given depth";
        }

        public int DisparityFormula(float depth)
        {
            if (depth == 0) return 0;
            return (int)(vbc.task.baseline * 1000 * vbc.task.focalLength / depth);
        }

        public void RunAlg(Mat src)
        {
            if (vbc.task.cameraName == "Azure Kinect 4K")
            {
                SetTrueText("Kinect for Azure does not have a left and right view to compute disparities", 2);
                return;
            }

            match.Run(src);
            dst2 = match.dst1;
            if (match.mpList.Count == 0) return; // no data...

            var disparity = new SortedDictionary<int, float>(new CompareAllowIdenticalIntegerInverted());
            for (int i = 0; i < match.mpList.Count; i++)
            {
                var mp = match.mpList[i];
                disparity.Add((int)(mp.p1.X - mp.p2.X), match.mpCorrelation[i]);
            }

            if (vbc.task.heartBeat)
            {
                dispStr = "Disparity: \n";
                depthStr = "Depth: \n";
                int index = 0;
                foreach (var entry in disparity)
                {
                    dispStr += $"{entry.Key}, ";
                    depthStr += $"{entry.Value:F3}, ";
                    index++;
                    if (index % 20 == 0)
                    {
                        dispStr += "\n";
                        depthStr += "\n";
                    }
                }

                int testIndex = Math.Min(disparity.Count - 1, 10);
                float actualDisparity = vbc.task.disparityAdjustment * disparity.ElementAt(testIndex).Key;
                float actualDepth = disparity.ElementAt(testIndex).Value;

                strOut = "Computing disparity from depth: disparity = ";
                strOut += "baseline * focal length / actual depth\n";
                strOut += "A disparity adjustment that is dependent on working resolution is used here \n";
                strOut += "to adjust the observed disparity to match the formula.\n";
                strOut += $"At working resolution = {vbc.task.dst2.Width}x{vbc.task.dst2.Height}";
                strOut += $" the adjustment factor is {vbc.task.disparityAdjustment:F3}\n\n";

                int disparityformulaoutput = DisparityFormula(actualDepth);
                strOut += $"At actual depth {actualDepth:F3}\n";

                strOut += $"Disparity formula is: {vbc.task.baseline:F3}";
                strOut += $" * {vbc.task.focalLength:F3} * 1000 / {actualDepth:F3}\n";

                strOut += $"Disparity formula:\t{disparityformulaoutput:F3} pixels\n";
                strOut += $"Disparity actual:\t\t{actualDisparity:F3} pixels\n";
                strOut += "Predicted disparity = baseline * focal length * 1000 / actual depth / disparityAdjustment\n";
                strOut += $"Predicted disparity at {actualDepth:F3}m = {(int)(disparityformulaoutput / vbc.task.disparityAdjustment)} pixels";
            }

            SetTrueText(depthStr + "\n\n" + dispStr, 3);
            SetTrueText(strOut, new cv.Point(0, dst2.Height / 3), 3);
        }
    }







    public class Distance_Basics_CS : VB_Parent
    {
        Options_Distance options = new Options_Distance();

        public Distance_Basics_CS()
        {
            labels = new string[] { "", "", "Distance transform - create a mask with threshold", "" };
            UpdateAdvice(traceName + ": use local options to control which method is used.");
            desc = "Distance algorithm basics.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest()) src = vbc.task.depthRGB;
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            dst0 = src.DistanceTransform(options.distanceType, 0);
            dst1 = Convert32f_To_8UC3(dst0);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
        }
    }





    public class Distance_Labels_CS : VB_Parent
    {
        Options_Distance options = new Options_Distance();

        public Distance_Labels_CS()
        {
            labels[2] = "Distance results";
            labels[3] = "Input mask to distance transform";
            desc = "Distance algorithm basics.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest()) src = vbc.task.depthRGB;
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            // Commented out code
            //Mat labels;
            //Cv2.DistanceTransformWithLabels(src, dst0, out labels, DistanceTypes.L2, DistanceTransformMasks.Precise);
            //Mat dist32f = dst0.Normalize(0, 255, NormTypes.MinMax);
            //dist32f.ConvertTo(src, MatType.CV_8UC1);
            //dst2 = src.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }





    public class Distance_Foreground_CS : VB_Parent
    {
        Distance_Basics dist = new Distance_Basics();
        Foreground_KMeans foreground = new Foreground_KMeans();
        public bool useBackgroundAsInput;

        public Distance_Foreground_CS()
        {
            labels[2] = "Distance results";
            labels[3] = "Input mask to distance transform";
            desc = "Distance algorithm basics.";
        }

        public void RunAlg(Mat src)
        {
            var cRadio = FindRadio("C");
            var l1Radio = FindRadio("L1");

            foreground.Run(src);
            dst3 = useBackgroundAsInput ? foreground.dst2 : foreground.dst3;

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            DistanceTypes DistanceType = DistanceTypes.L2;
            if (cRadio.Checked) DistanceType = DistanceTypes.C;
            if (l1Radio.Checked) DistanceType = DistanceTypes.L1;

            src = dst3 & src;
            Mat dist = src.DistanceTransform(DistanceType, cv.DistanceTransformMasks.Precise);
            Mat dist32f = dist.Normalize(0, 255, NormTypes.MinMax);
            dist32f.ConvertTo(src, MatType.CV_8UC1);
            dst2 = src.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }





    public class Distance_Background_CS : VB_Parent
    {
        Distance_Foreground dist = new Distance_Foreground();

        public Distance_Background_CS()
        {
            dist.useBackgroundAsInput = true;
            desc = "Use distance algorithm on the background";
        }

        public void RunAlg(Mat src)
        {
            dist.Run(src);
            dst2 = dist.dst2;
            dst3 = dist.dst3;
            labels[2] = dist.labels[2];
            labels[3] = dist.labels[3];
        }
    }





    public class Distance_Point3D_CS : VB_Parent
    {
        public Point3f inPoint1;
        public Point3f inPoint2;
        public float distance;

        public Distance_Point3D_CS()
        {
            desc = "Compute the distance in meters between 3D points in the point cloud";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest() && vbc.task.heartBeat)
            {
                inPoint1 = new Point3f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height), msRNG.Next(0, 10000));
                inPoint2 = new Point3f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height), msRNG.Next(0, 10000));

                dst2.SetTo(0);
                cv.Point p1 = new cv.Point((int)inPoint1.X, (int)inPoint1.Y);
                cv.Point p2 = new cv.Point((int)inPoint2.X, (int)inPoint2.Y);
                Cv2.Line(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);

                Point3f vec1 = vbc.task.pointCloud.Get<cv.Point3f>(p1.Y, p1.X);
                Point3f vec2 = vbc.task.pointCloud.Get<cv.Point3f>(p2.Y, p2.X);
            }

            float x = inPoint1.X - inPoint2.X;
            float y = inPoint1.Y - inPoint2.Y;
            float z = inPoint1.Z - inPoint2.Z;
            distance = (float)Math.Sqrt(x * x + y * y + z * z);

            string strOut = $"{inPoint1.X:F3}, {inPoint1.Y:F3}, {inPoint1.Z:F3}\n";
            strOut += $"{inPoint2.X:F3}, {inPoint2.Y:F3}, {inPoint2.Z:F3}\n";
            strOut += $"Distance = {distance:F3}";
            SetTrueText(strOut, 3);
        }
    }





    public class Distance_Point4D_CS : VB_Parent
    {
        public Vec4f inPoint1;
        public Vec4f inPoint2;
        public float distance;

        public Distance_Point4D_CS()
        {
            desc = "Compute the distance between 4D points";
        }

        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                inPoint1 = new Vec4f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height),
                                     msRNG.Next(0, (int)vbc.task.MaxZmeters), msRNG.Next(0, (int)vbc.task.MaxZmeters));
                inPoint2 = new Vec4f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height),
                                     msRNG.Next(0, (int)vbc.task.MaxZmeters), msRNG.Next(0, (int)vbc.task.MaxZmeters));
            }

            float x = inPoint1[0] - inPoint2[0];
            float y = inPoint1[1] - inPoint2[1];
            float z = inPoint1[2] - inPoint2[2];
            float d = inPoint1[3] - inPoint2[3];
            distance = (float)Math.Sqrt(x * x + y * y + z * z + d * d);

            string strOut = $"{inPoint1}\n{inPoint2}\nDistance = {distance:F1}";
            SetTrueText(strOut, new cv.Point(10, 10), 2);
        }
    }





    public class Distance_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public List<List<float>> pixelVector = new List<List<float>>();
        SortedList<double, int> distances = new SortedList<double, int>(new compareAllowIdenticalDoubleInverted());
        SortedList<double, int> lastDistances = new SortedList<double, int>(new compareAllowIdenticalDoubleInverted());
        List<rcData> lastredCells = new List<rcData>();

        public Distance_RedCloud_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.redOptions.setUseColorOnly(true);
            vbc.task.redOptions.setHistBinBar3D(5);
            labels[1] = "3D Histogram distance for each of the cells at left";
            desc = "Identify RedCloud cells using the cell's 3D histogram distance from zero";
        }

        double distanceFromZero(List<float> histlist)
        {
            double result = 0;
            foreach (var d in histlist)
            {
                result += d * d;
            }
            return Math.Sqrt(result);
        }

        public void RunAlg(Mat src)
        {
            redC.Run(src);

            pixelVector.Clear();
            distances.Clear();
            for (int i = 0; i < vbc.task.redCells.Count; i++)
            {
                var rc = vbc.task.redCells[i];
                hColor.inputMask = rc.mask;
                hColor.Run(src.SubMat(rc.rect));

                double nextD = distanceFromZero(hColor.histArray.ToList());
                distances.Add(nextD, i);
            }

            if (vbc.task.heartBeat)
            {
                string strOut = "3D histogram distances from zero for each cell\n";
                int index = 0;
                foreach (var el in distances)
                {
                    strOut += $"({el.Value}) {el.Key:F1}\t";
                    if (index % 6 == 5) strOut += "\n";
                    index++;

                    var rc = vbc.task.redCells[el.Value];
                    SetTrueText(el.Value.ToString(), rc.maxDist);
                }

                strOut += "----------------------\n";
                index = 0;
                foreach (var el in lastDistances)
                {
                    strOut += $"({el.Value}) {el.Key:F1}\t";
                    if (index % 6 == 5) strOut += "\n";
                    index++;
                    var rc = lastredCells[el.Value];
                    SetTrueText(el.Value.ToString(), new cv.Point(rc.maxDist.X, rc.maxDist.Y + 10));
                }

                foreach (var el in distances)
                {
                    var rc = vbc.task.redCells[el.Value];
                    SetTrueText(el.Value.ToString(), rc.maxDist);
                }
            }

            foreach (var el in lastDistances)
            {
                var rp = lastredCells[el.Value];
                SetTrueText(el.Value.ToString(), new cv.Point(rp.maxDist.X, rp.maxDist.Y + 10));
            }

            SetTrueText(strOut, 1);

            dst2.SetTo(0);
            dst3.SetTo(0);
            for (int i = 0; i < distances.Count; i++)
            {
                var rp = vbc.task.redCells[distances.ElementAt(i).Value];
                vbc.task.color.SubMat(rp.rect).CopyTo(dst2.SubMat(rp.rect), rp.mask);
                dst3.SubMat(rp.rect).SetTo(vbc.task.scalarColors[i], rp.mask);
            }
            labels[2] = redC.labels[3];

            lastDistances.Clear();
            foreach (var el in distances)
            {
                lastDistances.Add(el.Key, el.Value);
            }

            lastredCells = new List<rcData>(vbc.task.redCells);
        }
    }







    public class Distance_BinaryImage_CS : VB_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        Distance_Basics distance = new Distance_Basics();

        public Distance_BinaryImage_CS()
        {
            if (standalone)
            {
                vbc.task.gOptions.setDisplay1();
            }
            desc = "Measure the fragmentation of a binary image by using the distance transform";
        }

        public void RunAlg(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            labels[2] = binary.labels[2] + " Draw a rectangle to measure specific area.";

            if (vbc.task.drawRect.Width > 0)
            {
                distance.Run(dst2[vbc.task.drawRect]);
            }
            else
            {
                distance.Run(dst2);
            }
            dst3 = distance.dst2;
            dst1 = dst3.Threshold(vbc.task.gOptions.DebugSliderValue, 255, ThresholdTypes.Binary);
        }
    }






    public class Draw_Noise_CS : VB_Parent
    {
        public int maxNoiseWidth = 3;
        public bool addRandomColor;
        public Mat noiseMask;
        Options_DrawNoise options = new Options_DrawNoise();
        public Draw_Noise_CS()
        {
            desc = "Add Noise to the color image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            src.CopyTo(dst2);
            noiseMask = new Mat(src.Size(), MatType.CV_8UC1, Scalar.Black);
            for (int n = 0; n < options.noiseCount; n++)
            {
                int i = msRNG.Next(0, src.Cols - 1);
                int j = msRNG.Next(0, src.Rows - 1);
                Point2f center = new Point2f(i, j);
                Scalar c = addRandomColor ? new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255)) : Scalar.Black;
                int noiseWidth = msRNG.Next(1, options.noiseWidth);
                DrawCircle(dst2, center, noiseWidth, c, -1);
                DrawCircle(noiseMask, center, noiseWidth, Scalar.White, -1);
            }
        }
    }







    public class Draw_Ellipses_CS : VB_Parent
    {
        Options_Draw options = new Options_Draw();
        public Draw_Ellipses_CS()
        {
            desc = "Draw the requested number of ellipses.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                for (int i = 0; i < options.drawCount; i++)
                {
                    Point2f nPoint = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    Size2f eSize = new Size2f((float)msRNG.Next(0, src.Cols - (int)nPoint.X - 1), (float)msRNG.Next(0, src.Rows - (int)nPoint.Y - 1));
                    float angle = 180.0f * (float)msRNG.Next(0, 1000) / 1000.0f;
                    Scalar nextColor = new Scalar(vbc.task.vecColors[i][0], vbc.task.vecColors[i][1], vbc.task.vecColors[i][2]);
                    Cv2.Ellipse(dst2, new RotatedRect(nPoint, eSize, angle), nextColor, options.drawFilled);
                }
            }
        }
    }




    public class Draw_Circles_CS : VB_Parent
    {
        Options_Draw options = new Options_Draw();
        public Draw_Circles_CS()
        {
            desc = "Draw the requested number of circles.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                for (int i = 0; i < options.drawCount; i++)
                {
                    Point2f nPoint = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    int radius = msRNG.Next(10, 10 + msRNG.Next(src.Cols / 4));
                    Scalar nextColor = new Scalar(vbc.task.vecColors[i][0], vbc.task.vecColors[i][1], vbc.task.vecColors[i][2]);
                    DrawCircle(dst2, nPoint, radius, nextColor, options.drawFilled);
                }
            }
        }
    }




    public class Draw_Lines_CS : VB_Parent
    {
        Options_Draw options = new Options_Draw();
        public Draw_Lines_CS()
        {
            desc = "Draw the requested number of Lines.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                for (int i = 0; i < options.drawCount; i++)
                {
                    Point2f nPoint1 = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    Point2f nPoint2 = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    Scalar nextColor = new Scalar(vbc.task.vecColors[i][0], vbc.task.vecColors[i][1], vbc.task.vecColors[i][2]);
                    DrawLine(dst2, nPoint1, nPoint2, nextColor, options.drawFilled);
                }
            }
        }
    }




    public class Draw_Polygon_CS : VB_Parent
    {
        Options_Draw options = new Options_Draw();
        public Draw_Polygon_CS()
        {
            desc = "Draw Polygon figures";
            labels = new string[] { "", "", "Convex Hull for the same points", "Polylines output" };
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (!vbc.task.heartBeat) return;
            int height = src.Height / 8;
            int width = src.Width / 8;
            Scalar polyColor = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
            dst3.SetTo(Scalar.Black);
            for (int i = 0; i < options.drawCount; i++)
            {
                List<cv.Point> points = new List<cv.Point>();
                List<List<cv.Point>> listOfPoints = new List<List<cv.Point>>();
                for (int j = 0; j < 11; j++)
                {
                    points.Add(new cv.Point(msRNG.Next(width, width * 7), msRNG.Next(height, height * 7)));
                }
                listOfPoints.Add(points);
                if (options.drawFilled != -1)
                {
                    Cv2.Polylines(dst3, listOfPoints, true, polyColor, vbc.task.lineWidth + 1, vbc.task.lineType);
                }
                else
                {
                    Cv2.FillPoly(dst3, listOfPoints, new Scalar(0, 0, 255));
                }
                cv.Point[] hull = Cv2.ConvexHull(points, true);
                listOfPoints = new List<List<cv.Point>>();
                points = new List<cv.Point>();
                for (int j = 0; j < hull.Length; j++)
                {
                    points.Add(new cv.Point(hull[j].X, hull[j].Y));
                }
                listOfPoints.Add(points);
                dst2.SetTo(Scalar.Black);
                Cv2.DrawContours(dst2, listOfPoints, 0, polyColor, options.drawFilled);
            }
        }
    }




    public class Draw_Shapes_CS : VB_Parent
    {
        public Draw_Shapes_CS()
        {
            desc = "Use RNG to draw the same set of shapes every time";
        }
        public void RunAlg(Mat src)
        {
            int offsetX = 25, offsetY = 25, lineLength = 25, thickness = 2;
            dst2.SetTo(0);
            for (int i = 1; i <= 256; i++)
            {
                cv.Point p1 = new cv.Point(thickness * i + offsetX, offsetY);
                cv.Point p2 = new cv.Point(thickness * i + offsetX, offsetY + lineLength);
                Cv2.Line(dst2, p1, p2, new Scalar(i, i, i), thickness);
            }
            for (int i = 1; i <= 256; i++)
            {
                Scalar color = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                switch (msRNG.Next(0, 3))
                {
                    case 0: // circle
                        cv.Point center = new cv.Point(msRNG.Next(offsetX, dst2.Cols - offsetX), msRNG.Next(offsetY + lineLength, dst2.Rows - offsetY));
                        int radius = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        Cv2.Circle(dst2, center, radius, color, -1);
                        break;
                    case 1: // Rectangle
                        center = new cv.Point(msRNG.Next(offsetX, dst2.Cols - offsetX), msRNG.Next(offsetY + lineLength, dst2.Rows - offsetY));
                        int width = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        int height = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        cv.Rect rcenter = new cv.Rect(center.X - width, center.Y - height / 2, width, height);
                        Cv2.Rectangle(dst2, rcenter, color, -1, LineTypes.Link8);
                        break;
                    case 2: // Ellipse
                        center = new cv.Point(msRNG.Next(offsetX, dst2.Cols - offsetX), msRNG.Next(offsetY + lineLength, dst2.Rows - offsetY));
                        width = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        height = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        int angle = msRNG.Next(0, 180);
                        Cv2.Ellipse(dst2, center, new cv.Size(width / 2, height / 2), angle, 0, 360, color, -1, LineTypes.Link8);
                        break;
                }
            }
        }
    }




    public class Draw_SymmetricalShapes_CS : VB_Parent
    {
        Options_SymmetricalShapes options = new Options_SymmetricalShapes();
        public Draw_SymmetricalShapes_CS()
        {
            desc = "Generate shapes programmatically";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                cv.Point pt = new cv.Point();
                cv.Point center = new cv.Point(src.Width / 2, src.Height / 2);
                List<cv.Point> points = new List<cv.Point>();
                for (int i = 0; i < options.numPoints; i++)
                {
                    double theta = i * options.dTheta;
                    double ripple = options.radius2 * Math.Cos(options.nGenPer * theta);
                    if (!options.symmetricRipple) ripple = Math.Abs(ripple);
                    if (options.reverseInOut) ripple = -ripple;
                    pt.X = (int)(center.X + (options.radius1 + ripple) * Math.Cos(theta + options.rotateAngle) + 0.5);
                    pt.Y = (int)(center.Y - (options.radius1 + ripple) * Math.Sin(theta + options.rotateAngle) + 0.5);
                    points.Add(pt);
                }
                for (int i = 0; i < options.numPoints; i++)
                {
                    cv.Point p1 = points[i];
                    cv.Point p2 = points[(i + 1) % options.numPoints];
                    Cv2.Line(dst2, p1, p2, vbc.task.scalarColors[i % vbc.task.scalarColors.Count()], vbc.task.lineWidth + 1, vbc.task.lineType);
                }
                if (options.fillRequest) Cv2.FloodFill(dst2, center, options.fillColor);
            }
        }
    }




    public class Draw_Arc_CS : VB_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        cv.Rect rect;
        float angle;
        float startAngle;
        float endAngle;
        int colorIndex;
        int thickness;
        Options_DrawArc options = new Options_DrawArc();
        public Draw_Arc_CS()
        {
            desc = "Use OpenCV's ellipse function to draw an arc";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                rect = InitRandomRect(options.saveMargin);
                angle = msRNG.Next(0, 360);
                colorIndex = msRNG.Next(0, 255);
                thickness = msRNG.Next(1, 5);
                startAngle = msRNG.Next(1, 360);
                endAngle = msRNG.Next(1, 360);
                kalman.kInput = new[] { rect.X, rect.Y, rect.Width, rect.Height, angle, startAngle, endAngle };
            }
            kalman.kInput = new[] { rect.X, rect.Y, rect.Width, rect.Height, angle, startAngle, endAngle };
            kalman.Run(src);
            cv.Rect r = new cv.Rect((int)kalman.kOutput[0], (int)kalman.kOutput[1], (int)kalman.kOutput[2], (int)kalman.kOutput[3]);
            if (r.Width <= 5) r.Width = 5;
            if (r.Height <= 5) r.Height = 5;
            RotatedRect rr = new RotatedRect(new Point2f(r.X, r.Y), new Size2f(r.Width, r.Height), angle);
            Scalar color = vbc.task.scalarColors[colorIndex];
            dst2.SetTo(Scalar.White);
            if (options.drawFull)
            {
                Cv2.Ellipse(dst2, rr, color, thickness, vbc.task.lineType);
                DrawRotatedOutline(rr, dst2, vbc.task.scalarColors[colorIndex]);
            }
            else
            {
                angle = kalman.kOutput[4];
                startAngle = kalman.kOutput[5];
                endAngle = kalman.kOutput[6];
                if (options.drawFill) thickness = -1;
                cv.Rect r1 = rr.BoundingRect();
                Cv2.Ellipse(dst2, new cv.Point(rr.Center.X, rr.Center.Y), new cv.Size(r1.Width, r1.Height),
                            angle, startAngle, endAngle, color, thickness, vbc.task.lineType);
            }
        }
    }




    public class Draw_ClipLine_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        Kalman_Basics kalman = new Kalman_Basics();
        cv.Point pt1;
        cv.Point pt2;
        cv.Rect rect;
        int linenum = 0;
        int hitCount = 0;
        void setup()
        {
            kalman.kInput = new float[9];
            cv.Rect r = InitRandomRect(25);
            pt1 = new cv.Point(r.X, r.Y);
            pt2 = new cv.Point(r.X + r.Width, r.Y + r.Height);
            rect = InitRandomRect(25);
            if (vbc.task.gOptions.GetUseKalman()) flow.flowText.Add("--------------------------- setup ---------------------------");
        }
        public Draw_ClipLine_CS()
        {
            flow.parentData = this;
            setup();
            desc = "Demonstrate the use of the ClipLine function in Opencv. NOTE: when clipline returns true, p1/p2 are clipped by the rectangle";
        }
        public void RunAlg(Mat src)
        {
            dst3 = src;
            kalman.kInput = new float[] { pt1.X, pt1.Y, pt2.X, pt2.Y, rect.X, rect.Y, rect.Width, rect.Height };
            kalman.Run(src);
            cv.Point p1 = new cv.Point((int)kalman.kOutput[0], (int)kalman.kOutput[1]);
            cv.Point p2 = new cv.Point((int)kalman.kOutput[2], (int)kalman.kOutput[3]);
            if (kalman.kOutput[6] < 5) kalman.kOutput[6] = 5; // don't let the width/height get too small...
            if (kalman.kOutput[7] < 5) kalman.kOutput[7] = 5;
            cv.Rect r = new cv.Rect((int)kalman.kOutput[4], (int)kalman.kOutput[5], (int)kalman.kOutput[6], (int)kalman.kOutput[7]);
            bool clipped = Cv2.ClipLine(r, ref p1, ref p2); // Returns false when the line and the rectangle don't intersect.
            Cv2.Line(dst3, p1, p2, clipped ? Scalar.White : Scalar.Black, vbc.task.lineWidth + 1, vbc.task.lineType);
            Cv2.Rectangle(dst3, r, clipped ? Scalar.Yellow : Scalar.Red, vbc.task.lineWidth + 1, vbc.task.lineType);
            flow.nextMsg = $"({linenum}) line {(clipped ? "intersects rectangle" : "does not intersect rectangle")}";
            linenum++;
            hitCount += clipped ? 1 : 0;
            SetTrueText($"There were {hitCount:###,##0} intersects and {linenum - hitCount} misses",
                         new cv.Point(src.Width / 2, 200));
            if (r == rect) setup();
            flow.Run(empty);
        }
    }
    //



    //	public class CS_Draw_Hexagon : VB_Parent
    //{
    //    ImageForm alpha = new ImageForm();
    //    public CS_Draw_Hexagon()
    //    {
    //        alpha.ImagePic.Image = Image.(vbc.task.HomeDir + "Data/GestaltCube.gif");
    //        alpha.Show();
    //        alpha.Size = new System.Drawing.Size(512, 512);
    //        alpha.Text = "Perception is the key";
    //        desc = "What it means to recognize a cube.  Zygmunt Pizlo - UC Irvine";
    //    }
    //    public void RunAlg(Mat src)
    //    {
    //    }
    //}




    public class Draw_Line_CS : VB_Parent
    {
        public cv.Point p1, p2;
        public bool externalUse;
        public Draw_Line_CS()
        {
            desc = "Draw a line between the selected p1 and p2 - either by clicking twice in the image or externally providing p1 and p2.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) vbc.task.ClickPoint = new cv.Point();
            if (p1 != new cv.Point() && p2 != new cv.Point() && vbc.task.ClickPoint != new cv.Point())
            {
                p1 = new cv.Point();
                p2 = new cv.Point();
            }
            dst2 = src;
            if (vbc.task.ClickPoint != new cv.Point() || externalUse)
            {
                if (p1 == new cv.Point()) p1 = vbc.task.ClickPoint; else p2 = vbc.task.ClickPoint;
            }
            if (p1 != new cv.Point() && p2 == new cv.Point()) Cv2.Circle(dst2, p1, vbc.task.DotSize, vbc.task.HighlightColor);
            if (p1 != new cv.Point() && p2 != new cv.Point())
            {
                Cv2.Line(dst2, p1, p2, vbc.task.HighlightColor);
            }
            SetTrueText("Click twice in the image to provide the points below and they will be connected with a line\n" +
                        "P1 = " + p1.ToString() + "\nP2 = " + p2.ToString(), 3);
            vbc.task.ClickPoint = new cv.Point();
        }
    }




    public class Draw_LineTest_CS : VB_Parent
    {
        Draw_Line line = new Draw_Line();
        public Draw_LineTest_CS()
        {
            desc = "Test the external use of the Draw_Line algorithm - provide 2 points and draw the line...";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                line.p1 = new cv.Point(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height));
                line.p2 = new cv.Point(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height));
            }
            line.Run(src);
            dst2 = line.dst2;
        }
    }




    public class Draw_Frustrum_CS : VB_Parent
    {
        public Depth_WorldXYZ xyzDepth = new Depth_WorldXYZ();
        public Draw_Frustrum_CS()
        {
            xyzDepth.depthUnitsMeters = true;
            labels[3] = "Frustrum 3D pointcloud";
            desc = "Draw a frustrum for a camera viewport";
        }
        public void RunAlg(Mat src)
        {
            src = new Mat(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height), MatType.CV_32F, Scalar.All(0));
            int mid = src.Height / 2;
            float zIncr = vbc.task.MaxZmeters / mid;
            dst2 = src.Clone();
            cv.Rect fRect = new cv.Rect((src.Width - src.Height) / 2, 0, src.Height, src.Height);
            for (int i = 0; i <= src.Height / 2; i++)
            {
                cv.Cv2.Rectangle(dst2[fRect], new cv.Rect(mid - i, mid - i, i * 2, (i + 1) * 2), new Scalar(i * zIncr), 1);
            }
            xyzDepth.Run(dst2);
            dst3 = xyzDepth.dst2.Resize(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height));
        }
    }






    public class Duster_Basics_CS : VB_Parent
    {
        public Duster_MaskZ dust = new Duster_MaskZ();
        public Duster_Basics_CS()
        {
            desc = "Removed blowback in the pointcloud";
        }
        public void RunAlg(Mat src)
        {
            dust.Run(src);
            for (int i = 1; i <= dust.classCount; i++)
            {
                Mat mask = dust.dst2.InRange(i, i);
                Scalar depth = vbc.task.pcSplit[2].Mean(mask);
                vbc.task.pcSplit[2].SetTo(depth[0], mask);
            }
            Cv2.Merge(vbc.task.pcSplit, dst2);
            dst2.SetTo(0, ~dust.dst0);
            dst2.SetTo(0, vbc.task.maxDepthMask);
            dst3 = dust.dst3;
        }
    }




    public class Duster_MaskZ_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public int classCount;
        public Options_GuidedBPDepth options = new Options_GuidedBPDepth();
        public Duster_MaskZ_CS()
        {
            labels[3] = "Any flickering below is from changes in the sorted order of the clusters.  It should not be a problem.";
            desc = "Build a histogram that finds the clusters of depth data";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            hist.bins = options.bins;
            Mat src32f = vbc.task.pcSplit[2];
            vbc.task.maxDepthMask = src32f.InRange(vbc.task.MaxZmeters, vbc.task.MaxZmeters).ConvertScaleAbs();
            src32f.SetTo(vbc.task.MaxZmeters, vbc.task.maxDepthMask);
            hist.fixedRanges = new[] { new Rangef(0.001f, vbc.task.MaxZmeters) };
            hist.Run(src32f);
            List<float> histArray = hist.histArray.ToList();
            // This ensures that the maxDepthMask is separate from any previous cluster
            histArray[histArray.Count - 1] = 0;
            int start = 0;
            SortedList<int, Vec2i> clusters = new SortedList<int, Vec2i>(new compareAllowIdenticalIntegerInverted());
            float lastEntry = 0;
            int sampleCount = 0;
            for (int i = 0; i < histArray.Count; i++)
            {
                if (histArray[i] > 0 && lastEntry == 0) start = i;
                if (histArray[i] == 0 && lastEntry > 0)
                {
                    clusters.Add(sampleCount, new Vec2i(start, i));
                    sampleCount = 0;
                }
                lastEntry = histArray[i];
                sampleCount += (int)histArray[i];
            }
            float incr = vbc.task.MaxZmeters / options.bins;
            classCount = 0;
            for (int i = 0; i < Math.Min(clusters.Count, options.maxClusters); i++)
            {
                Vec2i vec = clusters.ElementAt(i).Value;
                classCount++;
                for (int j = vec[0]; j <= vec[1]; j++)
                {
                    histArray[j] = classCount;
                }
            }
            Marshal.Copy(histArray.ToArray(), 0, hist.histogram.Data, histArray.Count);
            Cv2.CalcBackProject(new[] { src32f }, new[] { 0 }, hist.histogram, dst1, hist.ranges);
            dst1.ConvertTo(dst2, MatType.CV_8U);
            classCount++;
            dst2.SetTo(classCount, vbc.task.maxDepthMask);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            if (vbc.task.heartBeat) labels[2] = $"dst2 = CV_8U version of depth segmented into {classCount} clusters.";
            dst0 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }




    public class Duster_BasicsY_CS : VB_Parent
    {
        Duster_MaskZ dust = new Duster_MaskZ();
        public Duster_BasicsY_CS()
        {
            desc = "Removed blowback in the pointcloud";
        }
        public void RunAlg(Mat src)
        {
            dust.Run(src);
            for (int i = 1; i <= dust.classCount; i++)
            {
                Mat mask = dust.dst2.InRange(i, i);
                Scalar pcY = vbc.task.pcSplit[1].Mean(mask);
                vbc.task.pcSplit[1].SetTo(pcY[0], mask);
            }
            Cv2.Merge(vbc.task.pcSplit, dst2);
            dst2.SetTo(0, ~dust.dst0);
            dst2.SetTo(0, vbc.task.maxDepthMask);
            dst3 = dust.dst3;
        }
    }




    public class Duster_RedCloud_CS : VB_Parent
    {
        Duster_Basics duster = new Duster_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Duster_RedCloud_CS()
        {
            desc = "Run Bin3Way_RedCloud on the largest regions identified in Duster_Basics";
        }
        public void RunAlg(Mat src)
        {
            duster.Run(src);
            dst1 = duster.dust.dst2.InRange(1, 1);
            dst3.SetTo(0);
            src.CopyTo(dst3, dst1);
            redC.inputMask = ~dst1;
            redC.Run(dst3);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }





    public class Edge_DepthAndColor_CS : VB_Parent
    {
        Depth_Holes shadow = new Depth_Holes();
        Edge_Canny canny = new Edge_Canny();
        Dilate_Basics dilate = new Dilate_Basics();
        public Edge_DepthAndColor_CS()
        {
            FindRadio("Dilate shape: Rect").Checked = true;
            FindSlider("Canny threshold1").Value = 100;
            FindSlider("Canny threshold2").Value = 100;
            desc = "Find all the edges in an image include Canny from the grayscale image and edges of depth shadow.";
            labels[2] = "Edges in color and depth after dilate";
            labels[3] = "Edges in color and depth no dilate";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(src);
            shadow.Run(src);
            dst3 = shadow.dst3.Channels() != 1 ? shadow.dst3.CvtColor(ColorConversionCodes.BGR2GRAY) : shadow.dst3;
            dst3 += canny.dst2.Threshold(1, 255, ThresholdTypes.Binary);
            dilate.Run(dst3);
            dilate.dst2.SetTo(0, shadow.dst2);
            dst2 = dilate.dst2;
        }
    }
    public class Edge_Scharr_CS : VB_Parent
    {
        Options_Edges options = new Options_Edges();
        public Edge_Scharr_CS()
        {
            labels[3] = "x field + y field in CV_32F format";
            desc = "Scharr is most accurate with 3x3 kernel.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var xField = gray.Scharr(MatType.CV_32FC1, 1, 0);
            var yField = gray.Scharr(MatType.CV_32FC1, 0, 1);
            Cv2.Add(xField, yField, dst3);
            dst3.ConvertTo(dst2, MatType.CV_8U, options.scharrMultiplier);
        }
    }
    public class Edge_Preserving_CS : VB_Parent
    {
        Options_Edges options = new Options_Edges();
        public Edge_Preserving_CS()
        {
            labels[3] = "Edge preserving blur for BGR depth image above";
            desc = "OpenCV's edge preserving filter.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.recurseCheck)
            {
                Cv2.EdgePreservingFilter(src, dst2, EdgePreservingMethods.RecursFilter, (float)options.EP_Sigma_s,
                                        (float)options.EP_Sigma_r);
            }
            else
            {
                Cv2.EdgePreservingFilter(src, dst2, EdgePreservingMethods.NormconvFilter, (float)options.EP_Sigma_s,
                                        (float)options.EP_Sigma_r);
            }
            if (options.recurseCheck)
            {
                Cv2.EdgePreservingFilter(vbc.task.depthRGB, dst3, EdgePreservingMethods.RecursFilter, (float)options.EP_Sigma_s,
                                        (float)options.EP_Sigma_r);
            }
            else
            {
                Cv2.EdgePreservingFilter(vbc.task.depthRGB, dst3, EdgePreservingMethods.NormconvFilter, (float)options.EP_Sigma_s,
                                        (float)options.EP_Sigma_r);
            }
        }
    }
    public class Edge_RandomForest_CPP_CS : VB_Parent
    {
        byte[] rgbData;
        Options_Edges2 options = new Options_Edges2();
        public Edge_RandomForest_CPP_CS()
        {
            desc = "Detect edges using structured forests - Opencv Contrib";
            rgbData = new byte[dst2.Total() * dst2.ElemSize()];
            labels[3] = "Thresholded Edge Mask (use slider to adjust)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.frameCount < 100)
                SetTrueText("On the first call only, it takes a few seconds to load the randomForest model.", new cv.Point(10, 100));
            if (vbc.task.frameCount == 5)
            {
                var modelInfo = new FileInfo(vbc.task.HomeDir + "Data/model.yml.gz");
                cPtr = Edge_RandomForest_Open(modelInfo.FullName);
            }
            if (vbc.task.frameCount > 5)
            {
                Marshal.Copy(src.Data, rgbData, 0, rgbData.Length);
                var handleRGB = GCHandle.Alloc(rgbData, GCHandleType.Pinned);
                var imagePtr = Edge_RandomForest_Run(cPtr, handleRGB.AddrOfPinnedObject(), src.Rows, src.Cols);
                handleRGB.Free();
                dst3 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Threshold(options.edgeRFthreshold, 255, ThresholdTypes.Binary);
            }
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0)
                cPtr = Edge_RandomForest_Close(cPtr);
        }
    }
    public class Edge_DCTfrequency_CS : VB_Parent
    {
        Options_Edges2 options = new Options_Edges2();
        public Edge_DCTfrequency_CS()
        {
            labels[3] = "Mask for the isolated frequencies";
            desc = "Find edges by removing all the highest frequencies.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var gray = vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            var frequencies = new Mat();
            var src32f = new Mat();
            gray.ConvertTo(src32f, MatType.CV_32F, 1 / 255.0);
            Cv2.Dct(src32f, frequencies, DctFlags.None);
            var roi = new cv.Rect(0, 0, options.removeFrequencies, src32f.Height);
            if (roi.Width > 0) frequencies[roi].SetTo(0);
            labels[2] = "Highest " + options.removeFrequencies + " frequencies removed from RGBDepth";
            Cv2.Dct(frequencies, src32f, DctFlags.Inverse);
            src32f.ConvertTo(dst2, MatType.CV_8UC1, 255);
            dst3 = dst2.Threshold(options.dctThreshold, 255, ThresholdTypes.Binary);
        }
    }
    public class Edge_Deriche_CPP_CS : VB_Parent
    {
        Options_Edges3 options = new Options_Edges3();
        public Edge_Deriche_CPP_CS()
        {
            cPtr = Edge_Deriche_Open();
            labels[3] = "Image enhanced with Deriche results";
            desc = "Edge detection using the Deriche X and Y gradients";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            var handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            var imagePtr = Edge_Deriche_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols,
                                           (float)options.alpha, (float)options.omega);
            handleSrc.Free();
            if (imagePtr != (IntPtr)0)
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
            dst3 = src | dst2;
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0)
                cPtr = Edge_Deriche_Close(cPtr);
        }
    }
    public class Edge_DCTinput_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        DCT_FeatureLess dct = new DCT_FeatureLess();
        public Edge_DCTinput_CS()
        {
            labels[2] = "Canny edges produced from original grayscale image";
            labels[3] = "Edges produced with featureless regions cleared";
            desc = "Use the featureless regions to enhance the edge detection";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2.Clone();
            dct.Run(src);
            var tmp = src.SetTo(Scalar.White, dct.dst2);
            edges.Run(tmp);
            dst3 = edges.dst2;
        }
    }
    public class Edge_Consistent_CS : VB_Parent
    {
        Bin4Way_Sobel edges = new Bin4Way_Sobel();
        List<Mat> saveFrames = new List<Mat>();
        public Edge_Consistent_CS()
        {
            FindSlider("Sobel kernel Size").Value = 5;
            desc = "Edges that are consistent for x number of frames";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) saveFrames = new List<Mat>();
            edges.Run(src);
            Mat tmp = edges.dst2.Channels() == 1 ? edges.dst2.Clone() : edges.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            saveFrames.Add(tmp);
            if (saveFrames.Count() > vbc.task.frameHistoryCount) saveFrames.RemoveAt(0);
            dst2 = saveFrames[0];
            for (int i = 1; i < saveFrames.Count(); i++)
            {
                dst2 = saveFrames[i] & dst2;
            }
            dst3.SetTo(0);
            src.CopyTo(dst3, ~edges.dst3);
        }
    }
    public class Edge_BinarizedReduction_CS : VB_Parent
    {
        Bin4Way_Sobel edges = new Bin4Way_Sobel();
        Reduction_Basics reduction = new Reduction_Basics();
        public Edge_BinarizedReduction_CS()
        {
            desc = "Visualize the impact of reduction on Edge_BinarizeSobel";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst3 = reduction.dst2;
            edges.Run(dst3);
            dst2 = edges.dst2;
        }
    }
    public class Edge_BinarizedBrightness_CS : VB_Parent
    {
        Edge_Basics edges = new Edge_Basics();
        Brightness_Basics bright = new Brightness_Basics();
        public Edge_BinarizedBrightness_CS()
        {
            FindRadio("Binarized Sobel").Checked = true;
            desc = "Visualize the impact of brightness on Bin4Way_Sobel";
        }
        public void RunAlg(Mat src)
        {
            bright.Run(src);
            dst2 = bright.dst3;
            edges.Run(bright.dst3);
            dst3 = edges.dst2;
            labels[3] = edges.labels[2];
        }
    }
    public class Edge_SobelLRBinarized_CS : VB_Parent
    {
        Bin4Way_Sobel edges = new Bin4Way_Sobel();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public Edge_SobelLRBinarized_CS()
        {
            labels = new string[] { "", "", "Horizontal Sobel - Left View", "Horizontal Sobel - Right View" };
            desc = "Isolate edges in the left and right views.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.mouseClickFlag) vbc.task.mouseClickFlag = false; // preempt use of quadrants.
            edges.Run(vbc.task.rightView);
            if (standaloneTest())
            {
                addw.src2 = edges.dst3;
                addw.Run(vbc.task.rightView);
                dst3 = addw.dst2.Clone();
            }
            else
            {
                dst3 = edges.dst3.Clone();
            }
            edges.Run(vbc.task.leftView);
            if (standaloneTest())
            {
                addw.src2 = edges.dst3;
                addw.Run(vbc.task.leftView);
                dst2 = addw.dst2;
            }
            else
            {
                dst2 = edges.dst3;
            }
        }
    }
    public class Edge_Matching_CS : VB_Parent
    {
        Match_Basics match = new Match_Basics();
        List<int> redRects = new List<int>();
        Options_EdgeMatching options = new Options_EdgeMatching();
        public Edge_Matching_CS()
        {
            desc = "Match edges in the left and right views to determine distance";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = vbc.task.leftView;
            dst3 = vbc.task.rightView;
            int[] maxLocs = new int[vbc.task.gridRects.Count()];
            List<int> highlights = new List<int>();
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                int width = roi.X + roi.Width + options.searchDepth < dst2.Width ? roi.Width + options.searchDepth : dst2.Width - roi.X - 1;
                var searchROI = new cv.Rect(roi.X, roi.Y, width, roi.Height);
                match.template = dst3[roi];
                match.Run(dst2[searchROI]);
                maxLocs[i] = match.matchRect.X;
                if (match.correlation > options.threshold || redRects.Contains(i))
                {
                    highlights.Add(i);
                    SetTrueText(match.correlation.ToString("F2"), new cv.Point(roi.X, roi.Y), 3);
                }
            }
            if (options.overlayChecked)
            {
                dst2.SetTo(255, vbc.task.gridMask);
                dst3.SetTo(255, vbc.task.gridMask);
            }
            dst2 = dst2.Channels() == 3 ? dst2 : dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3 = dst3.Channels() == 3 ? dst3 : dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            if (options.highlightChecked)
            {
                labels[2] = "Matched grid segments in dst3 with disparity";
                foreach (var i in highlights)
                {
                    var roi = vbc.task.gridRects[i];
                    dst3.Rectangle(roi, Scalar.Red, 2);
                    roi.X += maxLocs[i];
                    dst2.Rectangle(roi, Scalar.Red, 2);
                    SetTrueText(maxLocs[i].ToString(), new cv.Point(roi.X, roi.Y), 2);
                }
            }
            else
            {
                labels[2] = "Click in dst3 to highlight segment in dst2";
                if (options.clearChecked)
                {
                    redRects.Clear();
                    vbc.task.gridROIclicked = 0;
                    options.clearChecked = false;
                }
                if (vbc.task.gridROIclicked > 0)
                {
                    if (!redRects.Contains(vbc.task.gridROIclicked)) redRects.Add(vbc.task.gridROIclicked);
                    foreach (var i in redRects)
                    {
                        var roi = vbc.task.gridRects[i];
                        dst3.Rectangle(roi, Scalar.Red, 2);
                        roi.X += maxLocs[i];
                        dst2.Rectangle(roi, Scalar.Red, 2);
                        SetTrueText(maxLocs[i].ToString(), new cv.Point(roi.X, roi.Y), 2);
                    }
                }
            }
            labels[3] = "Grid segments > " + options.threshold.ToString("P0") + " correlation coefficient";
        }
    }
    public class Edge_RGB_CS : VB_Parent
    {
        Edge_Sobel sobel = new Edge_Sobel();
        public Edge_RGB_CS()
        {
            desc = "Combine the edges from all 3 channels";
        }
        public void RunAlg(Mat src)
        {
            Mat img32f = new Mat();
            src.ConvertTo(img32f, MatType.CV_32FC3);
            var split = img32f.Split();
            for (int i = 0; i < 3; i++)
            {
                split[i] = split[i].Normalize(0, 255, NormTypes.MinMax);
            }
            Cv2.Merge(split, img32f);
            img32f.ConvertTo(dst2, MatType.CV_8UC3);
            for (int i = 0; i < 3; i++)
            {
                sobel.Run(split[i]);
                split[i] = cv.Scalar.All(255) - sobel.dst2;
            }
            Cv2.Merge(split, dst2);
        }
    }
    public class Edge_HSV_CS : VB_Parent
    {
        Edge_RGB edges = new Edge_RGB();
        public Edge_HSV_CS()
        {
            desc = "Combine the edges from all 3 HSV channels";
        }
        public void RunAlg(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            edges.Run(hsv);
            dst2 = edges.dst2;
        }
    }
    public class Edge_SobelLR_CS : VB_Parent
    {
        Edge_Sobel sobel = new Edge_Sobel();
        public Edge_SobelLR_CS()
        {
            FindSlider("Sobel kernel Size").Value = 3;
            desc = "Find the edges in the LeftViewimages.";
            labels = new string[] { "", "", "Edges in Left Image", "Edges in Right Image (except on Kinect 4 Azure)" };
        }
        public void RunAlg(Mat src)
        {
            sobel.Run(vbc.task.rightView);
            dst3 = sobel.dst2.Clone();
            sobel.Run(vbc.task.leftView);
            dst2 = sobel.dst2;
        }
    }
    public class Edge_ColorGap_CPP_CS : VB_Parent
    {
        Edge_ColorGap_VB gap = new Edge_ColorGap_VB();
        TrackBar distanceSlider;
        TrackBar diffSlider;
        public Edge_ColorGap_CPP_CS()
        {
            distanceSlider = FindSlider("Input pixel distance");
            diffSlider = FindSlider("Input pixel difference");
            cPtr = Edge_ColorGap_Open();
            desc = "Using grayscale image to identify color gaps which imply an edge - C++ version";
        }
        public void RunAlg(Mat src)
        {
            int diff = diffSlider.Value;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Edge_ColorGap_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, distanceSlider.Value & 254, diff);
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero) dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
            dst3.SetTo(0);
            src.CopyTo(dst3, ~dst2);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Edge_ColorGap_Close(cPtr);
        }
    }
    public class Edge_ColorGap_CS : VB_Parent
    {
        Options_Edges3 options = new Options_Edges3();
        public Edge_ColorGap_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Vertical and Horizontal edges", "Vertical edges", "Horizontal edges" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Using grayscale image to identify color gaps which imply an edge - C# edition";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            dst2.SetTo(0);
            int half = options.gapDistance / 2;
            int pix1, pix2;
            for (int y = 0; y < dst1.Height; y++)
            {
                for (int x = options.gapDistance; x < dst1.Width - options.gapDistance; x++)
                {
                    pix1 = src.At<byte>(y, x);
                    pix2 = src.At<byte>(y, x + options.gapDistance);
                    if (Math.Abs(pix1 - pix2) >= options.gapdiff) dst2.Set<byte>(y, x + half, 255);
                }
            }
            dst3.SetTo(0);
            for (int y = options.gapDistance; y < dst1.Height - options.gapDistance; y++)
            {
                for (int x = 0; x < dst1.Width; x++)
                {
                    pix1 = src.At<byte>(y, x);
                    pix2 = src.At<byte>(y + options.gapDistance, x);
                    if (Math.Abs(pix1 - pix2) >= options.gapdiff) dst3.Set<byte>(y + half, x, 255);
                }
            }
            dst1 = dst2 | dst3;
        }
    }
    public class Edge_DepthGap_Native_CS : VB_Parent
    {
        Options_DepthEdges options = new Options_DepthEdges();
        public Edge_DepthGap_Native_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Vertical and Horizontal edges", "Vertical edges", "Horizontal edges" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Using depth image to identify gaps which imply an edge";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() != 1) src = vbc.task.pcSplit[2];
            dst2.SetTo(0);
            int half = options.depthDist / 2;
            float pix1, pix2;
            for (int y = 0; y < src.Height; y++)
            {
                for (int x = options.depthDist; x < src.Width - options.depthDist; x++)
                {
                    pix1 = src.At<float>(y, x);
                    pix2 = src.At<float>(y, x + options.depthDist);
                    if (Math.Abs(pix1 - pix2) >= options.mmDepthDiff) dst2.Set<byte>(y, x + half, 255);
                }
            }
            dst3.SetTo(0);
            for (int y = options.depthDist; y < src.Height - options.depthDist; y++)
            {
                for (int x = 0; x < src.Width; x++)
                {
                    pix1 = src.At<float>(y, x);
                    pix2 = src.At<float>(y + options.depthDist, x);
                    if (Math.Abs(pix1 - pix2) >= options.mmDepthDiff) dst3.Set<byte>(y + half, x, 255);
                }
            }
            dst1 = dst2 | dst3;
        }
    }
    public class Edge_DepthGap_CPP_CS : VB_Parent
    {
        Options_DepthEdges options = new Options_DepthEdges();
        public Edge_DepthGap_CPP_CS()
        {
            cPtr = Edge_DepthGap_Open();
            desc = "Create edges wherever depth differences are greater than x";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Type() != MatType.CV_32FC1) src = vbc.task.pcSplit[2];
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Edge_DepthGap_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.mmDepthDiff);
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero) dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Edge_DepthGap_Close(cPtr);
        }
    }
    public class Edge_CannyMin_CS : VB_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        public Edge_CannyMin_CS()
        {
            FindSlider("Canny threshold1").Value = 200;
            FindSlider("Canny threshold2").Value = 200;
            desc = "Set the max thresholds for Canny to get the minimum number of edge pixels";
            labels[2] = "Essential lines in the image - minimum number of pixels in Canny output";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(src);
            dst2 = canny.dst2;
        }
    }
    public class Edge_CannyLeftRight_CS : VB_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        public Edge_CannyLeftRight_CS()
        {
            FindSlider("Canny threshold1").Value = 200;
            FindSlider("Canny threshold2").Value = 200;
            labels = new string[] { "", "", "Essential lines in the left image", "Essential lines in the right image" };
            desc = "Set the max thresholds for Canny to get the minimum number of edge pixels for the left and right images.";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(vbc.task.leftView);
            dst2 = canny.dst2.Clone();
            canny.Run(vbc.task.rightView);
            dst3 = canny.dst2;
        }
    }
    public class Edge_Reduction_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Edge_Canny edge = new Edge_Canny();
        public Edge_Reduction_CS()
        {
            vbc.task.redOptions.setSimpleReductionBar(1);
            labels = new string[] { "", "", "Edges in the Reduction output", "Reduction_Basics output" };
            desc = "Find edges in the reduction image.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst3 = reduction.dst2;
            edge.Run(dst3);
            dst2 = edge.dst2;
        }
    }
    public class Edge_Regions_CS : VB_Parent
    {
        Depth_Tiers tiers = new Depth_Tiers();
        Edge_Canny edge = new Edge_Canny();
        public Edge_Regions_CS()
        {
            FindSlider("Canny threshold2").Value = 30;
            labels = new string[] { "", "", "Edge_Canny output for the depth regions", "Identified regions " };
            desc = "Find the edges for the depth tiers.";
        }
        public void RunAlg(Mat src)
        {
            tiers.Run(src);
            dst3 = tiers.dst3;
            edge.Run(dst3.CvtColor(cv.ColorConversionCodes.BGR2GRAY));
            dst2 = edge.dst2;
        }
    }
    public class Edge_Canny_CS : VB_Parent
    {
        Options_Canny options = new Options_Canny();
        public Edge_Canny_CS()
        {
            labels = new string[] { "", "", "Canny using L1 Norm", "Canny using L2 Norm" };
            desc = "Show canny edge detection with varying thresholds";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (src.Type() != MatType.CV_8U) src.ConvertTo(src, MatType.CV_8U);
            dst2 = src.Canny(options.threshold1, options.threshold2, options.aperture, true);
            // dst3 = src.Canny(options.threshold1, options.threshold2, options.aperture, false);
        }
    }
    public class Edge_CannyHistory_CS : VB_Parent
    {
        Options_Canny options = new Options_Canny();
        List<Mat> frameList = new List<Mat>();
    public Edge_CannyHistory_CS()
        {
            labels = new string[] { "", "", "Canny using L1 Norm", "" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Show canny edge over the last X frame (see global option 'FrameHistory')";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = src.Canny(options.threshold1, options.threshold2, options.aperture, true);
            if (vbc.task.optionsChanged) frameList.Clear();
            frameList.Add(dst2);
            dst3.SetTo(0);
            foreach (var m in frameList)
            {
                dst3 = dst3 | m;
            }
            if (frameList.Count() >= vbc.task.frameHistoryCount) frameList.RemoveAt(0);
        }
    }
    public class Edge_ResizeAdd_CS : VB_Parent
    {
        Options_Edges4 options = new Options_Edges4();
        public Edge_ResizeAdd_CS()
        {
            desc = "Find edges using a resize, subtract, and threshold.";
            labels[2] = "Edges found with just resizing";
            labels[3] = "Found edges added to grayscale image source.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat gray = src;
            if (src.Channels() == 3) gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat newFrame = gray[new cv.Range(options.vertPixels, gray.Rows - options.vertPixels),
                                 new cv.Range(options.horizPixels, gray.Cols - options.horizPixels)];
            newFrame = newFrame.Resize(gray.Size(), 0, 0, InterpolationFlags.Nearest);
            Cv2.Absdiff(gray, newFrame, dst2);
            dst2 = dst2.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            Cv2.Add(gray, dst2, dst3);
        }
    }
    public class Edge_CannyCombined_CS : VB_Parent
    {
        Edge_CannyHistory canny = new Edge_CannyHistory();
        Edge_ResizeAdd edges = new Edge_ResizeAdd();
        public Edge_CannyCombined_CS()
        {
            desc = "Combine the results of Edge_ResizeAdd and Canny";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(src);
            edges.Run(canny.dst2);
            dst2 = canny.dst2 | edges.dst2;
        }
    }
    public class Edge_SobelCustomV_CS : VB_Parent
    {
        public Edge_SobelCustomV_CS()
        {
            labels = new string[] { "", "", "Sobel Custom 1", "Sobel Custom 2" };
            desc = "Show Sobel edge detection a custom vertical kernel";
        }
        public void RunAlg(Mat src)
        {
            dst1 = src.Filter2D(MatType.CV_32F, cv.Mat.FromPixelData(3, 3, MatType.CV_32FC1, new float[] { 1, 0, -1, 2, 0, -2, 1, 0, -1 }));
            dst1.ConvertTo(dst2, src.Type());
            dst1 = src.Filter2D(MatType.CV_32F, cv.Mat.FromPixelData(3, 3, MatType.CV_32FC1, new float[] { 3, 0, -3, 10, 0, -10, 3, 0, -3 }));
            dst1.ConvertTo(dst3, src.Type());
        }
    }
    public class Edge_SobelCustomH_CS : VB_Parent
    {
        public Edge_SobelCustomH_CS()
        {
            labels = new string[] { "", "", "Sobel Custom 1", "Sobel Custom 2" };
            desc = "Show Sobel edge detection a custom horizontal kernel";
        }
        public void RunAlg(Mat src)
        {
            dst1 = src.Filter2D(MatType.CV_32F, cv.Mat.FromPixelData(3, 3, MatType.CV_32FC1, new float[] { 1, 2, 1, 0, 0, 0, -1, -2, -1 }));
            dst1.ConvertTo(dst2, src.Type());
            dst1 = src.Filter2D(MatType.CV_32F, cv.Mat.FromPixelData(3, 3, MatType.CV_32FC1, new float[] { 3, 10, 3, 0, 0, 0, -3, -10, -3 }));
            dst1.ConvertTo(dst3, src.Type());
        }
    }
    public class Edge_SobelCustom_CS : VB_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        Edge_SobelCustomV edgesV = new Edge_SobelCustomV();
        Edge_SobelCustomH edgesH = new Edge_SobelCustomH();
        Options_Edges4 options = new Options_Edges4();
        public Edge_SobelCustom_CS()
        {
            labels = new string[] { "", "", "Sobel Custom 1", "Sobel Custom 2" };
            desc = "Show Sobel edge detection with custom horizont and vertical kernels";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.horizonCheck)
            {
                edgesH.Run(src);
                dst2 = edgesH.dst2;
                dst3 = edgesH.dst3;
            }
            if (options.verticalCheck) edgesV.Run(src);
            if (options.horizonCheck && options.verticalCheck)
            {
                addw.src2 = edgesV.dst2;
                addw.Run(dst2);
                dst2 = addw.dst2;
                addw.src2 = edgesV.dst3;
                addw.Run(dst3);
                dst3 = addw.dst2;
            }
            else if (options.verticalCheck)
            {
                dst2 = edgesV.dst2.Clone();
                dst3 = edgesV.dst3.Clone();
            }
        }
    }
    public class Edge_SobelCustomLeftRight_CS : VB_Parent
    {
        Edge_SobelCustom custom = new Edge_SobelCustom();
        public Edge_SobelCustomLeftRight_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "Left Image Custom 1", "Left Image Custom 2", "Right Image Custom 1", "Right Image Custom 2" };
            desc = "Show Sobel edge detection for both left and right images";
        }
        public void RunAlg(Mat src)
        {
            custom.Run(vbc.task.leftView);
            dst0 = custom.dst2.Clone();
            dst1 = custom.dst3.Clone();
            custom.Run(vbc.task.rightView);
            dst2 = custom.dst2;
            dst3 = custom.dst3;
        }
    }
    public class Edge_BackProjection_CS : VB_Parent
    {
        HistValley_OptionsAuto valley = new HistValley_OptionsAuto();
        Edge_Canny canny = new Edge_Canny();
        public Edge_BackProjection_CS()
        {
            labels[3] = "Canny edges in grayscale (red) and edges in back projection (blue)";
            desc = "Find the edges in the HistValley_FromPeaks backprojection";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(src);
            dst1 = canny.dst2.Clone();
            valley.Run(src);
            dst2 = valley.dst1;
            canny.Run(valley.dst1);
            int offset = 1;
            cv.Rect r1 = new cv.Rect(offset, offset, dst2.Width - offset - 1, dst2.Height - offset - 1);
            cv.Rect r2 = new cv.Rect(0, 0, dst2.Width - offset - 1, dst2.Height - offset - 1);
            dst3.SetTo(Scalar.White);
            dst3[r1].SetTo(Scalar.Blue, canny.dst2[r2]);
            dst3.SetTo(Scalar.Red, dst1);
            labels[2] = valley.labels[3];
        }
    }
    public class Edge_Sobel_CS : VB_Parent
    {
        public AddWeighted_Basics addw = new AddWeighted_Basics();
        Options_Sobel options = new Options_Sobel();
        public Edge_Sobel_CS()
        {
            desc = "Show Sobel edge detection with varying kernel sizes";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst0 = src.Sobel(MatType.CV_32F, 1, 0, options.kernelSize);
            if (options.horizontalDerivative && options.verticalDerivative)
            {
                dst1 = src.Sobel(MatType.CV_32F, 0, 1, options.kernelSize);
                if (standaloneTest())
                {
                    addw.src2 = dst1;
                    addw.Run(dst0);
                    dst2 = addw.dst2.ConvertScaleAbs();
                }
                else
                {
                    Mat tmp = dst1 + dst0;
                    dst2 = tmp.ConvertScaleAbs();
                }
            }
            else
            {
                dst2 = dst0.ConvertScaleAbs();
            }
        }
    }
    public class Edge_Laplacian_CS : VB_Parent
    {
        Options_LaplacianKernels options = new Options_LaplacianKernels();
        public Edge_Laplacian_CS()
        {
            labels[3] = "Laplacian of DepthRGB";
            desc = "Show Laplacian edge detection with varying kernel sizes";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.GaussianBlur(new cv.Size((int)options.gaussiankernelSize, (int)options.gaussiankernelSize), 0, 0);
            dst2 = dst2.Laplacian(MatType.CV_8U, options.LaplaciankernelSize, 1, 0);
            dst2 = dst2.ConvertScaleAbs();
            dst3 = vbc.task.depthRGB.GaussianBlur(new cv.Size((int)options.gaussiankernelSize, (int)options.gaussiankernelSize), 0, 0);
            dst3 = dst3.Laplacian(MatType.CV_8U, options.LaplaciankernelSize, 1, 0);
            dst3 = dst3.ConvertScaleAbs();
        }
    }
    public class Edge_SobelHorizontal_CS : VB_Parent
    {
        Edge_Sobel edges = new Edge_Sobel();
        TrackBar thresholdSlider;
        public Edge_SobelHorizontal_CS()
        {
            thresholdSlider = FindSlider("Threshold to zero pixels below this value");
            FindCheckBox("Vertical Derivative").Checked = false;
            FindCheckBox("Horizontal Derivative").Checked = true;
            desc = "Find edges with Sobel only in the horizontal direction";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2.Threshold(thresholdSlider.Value, 255, ThresholdTypes.Binary);
        }
    }
    public class Edge_MotionFrames_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        History_Basics frames = new History_Basics();
        public Edge_MotionFrames_CS()
        {
            labels = new string[] { "", "", "The multi-frame edges output", "The Edge_Canny output for the last frame only" };
            FindSlider("Canny threshold1").Value = 50;
            FindSlider("Canny threshold2").Value = 50;
            desc = "Collect edges over several frames controlled with global frame history";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(src);
            dst3 = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            frames.Run(edges.dst2);
            dst2 = frames.dst2;
        }
    }
    public class Edge_MotionOverlay_CS : VB_Parent
    {
        Options_EdgeOverlay options = new Options_EdgeOverlay();
        Mat offsetImage = new cv.Mat();
        public Edge_MotionOverlay_CS()
        {
            labels[3] = "AbsDiff output of offset with original";
            desc = "Find edges by displacing the current BGR image in any direction and diff it with the original.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) offsetImage = src.Clone();
            var rect1 = new cv.Rect(options.xDisp, options.yDisp, dst2.Width - options.xDisp - 1, dst2.Height - options.yDisp - 1);
            var rect2 = new cv.Rect(0, 0, dst2.Width - options.xDisp - 1, dst2.Height - options.yDisp - 1);
            offsetImage[rect2] = src[rect1].Clone();
            Cv2.Absdiff(src, offsetImage, dst0);
            dst2 = dst0.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            labels[2] = "Src offset (x,y) = (" + options.xDisp.ToString() + "," + options.yDisp.ToString() + ")";
            offsetImage = src.Clone();
        }
    }





    public class Edge_Color8U_CS : VB_Parent
    {
        public object[] colorMethods = {
        new BackProject_Full(), new BackProject2D_Full(), new Bin4Way_Regions(),
        new Binarize_DepthTiers(), new FeatureLess_Groups(), new Hist3Dcolor_Basics(),
        new KMeans_Basics(), new LUT_Basics(), new Reduction_Basics(), new PCA_NColor_CPP_VB()
    };
        Edge_Canny canny = new Edge_Canny();
        Options_ColorMethod options = new Options_ColorMethod();
        System.Windows.Forms.Form frmCheck;
        public Edge_Color8U_CS()
        {
            frmCheck = vbc.FindFrm("Options_ColorMethod CheckBoxes");
            dst2 = new Mat(dst2.Size(), MatType.CV_8U);
            dst3 = new Mat(dst3.Size(), MatType.CV_8U);
            labels = new string[] { "", "", "The 'OR' of each selected method", "The 'AND' of each selected method" };
            desc = "Find edges in a variety of Color8U algorithms then find the edges common to all.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.FirstPass)
                frmCheck.Left = vbc.task.gOptions.Width / 2;
            dst2.SetTo(0);
            dst3.SetTo(0);
            bool initdst3 = false;
            for (int i = 0; i < colorMethods.Length; i++)
            {
                if (options.check.Box[i].Checked)
                {
                    ((dynamic)colorMethods[i]).Run(src);
                    if (options.check.Box[i].Text == "FeatureLess_Groups")
                    {
                        canny.dst2 = ((dynamic)colorMethods[i]).dst2;
                    }
                    else
                    {
                        canny.Run(((dynamic)colorMethods[i]).dst3);
                    }
                    Cv2.BitwiseOr(dst2, canny.dst2, dst2);
                    if (!initdst3)
                    {
                        canny.dst2.CopyTo(dst3);
                        initdst3 = true;
                    }
                    else
                    {
                        Cv2.BitwiseAnd(dst3, canny.dst2, dst3);
                    }
                }
            }
        }
    }





    public class EdgeDraw_Basics_CPP_CS : VB_Parent
    {
        public EdgeDraw_Basics_CPP_CS()
        {
            cPtr = EdgeDraw_Edges_Open();
            labels = new string[] { "", "", "EdgeDraw_Basics_CS output", "" };
            desc = "Access the EdgeDraw algorithm directly rather than through to CPP_Basics interface - more efficient";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = EdgeDraw_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, vbc.task.lineWidth);
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero)
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
            Cv2.Rectangle(dst2, new cv.Rect(0, 0, dst2.Width, dst2.Height), new Scalar(255), vbc.task.lineWidth);
        }
        public void Close()
        {
            EdgeDraw_Edges_Close(cPtr);
        }
    }




    public class EdgeDraw_Segments_CPP_CS : VB_Parent
    {
        public List<cv.Point2f> segPoints = new List<cv.Point2f>();
        public EdgeDraw_Segments_CPP_CS()
        {
            cPtr = EdgeDraw_Lines_Open();
            labels = new string[] { "", "", "EdgeDraw_Segments_CS output", "" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, new Scalar(0));
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, new Scalar(0));
            desc = "Access the EdgeDraw algorithm directly rather than through to CPP_Basics interface - more efficient";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr vecPtr = EdgeDraw_Lines_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, vbc.task.lineWidth);
            handleSrc.Free();
            Mat ptData = cv.Mat.FromPixelData(EdgeDraw_Lines_Count(cPtr), 2, MatType.CV_32FC2, vecPtr).Clone();
            dst2.SetTo(new Scalar(0));
            if (vbc.task.heartBeat)
                dst3.SetTo(new Scalar(0));
            segPoints.Clear();
            for (int i = 0; i < ptData.Rows; i += 2)
            {
                Point2f pt1 = ptData.Get<cv.Point2f>(i, 0);
                Point2f pt2 = ptData.Get<cv.Point2f>(i, 1);
                DrawLine(dst2, pt1, pt2, Scalar.White, vbc.task.lineWidth);
                Cv2.Add(dst3, dst2, dst3);
                segPoints.Add(pt1);
                segPoints.Add(pt2);
            }
        }
        public void Close()
        {
            EdgeDraw_Lines_Close(cPtr);
        }
    }







    public class Eigen_Basics_CS : VB_Parent
    {
        public Eigen_Basics_CS()
        {
            desc = "Solve system of equations using OpenCV's EigenVV";
            labels[2] = "EigenVec (solution)";
            labels[3] = "Relationship between Eigen Vec and Vals";
        }
        public void RunAlg(Mat src)
        {
            double[] a = { 1.96, -6.49, -0.47, -7.2, -0.65,
                       -6.49, 3.8, -6.39, 1.5, -6.34,
                       -0.47, -6.39, 4.17, -1.51, 2.67,
                       -7.2, 1.5, -1.51, 5.7, 1.8,
                       -0.65, -6.34, 2.67, 1.8, -7.1 };
            Mat mat = cv.Mat.FromPixelData(5, 5, MatType.CV_64FC1, a);
            Mat eigenVal = new Mat();
            Mat eigenVec = new Mat();
            Cv2.Eigen(mat, eigenVal, eigenVec);
            double[] solution = new double[mat.Cols];
            string nextLine = "Eigen Vals\tEigen Vectors\t\t\t\t\tOriginal Matrix\n\n";
            Scalar scalar;
            for (int i = 0; i < eigenVal.Rows; i++)
            {
                scalar = eigenVal.Get<Scalar>(0, i);
                solution[i] = scalar.Val0;
                nextLine += string.Format("{0:F2}\t\t", scalar.Val0);
                for (int j = 0; j < eigenVec.Rows; j++)
                {
                    scalar = eigenVec.Get<Scalar>(i, j);
                    nextLine += string.Format("{0:F2}\t", scalar.Val0);
                }
                for (int j = 0; j < eigenVec.Rows; j++)
                {
                    nextLine += string.Format("\t{0:F2}", a[i * 5 + j]);
                }
                nextLine += "\n\n";
            }
            for (int i = 0; i < eigenVec.Rows; i++)
            {
                string plusSign = " + ";
                for (int j = 0; j < eigenVec.Cols; j++)
                {
                    scalar = eigenVec.Get<Scalar>(i, j);
                    if (j == eigenVec.Cols - 1) plusSign = "\t";
                    nextLine += string.Format("{0:F2} * {1:F2}{2}", scalar.Val0, solution[j], plusSign);
                }
                nextLine += " = \t0.0\n";
            }
            SetTrueText(nextLine);
        }
    }




    public class Eigen_FitLineInput_CS : VB_Parent
    {
        public List<cv.Point2f> points = new List<cv.Point2f>();
        public float m;
        public float bb;
        public Options_Eigen options = new Options_Eigen();
        public Eigen_FitLineInput_CS()
        {
            labels[2] = "Use sliders to adjust the width and intensity of the line";
            desc = "Generate a noisy line in a field of random data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.heartBeat)
            {
                if (!vbc.task.testAllRunning) options.recompute = false;
                dst2.SetTo(0);
                int width = src.Width;
                int height = src.Height;
                points.Clear();
                Random rand = new Random();
                for (int i = 0; i < options.randomCount; i++)
                {
                    Point2f pt = new Point2f((float)(rand.NextDouble() * width), (float)(rand.NextDouble() * height));
                    pt.X = Math.Max(0, Math.Min(pt.X, width));
                    pt.Y = Math.Max(0, Math.Min(pt.Y, height));
                    points.Add(pt);
                    Cv2.Circle(dst2, (cv.Point)points[i], vbc.task.DotSize, Scalar.White, -1);
                }
                Point2f p1, p2;
                if (rand.NextDouble() * 2 - 1 >= 0)
                {
                    p1 = new Point2f((float)(rand.NextDouble() * width), 0);
                    p2 = new Point2f((float)(rand.NextDouble() * width), height);
                }
                else
                {
                    p1 = new Point2f(0, (float)(rand.NextDouble() * height));
                    p2 = new Point2f(width, (float)(rand.NextDouble() * height));
                }
                if (p1.X == p2.X) p1.X += 1;
                if (p1.Y == p2.Y) p1.Y += 1;
                m = (p2.Y - p1.Y) / (p2.X - p1.X);
                bb = p2.Y - p2.X * m;
                float startx = Math.Min(p1.X, p2.X);
                float incr = (Math.Max(p1.X, p2.X) - startx) / options.linePairCount;
                Scalar highLight = options.highlight ? Scalar.Gray : Scalar.White;
                for (int i = 0; i < options.linePairCount; i++)
                {
                    float noiseOffsetX = (float)((rand.NextDouble() * 2 - 1) * options.noiseOffset);
                    float noiseOffsetY = (float)((rand.NextDouble() * 2 - 1) * options.noiseOffset);
                    cv.Point pt = new cv.Point(
                        startx + i * incr + noiseOffsetX,
                        Math.Max(0, Math.Min(m * (startx + i * incr) + bb + noiseOffsetY, height))
                    );
                    pt.X = Math.Max(0, Math.Min(pt.X, width));
                    pt.Y = Math.Max(0, Math.Min(pt.Y, height));
                    points.Add((Point2f)pt);
                    Cv2.Circle(dst2, pt, vbc.task.DotSize + 1, highLight, -1);
                }
            }
        }
    }




    public class Eigen_Fitline_CS : VB_Parent
    {
        Eigen_FitLineInput noisyLine = new Eigen_FitLineInput();
        Mat eigenVec = new Mat(2, 2, MatType.CV_32F, cv.Scalar.All(0));
        Mat eigenVal = new Mat(2, 2, MatType.CV_32F, cv.Scalar.All(0));
        float theta;
        float len;
        float m2;
        public Eigen_Fitline_CS()
        {
            labels[2] = "blue is Ground Truth, red is fitline, yellow is EigenFit";
            labels[3] = "Raw input (use sliders below to explore)";
            desc = "Remove outliers when trying to fit a line. Fitline and the Eigen computation below produce the same result.";
        }
        public void RunAlg(Mat src)
        {
            noisyLine.options.recompute = true;
            noisyLine.Run(src);
            dst3 = noisyLine.dst2.Clone();
            dst2.SetTo(0);
            noisyLine.options.recompute = false;
            int width = src.Width;
            var nLines = Cv2.FitLine(noisyLine.points, DistanceTypes.L2, 1, 0.01, 0.01);
            Vec4f line = new Vec4f((float)nLines.Vx, (float)nLines.Vy, (float)nLines.X1, (float)nLines.Y1);
            float m = line[1] / line[0];
            float bb = line[3] - m * line[2];
            cv.Point p1 = new cv.Point(0, bb);
            cv.Point p2 = new cv.Point(width, m * width + bb);
            Cv2.Line(dst2, p1, p2, Scalar.Red, 20, LineTypes.Link8);
            Mat pointMat = cv.Mat.FromPixelData(noisyLine.options.randomCount, 1, MatType.CV_32FC2, noisyLine.points.ToArray());
            Scalar mean = Cv2.Mean(pointMat);
            Mat[] split = Cv2.Split(pointMat);
            var mmX = GetMinMax(split[0]);
            var mmY = GetMinMax(split[1]);
            Vec4f eigenInput = new Vec4f();
            foreach (Point2f pt in noisyLine.points)
            {
                float x = pt.X - (float)mean.Val0;
                float y = pt.Y - (float)mean.Val1;
                eigenInput[0] += x * x;
                eigenInput[1] += x * y;
                eigenInput[3] += y * y;
            }
            eigenInput[2] = eigenInput[1];
            List<cv.Point2f> vec4f = new List<cv.Point2f>
        {
            new Point2f(eigenInput[0], eigenInput[1]),
            new Point2f(eigenInput[1], eigenInput[3])
        };
            Mat D = cv.Mat.FromPixelData(2, 2, MatType.CV_32FC1, vec4f.ToArray());
            Cv2.Eigen(D, eigenVal, eigenVec);
            theta = (float)Math.Atan2(eigenVec.Get<float>(1, 0), eigenVec.Get<float>(0, 0));
            len = (float)Math.Sqrt(Math.Pow(mmX.maxVal - mmX.minVal, 2) + Math.Pow(mmY.maxVal - mmY.minVal, 2));
            p1 = new cv.Point((int)(mean.Val0 - Math.Cos(theta) * len / 2), (int)(mean.Val1 - Math.Sin(theta) * len / 2));
            p2 = new cv.Point((int)(mean.Val0 + Math.Cos(theta) * len / 2), (int)(mean.Val1 + Math.Sin(theta) * len / 2));
            m2 = (p2.Y - p1.Y) / (p2.X - p1.X);
            if (Math.Abs(m2) > 1.0)
            {
                Cv2.Line(dst2, (cv.Point)p1, (cv.Point)p2, vbc.task.HighlightColor, 10, LineTypes.Link8);
            }
            else
            {
                p1 = new cv.Point((int)(mean.Val0 - Math.Cos(-theta) * len / 2), (int)(mean.Val1 - Math.Sin(-theta) * len / 2));
                p2 = new cv.Point((int)(mean.Val0 + Math.Cos(-theta) * len / 2), (int)(mean.Val1 + Math.Sin(-theta) * len / 2));
                m2 = (p2.Y - p1.Y) / (p2.X - p1.X);
                Cv2.Line(dst2, (cv.Point)p1, (cv.Point)p2, Scalar.Yellow, 10, LineTypes.Link8);
            }
            p1 = new cv.Point(0, noisyLine.bb);
            p2 = new cv.Point(width, noisyLine.m * width + noisyLine.bb);
            Cv2.Line(dst2, p1, p2, Scalar.Blue, vbc.task.lineWidth + 2, LineTypes.Link8);
            SetTrueText($"Ground Truth m = {noisyLine.m:F2} eigen m = {m2:F2}    len = {(int)len}\n" +
                        $"Confidence = {eigenVal.Get<float>(0, 0) / eigenVal.Get<float>(1, 0):F1}\n" +
                        $"theta: atan2({eigenVec.Get<float>(1, 0):F1}, {eigenVec.Get<float>(0, 0):F1}) = {theta:F4}");
        }
    }






    public class EMax_Basics_CPP_CS : VB_Parent
    {
        public EMax_InputClusters emaxInput = new EMax_InputClusters();
        public List<int> eLabels = new List<int>();
        public List<cv.Point2f> eSamples = new List<cv.Point2f>();
        public int dimension = 2;
        public int regionCount;
        public List<cv.Point2f> centers = new List<cv.Point2f>();
        Options_Emax options = new Options_Emax();
        bool useInputClusters;
        Palette_Variable palette = new Palette_Variable();
        public EMax_Basics_CPP_CS()
        {
            cPtr = EMax_Open();
            FindSlider("EMax Number of Samples per region").Value = 1;
            labels[3] = "Emax regions as integers";
            UpdateAdvice(traceName + ": use local options to control EMax.");
            desc = "Use EMax - Expectation Maximization - to classify the regions around a series of labeled points";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (eLabels.Count == 0 || useInputClusters)
            {
                useInputClusters = true;
                emaxInput.Run(empty);
                eLabels = new List<int>(emaxInput.eLabels);
                eSamples = new List<cv.Point2f>(emaxInput.eSamples);
                regionCount = emaxInput.regionCount;
            }
            if (centers.Count == 0) centers = new List<cv.Point2f>(emaxInput.centers);
            labels[2] = $"{eLabels.Count} samples provided in {regionCount} regions";
            GCHandle handleSrc = GCHandle.Alloc(eSamples.ToArray(), GCHandleType.Pinned);
            GCHandle handleLabels = GCHandle.Alloc(eLabels.ToArray(), GCHandleType.Pinned);
            IntPtr imagePtr = EMax_Run(cPtr, handleSrc.AddrOfPinnedObject(), handleLabels.AddrOfPinnedObject(), eLabels.Count, dimension,
                                       dst2.Rows, dst2.Cols, regionCount, options.predictionStepSize, (int)options.covarianceType);
            handleLabels.Free();
            handleSrc.Free();
            dst1 = cv.Mat.FromPixelData(dst1.Rows, dst1.Cols, MatType.CV_32S, imagePtr).Clone();
            dst1.ConvertTo(dst0, MatType.CV_8U);
            if (options.consistentcolors)
            {
                palette.colors.Clear();
                Vec3b[] newLabels = new Vec3b[regionCount + 1];
                for (int i = 0; i < eLabels.Count; i++)
                {
                    Point2f pt = eSamples[i];
                    if (pt.X < 0 || pt.X >= dst2.Width || pt.Y < 0 || pt.Y >= dst2.Height) continue;
                    byte newLabel = dst0.Get<byte>((int)pt.Y, (int)pt.X);
                    int original = eLabels[i];
                    Vec3b c = palette.originalColorMap.Get<Vec3b>(0, original % 256);
                    if (!newLabels.Contains(c) && newLabel <= regionCount) newLabels[newLabel] = c;
                }
                palette.colors = new List<Vec3b>(newLabels);
                palette.Run(dst0);
                dst2 = palette.dst2;
            }
            else
            {
                dst0 *= 255 / regionCount;
                dst2 = ShowPalette(dst0);
            }
            centers = new List<cv.Point2f>(emaxInput.centers);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = EMax_Close(cPtr);
        }
    }




    public class EMax_Centers_CS : VB_Parent
    {
        EMax_Basics emax = new EMax_Basics();
        public EMax_Centers_CS()
        {
            labels[2] = "Centers are highlighted, Previous centers are black";
            desc = "Display the Emax centers as they move";
        }
        public void RunAlg(Mat src)
        {
            emax.Run(src);
            dst2 = emax.dst2;
            List<cv.Point2f> lastCenters = new List<cv.Point2f>(emax.centers);
            for (int i = 0; i < emax.centers.Count; i++)
            {
                Cv2.Circle(dst2, emax.centers[i].ToPoint(), vbc.task.DotSize + 1, vbc.task.HighlightColor);
                if (i < lastCenters.Count)
                {
                    Cv2.Circle(dst2, lastCenters[i].ToPoint(), vbc.task.DotSize + 2, Scalar.Black);
                }
            }
            lastCenters = new List<cv.Point2f>(emax.centers);
        }
    }




    public class EMax_InputClusters_CS : VB_Parent
    {
        public int regionCount;
        public int[] eLabels;
        public List<cv.Point2f> eSamples = new List<cv.Point2f>();
        public List<cv.Point2f> centers = new List<cv.Point2f>();
        Options_EmaxInputClusters options = new Options_EmaxInputClusters();
        public EMax_InputClusters_CS()
        {
            labels[2] = "EMax algorithms input samples";
            desc = "Options for EMax algorithms.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.FirstPass)
            {
                vbc.task.gOptions.setGridMaximum(dst2.Width);
                vbc.task.gOptions.setGridSize((int)(dst2.Width / 3));
                vbc.task.grid.Run(dst2);
            }
            if (regionCount != vbc.task.gridRects.Count) vbc.task.optionsChanged = true;
            regionCount = vbc.task.gridRects.Count;
            Mat samples = new Mat(regionCount * options.samplesPerRegion, 2, MatType.CV_32F).Reshape(2, 0);
            Mat eLabelMat = new Mat(regionCount * options.samplesPerRegion, 1, MatType.CV_32S);
            for (int i = 0; i < regionCount; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                eLabelMat.RowRange(i * options.samplesPerRegion, (i + 1) * options.samplesPerRegion).SetTo(i);
                Mat tmp = samples.RowRange(i * options.samplesPerRegion, (i + 1) * options.samplesPerRegion);
                Cv2.Randn(tmp, new Scalar(roi.X + vbc.task.gridSize / 2, roi.Y + vbc.task.gridSize / 2),
                          Scalar.All(options.sigma));
            }
            samples = samples.Reshape(1, 0);
            dst2.SetTo(0);
            eSamples.Clear();
            centers.Clear();
            for (int i = 0; i < regionCount * options.samplesPerRegion; i++)
            {
                Point2f pt = samples.Get<cv.Point2f>(i, 0);
                centers.Add(pt);
                eSamples.Add(new Point2f((int)pt.X, (int)pt.Y));
                int label = eLabelMat.Get<int>(i);
                Cv2.Circle(dst2, pt.ToPoint(), vbc.task.DotSize + 2, vbc.task.HighlightColor, -1);
            }
            eLabels = new int[eLabelMat.Rows];
            Marshal.Copy(eLabelMat.Data, eLabels, 0, eLabels.Length);
        }
    }




    public class EMax_VB_Failing_CS : VB_Parent
    {
        public EMax_InputClusters emaxInput = new EMax_InputClusters();
        public List<int> eLabels = new List<int>();
        public List<cv.Point2f> eSamples = new List<cv.Point2f>();
        public int dimension = 2;
        public int regionCount;
        public EMax_VB_Failing_CS()
        {
            desc = "OpenCV expectation maximization example.";
        }
        public void RunAlg(Mat src)
        {
            emaxInput.Run(empty);
            eLabels = new List<int>(emaxInput.eLabels);
            eSamples = new List<cv.Point2f>(emaxInput.eSamples);
            regionCount = emaxInput.regionCount;
            SetTrueText("The EMax algorithm fails as a result of a bug in em_model.Predict2.  See code for details." + "\n" +
                        "The C++ version works fine (EMax_RedCloud) and the 2 are functionally identical.", new cv.Point(20, 100));
            return; // Comment this line to see the bug in the C# version of this Predict2 below. Any answers would be gratefully received.
            //EM em_model = EM.Create();
            //em_model.ClustersNumber = regionCount;
            //em_model.CovarianceMatrixType = EMTypes.CovMatSpherical;
            //em_model.TermCriteria = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 300, 1.0);
            //Mat samples = new Mat(eSamples.Count, 2, MatType.CV_32FC1, eSamples.ToArray());
            //Mat eLabelsMat = new Mat(eLabels.Count, 1, MatType.CV_32S, eLabels.ToArray());
            //em_model.TrainEM(samples, null, eLabelsMat, null);
            //Mat sample = new Mat(1, 2, MatType.CV_32FC1, 0);
            //for (int i = 0; i < dst2.Rows; i++)
            //{
            //    for (int j = 0; j < dst2.Cols; j++)
            //    {
            //        sample.Set<float>(0, 0, (float)j);
            //        sample.Set<float>(0, 1, (float)i);
            //        double response = Math.Round(em_model.Predict2(sample)[1]);
            //        Scalar c = vbc.task.vecColors[(int)response];
            //        Cv2.Circle(dst2, new cv.Point(j, i), vbc.task.DotSize, c);
            //    }
            //}
        }
    }






    public class EMax_PointTracker_CS : VB_Parent
    {
        KNN_Basics knn = new KNN_Basics();
        EMax_Basics emax = new EMax_Basics();
        public EMax_PointTracker_CS()
        {
            labels = new string[] { "", "", "Output of EMax_RedCloud", "Emax centers tracked and smoothed." };
            desc = "Use KNN to track the EMax Centers";
        }
        public void RunAlg(Mat src)
        {
            emax.Run(src);
            dst2 = emax.dst2;
            knn.queries = new List<cv.Point2f>(emax.centers);
            knn.Run(empty);
            if (vbc.task.FirstPass)
            {
                knn.trainInput = new List<cv.Point2f>(knn.queries);
                return;
            }
            dst3.SetTo(0);
            for (int i = 0; i < knn.queries.Count; i++)
            {
                Point2f p1 = knn.queries[i];
                Point2f p2 = knn.trainInput[knn.result[i, 0]];
                DrawCircle(dst3, p1, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                DrawCircle(dst3, p2, vbc.task.DotSize, Scalar.Red, -1);
                DrawLine(dst3, p1, p2, Scalar.White, vbc.task.lineWidth);
            }
            knn.trainInput = new List<cv.Point2f>(knn.queries);
            dst2 = dst2 | emax.emaxInput.dst2;
        }
    }




    public class EMax_RandomClusters_CS : VB_Parent
    {
        Random_Clusters clusters = new Random_Clusters();
        EMax_Basics emax = new EMax_Basics();
        public EMax_RandomClusters_CS()
        {
            FindSlider("Number of points per cluster").Value = 1;
            labels = new string[] { "", "", "Random_Clusters output", "EMax layout for the random clusters supplied" };
            desc = "Build an EMax layout for random set of clusters (not a grid)";
        }
        public void RunAlg(Mat src)
        {
            var regionSlider = FindSlider("Number of Clusters");
            emax.regionCount = regionSlider.Value;
            clusters.Run(empty);
            dst3 = clusters.dst2;
            emax.eLabels.Clear();
            emax.eSamples.Clear();
            for (int i = 0; i < emax.regionCount; i++)
            {
                var cList = clusters.clusters[i];
                var cLabels = clusters.clusterLabels[i];
                for (int j = 0; j < cList.Count; j++)
                {
                    emax.eSamples.Add(cList[j]);
                    emax.eLabels.Add(cLabels[j]);
                }
            }
            emax.Run(src);
            dst2 = emax.dst2;
        }
    }







    public class Encode_Basics_CS : VB_Parent
    {
        Options_Encode options = new Options_Encode();
        public Encode_Basics_CS()
        {
            desc = "Error Level Analysis - to verify a jpg image has not been modified.";
            labels[2] = "absDiff with original";
            labels[3] = "Original decompressed";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.FirstPass) FindSlider("Encode Output Scaling").Value = 10;

            int[] encodeParams = { (int)options.encodeOption, options.qualityLevel };
            byte[] buf = src.ImEncode(".jpg", encodeParams);
            Mat image = cv.Mat.FromPixelData(buf.Length, 1, MatType.CV_8U, buf);
            dst3 = Cv2.ImDecode(image, ImreadModes.AnyColor);
            Mat output = new Mat();
            Cv2.Absdiff(src, dst3, output);
            output.ConvertTo(dst2, MatType.CV_8UC3, options.scalingLevel);
            double compressionRatio = (double)buf.Length / (src.Rows * src.Cols * src.ElemSize());
            labels[3] = $"Original compressed to len={buf.Length} ({compressionRatio:P1})";
        }
    }




    public class Encode_Scaling_CS : VB_Parent
    {
        Options_Encode options = new Options_Encode();
        public Encode_Scaling_CS()
        {
            desc = "JPEG Encoder";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.FirstPass) FindSlider("Encode Output Scaling").Value = 10;

            int[] encodeParams = { (int)options.encodeOption, options.qualityLevel };
            byte[] buf = src.ImEncode(".jpg", encodeParams);
            Mat image = cv.Mat.FromPixelData(buf.Length, 1, MatType.CV_8U, buf);
            dst3 = Cv2.ImDecode(image, ImreadModes.AnyColor);
            Mat output = new Mat();
            Cv2.Absdiff(src, dst3, output);
            output.ConvertTo(dst2, MatType.CV_8UC3, options.scalingLevel);
            double compressionRatio = (double)buf.Length / (src.Rows * src.Cols * src.ElemSize());
        }
    }






    public class Entropy_Basics_CS : VB_Parent
    {
        Entropy_Rectangle entropy = new Entropy_Rectangle();
        public Entropy_Basics_CS()
        {
            labels[2] = "Control entropy values with histogram bins slider";
            desc = "Compute the entropy in an image - a measure of contrast(iness)";
        }
        cv.Rect ValidatePreserve(cv.Rect r)
        {
            if (r.Width <= 0) r.Width = 1;
            if (r.Height <= 0) r.Height = 1;
            if (r.X < 0) r.X = 0;
            if (r.Y < 0) r.Y = 0;
            if (r.X + r.Width >= vbc.task.dst2.Width) r.X = vbc.task.dst2.Width - r.Width - 1;
            if (r.Y + r.Height >= vbc.task.dst2.Height) r.Y = vbc.task.dst2.Height - r.Height - 1;
            return r;
        }
        public void RunAlg(Mat src)
        {
            int stdSize = 30;
            if (vbc.task.drawRect == new cv.Rect())
            {
                vbc.task.drawRect = new cv.Rect(30, 30, stdSize, stdSize); // arbitrary rectangle
            }
            if (vbc.task.mouseClickFlag)
            {
                vbc.task.drawRect = ValidatePreserve(new cv.Rect(vbc.task.ClickPoint.X, vbc.task.ClickPoint.Y, stdSize, stdSize));
            }
            vbc.task.drawRect = ValidateRect(vbc.task.drawRect);
            if (src.Channels() == 3)
            {
                entropy.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY)[vbc.task.drawRect]);
            }
            else
            {
                entropy.Run(src[vbc.task.drawRect]);
            }
            dst2 = entropy.dst2;
            Cv2.Rectangle(dst2, vbc.task.drawRect, Scalar.White, vbc.task.lineWidth);
            if (vbc.task.heartBeat)
            {
                strOut = $"Click anywhere to measure the entropy with cv.Rect(pt.x, pt.y, {stdSize}, {stdSize})\n\n" +
                         $"Total entropy = {entropy.entropyVal.ToString(vbc.fmt1)}\n{entropy.strOut}";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Entropy_Highest_CS : VB_Parent
    {
        Entropy_Rectangle entropy = new Entropy_Rectangle();
        public cv.Rect eMaxRect;
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public Entropy_Highest_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setGridSize((int)(dst2.Width / 10));
            labels[2] = "Highest entropy marked with red rectangle";
            desc = "Find the highest entropy section of the color image.";
        }
        public void RunAlg(Mat src)
        {
            Mat entropyMap = new Mat(src.Size(), MatType.CV_32F);
            float[] entropyList = new float[vbc.task.gridRects.Count];
            float maxEntropy = float.MinValue;
            float minEntropy = float.MaxValue;
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            for (int i = 0; i < vbc.task.gridRects.Count; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                entropy.Run(src[roi]);
                entropyMap[roi].SetTo(entropy.entropyVal);
                if (entropy.entropyVal > maxEntropy || vbc.task.optionsChanged)
                {
                    maxEntropy = entropy.entropyVal;
                    eMaxRect = roi;
                }
                if (entropy.entropyVal < minEntropy) minEntropy = entropy.entropyVal;
                if (standaloneTest())
                {
                    cv.Point pt = new cv.Point(roi.X, roi.Y);
                    SetTrueText(entropy.entropyVal.ToString(vbc.fmt2), pt, 2);
                    SetTrueText(entropy.entropyVal.ToString(vbc.fmt2), pt, 3);
                }
            }
            dst2 = entropyMap.ConvertScaleAbs(255 / (maxEntropy - minEntropy), minEntropy);
            addw.src2 = src;
            addw.Run(dst2);
            dst2 = addw.dst2;
            if (standaloneTest())
            {
                Cv2.Rectangle(dst2, eMaxRect, new Scalar(255), vbc.task.lineWidth);
                dst3.SetTo(0);
                Cv2.Rectangle(dst3, eMaxRect, Scalar.White, vbc.task.lineWidth);
            }
            labels[2] = $"Lighter = higher entropy. Range: {minEntropy:0.0} to {maxEntropy:0.0}";
        }
    }




    public class Entropy_FAST_CS : VB_Parent
    {
        Corners_Basics fast = new Corners_Basics();
        Entropy_Highest entropy = new Entropy_Highest();
        public Entropy_FAST_CS()
        {
            labels = new string[] { "", "", "Output of Corners_FAST, input to entropy calculation", "Lighter color is higher entropy, highlight shows highest" };
            desc = "Use FAST markings to add to entropy";
        }
        public void RunAlg(Mat src)
        {
            fast.Run(src);
            entropy.Run(fast.dst2);
            dst2 = entropy.dst2;
            dst3 = entropy.dst2;
            Cv2.Rectangle(dst3, entropy.eMaxRect, vbc.task.HighlightColor, vbc.task.lineWidth);
        }
    }




    public class Entropy_Rectangle_CS : VB_Parent
    {
        public float entropyVal;
        public Entropy_Rectangle_CS()
        {
            desc = "Calculate the entropy in the drawRect when run standalone";
        }
        public float ChannelEntropy(int total, Mat hist)
        {
            float channelEntropy = 0;
            for (int i = 0; i < hist.Rows; i++)
            {
                float hc = Math.Abs(hist.Get<float>(i));
                if (hc != 0) channelEntropy += -(hc / total) * (float)Math.Log10(hc / total);
            }
            return channelEntropy;
        }
        public void RunAlg(Mat src)
        {
            int[] dimensions = new int[] { vbc.task.histogramBins };
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var mm = GetMinMax(src);
            Rangef[] ranges = new Rangef[] { new Rangef((float)mm.minVal, (float)mm.maxVal) };
            if (mm.minVal == mm.maxVal) ranges = new Rangef[] { new Rangef(0, 255) };
            if (standalone)
            {
                if (vbc.task.drawRect.Width == 0 || vbc.task.drawRect.Height == 0)
                {
                    vbc.task.drawRect = new cv.Rect(10, 10, 50, 50); // arbitrary template to match
                }
                src = src[vbc.task.drawRect];
            }
            Mat hist = new Mat();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, null, hist, 1, dimensions, ranges);
            Mat histNormalized = hist.Normalize(0, hist.Rows, NormTypes.MinMax);
            entropyVal = ChannelEntropy((int)src.Total(), histNormalized) * 1000;
            strOut = $"Entropy X1000 {entropyVal.ToString(vbc.fmt1)}\n";
            dst2 = src;
            Cv2.Rectangle(dst2, vbc.task.drawRect, Scalar.White, vbc.task.lineWidth);
            dst3 = src;
            SetTrueText(strOut, 3);
        }
    }




    public class Entropy_SubDivisions_CS : VB_Parent
    {
        Entropy_Rectangle entropy = new Entropy_Rectangle();
        List<List<float>> entropies = new List<List<float>>();
        List<List<cv.Rect>> eROI = new List<List<cv.Rect>>();
        public List<cv.Rect> roiList = new List<cv.Rect>();
        public Entropy_SubDivisions_CS()
        {
            labels[2] = "The top entropy values in each subdivision";
            for (int i = 0; i < vbc.task.subDivisionCount; i++)
            {
                entropies.Add(new List<float>()); // 4 quadrants
                eROI.Add(new List<cv.Rect>()); // 4 quadrants
            }
            desc = "Find the highest entropy in each quadrant";
        }
        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.color.Clone();
            for (int i = 0; i < vbc.task.subDivisionCount; i++)
            {
                entropies[i].Clear();
                eROI[i].Clear();
            }
            dst1 = src.Channels() == 1 ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
            int[] dimensions = new int[] { vbc.task.histogramBins };
            Rangef[] ranges = new Rangef[] { new Rangef(0, 255) };
            Mat hist = new Mat();
            for (int i = 0; i < vbc.task.gridRects.Count; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                Cv2.CalcHist(new Mat[] { dst1[roi] }, new int[] { 0 }, null, hist, 1, dimensions, ranges);
                hist = hist.Normalize(0, hist.Rows, NormTypes.MinMax);
                float nextEntropy = entropy.channelEntropy((int)dst1[roi].Total(), hist) * 1000;
                entropies[vbc.task.subDivisions[i]].Add(nextEntropy);
                eROI[vbc.task.subDivisions[i]].Add(roi);
                if (standaloneTest()) SetTrueText(nextEntropy.ToString(vbc.fmt2), new cv.Point(roi.X, roi.Y), 3);
            }
            roiList.Clear();
            for (int i = 0; i < vbc.task.subDivisionCount; i++)
            {
                var eList = entropies[i];
                float maxEntropy = eList.Max();
                cv.Rect roi = eROI[i][eList.IndexOf(maxEntropy)];
                roiList.Add(roi);
                Cv2.Rectangle(dst2, roi, Scalar.White);
            }
            cv.Point p1 = new cv.Point(0, dst2.Height / 3);
            cv.Point p2 = new cv.Point(dst2.Width, dst2.Height / 3);
            DrawLine(dst2, p1, p2, Scalar.White, vbc.task.lineWidth);
            p1 = new cv.Point(0, dst2.Height * 2 / 3);
            p2 = new cv.Point(dst2.Width, dst2.Height * 2 / 3);
            DrawLine(dst2, p1, p2, Scalar.White, vbc.task.lineWidth);
            p1 = new cv.Point(dst2.Width / 3, 0);
            p2 = new cv.Point(dst2.Width / 3, dst2.Height);
            DrawLine(dst2, p1, p2, Scalar.White, vbc.task.lineWidth);
            p1 = new cv.Point(dst2.Width * 2 / 3, 0);
            p2 = new cv.Point(dst2.Width * 2 / 3, dst2.Height);
            DrawLine(dst2, p1, p2, Scalar.White, vbc.task.lineWidth);
        }
    }




    public class Entropy_BinaryImage_CS : VB_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        Entropy_Basics entropy = new Entropy_Basics();
        public Entropy_BinaryImage_CS()
        {
            desc = "Measure entropy in a binary image";
        }
        public void RunAlg(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            labels[2] = binary.labels[2];
            entropy.Run(dst2);
            SetTrueText(entropy.strOut, 3);
        }
    }







    public class Erode_Basics_CS : VB_Parent
    {
        public Options_Erode options = new Options_Erode();
        public Erode_Basics_CS()
        {
            UpdateAdvice(traceName + ": use local options to control erosion.");
            desc = "Erode the image provided.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.noshape || options.iterations == 0)
                dst2 = src;
            else
                dst2 = src.Erode(options.element, null, options.iterations);
            if (standaloneTest())
            {
                dst3 = vbc.task.depthRGB.Erode(options.element, null, options.iterations);
                labels[3] = "Eroded Depth " + options.iterations.ToString() + " times";
            }
            labels[2] = "Eroded BGR " + (-options.iterations).ToString() + " times";
        }
    }




    public class Erode_CloudXY_CS : VB_Parent
    {
        Erode_Basics erode = new Erode_Basics();
        Dilate_Basics dilate = new Dilate_Basics();
        Erode_Basics erodeMask = new Erode_Basics();
        public Erode_CloudXY_CS()
        {
            FindSlider("Dilate Iterations").Value = 2;
            FindRadio("Erode shape: Ellipse").Checked = true;
            labels = new string[] { "", "", "Eroded point cloud X", "Erode point cloud Y" };
            desc = "Erode depth and then find edges";
        }
        public void RunAlg(Mat src)
        {
            var dilateSlider = FindSlider("Dilate Iterations");
            var erodeSlider = FindSlider("Erode Iterations");
            erodeMask.Run(vbc.task.depthMask);
            dst1 = ~erodeMask.dst2;
            dilate.Run(vbc.task.pcSplit[0]);
            var mm = GetMinMax(dilate.dst2, erodeMask.dst2);
            dst2 = (dilate.dst2 - cv.Scalar.All(mm.minVal)) / (mm.maxVal - mm.minVal);
            dst2.SetTo(0, dst1);
            erode.Run(vbc.task.pcSplit[1]);
            mm = GetMinMax(dilate.dst2, erodeMask.dst2);
            dst3 = (erode.dst2 - cv.Scalar.All(mm.minVal)) / (mm.maxVal - mm.minVal);
            dst3.SetTo(0, dst1);
        }
    }




    public class Erode_DepthSeed_CS : VB_Parent
    {
        Erode_Basics erode = new Erode_Basics();
        Options_Erode options = new Options_Erode();
        public Erode_DepthSeed_CS()
        {
            desc = "Erode depth to build a depth mask for inrange data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Cv2.Erode(vbc.task.pcSplit[2], dst0, erode.options.element);
            dst0 = vbc.task.pcSplit[2] - dst0;
            dst3 = dst0.LessThan(options.flatDepth).ToMat();
            dst1 = vbc.task.pcSplit[2].GreaterThan(0).ToMat();
            dst1.SetTo(0, vbc.task.pcSplit[2].GreaterThan(vbc.task.MaxZmeters));
            dst3 = dst3 & dst1;
            dst2.SetTo(0);
            vbc.task.depthRGB.CopyTo(dst2, dst3);
        }
    }





    public class Erode_Dilate_CS : VB_Parent
    {
        Options_Dilate options = new Options_Dilate();
        public Erode_Dilate_CS()
        {
            desc = "Erode and then dilate with MorphologyEx on the input image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Cv2.MorphologyEx(src, dst2, MorphTypes.Close, options.element);
            Cv2.MorphologyEx(dst2, dst2, MorphTypes.Open, options.element);
        }
    }








    public class Etch_ASketch_CS : VB_Parent
    {
        Keyboard_Basics keys;
        Scalar slateColor = new Scalar(122, 122, 122);
        cv.Point cursor;
        Random ms_rng = new Random();
        Options_Etch_ASketch options = new Options_Etch_ASketch();
        cv.Point lastCursor;
        cv.Point RandomCursor()
        {
            cv.Point nextCursor = new cv.Point(ms_rng.Next(0, dst2.Width), ms_rng.Next(0, dst2.Height));
            lastCursor = nextCursor;
            return nextCursor;
        }
        public Etch_ASketch_CS()
        {
            keys = new Keyboard_Basics();
            cursor = RandomCursor();
            dst2.SetTo(slateColor);
            desc = "Use OpenCV to simulate the Etch-a-Sketch Toy";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            keys.Run(src);
            List<string> keyIn = new List<string>(keys.keyInput);
            if (options.demoMode)
            {
                keyIn.Clear(); // ignore any keyboard input when in Demo mode.
                string nextKey = new[] { "Down", "Up", "Left", "Right" }[ms_rng.Next(0, 4)];
                labels[2] = "Etch_ASketch_CS demo mode - moving randomly";
                for (int i = 0; i < ms_rng.Next(10, 51); i++)
                {
                    keyIn.Add(nextKey);
                }
            }
            else
            {
                labels[2] = "Use Up/Down/Left/Right keys to create image";
            }
            if (options.cleanMode)
            {
                cursor = RandomCursor();
                dst2.SetTo(slateColor);
            }
            foreach (string key in keyIn)
            {
                switch (key)
                {
                    case "Down":
                        cursor.Y += 1;
                        break;
                    case "Up":
                        cursor.Y -= 1;
                        break;
                    case "Left":
                        cursor.X -= 1;
                        break;
                    case "Right":
                        cursor.X += 1;
                        break;
                }
                cursor.X = Math.Max(0, Math.Min(cursor.X, src.Width - 1));
                cursor.Y = Math.Max(0, Math.Min(cursor.Y, src.Height - 1));
                dst2.Set<Vec3b>(cursor.Y, cursor.X, black);
            }
            if (options.demoMode)
            {
                lastCursor = cursor;
            }
        }
    }




    public class Extrinsics_Basics_CS : VB_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public Extrinsics_Basics_CS()
        {
            if (standalone) vbc.task.gOptions.SetDotSize(5);
            desc = "MatchShapes: Show the alignment of the BGR image to the left and right camera images.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.leftView;
            dst3 = vbc.task.rightView;
            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.drawRect.Width > 0)
            {
                dst2.Rectangle(vbc.task.drawRect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
                addw.src2 = dst2[vbc.task.drawRect].Resize(dst2.Size());
                addw.Run(gray);
                dst1 = addw.dst2;
            }
            cv.Point pt = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            if (standaloneTest())
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White);
                DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.White);
                DrawCircle(dst2, pt, vbc.task.DotSize - 2, Scalar.Black);
                DrawCircle(dst3, pt, vbc.task.DotSize - 2, Scalar.Black);
                DrawCircle(vbc.task.color, pt, vbc.task.DotSize, Scalar.White);
            }
        }
    }




    public class Extrinsics_Display_CS : VB_Parent
    {
        Options_Extrinsics options = new Options_Extrinsics();
        Options_Translation optTrans = new Options_Translation();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public Extrinsics_Display_CS()
        {
            labels = new string[] { "", "", "Left Image", "Right Image" };
            desc = "MatchShapes: Build overlays for the left and right images on the BGR image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optTrans.RunOpt();
            cv.Rect rectLeft = new cv.Rect(options.leftCorner - optTrans.leftTrans, options.topCorner, dst2.Width - 2 * options.leftCorner, dst2.Height - 2 * options.topCorner);
            cv.Rect rectRight = new cv.Rect(options.rightCorner - optTrans.rightTrans, options.topCorner, dst2.Width - 2 * options.rightCorner, dst2.Height - 2 * options.topCorner);
            addw.src2 = vbc.task.leftView[rectLeft].Resize(dst2.Size());
            addw.Run(src);
            dst2 = addw.dst2.Clone();
            addw.src2 = vbc.task.rightView[rectRight].Resize(dst2.Size());
            addw.Run(src);
            dst3 = addw.dst2.Clone();
        }
    }






    public class Face_Haar_LBP_CS : VB_Parent
    {
        CascadeClassifier haarCascade;
        CascadeClassifier lbpCascade;
        public Face_Haar_LBP_CS()
        {
            haarCascade = new CascadeClassifier(vbc.task.HomeDir + "Data/haarcascade_frontalface_default.xml");
            lbpCascade = new CascadeClassifier(vbc.task.HomeDir + "Data/lbpcascade_frontalface.xml");
            desc = "Detect faces in the video stream.";
            labels[2] = "Faces detected with Haar";
            labels[3] = "Faces detected with LBP";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            DetectFace(ref dst2, haarCascade);
            dst3 = src.Clone();
            DetectFace(ref dst3, lbpCascade);
        }
    }




    public class Face_Haar_Alt_CS : VB_Parent
    {
        CascadeClassifier haarCascade;
        public Face_Haar_Alt_CS()
        {
            haarCascade = new CascadeClassifier(vbc.task.HomeDir + "Data/haarcascade_frontalface_alt.xml");
            desc = "Detect faces Haar_alt database.";
            labels[2] = "Faces detected with Haar_Alt";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            DetectFace(ref dst2, haarCascade);
        }
    }






    public class Feature_Stable_CS : VB_Parent
    {
        List<Mat> matList = new List<Mat>();
        List<cv.Point2f> ptList = new List<cv.Point2f>();
        KNN_Basics knn = new KNN_Basics();
        List<cv.Point2f> ptLost = new List<cv.Point2f>();
        Feature_Gather gather = new Feature_Gather();
        List<Mat> featureMat = new List<Mat>();
        public Options_Features options = new Options_Features();
        public Feature_Stable_CS()
        {
            vbc.task.features.Clear(); // in case it was previously in use...
            desc = "Identify features with GoodFeaturesToTrack but manage them with MatchTemplate";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            gather.Run(src);
            if (vbc.task.optionsChanged)
            {
                vbc.task.features.Clear();
                featureMat.Clear();
            }
            matList.Clear();
            ptList.Clear();
            Mat correlationMat = new Mat();
            for (int i = 0; i < Math.Min(featureMat.Count, vbc.task.features.Count); i++)
            {
                Point2f pt = vbc.task.features[i];
                cv.Rect rect = ValidateRect(new cv.Rect((int)(pt.X - options.templatePad), (int)(pt.Y - options.templatePad), featureMat[i].Width, featureMat[i].Height));
                if (!gather.ptList.Contains(new cv.Point((int)pt.X, (int)pt.Y)))
                {
                    Cv2.MatchTemplate(src.SubMat(rect), featureMat[i], correlationMat, TemplateMatchModes.CCoeffNormed);
                    if (correlationMat.Get<float>(0, 0) < options.correlationMin)
                    {
                        Point2f ptNew = new Point2f((int)pt.X, (int)pt.Y);
                        if (!ptLost.Contains(ptNew)) ptLost.Add(ptNew);
                        continue;
                    }
                }
                matList.Add(featureMat[i]);
                ptList.Add(pt);
            }
            featureMat = new List<Mat>(matList);
            vbc.task.features = new List<cv.Point2f>(ptList);
            double extra = 1 + (1 - options.resyncThreshold);
            vbc.task.featureMotion = true;
            if (vbc.task.features.Count < gather.features.Count * options.resyncThreshold || 
                vbc.task.features.Count > extra * gather.features.Count)
            {
                ptLost.Clear();
                featureMat.Clear();
                vbc.task.features.Clear();
                foreach (Point2f pt in gather.features)
                {
                    cv.Rect rect = ValidateRect(new cv.Rect((int)(pt.X - options.templatePad), (int)(pt.Y - options.templatePad), options.templateSize, options.templateSize));
                    featureMat.Add(src.SubMat(rect));
                    vbc.task.features.Add(pt);
                }
            }
            else
            {
                if (ptLost.Count > 0)
                {
                    knn.queries = ptLost;
                    knn.trainInput = gather.features;
                    knn.Run(null);
                    for (int i = 0; i < knn.queries.Count; i++)
                    {
                        Point2f pt = knn.queries[i];
                        cv.Rect rect = ValidateRect(new cv.Rect((int)(pt.X - options.templatePad), (int)(pt.Y - options.templatePad), options.templateSize, options.templateSize));
                        featureMat.Add(src.SubMat(rect));
                        vbc.task.features.Add(knn.trainInput[knn.result[i, 0]]);
                    }
                }
                else
                {
                    vbc.task.featureMotion = false;
                }
            }
            vbc.task.featurePoints.Clear();
            foreach (Point2f pt in vbc.task.features)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                vbc.task.featurePoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = $"{vbc.task.features.Count}/{matList.Count} features were matched to the previous frame using correlation and {ptLost.Count} features had to be relocated.";
            }
        }
    }




    public class Feature_Basics_CS : VB_Parent
    {
        public Options_Features options = new Options_Features();
        Feature_Gather gather = new Feature_Gather();
        public Feature_Basics_CS()
        {
            UpdateAdvice(traceName + ": Use 'Options_Features' to control output.");
            desc = "Find good features to track in a BGR image without using correlation coefficients which produce more consistent results.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            gather.Run(src);
            vbc.task.features.Clear();
            vbc.task.featurePoints.Clear();
            foreach (Point2f pt in gather.features)
            {
                vbc.task.features.Add(pt);
                vbc.task.featurePoints.Add(new cv.Point((int)pt.X, (int)pt.X));
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = gather.labels[2];
        }
    }




    public class Feature_KNN_CS : VB_Parent
    {
        KNN_Basics knn = new KNN_Basics();
        public List<cv.Point2f> featurePoints = new List<cv.Point2f>();
        public Feature_Stable feat = new Feature_Stable();
        public Feature_KNN_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find good features to track in a BGR image but use the same point if closer than a threshold";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            knn.queries = new List<cv.Point2f>(vbc.task.features);
            if (vbc.task.FirstPass) knn.trainInput = new List<cv.Point2f>(knn.queries);
            knn.Run(null);
            for (int i = 0; i < knn.neighbors.Count; i++)
            {
                int trainIndex = knn.neighbors[i][0]; // index of the matched train input
                Point2f pt = knn.trainInput[trainIndex];
                Point2f qPt = vbc.task.features[i];
                if (pt.DistanceTo(qPt) > feat.options.minDistance) knn.trainInput[trainIndex] = vbc.task.features[i];
            }
            featurePoints = new List<cv.Point2f>(knn.trainInput);
            src.CopyTo(dst2);
            dst3.SetTo(0);
            foreach (Point2f pt in featurePoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize + 2, Scalar.White);
                DrawCircle(dst3, pt, vbc.task.DotSize + 2, Scalar.White);
            }
            labels[2] = feat.labels[2];
            labels[3] = feat.labels[2];
        }
    }




    public class Feature_Reduction_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Feature_Stable feat = new Feature_Stable();
        public Feature_Reduction_CS()
        {
            labels = new string[] { "", "", "Good features", "History of good features" };
            desc = "Get the features in a reduction grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = src;
            feat.Run(reduction.dst2);
            if (vbc.task.heartBeat) dst3.SetTo(0);
            foreach (Point2f pt in vbc.task.features)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White);
                DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.White);
            }
        }
    }




    public class Feature_MultiPass_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        public List<cv.Point2f> featurePoints = new List<cv.Point2f>();
        PhotoShop_SharpenDetail sharpen = new PhotoShop_SharpenDetail();
        public Feature_MultiPass_CS()
        {
            vbc.task.gOptions.setRGBFilterActive(true);
            vbc.task.gOptions.setRGBFilterSelection("Filter_Laplacian");
            desc = "Run Feature_Stable twice and compare results.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(vbc.task.color);
            dst2 = src.Clone();
            featurePoints = new List<cv.Point2f>(vbc.task.features);
            string passCounts = $"{featurePoints.Count}/";
            feat.Run(src);
            foreach (var pt in vbc.task.features)
            {
                featurePoints.Add(pt);
            }
            passCounts += $"{vbc.task.features.Count}/";
            sharpen.Run(vbc.task.color);
            feat.Run(sharpen.dst2);
            foreach (var pt in vbc.task.features)
            {
                featurePoints.Add(pt);
            }
            passCounts += $"{vbc.task.features.Count}";
            foreach (var pt in featurePoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = $"Total features = {featurePoints.Count}, pass counts = {passCounts}";
            }
        }
    }




    public class Feature_PointTracker_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        public Feature_Stable feat = new Feature_Stable();
        Match_Points mPoints = new Match_Points();
        Options_Features options = new Options_Features();
        public Feature_PointTracker_CS()
        {
            flow.parentData = this;
            flow.dst = 3;
            labels[3] = "Correlation coefficients for each remaining cell";
            desc = "Use the top X goodFeatures and then use matchTemplate to find track them.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            double correlationMin = options.correlationMin;
            int templatePad = options.templatePad;
            int templateSize = options.templateSize;
            strOut = "";
            if (mPoints.ptx.Count <= 3)
            {
                mPoints.ptx.Clear();
                feat.Run(src);
                foreach (var pt in vbc.task.features)
                {
                    mPoints.ptx.Add(pt);
                    cv.Rect rect = ValidateRect(new cv.Rect((int)(pt.X - templatePad), (int)(pt.Y - templatePad), templateSize, templateSize));
                }
                strOut = "Restart tracking -----------------------------------------------------------------------------\n";
            }
            mPoints.Run(src);
            dst2 = src.Clone();
            for (int i = mPoints.ptx.Count - 1; i >= 0; i--)
            {
                if (mPoints.correlation[i] > correlationMin)
                {
                    DrawCircle(dst2, mPoints.ptx[i], vbc.task.DotSize, vbc.task.HighlightColor);
                    strOut += $"{mPoints.correlation[i]:F3}, ";
                }
                else
                {
                    mPoints.ptx.RemoveAt(i);
                }
            }
            if (standaloneTest())
            {
                flow.nextMsg = strOut;
                flow.Run(empty);
            }
            labels[2] = $"Of the {vbc.task.features.Count} input points, {mPoints.ptx.Count} points were tracked with correlation above {correlationMin:F2}";
        }
    }




    public class Feature_Delaunay_CS : VB_Parent
    {
        Delaunay_Contours facet = new Delaunay_Contours();
        Feature_Stable feat = new Feature_Stable();
        public Feature_Delaunay_CS()
        {
            FindSlider("Min Distance to next").Value = 10;
            desc = "Divide the image into contours with Delaunay using features";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
            facet.inputPoints.Clear();
            foreach (var pt in vbc.task.features)
            {
                facet.inputPoints.Add(pt);
            }
            facet.Run(src);
            dst3 = facet.dst2;
            foreach (var pt in vbc.task.features)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.White);
            }
            labels[3] = $"There were {vbc.task.features.Count} Delaunay contours";
        }
    }




    public class Feature_LucasKanade_CS : VB_Parent
    {
        FeatureFlow_LucasKanade pyr = new FeatureFlow_LucasKanade();
        public List<cv.Point> ptList = new List<cv.Point>();
        public List<cv.Point> ptLast = new List<cv.Point>();
        List<List<cv.Point>> ptHist = new List<List<cv.Point>>();
        public Feature_LucasKanade_CS()
        {
            desc = "Provide a trace of the tracked features";
        }
        public void RunAlg(Mat src)
        {
            pyr.Run(src);
            dst2 = src;
            labels[2] = pyr.labels[2];
            if (vbc.task.heartBeat) dst3.SetTo(0);
            ptList.Clear();
            int stationary = 0, motion = 0;
            for (int i = 0; i < pyr.features.Count; i++)
            {
                cv.Point pt = new cv.Point((int)pyr.features[i].X, (int)pyr.features[i].Y);
                ptList.Add(pt);
                if (ptLast.Contains(pt))
                {
                    Cv2.Circle(dst3, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                    stationary++;
                }
                else
                {
                    DrawLine(dst3, pyr.lastFeatures[i], pyr.features[i], Scalar.White, vbc.task.lineWidth);
                    motion++;
                }
            }
            if (vbc.task.heartBeat) labels[3] = $"{stationary} features were stationary and {motion} features had some motion.";
            ptLast = new List<cv.Point>(ptList);
        }
    }




    public class Feature_NearestCell_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        FeatureLeftRight_Basics feat = new FeatureLeftRight_Basics();
        KNN_Basics knn = new KNN_Basics();
        public Feature_NearestCell_CS()
        {
            desc = "Find the nearest feature to every cell in vbc.task.redCells";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            redC.Run(src);
            dst2 = redC.dst2;
            dst3 = redC.dst2.Clone();
            labels[2] = redC.labels[2];
            knn.queries.Clear();
            foreach (var rc in vbc.task.redCells)
            {
                knn.queries.Add(rc.maxDStable);
            }
            knn.trainInput.Clear();
            foreach (var mp in feat.mpList)
            {
                knn.trainInput.Add(new Point2f(mp.p1.X, mp.p1.Y));
            }
            knn.Run(null);
            for (int i = 0; i < vbc.task.redCells.Count; i++)
            {
                var rc = vbc.task.redCells[i];
                rc.nearestFeature = knn.trainInput[knn.result[i, 0]];
                DrawLine(dst3, rc.nearestFeature, rc.maxDStable, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
        }
    }




    public class Feature_Points_CS : VB_Parent
    {
        public Feature_Stable feat = new Feature_Stable();
        public Feature_Points_CS()
        {
            labels[3] = "Features found in the image";
            desc = "Use the sorted list of Delaunay regions to find the top X points to track.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            if (vbc.task.heartBeat) dst3.SetTo(0);
            foreach (var pt in vbc.task.features)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                DrawCircle(dst3, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = $"{vbc.task.features.Count} targets were present with {feat.options.featurePoints} requested.";
        }
    }




    public class Feature_Trace_CS : VB_Parent
    {
        RedTrack_Features track = new RedTrack_Features();
        public Feature_Trace_CS()
        {
            desc = "Placeholder to help find RedTrack_Features";
        }
        public void RunAlg(Mat src)
        {
            track.Run(src);
            dst2 = track.dst2;
            labels = track.labels;
        }
    }




    public class Feature_TraceDelaunay_CS : VB_Parent
    {
        Feature_Delaunay features = new Feature_Delaunay();
        public List<List<cv.Point2f>> goodList = new List<List<cv.Point2f>>(); // stable points only
        public Feature_TraceDelaunay_CS()
        {
            labels = new string[] { "Stable points highlighted", "", "", "Delaunay map of regions defined by the feature points" };
            desc = "Trace the GoodFeatures points using only Delaunay - no KNN or RedCloud or Matching.";
        }
        public void RunAlg(Mat src)
        {
            features.Run(src);
            dst3 = features.dst2;
            if (vbc.task.optionsChanged)
                goodList.Clear();
            List<cv.Point2f> ptList = new List<cv.Point2f>(vbc.task.features);
            goodList.Add(ptList);
            if (goodList.Count >= vbc.task.frameHistoryCount)
                goodList.RemoveAt(0);
            dst2.SetTo(0);
            foreach (var pt_List in goodList)
            {
                foreach (var pt in pt_List)
                {
                    DrawCircle(vbc.task.color, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                    Vec3b c = dst3.Get<Vec3b>((int)pt.Y, (int)pt.X);
                    DrawCircle(dst2, pt, vbc.task.DotSize + 1, vecToScalar(c));
                }
            }
            labels[2] = $"{vbc.task.features.Count} features were identified in the image.";
        }
    }




    public class Feature_ShiTomasi_CS : VB_Parent
    {
        Corners_HarrisDetector_CPP_VB harris = new Corners_HarrisDetector_CPP_VB();
        Corners_ShiTomasi_CPP_VB shiTomasi = new Corners_ShiTomasi_CPP_VB();
        Options_ShiTomasi options = new Options_ShiTomasi();
        public Feature_ShiTomasi_CS()
        {
            FindSlider("Corner normalize threshold").Value = 15;
            labels = new string[] { "", "", "Features in the left camera image", "Features in the right camera image" };
            desc = "Identify feature points in the left and right views";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.useShiTomasi)
            {
                dst2 = vbc.task.leftView;
                dst3 = vbc.task.rightView;
                shiTomasi.Run(vbc.task.leftView);
                dst2.SetTo(Scalar.White, shiTomasi.dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
                shiTomasi.Run(vbc.task.rightView);
                dst3.SetTo(vbc.task.HighlightColor, shiTomasi.dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
            }
            else
            {
                harris.Run(vbc.task.leftView);
                dst2 = harris.dst2.Clone();
                harris.Run(vbc.task.rightView);
                dst3 = harris.dst2;
            }
        }
    }




    public class Feature_Generations_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        List<cv.Point> features = new List<cv.Point>();
        List<int> gens = new List<int>();
        public Feature_Generations_CS()
        {
            UpdateAdvice(traceName + ": Local options will determine how many features are present.");
            desc = "Find feature age maximum and average.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            SortedList<int, cv.Point> newfeatures = new SortedList<int, cv.Point>(new compareAllowIdenticalIntegerInverted());
            foreach (var pt in vbc.task.featurePoints)
            {
                int index = features.IndexOf(pt);
                if (index >= 0)
                    newfeatures.Add(gens[index] + 1, pt);
                else
                    newfeatures.Add(1, pt);
            }
            if (vbc.task.heartBeat)
            {
                features.Clear();
                gens.Clear();
            }
            features = new List<cv.Point>(newfeatures.Values);
            gens = new List<int>(newfeatures.Keys);
            dst2 = src;
            for (int i = 0; i < features.Count; i++)
            {
                if (gens[i] == 1)
                    break;
                cv.Point pt = features[i];
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White);
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = $"{features.Count} features found with max/average {gens[0]}/{gens.Average():F2} generations";
            }
        }
    }




    public class Feature_History_CS : VB_Parent
    {
        public List<cv.Point> features = new List<cv.Point>();
        public Feature_Stable feat = new Feature_Stable();
        List<List<cv.Point>> featureHistory = new List<List<cv.Point>>();
        List<int> gens = new List<int>();
        public Feature_History_CS()
        {
            desc = "Find good features across multiple frames.";
        }
        public void RunAlg(Mat src)
        {
            int histCount = vbc.task.frameHistoryCount;
            feat.Run(src);
            dst2 = src.Clone();
            featureHistory.Add(new List<cv.Point>(vbc.task.featurePoints));
            List<cv.Point> newFeatures = new List<cv.Point>();
            gens.Clear();
            foreach (var cList in featureHistory)
            {
                foreach (var pt in cList)
                {
                    int index = newFeatures.IndexOf(pt);
                    if (index >= 0)
                    {
                        gens[index]++;
                    }
                    else
                    {
                        newFeatures.Add(pt);
                        gens.Add(1);
                    }
                }
            }
            int threshold = histCount == 1 ? 0 : 1;
            features.Clear();
            int whiteCount = 0;
            for (int i = 0; i < newFeatures.Count; i++)
            {
                if (gens[i] > threshold)
                {
                    cv.Point pt = newFeatures[i];
                    features.Add(pt);
                    if (gens[i] < histCount)
                    {
                        DrawCircle(dst2, pt, vbc.task.DotSize + 2, Scalar.Red);
                    }
                    else
                    {
                        whiteCount++;
                        DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                    }
                }
            }
            if (featureHistory.Count > histCount)
                featureHistory.RemoveAt(0);
            if (vbc.task.heartBeat)
            {
                labels[2] = $"{features.Count}/{whiteCount} present/present on every frame" +
                            $" Red is a recent addition, yellow is present on previous {histCount} frames";
            }
        }
    }




    public class Feature_GridPopulation_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        public Feature_GridPopulation_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[3] = "Click 'Show grid mask overlay' to see grid boundaries.";
            desc = "Find the feature population for each cell.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
            dst3.SetTo(0);
            foreach (var pt in vbc.task.featurePoints)
            {
                dst3.Set<byte>((int)pt.Y, (int)pt.X, 255);
            }
            foreach (var roi in vbc.task.gridRects)
            {
                Mat test = dst3.SubMat(roi).FindNonZero();
                SetTrueText(test.Rows.ToString(), roi.TopLeft, 3);
            }
        }
    }




    public class Feature_Compare_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        Feature_Basics noFrill = new Feature_Basics();
        List<cv.Point2f> saveLFeatures = new List<cv.Point2f>();
        List<cv.Point2f> saveRFeatures = new List<cv.Point2f>();
        public Feature_Compare_CS()
        {
            desc = "Prepare features for the left and right views";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.features = new List<cv.Point2f>(saveLFeatures);
            feat.Run(src.Clone());
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
            saveLFeatures = new List<cv.Point2f>(vbc.task.features);
            vbc.task.features = new List<cv.Point2f>(saveRFeatures);
            noFrill.Run(src.Clone());
            dst3 = noFrill.dst2;
            labels[3] = "With no correlation coefficients " + noFrill.labels[2];
            saveRFeatures = new List<cv.Point2f>(vbc.task.features);
        }
    }




    public class Feature_Gather_CPP_CS : VB_Parent
    {
        Corners_HarrisDetector_CPP_VB harris = new Corners_HarrisDetector_CPP_VB();
        Corners_Basics FAST = new Corners_Basics();
        Options_FeatureGather myOptions = new Options_FeatureGather();
        public List<cv.Point2f> features = new List<cv.Point2f>();
        public List<cv.Point> ptList = new List<cv.Point>();
        BRISK_Basics brisk = new BRISK_Basics();
        public Options_Features options = new Options_Features();
        public Feature_Gather_CPP_CS()
        {
            FindSlider("Feature Sample Size").Value = 400;
            cPtr = Agast_Open();
            desc = "Gather features from a list of sources - GoodFeatures, Agast, Brisk.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            myOptions.RunOpt();

            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            switch (myOptions.featureSource)
            {
                case (int) FeatureSrc.GoodFeaturesFull:
                    features = new List<cv.Point2f>(Cv2.GoodFeaturesToTrack(src, options.featurePoints, options.quality, options.minDistance, null,
                                                          options.blockSize, true, options.k));
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case (int) FeatureSrc.GoodFeaturesGrid:
                    options.featurePoints = 4;
                    features.Clear();
                    for (int i = 0; i < vbc.task.gridRects.Count; i++)
                    {
                        var roi = vbc.task.gridRects[i];
                        var tmpFeatures = new List<cv.Point2f>(Cv2.GoodFeaturesToTrack(src.SubMat(roi), options.featurePoints, options.quality, options.minDistance, null,
                                                                     options.blockSize, true, options.k));
                        for (int j = 0; j < tmpFeatures.Count; j++)
                        {
                            features.Add(new Point2f(tmpFeatures[j].X + roi.X, tmpFeatures[j].Y + roi.Y));
                        }
                    }
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case (int) FeatureSrc.Agast:
                    src = vbc.task.color.Clone();
                    byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
                    Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
                    GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
                    IntPtr imagePtr = Agast_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.agastThreshold);
                    handleSrc.Free();
                    Mat ptMat = cv.Mat.FromPixelData(Agast_Count(cPtr), 1, MatType.CV_32FC2, imagePtr).Clone();
                    features.Clear();
                    if (standaloneTest())
                        dst2 = src;
                    for (int i = 0; i < ptMat.Rows; i++)
                    {
                        Point2f pt = ptMat.Get<cv.Point2f>(i, 0);
                        features.Add(pt);
                        if (standaloneTest())
                            DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White);
                    }
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case (int) FeatureSrc.BRISK:
                    brisk.Run(src);
                    features = brisk.features;
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case (int) FeatureSrc.Harris:
                    harris.Run(src);
                    features = harris.features;
                    labels[2] = $"Harris Detector produced {features.Count} features";
                    break;
                case (int) FeatureSrc.FAST:
                    FAST.Run(src);
                    features = FAST.features;
                    labels[2] = $"FAST produced {features.Count} features";
                    break;
            }
            ptList.Clear();
            foreach (var pt in features)
            {
                ptList.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            if (standaloneTest())
            {
                dst2 = vbc.task.color.Clone();
                foreach (var pt in features)
                {
                    DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                }
            }
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Agast_Close(cPtr);
        }
    }






    public class FeatureFlow_Basics_CS : VB_Parent
    {
        public Feature_Stable feat = new Feature_Stable();
        public List<PointPair> mpList = new List<PointPair>();
        public List<float> mpCorrelation = new List<float>();
        public FeatureFlow_Basics_CS()
        {
            vbc.task.gOptions.setMaxDepth(20);
            if (standalone) vbc.task.gOptions.setDisplay1();
            labels[1] = "NOTE: matching right point is always to the left of the left point";
            desc = "Identify which feature in the left image corresponds to the feature in the right image.";
        }
        public void buildCorrelations(List<cv.Point> prevFeatures, List<cv.Point> currFeatures)
        {
            double correlationMin = feat.options.correlationMin;
            Mat correlationmat = new Mat();
            mpList.Clear();
            mpCorrelation.Clear();
            int pad = feat.options.templatePad, size = feat.options.templateSize;
            foreach (cv.Point p1 in prevFeatures)
            {
                cv.Rect rect = ValidateRect(new cv.Rect(p1.X - pad, p1.Y - pad, size, size));
                List<float> correlations = new List<float>();
                foreach (cv.Point p2 in currFeatures)
                {
                    cv.Rect r = ValidateRect(new cv.Rect(p2.X - pad, p2.Y - pad, Math.Min(rect.Width, size), Math.Min(size, rect.Height)));
                    Cv2.MatchTemplate(dst2[rect], dst3[r], correlationmat, TemplateMatchModes.CCoeffNormed);
                    correlations.Add(correlationmat.Get<float>(0, 0));
                }
                float maxCorrelation = correlations.Max();
                if (maxCorrelation >= correlationMin)
                {
                    int index = correlations.IndexOf(maxCorrelation);
                    mpList.Add(new PointPair(p1, currFeatures[index]));
                    mpCorrelation.Add(maxCorrelation);
                }
            }
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            labels = feat.labels;
            dst3 = vbc.task.FirstPass ? src.Clone() : dst2.Clone();
            List<cv.Point> prevFeatures = new List<cv.Point>(vbc.task.featurePoints);
            buildCorrelations(prevFeatures, vbc.task.featurePoints);
            SetTrueText("Click near any feature to find the corresponding pair of features.", 1);
            dst2 = src.Clone();
            foreach (cv.Point pt in vbc.task.featurePoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            prevFeatures = new List<cv.Point>(vbc.task.featurePoints);
        }
    }




    public class FeatureFlow_Dense_CS : VB_Parent
    {
        public Options_OpticalFlow options = new Options_OpticalFlow();
        public FeatureFlow_Dense_CS()
        {
            desc = "Use dense optical flow algorithm";
        }
        public Mat opticalFlow_Dense(Mat oldGray, Mat gray, float pyrScale, int levels, int winSize, int iterations,
                   float polyN, float polySigma, OpticalFlowFlags OpticalFlowFlags)
        {
            Mat flow = new Mat();
            if (pyrScale >= 1) pyrScale = 0.99f;

            if (oldGray.Size() != gray.Size()) oldGray = gray.Clone();

            Cv2.CalcOpticalFlowFarneback(oldGray, gray, flow, pyrScale, levels, winSize, iterations, (int)polyN, polySigma, OpticalFlowFlags);
            Mat[] flowVec = flow.Split();

            Mat hsv = new Mat();
            Mat hsv0 = new Mat();
            Mat hsv1 = new Mat(gray.Rows, gray.Cols, MatType.CV_8UC1, new Scalar(255));
            Mat hsv2 = new Mat();

            Mat magnitude = new Mat();
            Mat angle = new Mat();
            Cv2.CartToPolar(flowVec[0], flowVec[1], magnitude, angle);
            angle.ConvertTo(hsv0, MatType.CV_8UC1, 180 / Math.PI / 2);
            Cv2.Normalize(magnitude, hsv2, 0, 255, NormTypes.MinMax, (int)MatType.CV_8UC1);

            Mat[] hsvVec = { hsv0, hsv1, hsv2 };
            Cv2.Merge(hsvVec, hsv);
            return hsv;
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            options.RunOpt();
            Mat lastGray = src.Clone();
            Mat hsv = opticalFlow_Dense(lastGray, src, (float)options.pyrScale, options.levels, options.winSize, 
                                        options.iterations, (float)options.polyN, (float)options.polySigma, options.OpticalFlowFlags);
            dst2 = hsv.CvtColor(ColorConversionCodes.HSV2RGB);
            dst2 = dst2.ConvertScaleAbs(options.outputScaling);
            dst3 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            lastGray = src.Clone();
        }
    }




    public class FeatureFlow_LucasKanade_CS : VB_Parent
    {
        public List<cv.Point2f> features = new List<cv.Point2f>();
        public List<cv.Point2f> lastFeatures = new List<cv.Point2f>();
        public Feature_Stable feat = new Feature_Stable();
        public Options_OpticalFlowSparse options = new Options_OpticalFlowSparse();
        public FeatureFlow_LucasKanade_CS()
        {
            desc = "Show the optical flow of a sparse matrix.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            dst3 = src.Clone();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat lastGray = src.Clone();
            feat.Run(src);
            features = vbc.task.features.ToList();
            Mat features1 = cv.Mat.FromPixelData(features.Count, 1, MatType.CV_32FC2, features.ToArray());
            Mat features2 = new Mat();
            Mat status = new Mat();
            Mat err = new Mat();
            cv.Size winSize = new cv.Size(3, 3);
            cv.TermCriteria term = new cv.TermCriteria((cv.CriteriaTypes)((int)cv.CriteriaTypes.Eps + (int)cv.CriteriaTypes.Count), 10, 1.0);
            Cv2.CalcOpticalFlowPyrLK(src, lastGray, features1, features2, status, err, winSize, 3, term, options.OpticalFlowFlag);
            features = new List<cv.Point2f>();
            lastFeatures.Clear();
            for (int i = 0; i < status.Rows; i++)
            {
                if (status.Get<byte>(i, 0) != 0)
                {
                    Point2f pt1 = features1.Get<cv.Point2f>(i, 0);
                    Point2f pt2 = features2.Get<cv.Point2f>(i, 0);
                    float length = (float)Math.Sqrt((pt1.X - pt2.X) * (pt1.X - pt2.X) + (pt1.Y - pt2.Y) * (pt1.Y - pt2.Y));
                    if (length < 30)
                    {
                        features.Add(pt1);
                        lastFeatures.Add(pt2);
                        DrawLine(dst2, pt1, pt2, vbc.task.HighlightColor, vbc.task.lineWidth + vbc.task.lineWidth);
                        DrawCircle(dst3, pt1, vbc.task.DotSize + 3, Scalar.White, -1);
                        DrawCircle(dst3, pt2, vbc.task.DotSize + 1, Scalar.Red, -1);
                    }
                }
            }
            labels[2] = "Matched " + features.Count + " points";
            if (vbc.task.heartBeat) lastGray = src.Clone();
            lastGray = src.Clone();
        }
    }




    public class FeatureFlow_LeftRight1_CS : VB_Parent
    {
        public FeatureFlow_LucasKanade pyrLeft = new FeatureFlow_LucasKanade();
        public FeatureFlow_LucasKanade pyrRight = new FeatureFlow_LucasKanade();
        public List<cv.Point> ptLeft = new List<cv.Point>();
        public List<cv.Point> ptRight = new List<cv.Point>();
        public List<cv.Point> ptlist = new List<cv.Point>();
        public FeatureFlow_LeftRight1_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Find features using optical flow in both the left and right images.";
        }
        public void RunAlg(Mat src)
        {
            pyrLeft.Run(vbc.task.leftView);
            pyrRight.Run(vbc.task.rightView);
            List<int> leftY = new List<int>();
            ptLeft.Clear();
            dst2 = vbc.task.leftView.Clone();
            for (int i = 0; i < pyrLeft.features.Count; i++)
            {
                cv.Point pt = new cv.Point((int)pyrLeft.features[i].X, (int)pyrLeft.features[i].Y);
                ptLeft.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1, vbc.task.lineType, 0);
                leftY.Add(pt.Y);
                pt = new cv.Point((int)pyrLeft.lastFeatures[i].X, (int)pyrLeft.lastFeatures[i].Y);
                ptLeft.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1, vbc.task.lineType, 0);
                leftY.Add(pt.Y);
            }
            List<int> rightY = new List<int>();
            ptRight.Clear();
            dst3 = vbc.task.rightView.Clone();
            for (int i = 0; i < pyrRight.features.Count; i++)
            {
                cv.Point pt = new cv.Point((int)pyrRight.features[i].X, (int)pyrRight.features[i].Y);
                ptRight.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst3, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1, vbc.task.lineType, 0);
                rightY.Add(pt.Y);
                pt = new cv.Point((int)pyrRight.lastFeatures[i].X, (int)pyrRight.lastFeatures[i].Y);
                ptRight.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst3, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1, vbc.task.lineType, 0);
                rightY.Add(pt.Y);
            }
            List<PointPair> mpList = new List<PointPair>();
            ptlist.Clear();
            for (int i = 0; i < leftY.Count; i++)
            {
                int index = rightY.IndexOf(leftY[i]);
                if (index != -1) mpList.Add(new PointPair(ptLeft[i], ptRight[index]));
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = ptLeft.Count + " features found in the left image, " + ptRight.Count + " features in the right and " +
                            ptlist.Count + " features are matched.";
            }
        }
    }




    public class FeatureFlow_LeftRightHist_CS : VB_Parent
    {
        public FeatureFlow_LucasKanade pyrLeft = new FeatureFlow_LucasKanade();
        public FeatureFlow_LucasKanade pyrRight = new FeatureFlow_LucasKanade();
        public List<cv.Point> leftFeatures = new List<cv.Point>();
        public List<cv.Point> rightFeatures = new List<cv.Point>();
        public FeatureFlow_LeftRightHist_CS()
        {
            desc = "Keep only the features that have been around for the specified number of frames.";
        }
        public Mat displayFeatures(Mat dst, List<cv.Point> features)
        {
            foreach (cv.Point pt in features)
            {
                Cv2.Circle(dst, pt, vbc.task.DotSize, vbc.task.HighlightColor, -1, vbc.task.lineType, 0);
            }
            return dst;
        }
        public void RunAlg(Mat src)
        {
            pyrLeft.Run(vbc.task.leftView);
            List<cv.Point> tmpLeft = new List<cv.Point>();
            for (int i = 0; i < pyrLeft.features.Count; i++)
            {
                cv.Point pt = new cv.Point(pyrLeft.features[i].X, pyrLeft.features[i].Y);
                tmpLeft.Add(new cv.Point(pt.X, pt.Y));
                pt = new cv.Point(pyrLeft.lastFeatures[i].X, pyrLeft.lastFeatures[i].Y);
                tmpLeft.Add(new cv.Point(pt.X, pt.Y));
            }
            pyrRight.Run(vbc.task.rightView);
            List<cv.Point> tmpRight = new List<cv.Point>();
            for (int i = 0; i < pyrRight.features.Count; i++)
            {
                cv.Point pt = new cv.Point(pyrRight.features[i].X, pyrRight.features[i].Y);
                tmpRight.Add(new cv.Point(pt.X, pt.Y));
                pt = new cv.Point(pyrRight.lastFeatures[i].X, pyrRight.lastFeatures[i].Y);
                tmpRight.Add(new cv.Point(pt.X, pt.Y));
            }
            List<List<cv.Point>> leftHist = new List<List<cv.Point>> { tmpLeft };
            List<List<cv.Point>> rightHist = new List<List<cv.Point>> { tmpRight };
            if (vbc.task.optionsChanged)
            {
                leftHist = new List<List<cv.Point>> { tmpLeft };
                rightHist = new List<List<cv.Point>> { tmpRight };
            }
            leftFeatures.Clear();
            foreach (cv.Point pt in tmpLeft)
            {
                int count = 0;
                foreach (List<cv.Point> hist in leftHist)
                {
                    if (hist.Contains(pt)) count++;
                    else break;
                }
                if (count == leftHist.Count) leftFeatures.Add(pt);
            }
            rightFeatures.Clear();
            foreach (cv.Point pt in tmpRight)
            {
                int count = 0;
                foreach (List<cv.Point> hist in rightHist)
                {
                    if (hist.Contains(pt)) count++;
                    else break;
                }
                if (count == rightHist.Count) rightFeatures.Add(pt);
            }
            int minPoints = 10; // just a guess - trying to keep things current.
            if (leftFeatures.Count < minPoints)
            {
                leftFeatures = tmpLeft;
                leftHist = new List<List<cv.Point>> { tmpLeft };
            }
            if (rightFeatures.Count < minPoints)
            {
                rightFeatures = tmpRight;
                rightHist = new List<List<cv.Point>> { tmpRight };
            }
            dst2 = displayFeatures(vbc.task.leftView.Clone(), leftFeatures);
            dst3 = displayFeatures(vbc.task.rightView.Clone(), rightFeatures);
            leftHist.Add(tmpLeft);
            rightHist.Add(tmpRight);
            int threshold = Math.Min(vbc.task.frameHistoryCount, leftHist.Count);
            if (leftHist.Count >= vbc.task.frameHistoryCount) leftHist.RemoveAt(0);
            if (rightHist.Count >= vbc.task.frameHistoryCount) rightHist.RemoveAt(0);
            if (vbc.task.heartBeat)
            {
                labels[2] = leftFeatures.Count + " detected in the left image that have matches in " + threshold + " previous left images";
                labels[3] = rightFeatures.Count + " detected in the right image that have matches in " + threshold + " previous right images";
            }
        }
    }




    public class FeatureFlow_LeftRight_CS : VB_Parent
    {
        FeatureFlow_LeftRightHist_CS flowHist;
        public List<List<cv.Point>> leftFeatures = new List<List<cv.Point>>();
        public List<List<cv.Point>> rightFeatures = new List<List<cv.Point>>();
        public FeatureFlow_LeftRight_CS()
        {
            flowHist = new FeatureFlow_LeftRightHist_CS();
            desc = "Match features in the left and right images";
        }
        public Mat DisplayFeatures(Mat dst, List<List<cv.Point>> features)
        {
            foreach (var ptlist in features)
            {
                foreach (var pt in ptlist)
                {
                    Cv2.Circle(dst, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                }
            }
            return dst;
        }
        public void RunAlg(Mat src)
        {
            flowHist.Run(src);
            var tmpLeft = new SortedList<int, List<cv.Point>>();
            var tmpRight = new SortedList<int, List<cv.Point>>();
            ProcessFeatures(flowHist.leftFeatures, tmpLeft);
            ProcessFeatures(flowHist.rightFeatures, tmpRight);
            leftFeatures.Clear();
            rightFeatures.Clear();
            foreach (var ele in tmpLeft)
            {
                int index = tmpRight.Keys.ToList().IndexOf(ele.Key);
                if (index >= 0)
                {
                    leftFeatures.Add(ele.Value);
                    rightFeatures.Add(tmpRight.ElementAt(index).Value);
                }
            }
            dst2 = DisplayFeatures(vbc.task.leftView.Clone(), leftFeatures);
            dst3 = DisplayFeatures(vbc.task.rightView.Clone(), rightFeatures);
            if (vbc.task.heartBeat)
            {
                labels[2] = $"{leftFeatures.Count} detected in the left image that match one or more Y-coordinates found in the right image";
                labels[3] = $"{rightFeatures.Count} detected in the right image that match one or more Y-coordinates found in the left image";
            }
        }
        void ProcessFeatures(List<cv.Point> features, SortedList<int, List<cv.Point>> tmp)
        {
            foreach (var pt in features)
            {
                if (tmp.ContainsKey(pt.Y))
                {
                    var index = tmp.Keys.ToList().IndexOf(pt.Y);
                    var ptlist = tmp.ElementAt(index).Value;
                    ptlist.Add(pt);
                    tmp.RemoveAt(index);
                    tmp.Add(pt.Y, ptlist);
                }
                else
                {
                    tmp.Add(pt.Y, new List<cv.Point> { pt });
                }
            }
        }
    }





    public class FeatureLeftRight_Basics_CS : VB_Parent
    {
        public FeatureLeftRight_LeftRightPrep prep = new FeatureLeftRight_LeftRightPrep();
        public List<PointPair> mpList = new List<PointPair>();
        public List<float> mpCorrelation = new List<float>();
        public cv.Point selectedPoint;
        public int mpIndex;
        public cv.Point ClickPoint;
        public int picTag;
        public Options_Features options = new Options_Features();
        public KNN_Basics knn = new KNN_Basics();
        public FeatureLeftRight_Basics_CS()
        {
            labels[1] = "NOTE: matching right point is always to the left of the left point";
            if (standalone) vbc.task.gOptions.setDisplay1();
            FindSlider("Feature Correlation Threshold").Value = 75;
            FindSlider("Min Distance to next").Value = 1;
            vbc.task.gOptions.setMaxDepth(20); // up to 20 meters...
            labels[3] = "Click near any feature to get more details on the matched pair of points.";
            desc = "Match the left and right features and allow the user to select a point to get more details.";
        }
        public void setClickPoint(Point2f pt, int _pictag)
        {
            ClickPoint = new cv.Point((int)pt.X, (int)pt.Y);
            picTag = _pictag;
            vbc.task.drawRect = new cv.Rect(ClickPoint.X - options.templatePad, ClickPoint.Y - options.templatePad, options.templateSize, options.templateSize);
            vbc.task.drawRectUpdated = true;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = vbc.task.leftView.Clone();
            dst3 = vbc.task.rightView.Clone();
            prep.Run(src);
            List<PointPair> prepList = new List<PointPair>();
            foreach (cv.Point p1 in prep.leftFeatures)
            {
                foreach (cv.Point p2 in prep.rightFeatures)
                {
                    if (p1.Y == p2.Y) prepList.Add(new PointPair(p1, p2));
                }
            }
            Mat correlationmat = new Mat();
            mpList.Clear();
            mpCorrelation.Clear();
            for (int i = 0; i < prepList.Count; i++)
            {
                PointPair mpBase = prepList[i];
                List<float> correlations = new List<float>();
                List<PointPair> tmpList = new List<PointPair>();
                for (int j = i; j < prepList.Count; j++)
                {
                    PointPair mp = prepList[j];
                    if (mp.p1.Y != mpBase.p1.Y)
                    {
                        i = j;
                        break;
                    }
                    cv.Rect r1 = ValidateRect(new cv.Rect((int)(mp.p1.X - options.templatePad), (int)(mp.p1.Y - options.templatePad), options.templateSize, options.templateSize));
                    cv.Rect r2 = ValidateRect(new cv.Rect((int)(mp.p2.X - options.templatePad), (int)(mp.p2.Y - options.templatePad), options.templateSize, options.templateSize));
                    Cv2.MatchTemplate(vbc.task.leftView[r1], vbc.task.rightView[r2], correlationmat, TemplateMatchModes.CCoeffNormed);
                    correlations.Add(correlationmat.Get<float>(0, 0));
                    tmpList.Add(mp);
                }
                float maxCorrelation = correlations.Max();
                if (maxCorrelation >= options.correlationMin)
                {
                    mpList.Add(tmpList[correlations.IndexOf(maxCorrelation)]);
                    mpCorrelation.Add(maxCorrelation);
                }
            }
            foreach (PointPair mp in mpList)
            {
                DrawCircle(dst2, mp.p1, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                DrawCircle(dst3, mp.p2, vbc.task.DotSize, vbc.task.HighlightColor, -1);
            }
            if (vbc.task.mouseClickFlag) setClickPoint(vbc.task.ClickPoint, vbc.task.mousePicTag);
            SetTrueText("Click near any feature to find the corresponding pair of features." + "\n" +
                        "The correlation values in the lower left for the correlation of the left to the right views." + "\n" +
                        "The dst2 shows features for the left view, dst3 shows features for the right view.", 1);
            if (ClickPoint == new cv.Point() && mpList.Count > 0) setClickPoint(mpList[0].p1, 2);
            if (mpList.Count > 0)
            {
                knn.queries.Clear();
                knn.queries.Add(vbc.task.ClickPoint);
                PointPair mp;
                knn.trainInput.Clear();
                foreach (PointPair mpX in mpList)
                {
                    Point2f pt = (picTag == 2) ? mpX.p1 : mpX.p2;
                    knn.trainInput.Add(pt);
                }
                knn.Run(null);
                dst1.SetTo(Scalar.All(0));
                int mpIndex = knn.result[0, 0];
                mp = mpList[mpIndex];
                DrawCircle(dst2, mp.p1, vbc.task.DotSize + 4, Scalar.Red, -1);
                DrawCircle(dst3, mp.p2, vbc.task.DotSize + 4, Scalar.Red, -1);
                float dspDistance = vbc.task.pcSplit[2].Get<float>((int)mp.p1.Y, (int)mp.p1.X);
                int offset = (int)(mp.p1.X - mp.p2.X);
                string strOut = string.Format(vbc.fmt3, mpCorrelation[mpIndex]) + "\n" +
                                string.Format(vbc.fmt3, dspDistance) + "m (from camera)" + "\n" +
                                offset.ToString() + " Pixel difference";
                for (int i = 0; i < mpList.Count; i++)
                {
                    Point2f pt = mpList[i].p1;
                    SetTrueText(string.Format("{0:0%}", mpCorrelation[i]), new cv.Point((int)pt.X, (int)pt.Y));
                }
                if (vbc.task.heartBeat) dst1.SetTo(Scalar.All(0));
                DrawCircle(dst1, mp.p1, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                DrawCircle(dst1, mp.p2, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                selectedPoint = new cv.Point(mp.p1.X, mpList[mpIndex].p1.Y + 10);
                SetTrueText(strOut, selectedPoint, 1);
                if (vbc.task.heartBeat)
                {
                    labels[2] = mpList.Count + " features matched and confirmed with left/right image correlation coefficients";
                }
            }
            labels[2] = mpList.Count + " features were matched using correlation coefficients in the left and right images. White box is cell around click point.";
        }
    }




    public class FeatureLeftRight_LeftRightPrep_CS : VB_Parent
    {
        public Feature_Stable lFeat = new Feature_Stable();
        public Feature_Stable rFeat = new Feature_Stable();
        public List<cv.Point> leftFeatures = new List<cv.Point>();
        public List<cv.Point> rightFeatures = new List<cv.Point>();
        public List<cv.Point2f> saveLFeatures = new List<cv.Point2f>();
        public List<cv.Point2f> saveRFeatures = new List<cv.Point2f>();
        public FeatureLeftRight_LeftRightPrep_CS()
        {
            desc = "Prepare features for the left and right views";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.features = new List<cv.Point2f>(saveLFeatures);
            lFeat.Run(vbc.task.leftView);
            dst2 = lFeat.dst2;
            labels[2] = lFeat.labels[2];
            leftFeatures = vbc.task.featurePoints.ToList();
            saveLFeatures = vbc.task.features.ToList();
            vbc.task.features = new List<cv.Point2f>(saveRFeatures);
            rFeat.Run(vbc.task.rightView);
            dst3 = rFeat.dst2;
            labels[3] = rFeat.labels[2];
            rightFeatures = vbc.task.featurePoints.ToList();
            saveRFeatures = vbc.task.features.ToList();
        }
    }




    public class FeatureLeftRight_Grid_CS : VB_Parent
    {
        public FeatureLeftRight_Basics match = new FeatureLeftRight_Basics();
        public FeatureLeftRight_Grid_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            FindRadio("GoodFeatures (ShiTomasi) grid").Checked = true;
            desc = "Run FeatureLeftRight_Basics but with 'GoodFeatures grid' instead of 'GoodFeatures full image'";
        }
        public void RunAlg(Mat src)
        {
            match.Run(src);
            if (match.mpList.Count() == 0) return;
            dst1 = match.dst1.Clone();
            dst2 = match.dst2.Clone();
            dst3 = match.dst3.Clone();
            if (vbc.task.FirstPass) match.setClickPoint(match.mpList[0].p1, 2);
            SetTrueText(match.strOut, match.selectedPoint, 1);
            if (vbc.task.heartBeat) labels = match.labels;
        }
    }




    public class FeatureLeftRight_Input_CS : VB_Parent
    {
        public List<cv.Point> ptLeft = new List<cv.Point>();
        public List<cv.Point> ptRight = new List<cv.Point>();
        public List<PointPair> mpList = new List<PointPair>();
        public List<float> mpCorrelation = new List<float>();
        public cv.Point selectedPoint;
        public cv.Point ClickPoint;
        public int picTag;
        public Options_Features options = new Options_Features();
        public KNN_Basics knn = new KNN_Basics();
        public FeatureLeftRight_Input_CS()
        {
            labels[1] = "NOTE: matching right point is always to the left of the left point";
            if (standalone) vbc.task.gOptions.setDisplay1();
            FindSlider("Feature Correlation Threshold").Value = 75;
            FindSlider("Min Distance to next").Value = 1;
            vbc.task.gOptions.setMaxDepth(20); // up to 20 meters...
            labels[3] = "Click near any feature to get more details on the matched pair of points.";
            desc = "Match the left and right features and allow the user to select a point to get more details.";
        }
        public void setClickPoint(Point2f pt, int _pictag)
        {
            ClickPoint = new cv.Point(pt.X, pt.Y);
            picTag = _pictag;
            vbc.task.drawRect = new cv.Rect(ClickPoint.X - options.templatePad, ClickPoint.Y - options.templatePad, options.templateSize, options.templateSize);
            vbc.task.drawRectUpdated = true;
        }
        public void RunAlg(Mat src)
        {
            if (ptLeft.Count == 0 || ptRight.Count == 0)
            {
                SetTrueText("Caller provides the ptLeft/ptRight points to use.", 1);
                return;
            }
            options.RunOpt();
            List<PointPair> prepList = new List<PointPair>();
            foreach (cv.Point p1 in ptLeft)
            {
                foreach (cv.Point p2 in ptRight)
                {
                    if (p1.Y == p2.Y) prepList.Add(new PointPair(p1, p2));
                }
            }
            Mat correlationmat = new Mat();
            mpList.Clear();
            mpCorrelation.Clear();
            for (int i = 0; i < prepList.Count; i++)
            {
                PointPair mpBase = prepList[i];
                List<float> correlations = new List<float>();
                List<PointPair> tmpList = new List<PointPair>();
                for (int j = i; j < prepList.Count; j++)
                {
                    PointPair mp = prepList[j];
                    if (mp.p1.Y != mpBase.p1.Y)
                    {
                        i = j;
                        break;
                    }
                    cv.Rect r1 = ValidateRect(new cv.Rect((int)(mp.p1.X - options.templatePad), (int)(mp.p1.Y - options.templatePad), options.templateSize, options.templateSize));
                    cv.Rect r2 = ValidateRect(new cv.Rect((int)(mp.p2.X - options.templatePad), (int)(mp.p2.Y - options.templatePad), options.templateSize, options.templateSize));
                    Cv2.MatchTemplate(vbc.task.leftView[r1], vbc.task.rightView[r2], correlationmat, TemplateMatchModes.CCoeffNormed);
                    correlations.Add(correlationmat.Get<float>(0, 0));
                    tmpList.Add(mp);
                }
                float maxCorrelation = correlations.Max();
                if (maxCorrelation >= options.correlationMin)
                {
                    mpList.Add(tmpList[correlations.IndexOf(maxCorrelation)]);
                    mpCorrelation.Add(maxCorrelation);
                }
            }
            foreach (PointPair mp in mpList)
            {
                DrawCircle(dst2, mp.p1, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                DrawCircle(dst3, mp.p2, vbc.task.DotSize, vbc.task.HighlightColor, -1);
            }
            if (vbc.task.mouseClickFlag) setClickPoint(vbc.task.ClickPoint, vbc.task.mousePicTag);
            SetTrueText("Click near any feature to find the corresponding pair of features." + "\n" +
                        "The correlation values in the lower left for the correlation of the left to the right views." + "\n" +
                        "The dst2 shows features for the left view, dst3 shows features for the right view.", 1);
            if (ClickPoint == new cv.Point() && mpList.Count > 0) setClickPoint(mpList[0].p1, 2);
            if (mpList.Count > 0)
            {
                knn.queries.Clear();
                knn.queries.Add(vbc.task.ClickPoint);
                PointPair mp;
                knn.trainInput.Clear();
                foreach (PointPair mpX in mpList)
                {
                    cv.Point2f pt = (picTag == 2) ? mpX.p1 : mpX.p2;
                    knn.trainInput.Add(new Point2f(pt.X, pt.Y));
                }
                knn.Run(null);
                dst1.SetTo(Scalar.All(0));
                int mpIndex = knn.result[0, 0];
                mp = mpList[mpIndex];
                DrawCircle(dst2, mp.p1, vbc.task.DotSize + 4, Scalar.Red, -1);
                DrawCircle(dst3, mp.p2, vbc.task.DotSize + 4, Scalar.Red, -1);
                float dspDistance = vbc.task.pcSplit[2].Get<float>((int)mp.p1.Y, (int)mp.p1.X);
                int offset = (int)(mp.p1.X - mp.p2.X);
                string strOut = string.Format(vbc.fmt3, mpCorrelation[mpIndex]) + "\n" +
                                string.Format(vbc.fmt3, dspDistance) + "m (from camera)" + "\n" +
                                offset.ToString() + " Pixel difference";
                for (int i = 0; i < mpList.Count; i++)
                {
                    Point2f pt = mpList[i].p1;
                    SetTrueText(string.Format("{0:0%}", mpCorrelation[i]), new cv.Point((int)pt.X, (int)pt.Y));
                }
                if (vbc.task.heartBeat) dst1.SetTo(Scalar.All(0));
                DrawCircle(dst1, mp.p1, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                DrawCircle(dst1, mp.p2, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                selectedPoint = new cv.Point(mp.p1.X, mpList[mpIndex].p1.Y + 10);
                SetTrueText(strOut, selectedPoint, 1);
                if (vbc.task.heartBeat)
                {
                    labels[2] = mpList.Count + " features matched and confirmed with left/right image correlation coefficients";
                }
            }
            labels[2] = mpList.Count + " features were matched using correlation coefficients in the left and right images. White box is cell around click point.";
        }
    }






    public class FeatureLess_Basics_CS : VB_Parent
    {
        EdgeDraw_Basics edgeD = new EdgeDraw_Basics();
        public int classCount = 2;
        public FeatureLess_Basics_CS()
        {
            labels = new string[] { "", "", "EdgeDraw_Basics output", "" };
            desc = "Access the EdgeDraw_Basics algorithm directly rather than through the CPP_Basics interface - more efficient";
        }
        public void RunAlg(Mat src)
        {
            edgeD.Run(src);
            dst2 = edgeD.dst2;
            if (standaloneTest())
            {
                dst3 = src.Clone();
                dst3.SetTo(Scalar.Yellow, dst2);
            }
        }
    }




    public class FeatureLess_Canny_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        Options_Sobel options = new Options_Sobel();
        public FeatureLess_Canny_CS()
        {
            desc = "Use Canny edges to define featureless regions.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            edges.Run(src);
            dst2 = ~edges.dst2.Threshold(options.distanceThreshold, 255, ThresholdTypes.Binary);
        }
    }




    public class FeatureLess_Sobel_CS : VB_Parent
    {
        Edge_Sobel edges = new Edge_Sobel();
        Options_Sobel options = new Options_Sobel();
        public FeatureLess_Sobel_CS()
        {
            desc = "Use Sobel edges to define featureless regions.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            edges.Run(src);
            dst2 = ~edges.dst2.Threshold(options.distanceThreshold, 255, ThresholdTypes.Binary);
        }
    }




    public class FeatureLess_UniquePixels_CS : VB_Parent
    {
        Hough_FeatureLessTopX fless = new Hough_FeatureLessTopX();
        Sort_1Channel sort = new Sort_1Channel();
        public FeatureLess_UniquePixels_CS()
        {
            if (standaloneTest())
                FindSlider("Threshold for sort input").Value = 0;
            labels = new string[] { "", "Gray scale input to sort/remove dups", "Unique pixels", "" };
            desc = "Find the unique gray pixels for the featureless regions";
        }
        public void RunAlg(Mat src)
        {
            fless.Run(src);
            dst2 = fless.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            sort.Run(dst2);
            dst3 = sort.dst2;
        }
    }




    public class FeatureLess_Unique3Pixels_CS : VB_Parent
    {
        Hough_FeatureLessTopX fless = new Hough_FeatureLessTopX();
        Sort_3Channel sort3 = new Sort_3Channel();
        public FeatureLess_Unique3Pixels_CS()
        {
            desc = "Find the unique 3-channel pixels for the featureless regions";
        }
        public void RunAlg(Mat src)
        {
            fless.Run(src);
            dst2 = fless.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            sort3.Run(fless.dst2);
            dst3 = sort3.dst2;
        }
    }




    public class FeatureLess_Histogram_CS : VB_Parent
    {
        BackProject_FeatureLess backP = new BackProject_FeatureLess();
        public FeatureLess_Histogram_CS()
        {
            desc = "Create a histogram of the featureless regions";
        }
        public void RunAlg(Mat src)
        {
            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
            labels = backP.labels;
        }
    }




    public class FeatureLess_DCT_CS : VB_Parent
    {
        DCT_FeatureLess dct = new DCT_FeatureLess();
        public FeatureLess_DCT_CS()
        {
            labels[3] = "Largest FeatureLess Region";
            desc = "Use DCT to find featureless regions.";
        }
        public void RunAlg(Mat src)
        {
            dct.Run(src);
            dst2 = dct.dst2;
            dst3 = dct.dst3;
            Mat mask = dst2.Clone();
            List<int> objectSize = new List<int>();
            int regionCount = 1;
            for (int y = 0; y < mask.Rows; y++)
            {
                for (int x = 0; x < mask.Cols; x++)
                {
                    if (mask.Get<byte>(y, x) == 255)
                    {
                        cv.Point pt = new cv.Point(x, y);
                        int floodCount = mask.FloodFill(pt, cv.Scalar.All(regionCount));
                        objectSize.Add(floodCount);
                        regionCount++;
                    }
                }
            }
            int maxSize = 0, maxIndex = 0;
            for (int i = 0; i < objectSize.Count; i++)
            {
                if (maxSize < objectSize[i])
                {
                    maxSize = objectSize[i];
                    maxIndex = i;
                }
            }
            Mat label = mask.InRange(maxIndex + 1, maxIndex + 1);
            int nonZ = Cv2.CountNonZero(label);
            labels[3] = $"Largest FeatureLess Region ({nonZ} {(double)nonZ / label.Total():P1} pixels)";
            dst3.SetTo(Scalar.White, label);
        }
    }




    public class FeatureLess_LeftRight_CS : VB_Parent
    {
        FeatureLess_Basics fLess = new FeatureLess_Basics();
        public FeatureLess_LeftRight_CS()
        {
            labels = new string[] { "", "", "FeatureLess Left mask", "FeatureLess Right mask" };
            desc = "Find the featureless regions of the left and right images";
        }
        public void RunAlg(Mat src)
        {
            fLess.Run(vbc.task.leftView);
            dst2 = fLess.dst2.Clone();
            fLess.Run(vbc.task.rightView);
            dst3 = fLess.dst2;
        }
    }





    public class FeatureLess_History_CS : VB_Parent
    {
        FeatureLess_Basics fLess = new FeatureLess_Basics();
        History_Basics frames = new History_Basics();
        public FeatureLess_History_CS()
        {
            desc = "Accumulate the edges over a span of X images.";
        }
        public void RunAlg(Mat src)
        {
            fLess.Run(src);
            dst2 = fLess.dst2;
            frames.Run(dst2);
            dst3 = frames.dst2;
        }
    }




    public class FeatureLess_RedCloud_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        FeatureLess_Basics fless = new FeatureLess_Basics();
        public FeatureLess_RedCloud_CS()
        {
            desc = "Floodfill the FeatureLess output so each cell can be tracked.";
        }
        public void RunAlg(Mat src)
        {
            fless.Run(src);
            redC.Run(fless.dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class FeatureLess_Groups_CS : VB_Parent
    {
        RedCloud_CPP_VB redCPP = new RedCloud_CPP_VB();
        FeatureLess_Basics fless = new FeatureLess_Basics();
        public int classCount;
        public FeatureLess_Groups_CS()
        {
            desc = "Group RedCloud cells by the value of their featureless maxDist";
        }
        public void RunAlg(Mat src)
        {
            fless.Run(src);
            dst2 = fless.dst2;
            labels[2] = fless.labels[2];
            redCPP.Run(dst2);
            classCount = redCPP.classCount;
            dst3 = redCPP.dst2;
            labels[3] = $"{classCount} featureless regions were found.";
        }
    }







    public class FeatureLine_Basics_CS : VB_Parent
    {
        Line_SubsetRect lines = new Line_SubsetRect();
        Line_DisplayInfo lineDisp = new Line_DisplayInfo();
        Options_Features options = new Options_Features();
        Match_tCell match = new Match_tCell();
        public List<tCell> tcells;
        public FeatureLine_Basics_CS()
        {
            tCell tc = new tCell();
            tcells = new List<tCell> { tc, tc };
            labels = new string[] { "", "", "Longest line present.", "" };
            desc = "Find and track a line using the end points";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int distanceThreshold = 50; // pixels - arbitrary but realistically needs some value
            double linePercentThreshold = 0.7; // if less than 70% of the pixels in the line are edges, then find a better line.  Again, arbitrary but realistic.
            double correlationMin = options.correlationMin;
            bool correlationTest = tcells[0].correlation <= correlationMin || tcells[1].correlation <= correlationMin;
            lineDisp.distance = (int)tcells[0].center.DistanceTo(tcells[1].center);
            if (vbc.task.optionsChanged || correlationTest || lineDisp.maskCount / lineDisp.distance < linePercentThreshold || lineDisp.distance < distanceThreshold)
            {
                int templatePad = options.templatePad;
                lines.subsetRect = new cv.Rect(templatePad * 3, templatePad * 3, src.Width - templatePad * 6, src.Height - templatePad * 6);
                lines.Run(src.Clone());
                if (lines.mpList.Count == 0)
                {
                    SetTrueText("No lines found.", 3);
                    return;
                }
                var lp = lines.sortByLen.ElementAt(0).Value;
                tcells[0] = match.createCell(src, 0, lp.p1);
                tcells[1] = match.createCell(src, 0, lp.p2);
            }
            dst2 = src.Clone();
            for (int i = 0; i < tcells.Count; i++)
            {
                match.tCells[0] = tcells[i];
                match.Run(src);
                tcells[i] = match.tCells[0];
                SetTrueText(tcells[i].strOut, new cv.Point(tcells[i].rect.X, tcells[i].rect.Y));
                SetTrueText(tcells[i].strOut, new cv.Point(tcells[i].rect.X, tcells[i].rect.Y), 3);
            }
            lineDisp.tcells = new List<tCell>(tcells);
            lineDisp.Run(src);
            dst2 = lineDisp.dst2;
            SetTrueText(lineDisp.strOut, new cv.Point(10, 40), 3);
        }
    }




    public class FeatureLine_VerticalVerify_CS : VB_Parent
    {
        FeatureLine_VH linesVH = new FeatureLine_VH();
        public IMU_VerticalVerify verify = new IMU_VerticalVerify();
        public FeatureLine_VerticalVerify_CS()
        {
            desc = "Select a line or group of lines and track the result";
        }
        public void RunAlg(Mat src)
        {
            linesVH.Run(src);
            verify.gCells = new List<gravityLine>(linesVH.gCells);
            verify.Run(src);
            dst2 = verify.dst2;
        }
    }




    public class FeatureLine_VH_CS : VB_Parent
    {
        public List<gravityLine> gCells = new List<gravityLine>();
        Match_tCell match = new Match_tCell();
        Line_GCloud gLines = new Line_GCloud();
        Options_Features options = new Options_Features();
        public FeatureLine_VH_CS()
        {
            labels[3] = "More readable than dst1 - index, correlation, length (meters), and ArcY";
            desc = "Find and track all the horizontal or vertical lines";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            int templatePad = options.templatePad;
            // gLines.lines.subsetRect = new cv.Rect(templatePad * 3, templatePad * 3, src.Width - templatePad * 6, src.Height - templatePad * 6);
            gLines.Run(src);
            var vertRadio = FindRadio("Vertical lines");
            var sortedLines = vertRadio.Checked ? gLines.sortedVerticals : gLines.sortedHorizontals;
            if (sortedLines.Count == 0)
            {
                SetTrueText("There were no vertical lines found.", 3);
                return;
            }
            gCells.Clear();
            match.tCells.Clear();
            for (int i = 0; i < sortedLines.Count; i++)
            {
                var gc = sortedLines.ElementAt(i).Value;
                if (i == 0)
                {
                    dst1.SetTo(0);
                    gc.tc1.template.CopyTo(dst1[gc.tc1.rect]);
                    gc.tc2.template.CopyTo(dst1[gc.tc2.rect]);
                }
                match.tCells.Clear();
                match.tCells.Add(gc.tc1);
                match.tCells.Add(gc.tc2);
                match.Run(src);
                double correlationMin = options.correlationMin;
                if (match.tCells[0].correlation >= correlationMin && match.tCells[1].correlation >= correlationMin)
                {
                    gc.tc1 = match.tCells[0];
                    gc.tc2 = match.tCells[1];
                    cv.Point gc1 = new cv.Point(gc.tc1.center.X, gc.tc1.center.Y);
                    cv.Point gc2 = new cv.Point(gc.tc2.center.X, gc.tc2.center.Y);
                    gc = gLines.updateGLine(src, gc, gc1, gc2);
                    if (gc.len3D > 0) gCells.Add(gc);
                }
            }
            dst2 = src;
            dst3.SetTo(0);
            for (int i = 0; i < gCells.Count; i++)
            {
                var gc = gCells[i];
                cv.Point p1 = new cv.Point(gc.tc1.center.X, gc.tc1.center.Y);
                cv.Point p2 = new cv.Point(gc.tc2.center.X, gc.tc1.center.Y);
                SetTrueText($"{i}\n{gc.tc1.strOut}\n{gc.arcY.ToString(vbc.fmt1)}", p1, 2);
                SetTrueText($"{i}\n{gc.tc2.strOut}\n{gc.arcY.ToString(vbc.fmt1)}", p2, 3);
                DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                DrawLine(dst3, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
        }
    }




    public class FeatureLine_Tutorial1_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        public FeatureLine_Tutorial1_CS()
        {
            labels[3] = "The highlighted lines are also lines in 3D.";
            desc = "Find all the lines in the image and determine which are in the depth data.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            var raw2D = new List<PointPair>();
            var raw3D = new List<cv.Point3f>();
            foreach (var lp in lines.lpList)
            {
                if (vbc.task.pcSplit[2].Get<float>((int)lp.p1.Y, (int)lp.p1.X) > 0 && vbc.task.pcSplit[2].Get<float>((int)lp.p2.Y, (int)lp.p2.X) > 0)
                {
                    raw2D.Add(lp);
                    raw3D.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p1.Y, (int)lp.p1.X));
                    raw3D.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p2.Y, (int)lp.p2.X));
                }
            }
            dst3 = src.Clone();
            for (int i = 0; i < raw2D.Count - 1; i += 2)
            {
                DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = $"Starting with {lines.lpList.Count:000} lines, there are {raw3D.Count / 2:000} with depth data.";
            }
        }
    }




    public class FeatureLine_Tutorial2_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        IMU_GMatrix gMat = new IMU_GMatrix();
        Options_LineFinder options = new Options_LineFinder();
        public FeatureLine_Tutorial2_CS()
        {
            desc = "Find all the lines in the image and determine which are vertical and horizontal";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            lines.Run(src);
            dst2 = lines.dst2;
            var raw2D = new List<PointPair>();
            var raw3D = new List<cv.Point3f>();
            foreach (var lp in lines.lpList)
            {
                Point3f pt1 = new cv.Point3f(), pt2 = new cv.Point3f();
                for (int j = 0; j < 2; j++)
                {
                    cv.Point pt = (j == 0) ? new cv.Point(lp.p1.X, lp.p1.Y) : new cv.Point(lp.p2.X, lp.p2.Y);
                    cv.Rect rect = ValidateRect(new cv.Rect(pt.X - options.kSize, pt.Y - options.kSize, options.kernelSize, options.kernelSize));
                    Scalar val = vbc.task.pointCloud.SubMat(rect).Mean(vbc.task.depthMask.SubMat(rect));
                    if (j == 0)
                        pt1 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                    else
                        pt2 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                }
                if (pt1.Z > 0 && pt2.Z > 0)
                {
                    raw2D.Add(lp);
                    raw3D.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p1.Y, (int)lp.p1.X));
                    raw3D.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p2.Y, (int)lp.p2.X));
                }
            }
            dst3 = src.Clone();
            for (int i = 0; i < raw2D.Count - 1; i += 2)
            {
                DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = $"Starting with {lines.lpList.Count:000} lines, there are {raw3D.Count:000} with depth data.";
            }
            if (raw3D.Count == 0)
            {
                SetTrueText("No vertical or horizontal lines were found");
            }
            else
            {
                gMat.Run(empty);
                vbc.task.gMatrix = gMat.gMatrix;
                Mat matLines3D = cv.Mat.FromPixelData(raw3D.Count, 3, MatType.CV_32F, raw3D.ToArray()) * vbc.task.gMatrix;
            }
        }
    }




    public class FeatureLine_LongestVerticalKNN_CS : VB_Parent
    {
        Line_GCloud gLines = new Line_GCloud();
        FeatureLine_Longest longest = new FeatureLine_Longest();
        public FeatureLine_LongestVerticalKNN_CS()
        {
            labels[3] = "All vertical lines.  The numbers: index and Arc-Y for the longest X vertical lines.";
            desc = "Find all the vertical lines and then track the longest one with a lightweight KNN.";
        }
        bool testLastPair(PointPair lastPair, gravityLine gc)
        {
            var distance1 = lastPair.p1.DistanceTo(lastPair.p2);
            var p1 = gc.tc1.center;
            var p2 = gc.tc2.center;
            if (distance1 < 0.75 * p1.DistanceTo(p2)) return true; // it the longest vertical * 0.75 > current lastPair, then use the longest vertical...
            return false;
        }
        public void RunAlg(Mat src)
        {
            gLines.Run(src);
            if (gLines.sortedVerticals.Count == 0)
            {
                SetTrueText("No vertical lines were present", 3);
                return;
            }
            dst3 = src.Clone();
            var index = 0;
            if (testLastPair(longest.knn.lastPair, gLines.sortedVerticals.ElementAt(0).Value)) longest.knn.lastPair = new PointPair();
            foreach (var gc in gLines.sortedVerticals.Values)
            {
                if (index >= 10) break;
                var p1 = gc.tc1.center;
                var p2 = gc.tc2.center;
                if (longest.knn.lastPair.compare(new PointPair())) longest.knn.lastPair = new PointPair(p1, p2);
                var pt = new cv.Point((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);
                SetTrueText($"{index}\n{gc.arcY.ToString(vbc.fmt1)}", pt, 3);
                index++;
                DrawLine(dst3, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                longest.knn.trainInput.Add(p1);
                longest.knn.trainInput.Add(p2);
            }
            longest.Run(src);
            dst2 = longest.dst2;
        }
    }




    public class FeatureLine_LongestV_Tutorial1_CS : VB_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        public FeatureLine_LongestV_Tutorial1_CS()
        {
            desc = "Use FeatureLine_Finder to find all the vertical lines and show the longest.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            lines.Run(src);
            if (lines.sortedVerticals.Count == 0)
            {
                SetTrueText("No vertical lines were found", 3);
                return;
            }
            var index = lines.sortedVerticals.ElementAt(0).Value;
            var p1 = lines.lines2D[index];
            var p2 = lines.lines2D[index + 1];
            DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            dst3.SetTo(0);
            DrawLine(dst3, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
        }
    }




    public class FeatureLine_LongestV_Tutorial2_CS : VB_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        KNN_Basics4D knn = new KNN_Basics4D();
        public cv.Point3f pt1 = new cv.Point3f();
        public cv.Point3f pt2 = new cv.Point3f();
        int lengthReject;
        public FeatureLine_LongestV_Tutorial2_CS()
        {
            desc = "Use FeatureLine_Finder to find all the vertical lines.  Use KNN_Basics4D to track each line.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            lines.Run(src);
            dst1 = lines.dst3;
            if (lines.sortedVerticals.Count == 0)
            {
                SetTrueText("No vertical lines were found", 3);
                return;
            }
            var match3D = new List<cv.Point3f>();
            knn.trainInput.Clear();
            for (var i = 0; i < lines.sortedVerticals.Count; i++)
            {
                var sIndex = lines.sortedVerticals.ElementAt(i).Value;
                var x1 = lines.lines2D[sIndex];
                var x2 = lines.lines2D[sIndex + 1];
                var vec = x1.Y < x2.Y ? new cv.Vec4f(x1.X, x1.Y, x2.X, x2.Y) : new cv.Vec4f(x2.X, x2.Y, x1.X, x1.Y);
                if (knn.queries.Count == 0) knn.queries.Add(vec);
                knn.trainInput.Add(vec);
                match3D.Add(lines.lines3D[sIndex]);
                match3D.Add(lines.lines3D[sIndex + 1]);
            }
            var saveVec = knn.queries[0];
            knn.Run(empty);
            var index = knn.result[0, 0];
            var p1 = new cv.Point2f(knn.trainInput[index][0], knn.trainInput[index][1]);
            var p2 = new cv.Point2f(knn.trainInput[index][2], knn.trainInput[index][3]);
            pt1 = match3D[index * 2];
            pt2 = match3D[index * 2 + 1];
            DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            dst3.SetTo(0);
            DrawLine(dst3, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            var lastLength = lines.sorted2DV.ElementAt(0).Key;
            var bestLength = lines.sorted2DV.ElementAt(0).Key;
            knn.queries.Clear();
            if (lastLength > 0.5 * bestLength)
            {
                knn.queries.Add(new cv.Vec4f(p1.X, p1.Y, p2.X, p2.Y));
                lastLength = (float)p1.DistanceTo(p2);
            }
            else
            {
                lengthReject++;
                lastLength = bestLength;
            }
            labels[3] = "Length rejects = " + (lengthReject / (vbc.task.frameCount + 1)).ToString("P0");
        }
    }








    public class FeatureLine_Finder_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        public List<cv.Point2f> lines2D = new List<cv.Point2f>();
        public List<cv.Point3f> lines3D = new List<cv.Point3f>();
        public SortedList<float, int> sorted2DV = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
        public SortedList<float, int> sortedVerticals = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
        public SortedList<float, int> sortedHorizontals = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
        Options_LineFinder options = new Options_LineFinder();
        public FeatureLine_Finder_CS()
        {
            desc = "Find all the lines in the image and determine which are vertical and horizontal";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst3 = src.Clone();
            lines2D.Clear();
            lines3D.Clear();
            sorted2DV.Clear();
            sortedVerticals.Clear();
            sortedHorizontals.Clear();
            lines.Run(src);
            dst2 = lines.dst2;
            List<PointPair> raw2D = new List<PointPair>();
            List<cv.Point3f> raw3D = new List<cv.Point3f>();
            foreach (var lp in lines.lpList)
            {
                Point3f pt1 = new Point3f(), pt2 = new Point3f();
                for (int j = 0; j < 2; j++)
                {
                    cv.Point2f pt = (j == 0) ? lp.p1 : lp.p2;
                    cv.Rect rect = ValidateRect(new cv.Rect((int)(pt.X - options.kSize), (int)(pt.Y - options.kSize), options.kernelSize, options.kernelSize));
                    Scalar val = vbc.task.pointCloud[rect].Mean(vbc.task.depthMask[rect]);
                    if (j == 0)
                        pt1 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                    else
                        pt2 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                }
                if (pt1.Z > 0 && pt2.Z > 0 && pt1.Z < 4 && pt2.Z < 4)
                {
                    raw2D.Add(lp);
                    raw3D.Add(pt1);
                    raw3D.Add(pt2);
                }
            }
            if (raw3D.Count == 0)
            {
                SetTrueText("No vertical or horizontal lines were found");
            }
            else
            {
                Mat matLines3D = cv.Mat.FromPixelData(raw3D.Count, 3, MatType.CV_32F, raw3D.ToArray()) * vbc.task.gMatrix;
                for (int i = 0; i < raw2D.Count - 1; i += 2)
                {
                    Point3f pt1 = matLines3D.Get<cv.Point3f>(i, 0);
                    Point3f pt2 = matLines3D.Get<cv.Point3f>(i + 1, 0);
                    float len3D = distance3D(pt1, pt2);
                    double arcY = Math.Abs(Math.Asin((pt1.Y - pt2.Y) / len3D) * 57.2958);
                    if (Math.Abs(arcY - 90) < options.tolerance)
                    {
                        DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, Scalar.Blue, vbc.task.lineWidth);
                        sortedVerticals.Add(len3D, lines3D.Count);
                        sorted2DV.Add((float)raw2D[i].p1.DistanceTo(raw2D[i].p2), lines2D.Count);
                        if (pt1.Y > pt2.Y)
                        {
                            lines3D.Add(pt1);
                            lines3D.Add(pt2);
                            lines2D.Add(raw2D[i].p1);
                            lines2D.Add(raw2D[i].p2);
                        }
                        else
                        {
                            lines3D.Add(pt2);
                            lines3D.Add(pt1);
                            lines2D.Add(raw2D[i].p2);
                            lines2D.Add(raw2D[i].p1);
                        }
                    }
                    if (Math.Abs(arcY) < options.tolerance)
                    {
                        DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, Scalar.Yellow, vbc.task.lineWidth);
                        sortedHorizontals.Add(len3D, lines3D.Count);
                        if (pt1.X < pt2.X)
                        {
                            lines3D.Add(pt1);
                            lines3D.Add(pt2);
                            lines2D.Add(raw2D[i].p1);
                            lines2D.Add(raw2D[i].p2);
                        }
                        else
                        {
                            lines3D.Add(pt2);
                            lines3D.Add(pt1);
                            lines2D.Add(raw2D[i].p2);
                            lines2D.Add(raw2D[i].p1);
                        }
                    }
                }
            }
            labels[2] = $"Starting with {lines.lpList.Count:000} lines, there are {lines3D.Count / 2:000} with depth data.";
            labels[3] = $"There were {sortedVerticals.Count} vertical lines (blue) and {sortedHorizontals.Count} horizontal lines (yellow)";
        }
    }





    public class FeatureLine_VerticalLongLine_CS : VB_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        public FeatureLine_VerticalLongLine_CS()
        {
            desc = "Use FeatureLine_Finder data to identify the longest lines and show its angle.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                dst2 = src.Clone();
                lines.Run(src);
                if (lines.sortedVerticals.Count == 0)
                {
                    SetTrueText("No vertical lines were found", 3);
                    return;
                }
            }
            if (lines.sortedVerticals.Count == 0) return; // nothing found...
            var index = lines.sortedVerticals.ElementAt(0).Value;
            var p1 = lines.lines2D[index];
            var p2 = lines.lines2D[index + 1];
            DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            dst3.SetTo(0);
            DrawLine(dst3, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            var pt1 = lines.lines3D[index];
            var pt2 = lines.lines3D[index + 1];
            var len3D = distance3D(pt1, pt2);
            var arcY = Math.Abs(Math.Asin((pt1.Y - pt2.Y) / len3D) * 57.2958);
            SetTrueText($"{arcY.ToString(vbc.fmt3)}\n{len3D.ToString(vbc.fmt3)}m len\n{pt1.Z.ToString(vbc.fmt1)}m dist", new cv.Point(p1.X, p1.Y));
            SetTrueText($"{arcY.ToString(vbc.fmt3)}\n{len3D.ToString(vbc.fmt3)}m len\n{pt1.Z.ToString(vbc.fmt1)}m distant", new cv.Point(p1.X, p1.Y), 3);
        }
    }




    public class FeatureLine_DetailsAll_CS : VB_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        Font_FlowText flow = new Font_FlowText();
        List<float> arcList = new List<float>();
        List<float> arcLongAverage = new List<float>();
        List<float> firstAverage = new List<float>();
        int firstBest;
        public FeatureLine_DetailsAll_CS()
        {
            flow.parentData = this;
            flow.dst = 3;
            desc = "Use FeatureLine_Finder data to collect vertical lines and measure accuracy of each.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                dst2 = src.Clone();
                lines.Run(src);
                if (lines.sortedVerticals.Count == 0)
                {
                    SetTrueText("No vertical lines were found", 3);
                    return;
                }
                dst3.SetTo(0);
                arcList.Clear();
                flow.flowText.Clear();
                flow.flowText.Add("ID\tlength\tdistance");
                for (int i = 0; i < Math.Min(10, lines.sortedVerticals.Count); i++)
                {
                    int index = lines.sortedVerticals.ElementAt(i).Value;
                    cv.Point2f p1 = lines.lines2D[index];
                    cv.Point2f p2 = lines.lines2D[index + 1];
                    DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                    SetTrueText(i.ToString(), i % 2 == 1 ? new cv.Point(p1.X, p1.Y) : new cv.Point(p2.X, p2.Y), 2);
                    DrawLine(dst3, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                    Point3f pt1 = lines.lines3D[index];
                    Point3f pt2 = lines.lines3D[index + 1];
                    float len3D = distance3D(pt1, pt2);
                    if (len3D > 0)
                    {
                        float arcY = Math.Abs((float)(Math.Asin((pt1.Y - pt2.Y) / len3D) * 57.2958));
                        arcList.Add(arcY);
                        flow.flowText.Add($"{arcY:F3}\t{len3D:F3}m\t{pt1.Z:F1}m");
                    }
                }
            }
            flow.Run(empty);
            if (arcList.Count == 0) return;
            float mostAccurate = arcList[0];
            firstAverage.Add(mostAccurate);
            foreach (float arc in arcList)
            {
                if (arc > mostAccurate)
                {
                    mostAccurate = arc;
                    break;
                }
            }
            if (mostAccurate == arcList[0]) firstBest++;
            float avg = arcList.Average();
            arcLongAverage.Add(avg);
            labels[3] = $"arcY avg = {avg:F1}, long term average = {arcLongAverage.Average():F1}, " +
                        $"first was best {(float)firstBest / vbc.task.frameCount:P0} of the time, " +
                        $"Avg of longest line {firstAverage.Average():F1}";
            if (arcLongAverage.Count > 1000)
            {
                arcLongAverage.RemoveAt(0);
                firstAverage.RemoveAt(0);
            }
        }
    }




    public class FeatureLine_LongestKNN_CS : VB_Parent
    {
        Line_GCloud glines = new Line_GCloud();
        public KNN_ClosestTracker knn = new KNN_ClosestTracker();
        public Options_Features options = new Options_Features();
        public gravityLine gline;
        public Match_Basics match = new Match_Basics();
        cv.Point2f p1, p2;
        public FeatureLine_LongestKNN_CS()
        {
            desc = "Find and track the longest line in the BGR image with a lightweight KNN.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src;
            knn.Run(src.Clone());
            p1 = knn.lastPair.p1;
            p2 = knn.lastPair.p2;
            gline = glines.updateGLine(src, gline, new cv.Point(p1.X, p1.Y), new cv.Point(p2.X, p2.Y));
            cv.Rect rect = ValidateRect(new cv.Rect((int)Math.Min(p1.X, p2.X), (int)Math.Min(p1.Y, p2.Y), (int)Math.Abs(p1.X - p2.X) + 2, (int)Math.Abs(p1.Y - p2.Y)));
            match.template = new Mat(src, rect);
            match.Run(src);
            if (match.correlation >= options.correlationMin)
            {
                dst3 = match.dst0.Resize(dst3.Size());
                DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                DrawCircle(dst2, p1, vbc.task.DotSize, vbc.task.HighlightColor);
                DrawCircle(dst2, p2, vbc.task.DotSize, vbc.task.HighlightColor);
                rect = ValidateRect(new cv.Rect((int)(Math.Min(p1.X, p2.X)), (int)(Math.Min(p1.Y, p2.Y)), (int)(Math.Abs(p1.X - p2.X) + 2), (int)(Math.Abs(p1.Y - p2.Y))));
                match.template = new Mat(src, rect).Clone();
            }
            else
            {
                vbc.task.HighlightColor = vbc.task.HighlightColor == Scalar.Yellow ? Scalar.Blue : Scalar.Yellow;
                knn.lastPair = new PointPair(new Point2f(), new Point2f());
            }
            labels[2] = $"Longest line end points had correlation of {match.correlation:F3} with the original longest line.";
        }
    }




    public class FeatureLine_Longest_CS : VB_Parent
    {
        Line_GCloud glines = new Line_GCloud();
        public KNN_ClosestTracker knn = new KNN_ClosestTracker();
        public Options_Features options = new Options_Features();
        public gravityLine gline;
        public Match_Basics match1 = new Match_Basics();
        public Match_Basics match2 = new Match_Basics();
        public FeatureLine_Longest_CS()
        {
            labels[2] = "Longest line end points are highlighted ";
            desc = "Find and track the longest line in the BGR image with a lightweight KNN.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            double correlationMin = match1.options.correlationMin;
            int templatePad = match1.options.templatePad;
            int templateSize = match1.options.templateSize;
            cv.Point2f p1 = new cv.Point(), p2 = new cv.Point();
            if (vbc.task.heartBeat || (match1.correlation < correlationMin && match2.correlation < correlationMin))
            {
                knn.Run(src.Clone());
                p1 = knn.lastPair.p1;
                cv.Rect r1 = ValidateRect(new cv.Rect((int)(p1.X - templatePad), (int)(p1.Y - templatePad), templateSize, templateSize));
                match1.template = new Mat(src, r1).Clone();
                p2 = knn.lastPair.p2;
                cv.Rect r2 = ValidateRect(new cv.Rect((int)(p2.X - templatePad), (int)(p2.Y - templatePad), templateSize, templateSize));
                match2.template = new Mat(src, r2).Clone();
            }
            match1.Run(src);
            p1 = match1.matchCenter;
            match2.Run(src);
            p2 = match2.matchCenter;
            gline = glines.updateGLine(src, gline, new cv.Point(p1.X, p1.Y), new cv.Point(p2.X, p2.Y));
            DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth);
            DrawCircle(dst2, p1, vbc.task.DotSize, vbc.task.HighlightColor);
            DrawCircle(dst2, p2, vbc.task.DotSize, vbc.task.HighlightColor);
            SetTrueText($"{match1.correlation:F3}", new cv.Point(p1.X, p1.Y));
            SetTrueText($"{match2.correlation:F3}", new cv.Point(p2.X, p2.Y));
        }
    }







    public class FeaturePoly_Basics_CS : VB_Parent
    {
        public bool resync;
        public string resyncCause;
        public int resyncFrames;
        public float maskChangePercent;
        FeaturePoly_TopFeatures topFeatures = new FeaturePoly_TopFeatures();
        public FeaturePoly_Sides sides = new FeaturePoly_Sides();
        public FeaturePoly_Basics_CS()
        {
            FindSlider("Feature Sample Size").Value = 30;
            if (dst2.Width >= 640) FindSlider("Resync if feature moves > X pixels").Value = 15;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature Polygon with perpendicular lines for center of rotation.", "Feature polygon created by highest generation counts",
                  "Ordered Feature polygons of best features - white is original, yellow latest" };
            desc = "Build a Feature polygon with the top generation counts of the good features";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) sides.prevImage = src.Clone();
            sides.options.RunOpt();

            topFeatures.Run(src);
            dst2 = topFeatures.dst2;
            sides.currPoly = new List<cv.Point2f>(topFeatures.poly);
            if (sides.currPoly.Count < vbc.task.polyCount) return;
            sides.Run(src);
            dst3 = sides.dst2;
            for (int i = 0; i < sides.currPoly.Count; i++)
            {
                SetTrueText(i.ToString(), new cv.Point(sides.currPoly[i].X, sides.currPoly[i].Y), 3);
            }
            SetTrueText("Rotate center", new cv.Point(sides.rotateCenter.X + 10, sides.rotateCenter.Y), 3);
            string causes = "";
            if (Math.Abs(sides.rotateAngle * 57.2958) > 10)
            {
                resync = true;
                causes += " - Rotation angle exceeded threshold.";
                sides.rotateAngle = 0;
            }
            causes += "\n";
            if (vbc.task.optionsChanged)
            {
                resync = true;
                causes += " - Options changed";
            }
            causes += "\n";
            if (resyncFrames > sides.options.autoResyncAfterX)
            {
                resync = true;
                causes += $" - More than {sides.options.autoResyncAfterX} frames without resync";
            }
            causes += "\n";
            if (Math.Abs(sides.currLengths.Sum() - sides.prevLengths.Sum()) > sides.options.removeThreshold * vbc.task.polyCount)
            {
                resync = true;
                causes += $" - The top {vbc.task.polyCount} vertices have moved because of the generation counts";
            }
            else
            {
                if (Math.Abs(sides.prevFLineLen - sides.currFLineLen) > sides.options.removeThreshold)
                {
                    resync = true;
                    causes += $" - The Feature polygon's longest side (FLine) changed more than the threshold of {sides.options.removeThreshold} pixels";
                }
            }
            causes += "\n";
            if (resync || sides.prevPoly.Count != vbc.task.polyCount || vbc.task.optionsChanged)
            {
                sides.prevPoly = new List<cv.Point2f>(sides.currPoly);
                sides.prevLengths = new List<float>(sides.currLengths);
                sides.prevSideIndex = sides.prevLengths.IndexOf(sides.prevLengths.Max());
                sides.prevImage = src.Clone();
                resyncFrames = 0;
                resyncCause = causes;
            }
            resyncFrames++;
            strOut = $"Rotation: {sides.rotateAngle * 57.2958:F1} degrees{"\n"}";
            strOut += $"Translation: {(int)sides.centerShift.X}, {(int)sides.centerShift.Y}{"\n"}";
            strOut += $"Rotate center: {sides.rotateCenter.X:F0}, {sides.rotateCenter.Y:F0}{"\n"}";
            strOut += $"Frames since last resync: {resyncFrames:000}{"\n"}{"\n"}";
            strOut += $"Resync last caused by: {"\n"}{resyncCause}";
            foreach (var keyval in topFeatures.stable.goodCounts)
            {
                var ptmp = topFeatures.stable.basics.ptList[keyval.Value];
                var pt = new cv.Point((int)ptmp.X, (int)ptmp.Y);
                int g = topFeatures.stable.basics.facetGen.dst0.Get<int>(pt.Y, pt.X);
                SetTrueText(g.ToString(), pt);
            }
            SetTrueText(strOut, 1);
            resync = false;
        }
    }




    public class FeaturePoly_Sides_CS : VB_Parent
    {
        public List<cv.Point2f> currPoly = new List<cv.Point2f>();
        public int currSideIndex;
        public List<float> currLengths = new List<float>();
        public float currFLineLen;
        public PointPair mpCurr;
        public List<cv.Point2f> prevPoly = new List<cv.Point2f>();
        public int prevSideIndex;
        public List<float> prevLengths = new List<float>();
        public float prevFLineLen;
        public PointPair mpPrev;
        public Mat prevImage;
        public Point2f rotateCenter;
        public float rotateAngle;
        public Point2f centerShift;
        public Options_FPoly options = new Options_FPoly();
        Line_Nearest near = new Line_Nearest();
        public Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        List<cv.Point2f> newPoly;
        Random_Basics random = new Random_Basics();
        public FeaturePoly_Sides_CS()
        {
            labels[2] = "White is the original FPoly and yellow is the current FPoly.";
            desc = "Compute the lengths of each side in a polygon";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.FirstPass) prevImage = src.Clone();
            options.RunOpt();
            if (standaloneTest() && vbc.task.heartBeat)
            {
                random.Run(empty);
                currPoly = new List<cv.Point2f>(random.PointList);
            }
            dst2.SetTo(0);
            currLengths.Clear();
            for (int i = 0; i < currPoly.Count - 1; i++)
            {
                currLengths.Add(Distance(currPoly[i], currPoly[i + 1]));
            }
            currSideIndex = currLengths.IndexOf(currLengths.Max());
            if (vbc.task.FirstPass)
            {
                prevPoly = new List<cv.Point2f>(currPoly);
                prevLengths = new List<float>(currLengths);
                prevSideIndex = prevLengths.IndexOf(prevLengths.Max());
            }
            if (prevPoly.Count == 0) return;
            mpPrev = new PointPair(prevPoly[prevSideIndex], prevPoly[(prevSideIndex + 1) % vbc.task.polyCount]);
            mpCurr = new PointPair(currPoly[currSideIndex], currPoly[(currSideIndex + 1) % vbc.task.polyCount]);
            prevFLineLen = Distance(mpPrev.p1, mpPrev.p2);
            currFLineLen = Distance(mpCurr.p1, mpCurr.p2);
            float d1 = Distance(mpPrev.p1, mpCurr.p1);
            float d2 = Distance(mpPrev.p2, mpCurr.p2);
            PointPair newNear;
            if (d1 < d2)
            {
                centerShift = new Point2f(mpPrev.p1.X - mpCurr.p1.X, mpPrev.p1.Y - mpCurr.p1.Y);
                rotateCenter = mpPrev.p1;
                newNear = new PointPair(mpPrev.p2, mpCurr.p2);
            }
            else
            {
                centerShift = new Point2f(mpPrev.p2.X - mpCurr.p2.X, mpPrev.p2.Y - mpCurr.p2.Y);
                rotateCenter = mpPrev.p2;
                newNear = new PointPair(mpPrev.p1, mpCurr.p1);
            }
            List<cv.Point2f> transPoly = new List<cv.Point2f>();
            for (int i = 0; i < currPoly.Count; i++)
            {
                transPoly.Add(new Point2f(currPoly[i].X - centerShift.X, currPoly[i].Y - centerShift.Y));
            }
            newNear.p1 = new Point2f(newNear.p1.X - centerShift.X, newNear.p1.Y - centerShift.Y);
            newNear.p2 = new Point2f(newNear.p2.X - centerShift.X, newNear.p2.Y - centerShift.Y);
            rotateCenter = new Point2f(rotateCenter.X - centerShift.X, rotateCenter.Y - centerShift.Y);
            strOut = "No rotation" + "\n";
            rotateAngle = 0;
            if (d1 != d2)
            {
                if (Distance(newNear.p1, newNear.p2) > options.removeThreshold)
                {
                    near.lp = mpPrev;
                    near.pt = newNear.p1;
                    near.Run(empty);
                    DrawLine(dst1, near.pt, near.nearPoint, Scalar.Red, vbc.task.lineWidth + 5);
                    float hypotenuse = Distance(rotateCenter, near.pt);
                    rotateAngle = -(float)Math.Asin(Distance(near.nearPoint, near.pt) / hypotenuse);
                    if (float.IsNaN(rotateAngle)) rotateAngle = 0;
                    strOut = $"Angle is {rotateAngle * 57.2958:F1} degrees{"\n"}";
                }
            }
            strOut += $"Translation (shift) is {-centerShift.X:F0}, {-centerShift.Y:F0}";
            if (Math.Abs(rotateAngle) > 0)
            {
                rotatePoly.rotateCenter = rotateCenter;
                rotatePoly.rotateAngle = rotateAngle;
                rotatePoly.poly.Clear();
                rotatePoly.poly.Add(newNear.p1);
                rotatePoly.Run(empty);
                if (Distance(near.nearPoint, rotatePoly.poly[0]) > Distance(newNear.p1, rotatePoly.poly[0])) rotateAngle *= -1;
                rotatePoly.rotateAngle = rotateAngle;
                rotatePoly.poly = new List<cv.Point2f>(transPoly);
                rotatePoly.Run(empty);
                newPoly = new List<cv.Point2f>(rotatePoly.poly);
            }
            DrawFPoly(ref dst2, prevPoly, Scalar.White);
            DrawFPoly(ref dst2, currPoly, Scalar.Yellow);
            DrawFatLine(mpPrev.p1, mpPrev.p2, dst2, Scalar.White);
            DrawFatLine(mpCurr.p1, mpCurr.p2, dst2, Scalar.Yellow);
        }
        float Distance(Point2f p1, Point2f p2)
        {
            return (float)Math.Sqrt(Math.Pow(p2.X - p1.X, 2) + Math.Pow(p2.Y - p1.Y, 2));
        }
    }




    public class FeaturePoly_BasicsOriginal_CS : VB_Parent
    {
        public fPolyData fPD = new fPolyData();
        public Mat resyncImage;
        public bool resync;
        public string resyncCause;
        public int resyncFrames;
        public float maskChangePercent;
        FeaturePoly_TopFeatures topFeatures = new FeaturePoly_TopFeatures();
        public Options_FPoly options = new Options_FPoly();
        public object center;
        public FeaturePoly_BasicsOriginal_CS()
        {
            center = new FeaturePoly_Center(); // FeaturePoly_PerpendicularsTest can be used to test the perpendicular method of finding the rotate center.
            FindSlider("Feature Sample Size").Value = 30;
            if (dst2.Width >= 640) FindSlider("Resync if feature moves > X pixels").Value = 15;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature Polygon with perpendicular lines for center of rotation.", "Feature polygon created by highest generation counts",
                  "Ordered Feature polygons of best features - white is original, yellow latest" };
            desc = "Build a Feature polygon with the top generation counts of the good features";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) resyncImage = src.Clone();
            options.RunOpt();
            topFeatures.Run(src);
            dst2 = topFeatures.dst2;
            dst1 = topFeatures.dst3;
            fPD.currPoly = new List<cv.Point2f>(topFeatures.poly);
            if (vbc.task.optionsChanged) fPD = new fPolyData(fPD.currPoly);
            if (fPD.currPoly.Count < vbc.task.polyCount) return;
            fPD.computeCurrLengths();
            for (int i = 0; i < fPD.currPoly.Count; i++)
            {
                SetTrueText(i.ToString(), new cv.Point(fPD.currPoly[i].X, fPD.currPoly[i].Y), 1);
            }
            if (vbc.task.FirstPass) fPD.lengthPrevious = new List<float>(fPD.currLength);
            ((dynamic)center).fPD = fPD;
            ((dynamic)center).Run(src);
            fPD = ((dynamic)center).fPD;
            dst1 = (dst1 | ((dynamic)center).dst2).ToMat();
            dst0 = ((dynamic)center).dst3;
            fPD.jitterTest(dst2, this); // the feature line has not really moved.
            string causes = "";
            if (Math.Abs(fPD.rotateAngle * 57.2958) > 10)
            {
                resync = true;
                causes += " - Rotation angle exceeded threshold.";
                fPD.rotateAngle = 0;
            }
            causes += "\n";
            if (maskChangePercent > 0.2)
            {
                resync = true;
                causes += " - Difference of startFrame and current frame exceeded 20% of image size";
            }
            causes += "\n";
            if (vbc.task.optionsChanged)
            {
                resync = true;
                causes += " - Options changed";
            }
            causes += "\n";
            if (resyncFrames > options.autoResyncAfterX)
            {
                resync = true;
                causes += $" - More than {options.autoResyncAfterX} frames without resync";
            }
            causes += "\n";
            if (Math.Abs(fPD.currLength.Sum() - fPD.lengthPrevious.Sum()) > options.removeThreshold * vbc.task.polyCount)
            {
                resync = true;
                causes += $" - The top {vbc.task.polyCount} vertices have moved because of the generation counts";
            }
            else
            {
                if (fPD.computeFLineLength() > options.removeThreshold)
                {
                    resync = true;
                    causes += $" - The Feature polygon's longest side (FLine) changed more than the threshold of {options.removeThreshold} pixels";
                }
            }
            causes += "\n";
            if (resync || fPD.prevPoly.Count != vbc.task.polyCount || vbc.task.optionsChanged)
            {
                fPD.resync();
                resyncImage = src.Clone();
                resyncFrames = 0;
                resyncCause = causes;
            }
            resyncFrames++;
            DrawFPoly(ref dst2, fPD.currPoly, Scalar.White);
            fPD.DrawPolys(dst1, fPD.currPoly, this);
            for (int i = 0; i < fPD.prevPoly.Count; i++)
            {
                SetTrueText(i.ToString(), new cv.Point(fPD.currPoly[i].X, fPD.currPoly[i].Y), 1);
                SetTrueText(i.ToString(), new cv.Point(fPD.currPoly[i].X, fPD.currPoly[i].Y), 1);
            }
            strOut = $"Rotation: {fPD.rotateAngle * 57.2958:F1} degrees{"\n"}";
            strOut += $"Translation: {(int)fPD.centerShift.X}, {(int)fPD.centerShift.Y}{"\n"}";
            strOut += $"Rotate center: {fPD.rotateCenter.X:F0}, {fPD.rotateCenter.Y:F0}{"\n"}";
            strOut += $"Frames since last resync: {resyncFrames:000}{"\n"}";
            strOut += $"Last resync cause(s): {"\n"}{resyncCause}";
            foreach (var keyval in topFeatures.stable.goodCounts)
            {
                var pt = topFeatures.stable.basics.ptList[keyval.Value];
                int g = topFeatures.stable.basics.facetGen.dst0.At<int>((int)pt.Y, (int)pt.X);
                SetTrueText(g.ToString(), new cv.Point(pt.X, pt.Y));
            }
            SetTrueText(strOut, 1);
            dst3 = ((dynamic)center).dst3;
            labels[3] = ((dynamic)center).labels[3];
            resync = false;
        }
    }




    public class FeaturePoly_Plot_CS : VB_Parent
    {
        public FeaturePoly_Core fGrid = new FeaturePoly_Core();
        Plot_Histogram plot = new Plot_Histogram();
        public float[] hist;
        public List<float> distDiff = new List<float>();
        public FeaturePoly_Plot_CS()
        {
            plot.minRange = 0;
            plot.removeZeroEntry = false;
            labels = new string[] { "", "", "", "anchor and companions - input to distance difference" };
            desc = "Feature Grid: compute distances between good features from frame to frame and plot the distribution";
        }
        public void RunAlg(Mat src)
        {
            Mat lastDistance = fGrid.dst0.Clone();
            fGrid.Run(src);
            dst3 = fGrid.dst3;
            dst3 = src.Clone();
            hist = new float[fGrid.threshold + 2];
            distDiff.Clear();
            for (int i = 0; i < fGrid.stable.basics.facetGen.facet.facetList.Count; i++)
            {
                var pt = fGrid.stable.basics.ptList[i];
                float d = (float)fGrid.anchor.DistanceTo(pt);
                float lastd = lastDistance.At<float>((int)pt.Y, (int)pt.X);
                float absDiff = Math.Abs(lastd - d);
                if (absDiff >= hist.Length) absDiff = hist.Length - 1;
                if (absDiff < fGrid.threshold)
                {
                    hist[(int)absDiff]++;
                    DrawLine(dst3, fGrid.anchor, pt, vbc.task.HighlightColor, vbc.task.lineWidth);
                    distDiff.Add(absDiff);
                }
                else
                {
                    hist[fGrid.threshold]++;
                }
            }
            var hlist = hist.ToList();
            float peak = hlist.Max();
            int peakIndex = hlist.IndexOf(peak);
            Mat histMat = cv.Mat.FromPixelData(hist.Length, 1, MatType.CV_32F, hist);
            plot.maxRange = fGrid.stable.basics.ptList.Count;
            plot.Run(histMat);
            dst2 = plot.dst2;
            float avg = distDiff.Count > 0 ? distDiff.Average() : 0;
            labels[2] = $"Average distance change (after threshholding) = {avg:F3}, peak at {peakIndex} with {peak:F1} occurances";
        }
    }




    public class FeaturePoly_PlotWeighted_CS : VB_Parent
    {
        public FeaturePoly_Plot fPlot = new FeaturePoly_Plot();
        Plot_Histogram plot = new Plot_Histogram();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        public FeaturePoly_PlotWeighted_CS()
        {
            plot.minRange = 0;
            plot.removeZeroEntry = false;
            labels = new string[] { "", "Distance change from previous frame", "", "anchor and companions - input to distance difference" };
            desc = "Feature Grid: compute distances between good features from frame to frame and plot with weighting and Kalman to smooth results";
        }
        public void RunAlg(Mat src)
        {
            fPlot.Run(src);
            dst3 = fPlot.dst3;
            Mat lastPlot = plot.dst2.Clone();
            if (vbc.task.optionsChanged) kalman.kInput = new float[fPlot.hist.Length];
            kalman.kInput = fPlot.hist;
            kalman.Run(new Mat());
            fPlot.hist = kalman.kOutput;
            var hlist = fPlot.hist.ToList();
            float peak = hlist.Max();
            int peakIndex = hlist.IndexOf(peak);
            Mat histMat = cv.Mat.FromPixelData(fPlot.hist.Length, 1, MatType.CV_32F, fPlot.hist);
            plot.maxRange = fPlot.fGrid.stable.basics.ptList.Count;
            plot.Run(histMat);
            addw.src2 = plot.dst2;
            addw.Run(lastPlot);
            dst2 = addw.dst2;
            if (vbc.task.heartBeat)
            {
                float avg = fPlot.distDiff.Count > 0 ? fPlot.distDiff.Average() : 0;
                labels[2] = $"Average distance change (after threshholding) = {avg:F3}, peak at {peakIndex} with {peak:F1} occurances";
            }
        }
    }




    public class FeaturePoly_Stablizer_CS : VB_Parent
    {
        public FeaturePoly_Core fGrid;
        public FeaturePoly_Stablizer_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Movement amount - dot is current anchor point", "SyncImage aligned to current image - slide camera left or right",
                  "current image with distance map" };
            desc = "Feature Grid: show the accumulated camera movement in X and Y (no rotation)";
            fGrid = new FeaturePoly_Core();
        }
        public void RunAlg(Mat src)
        {
            fGrid.Run(src.Clone());
            dst3 = fGrid.dst3;
            labels[3] = fGrid.labels[2];
            Mat syncImage = src.Clone();
            if (fGrid.startAnchor == fGrid.anchor) syncImage = src.Clone();
            cv.Point shift = new cv.Point(fGrid.startAnchor.X - fGrid.anchor.X, fGrid.startAnchor.Y - fGrid.anchor.Y);
            cv.Rect rect = new cv.Rect();
            if (shift.X < 0) rect.X = 0; else rect.X = shift.X;
            if (shift.Y < 0) rect.Y = 0; else rect.Y = shift.Y;
            rect.Width = dst1.Width - Math.Abs(shift.X);
            rect.Height = dst1.Height - Math.Abs(shift.Y);

            dst1.SetTo(0);
            dst1[rect] = syncImage[rect];
            DrawLine(dst1, fGrid.startAnchor, fGrid.anchor, new cv.Scalar(255), 2);
            DrawCircle(dst1, fGrid.anchor, 5, new cv.Scalar(255), -1);
            cv.Rect r = new cv.Rect(0, 0, rect.Width, rect.Height);
            if (fGrid.anchor.X > fGrid.startAnchor.X) r.X = (int)(fGrid.anchor.X - fGrid.startAnchor.X);
            if (fGrid.anchor.Y > fGrid.startAnchor.Y) r.Y = (int)(fGrid.anchor.Y - fGrid.startAnchor.Y);

            dst2.SetTo(0);
            dst2[r] = syncImage[rect];
        }
    }




    public class FeaturePoly_StartPoints_CS : VB_Parent
    {
        public List<cv.Point> startPoints;
        public List<cv.Point> goodPoints;
        public FeaturePoly_Core fGrid = new FeaturePoly_Core();
        TrackBar resyncSlider;
        public FeaturePoly_StartPoints_CS()
        {
            resyncSlider = FindSlider("Resync if feature moves > X pixels");

            dst0 = new Mat(dst0.Rows, dst0.Cols, MatType.CV_8U, cv.Scalar.All(1));
            dst0.SetTo(new cv.Scalar(255));
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Track the feature grid points back to the last sync point";
        }
        public void RunAlg(Mat src)
        {
            int threshold = resyncSlider.Value;
            double maxShift = fGrid.anchor.DistanceTo(fGrid.startAnchor) + threshold;
            fGrid.Run(src);
            dst2 = fGrid.dst3;
            List<List<cv.Point>> facets = new List<List<cv.Point>>();
            Mat lastPoints = dst0.Clone();
            if (fGrid.startAnchor == fGrid.anchor || goodPoints.Count < 5)
            {
                startPoints = new List<cv.Point>();
                foreach (var pt in fGrid.goodPoints)
                {
                    startPoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
                }
                facets = new List<List<cv.Point>>(fGrid.goodFacets);
            }
            dst0.SetTo(new cv.Scalar(255));
            if (standaloneTest()) dst1.SetTo(new cv.Scalar(0));
            List<PointPair> mpList = new List<PointPair>();
            goodPoints = new List<cv.Point>();
            foreach (var pt in fGrid.goodPoints)
            {
                goodPoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            List<cv.Point> facet = new List<cv.Point>();
            List<int> usedGood = new List<int>();
            for (int i = 0; i < goodPoints.Count; i++)
            {
                cv.Point pt = goodPoints[i];
                byte startPoint = lastPoints.Get<byte>(pt.Y, pt.X);
                if (startPoint == 255 && i < 256) startPoint = (byte)i;
                if (startPoint < startPoints.Count && !usedGood.Contains(startPoint))
                {
                    usedGood.Add(startPoint);
                    facet = facets[startPoint];
                    dst0.FillConvexPoly(facet.ToArray(), cv.Scalar.All(startPoint), cv.LineTypes.Link4);
                    if (standaloneTest()) dst1.FillConvexPoly(facet.ToArray(), vbc.task.scalarColors[startPoint], vbc.task.lineType);
                    mpList.Add(new PointPair(startPoints[startPoint], pt));
                }
            }
            // dst3.SetTo(new cv.Scalar(0));
            foreach (PointPair mp in mpList)
            {
                if (mp.p1.DistanceTo(mp.p2) <= maxShift) DrawLine(dst1, mp.p1, mp.p2, new cv.Scalar(255, 255, 0), 2);
                DrawCircle(dst1, mp.p1, vbc.task.DotSize, new cv.Scalar(255, 255, 0), -1);
            }
            DrawLine(dst1, fGrid.anchor, fGrid.startAnchor, new cv.Scalar(255), vbc.task.lineWidth + 1);
        }
    }




    public class FeaturePoly_Triangle_CS : VB_Parent
    {
        Area_MinTriangle_CPP_VB triangle = new Area_MinTriangle_CPP_VB();
        FeaturePoly_Core fGrid = new FeaturePoly_Core();
        public FeaturePoly_Triangle_CS()
        {
            desc = "Find the minimum triangle that contains the feature grid";
        }
        public void RunAlg(Mat src)
        {
            fGrid.Run(src);
            dst2 = fGrid.dst2;
            triangle.srcPoints = new List<cv.Point2f>();
            foreach (var pt in fGrid.goodPoints)
            {
                triangle.srcPoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            triangle.Run(null);
            dst3 = triangle.dst2;
        }
    }




    public class FeaturePoly_TopFeatures_CS : VB_Parent
    {
        Stable_BasicsCount stable = new Stable_BasicsCount();
        List<cv.Point2f> poly = new List<cv.Point2f>();
        Options_FPoly options = new Options_FPoly();
        public FeaturePoly_TopFeatures_CS()
        {
            desc = "Get the top features and validate them";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            stable.Run(src);
            dst2 = stable.dst2;
            poly.Clear();
            foreach (KeyValuePair<int, int> keyVal in stable.goodCounts)
            {
                var ptmp = stable.basics.ptList[keyVal.Value];
                var pt = new cv.Point((int)ptmp.X, (int)ptmp.Y);
                int g = stable.basics.facetGen.dst0.Get<int>(pt.Y, pt.X);
                SetTrueText(g.ToString(), pt);
                if (poly.Count < vbc.task.polyCount) poly.Add(pt);
            }
            for (int i = 0; i < poly.Count - 1; i++)
            {
                DrawLine(dst2, poly[i], poly[i + 1], new cv.Scalar(255), 2);
            }
        }
    }




    public class FeaturePoly_WarpAffinePoly_CS : VB_Parent
    {
        Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        WarpAffine_BasicsQT warp = new WarpAffine_BasicsQT();
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        public FeaturePoly_WarpAffinePoly_CS()
        {
            labels = new string[] { "", "", "Feature polygon after just rotation - white (original), yellow (current)",
                  "Feature polygon with rotation and shift - should be aligned" };
            desc = "Rotate and shift just the Feature polygon as indicated by FeaturePoly_Basics";
        }
        public void RunAlg(Mat src)
        {
            fPoly.Run(src);
            List<cv.Point2f> polyPrev = fPoly.fPD.prevPoly;
            List<cv.Point2f> poly = new List<cv.Point2f>(fPoly.fPD.currPoly);
            dst2.SetTo(new cv.Scalar(0));
            dst3.SetTo(new cv.Scalar(0));
            DrawFPoly(ref dst2, polyPrev, new cv.Scalar(255));
            warp.rotateCenter = fPoly.fPD.rotateCenter;
            warp.rotateAngle = fPoly.fPD.rotateAngle;
            warp.Run(dst2);
            dst3 = warp.dst2;
            rotatePoly.rotateAngle = fPoly.fPD.rotateAngle;
            rotatePoly.rotateCenter = fPoly.fPD.rotateCenter;
            rotatePoly.poly = new List<cv.Point2f>(poly);
            rotatePoly.Run(null);
            if (fPoly.fPD.polyPrevSideIndex >= rotatePoly.poly.Count) fPoly.fPD.polyPrevSideIndex = 0;
            cv.Point offset = new cv.Point(rotatePoly.poly[fPoly.fPD.polyPrevSideIndex].X - polyPrev[fPoly.fPD.polyPrevSideIndex].X,
                                     rotatePoly.poly[fPoly.fPD.polyPrevSideIndex].Y - polyPrev[fPoly.fPD.polyPrevSideIndex].Y);
            cv.Rect r1 = new cv.Rect(offset.X, offset.Y, dst2.Width - Math.Abs(offset.X), dst2.Height - Math.Abs(offset.Y));
            if (offset.X < 0) r1.X = 0;
            if (offset.Y < 0) r1.Y = 0;
            cv.Rect r2 = new cv.Rect(Math.Abs(offset.X), Math.Abs(offset.Y), r1.Width, r1.Height);
            if (offset.X > 0) r2.X = 0;
            if (offset.Y > 0) r2.Y = 0;

            dst3[r1] = dst2[r1];
            dst3 -= dst2;

            DrawFPoly(ref dst3, rotatePoly.poly, new cv.Scalar(255, 255, 0));
            DrawFPoly(ref dst2, rotatePoly.poly, new cv.Scalar(255, 255, 0));
            SetTrueText(fPoly.strOut, 3);
        }
    }




    public class FeaturePoly_RotatePoints_CS : VB_Parent
    {
        Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        public List<cv.Point> poly;
        public List<cv.Point2f> polyPrev;
        public float rotateAngle;
        public cv.Point rotateCenter;
        public int polyPrevSideIndex;
        public cv.Point centerShift;
        public FeaturePoly_RotatePoints_CS()
        {
            labels = new string[] { "", "", "Feature polygon after just rotation - white (original), yellow (current)",
                  "Feature polygons with rotation and shift - should be aligned" };
            desc = "Rotate and shift just the Feature polygon as indicated by FeaturePoly_Basics";
        }
        public cv.Point shiftPoly(List<cv.Point2f> polyPrev, List<cv.Point> poly)
        {
            rotatePoly.rotateAngle = rotateAngle;
            rotatePoly.rotateCenter = rotateCenter;
            rotatePoly.poly = new List<cv.Point2f>();
            foreach (var pt in poly)
            {
                rotatePoly.poly.Add(new cv.Point2f(pt.X, pt.Y));
            }
            rotatePoly.Run(null);
            int totalX = (int)(rotatePoly.poly[polyPrevSideIndex].X - polyPrev[polyPrevSideIndex].X);
            int totalY = (int)(rotatePoly.poly[polyPrevSideIndex].Y - polyPrev[polyPrevSideIndex].Y);
            return new cv.Point(totalX, totalY);
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText(traceName + " is meant only to run with FeaturePoly_Basics to validate the translation", 3);
                return;
            }
            dst2.SetTo(new cv.Scalar(0));
            dst3.SetTo(new cv.Scalar(0));
            List<cv.Point2f> rotateAndShift = new List<cv.Point2f>();
            centerShift = shiftPoly(polyPrev, poly);
            DrawFPoly(ref dst2, polyPrev, new cv.Scalar(255));
            DrawFPoly(ref dst2, rotatePoly.poly, new cv.Scalar(255, 255, 0));
            for (int i = 0; i < polyPrev.Count; i++)
            {
                cv.Point2f p1 = new cv.Point(rotatePoly.poly[i].X - centerShift.X, rotatePoly.poly[i].Y - centerShift.Y);
                cv.Point p2 = new cv.Point(rotatePoly.poly[(i + 1) % vbc.task.polyCount].X - centerShift.X, rotatePoly.poly[(i + 1) % vbc.task.polyCount].Y - centerShift.Y);
                rotateAndShift.Add(p1);
                SetTrueText(i.ToString(), new cv.Point(rotatePoly.poly[i].X, rotatePoly.poly[i].Y), 2);
                SetTrueText(i.ToString(), new cv.Point(polyPrev[i].X, polyPrev[i].Y), 2);
            }
            DrawFPoly(ref dst3, polyPrev, new cv.Scalar(255));
            DrawFPoly(ref dst3, rotateAndShift, new cv.Scalar(255, 255, 0));
            strOut = "After Rotation: " + rotatePoly.rotateAngle.ToString("F2") + " degrees " +
                     "After Translation (shift) of: " + centerShift.X.ToString("F2") + ", " + centerShift.Y.ToString("F2") + "\r\n" +
                     "Center of Rotation: " + rotateCenter.X.ToString("F2") + ", " + rotateCenter.Y.ToString("F2") + "\r\n" +
                     "If the algorithm is working properly, the white and yellow Feature polygons below " + "\r\n" +
                     "should match in size and location.";
            SetTrueText(strOut, 3);
        }
    }




    public class FeaturePoly_WarpAffineImage_CS : VB_Parent
    {
        WarpAffine_BasicsQT warp = new WarpAffine_BasicsQT();
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        public FeaturePoly_WarpAffineImage_CS()
        {
            if (standaloneTest())
                vbc.task.gOptions.setDisplay1();
            desc = "Use OpenCV's WarpAffine to rotate and translate the starting image.";
        }
        public void RunAlg(Mat src)
        {
            fPoly.Run(src);
            warp.rotateCenter = fPoly.fPD.rotateCenter;
            warp.rotateAngle = fPoly.fPD.rotateAngle;
            warp.Run(fPoly.resyncImage.Clone());
            dst2 = warp.dst2;
            dst1 = fPoly.dst1;
            cv.Point2f offset = fPoly.fPD.centerShift;
            cv.Rect r1 = new cv.Rect((int)offset.X, (int)offset.Y, (int)(dst2.Width - Math.Abs(offset.X)), (int)(dst2.Height - Math.Abs(offset.Y)));
            if (offset.X < 0) r1.X = 0;
            if (offset.Y < 0) r1.Y = 0;
            cv.Rect r2 = new cv.Rect((int)Math.Abs(offset.X), (int)Math.Abs(offset.Y), r1.Width, r1.Height);
            if (offset.X > 0) r2.X = 0;
            if (offset.Y > 0) r2.Y = 0;
            dst3[r1] = dst2[r2];
            dst3 = src - dst2;
            Mat tmp = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat changed = tmp.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            int diffCount = changed.CountNonZero();
            strOut = fPoly.strOut;
            strOut += "\n" + string.Format("{0:N0}k pixels differ or {1:P0}", diffCount / 1000.0, (double)diffCount / dst3.Total());
            SetTrueText(strOut, 1);
        }
    }




    public class FeaturePoly_Perpendiculars_CS : VB_Parent
    {
        public Point2f altCenterShift;
        public fPolyData fPD;
        public FeaturePoly_RotatePoints rotatePoints = new FeaturePoly_RotatePoints();
        Line_Nearest near = new Line_Nearest();
        public FeaturePoly_Perpendiculars_CS()
        {
            labels = new string[] { "", "", "Output of FeaturePoly_Basics", "Center of rotation is where the extended lines intersect" };
            desc = "Find the center of rotation using the perpendicular lines from polymp and FLine (feature line) in FeaturePoly_Basics";
        }
        float findrotateAngle(Point2f p1, Point2f p2, Point2f pt)
        {
            near.lp = new PointPair(p1, p2);
            near.pt = pt;
            near.Run(empty);
            DrawLine(dst2, pt, near.nearPoint, Scalar.Red, vbc.task.lineWidth);
            double d1 = fPD.rotateCenter.DistanceTo(pt);
            double d2 = fPD.rotateCenter.DistanceTo(near.nearPoint);
            double angle = Math.Asin(near.nearPoint.DistanceTo(pt) / (d1 > d2 ? d1 : d2));
            if (double.IsNaN(angle)) return 0;
            return (float)angle;
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().");
                return;
            }
            Kalman_Basics kalman = new Kalman_Basics();
            Line_Perpendicular perp1 = new Line_Perpendicular();
            Line_Perpendicular perp2 = new Line_Perpendicular();
            dst2.SetTo(0);
            perp1.p1 = fPD.currPoly[fPD.polyPrevSideIndex];
            perp1.p2 = fPD.currPoly[(fPD.polyPrevSideIndex + 1) % vbc.task.polyCount];
            perp1.Run(empty);
            DrawLine(dst2, perp1.r1, perp1.r2, Scalar.Yellow, vbc.task.lineWidth);
            perp2.p1 = fPD.prevPoly[fPD.polyPrevSideIndex];
            perp2.p2 = fPD.prevPoly[(fPD.polyPrevSideIndex + 1) % vbc.task.polyCount];
            perp2.Run(empty);
            DrawLine(dst2, perp2.r1, perp2.r2, Scalar.White, vbc.task.lineWidth);
            fPD.rotateCenter = IntersectTest(perp2.r1, perp2.r2, perp1.r1, perp1.r2, new cv.Rect(0, 0, src.Width, src.Height));
            if (fPD.rotateCenter == new Point2f())
            {
                fPD.rotateAngle = 0;
            }
            else
            {
                DrawCircle(dst2, fPD.rotateCenter, vbc.task.DotSize + 2, Scalar.Red);
                fPD.rotateAngle = findrotateAngle(perp2.r1, perp2.r2, perp1.r1);
            }
            if (fPD.rotateAngle == 0) fPD.rotateCenter = new Point2f();
            altCenterShift = new Point2f(fPD.currPoly[fPD.polyPrevSideIndex].X - fPD.prevPoly[fPD.polyPrevSideIndex].X,
                                         fPD.currPoly[fPD.polyPrevSideIndex].Y - fPD.prevPoly[fPD.polyPrevSideIndex].Y);
            kalman.kInput = new float[] { fPD.rotateAngle };
            kalman.Run(empty);
            fPD.rotateAngle = kalman.kOutput[0];
            rotatePoints.poly = fPD.currPoly;
            rotatePoints.polyPrev = fPD.prevPoly;
            rotatePoints.polyPrevSideIndex = fPD.polyPrevSideIndex;
            rotatePoints.rotateAngle = fPD.rotateAngle;
            rotatePoints.Run(src);
            fPD.centerShift = rotatePoints.centerShift;
            dst3 = rotatePoints.dst3;
        }
    }




    public class FeaturePoly_PerpendicularsTest_CS : VB_Parent
    {
        FeaturePoly_Perpendiculars center = new FeaturePoly_Perpendiculars();
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        public FeaturePoly_PerpendicularsTest_CS()
        {
            fPoly.center = center;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Test the perpendicular method of finding the rotate center of the Feature Polygon";
        }
        public void RunAlg(Mat src)
        {
            fPoly.Run(src);
            dst1 = fPoly.dst1;
            dst2 = fPoly.dst2;
            dst3 = fPoly.dst3;
        }
    }




    public class FeaturePoly_PerpendicularsImage_CS : VB_Parent
    {
        FeaturePoly_Perpendiculars center = new FeaturePoly_Perpendiculars();
        FeaturePoly_Image fImage = new FeaturePoly_Image();
        public FeaturePoly_PerpendicularsImage_CS()
        {
            fImage.fpoly.center = center;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Rotate the image using the perpendicular method of finding the rotate center";
        }
        public void RunAlg(Mat src)
        {
            fImage.Run(src);
            dst1 = fImage.dst1;
            dst2 = fImage.dst2;
            dst3 = fImage.dst3;
        }
    }




    public class FeaturePoly_Image_CS : VB_Parent
    {
        public FeaturePoly_BasicsOriginal fpoly = new FeaturePoly_BasicsOriginal();
        Rotate_BasicsQT rotate = new Rotate_BasicsQT();
        public bool resync;
        public FeaturePoly_Image_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature polygon alignment, White is original, Yellow is current, Red Dot (if present) is center of rotation",
                                "Resync Image after rotation and translation", "Difference between current image and dst2" };
            desc = "Rotate and shift the image as indicated by FeaturePoly_Basics";
        }
        public void RunAlg(Mat src)
        {
            Mat input = src.Clone();
            fpoly.Run(src);
            dst1 = fpoly.dst1;
            if (!fpoly.resync)
            {
                if (!fpoly.fPD.featureLineChanged)
                {
                    dst2.SetTo(0);
                    dst3.SetTo(0);
                    rotate.rotateAngle = fpoly.fPD.rotateAngle;
                    rotate.rotateCenter = fpoly.fPD.rotateCenter;
                    rotate.Run(fpoly.resyncImage);
                    dst0 = rotate.dst2;
                    Point2f offset = fpoly.fPD.centerShift;
                    cv.Rect r1 = new cv.Rect((int)offset.X, (int)offset.Y, dst2.Width - Math.Abs((int)offset.X), dst2.Height - Math.Abs((int)offset.Y));
                    r1 = ValidateRect(r1);
                    if (offset.X < 0) r1.X = 0;
                    if (offset.Y < 0) r1.Y = 0;
                    cv.Rect r2 = new cv.Rect(Math.Abs((int)offset.X), Math.Abs((int)offset.Y), r1.Width, r1.Height);
                    r2.Width = r1.Width;
                    r2.Height = r1.Height;
                    if (r2.X < 0 || r2.X >= dst2.Width) return; // wedged...
                    if (r2.Y < 0 || r2.Y >= dst2.Height) return; // wedged...
                    if (offset.X > 0) r2.X = 0;
                    if (offset.Y > 0) r2.Y = 0;
                    Mat mask2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(255));
                    rotate.Run(mask2);
                    mask2 = rotate.dst2;
                    Mat mask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
                    mask[r1].SetTo(255);
                    mask[r1] = mask2[r2];
                    mask = ~mask;
                    dst2[r1] = dst0[r2];
                    dst3 = input - dst2;
                    dst3.SetTo(0, mask);
                }
                Mat tmp = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
                Mat changed = tmp.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
                int diffCount = changed.CountNonZero();
                resync = fpoly.resync;
                fpoly.maskChangePercent = (float)diffCount / dst3.Total();
                strOut = fpoly.strOut;
                strOut += "\n" + string.Format("{0:N0}k pixels differ or {1:P0}", diffCount / 1000.0, fpoly.maskChangePercent);
            }
            else
            {
                dst2 = fpoly.resyncImage.Clone();
                dst3.SetTo(0);
            }
            SetTrueText(strOut, 1);
        }
    }




    public class FeaturePoly_ImageMask_CS : VB_Parent
    {
        public FeaturePoly_Image fImage = new FeaturePoly_Image();
        public FeaturePoly_ImageMask_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.pixelDiffThreshold = 10;
            desc = "Build the image mask of the differences between the current frame and resync image";
        }
        public void RunAlg(Mat src)
        {
            fImage.Run(src);
            dst2 = fImage.dst3;
            dst0 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = dst0.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            labels = fImage.labels;
            dst1 = fImage.fpoly.dst1;
            SetTrueText(fImage.strOut, 1);
        }
    }




    public class FeaturePoly_PointCloud_CS : VB_Parent
    {
        public FeaturePoly_ImageMask fMask = new FeaturePoly_ImageMask();
        public Mat fPolyCloud;
        public FeaturePoly_PointCloud_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Update changed point cloud pixels as indicated by the FeaturePoly_ImageMask";
        }
        public void RunAlg(Mat src)
        {
            fMask.Run(src);
            if (fMask.fImage.fpoly.resync || vbc.task.FirstPass) fPolyCloud = vbc.task.pointCloud.Clone();
            dst1 = fMask.dst1;
            dst2 = fMask.dst2;
            dst3 = fMask.dst3;
            vbc.task.pointCloud.CopyTo(fPolyCloud, dst3);
            SetTrueText(fMask.fImage.strOut, 1);
        }
    }




    public class FeaturePoly_ResyncCheck_CS : VB_Parent
    {
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        int lastPixelCount = 0;
        public FeaturePoly_ResyncCheck_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "If there was no resync, check the longest side of the feature polygon (Feature Line) for unnecessary jitter.";
        }
        public void RunAlg(Mat src)
        {
            fPoly.Run(src);
            dst2 = fPoly.dst1;
            SetTrueText(fPoly.strOut, 2);
            if (fPoly.resync)
            {
                dst3.SetTo(0);
                lastPixelCount = 0;
            }
            if (fPoly.fPD.currPoly.Count < 2) return; // polygon not found...
            var polymp = fPoly.fPD.currmp();
            DrawLine(dst3, polymp.p1, polymp.p2, new Scalar(255), 1);
            int pixelCount = Cv2.CountNonZero(dst3);
            SetTrueText($"{Math.Abs(lastPixelCount - pixelCount)} pixels ", 3);
            lastPixelCount = pixelCount;
        }
    }




    public class FeaturePoly_Center_CS : VB_Parent
    {
        public Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        Line_Nearest near = new Line_Nearest();
        public fPolyData fPD;
        List<cv.Point2f> newPoly;
        public FeaturePoly_Center_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Layout of feature polygons after just translation - red line is used in sine computation",
                      "Layout of the starting (white) and current (yellow) feature polygons",
                      "Layout of feature polygons after rotation and translation" };
            desc = "Manually rotate and translate the current feature polygon to a previous feature polygon.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText(traceName + " is called by FeaturePoly_Basics to get the rotate center and angle." + "\n" +
                            "It does not produce any output when run standaloneTest().");
                return;
            }
            var thresholdSlider = FindSlider("Resync if feature moves > X pixels");
            float threshold = thresholdSlider.Value;
            int sindex1 = fPD.polyPrevSideIndex;
            int sIndex2 = (sindex1 + 1) % vbc.task.polyCount;
            var mp1 = fPD.currmp();
            var mp2 = fPD.prevmp();
            float d1 = (float)mp1.p1.DistanceTo(mp2.p1);
            float d2 = (float)mp1.p2.DistanceTo(mp2.p2);
            PointPair newNear;
            if (d1 < d2)
            {
                fPD.centerShift = new Point2f(mp1.p1.X - mp2.p1.X, mp1.p1.Y - mp2.p1.Y);
                fPD.rotateCenter = mp1.p1;
                newNear = new PointPair(mp1.p2, mp2.p2);
            }
            else
            {
                fPD.centerShift = new Point2f(mp1.p2.X - mp2.p2.X, mp1.p2.Y - mp2.p2.Y);
                fPD.rotateCenter = mp1.p2;
                newNear = new PointPair(mp1.p1, mp2.p1);
            }
            var transPoly = new List<cv.Point2f>();
            foreach (var point in fPD.currPoly)
            {
                transPoly.Add(new Point2f(point.X - fPD.centerShift.X, point.Y - fPD.centerShift.Y));
            }
            newNear.p1 = new Point2f(newNear.p1.X - fPD.centerShift.X, newNear.p1.Y - fPD.centerShift.Y);
            newNear.p2 = new Point2f(newNear.p2.X - fPD.centerShift.X, newNear.p2.Y - fPD.centerShift.Y);
            fPD.rotateCenter = new Point2f(fPD.rotateCenter.X - fPD.centerShift.X, fPD.rotateCenter.Y - fPD.centerShift.Y);
            dst1.SetTo(0);
            fPD.DrawPolys(dst1, transPoly, this);
            SetTrueText("Rotate center", new cv.Point(fPD.rotateCenter.X, fPD.rotateCenter.Y), 1);
            strOut = "No rotation" + "\n";
            fPD.rotateAngle = 0;
            if (d1 != d2)
            {
                if (newNear.p1.DistanceTo(newNear.p2) > threshold)
                {
                    near.lp = new PointPair(fPD.prevPoly[sindex1], fPD.prevPoly[sIndex2]);
                    near.pt = newNear.p1;
                    near.Run(new Mat());
                    DrawLine(dst1, near.pt, near.nearPoint, new Scalar(0, 0, 255), vbc.task.lineWidth + 5);
                    float hypotenuse = (float)fPD.rotateCenter.DistanceTo(near.pt);
                    fPD.rotateAngle = -(float)Math.Asin(near.nearPoint.DistanceTo(near.pt) / hypotenuse);
                    if (float.IsNaN(fPD.rotateAngle)) fPD.rotateAngle = 0;
                    strOut = $"Angle is {fPD.rotateAngle * 57.2958:F1} degrees" + "\n";
                }
            }
            strOut += $"Translation (shift) is {-fPD.centerShift.X:F0}, {-fPD.centerShift.Y:F0}";
            if (Math.Abs(fPD.rotateAngle) > 0)
            {
                rotatePoly.rotateCenter = fPD.rotateCenter;
                rotatePoly.rotateAngle = fPD.rotateAngle;
                rotatePoly.poly.Clear();
                rotatePoly.poly.Add(newNear.p1);
                rotatePoly.Run(new Mat());
                if (near.nearPoint.DistanceTo(rotatePoly.poly[0]) > newNear.p1.DistanceTo(rotatePoly.poly[0])) fPD.rotateAngle *= -1;
                rotatePoly.rotateAngle = fPD.rotateAngle;
                rotatePoly.poly = new List<cv.Point2f>(transPoly);
                rotatePoly.Run(new Mat());
                newPoly = new List<cv.Point2f>(rotatePoly.poly);
            }
            dst3.SetTo(0);
            fPD.DrawPolys(dst3, fPD.currPoly, this);
            SetTrueText(strOut, 2);
        }
    }




    public class FeaturePoly_EdgeRemoval_CS : VB_Parent
    {
        FeaturePoly_ImageMask fMask = new FeaturePoly_ImageMask();
        Edge_Basics edges = new Edge_Basics();
        public FeaturePoly_EdgeRemoval_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Remove edges from the FeaturePoly_ImageMask";
        }
        public void RunAlg(Mat src)
        {
            fMask.Run(src);
            dst2 = fMask.dst3;
            edges.Run(src);
            dst1 = edges.dst2;
            dst3 = dst2 & ~dst1;
        }
    }




    public class FeaturePoly_ImageNew_CS : VB_Parent
    {
        public FeaturePoly_Basics fpoly = new FeaturePoly_Basics();
        Rotate_BasicsQT rotate = new Rotate_BasicsQT();
        public bool resync;
        public FeaturePoly_ImageNew_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature polygon alignment, White is original, Yellow is current, Red Dot (if present) is center of rotation",
                  "Resync Image after rotation and translation", "Difference between current image and dst2" };
            desc = "Rotate and shift the image as indicated by FeaturePoly_Basics";
        }
        public void RunAlg(Mat src)
        {
            Mat input = src.Clone();
            fpoly.Run(src);
            dst1 = fpoly.dst3;
            if (!fpoly.resync)
            {
                dst2.SetTo(0);
                dst3.SetTo(0);
                rotate.rotateAngle = fpoly.sides.rotateAngle;
                rotate.rotateCenter = fpoly.sides.rotateCenter;
                rotate.Run(fpoly.sides.prevImage);
                dst0 = rotate.dst2;
                Point2f offset = fpoly.sides.centerShift;
                cv.Rect r1 = new cv.Rect((int)offset.X, (int)offset.Y, dst2.Width - Math.Abs((int)offset.X), dst2.Height - Math.Abs((int)offset.Y));
                if (offset.X < 0) r1.X = 0;
                if (offset.Y < 0) r1.Y = 0;
                cv.Rect r2 = new cv.Rect(Math.Abs((int)offset.X), Math.Abs((int)offset.Y), r1.Width, r1.Height);
                if (offset.X > 0) r2.X = 0;
                if (offset.Y > 0) r2.Y = 0;
                Mat mask2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(255));
                rotate.Run(mask2);
                mask2 = rotate.dst2;
                Mat mask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
                mask[r1].SetTo(255);
                mask[r1] = mask2[r2];
                Cv2.BitwiseNot(mask, mask);
                dst0[r2].CopyTo(dst2[r1]);
                Cv2.Subtract(input, dst2, dst3);
                dst3.SetTo(0, mask);
                Mat tmp = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
                Mat changed = tmp.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
                int diffCount = Cv2.CountNonZero(changed);
                resync = fpoly.resync;
                fpoly.maskChangePercent = (float)diffCount / dst3.Total();
                strOut = fpoly.strOut;
                strOut += "\n" + string.Format("{0:N0}k pixels differ or {1:P0}", diffCount / 1000.0, fpoly.maskChangePercent);
            }
            else
            {
                dst2 = fpoly.sides.prevImage.Clone();
                dst3.SetTo(0);
            }
            SetTrueText(strOut, 1);
        }
    }




    public class FeaturePoly_LeftRight_CS : VB_Parent
    {
        FeaturePoly_Basics leftPoly = new FeaturePoly_Basics();
        FeaturePoly_Basics rightPoly = new FeaturePoly_Basics();
        public FeaturePoly_LeftRight_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "Left image", "Right image", "FPoly output for left image", "FPoly output for right image" };
            desc = "Measure camera motion through the left and right images using FPoly";
        }
        public void RunAlg(Mat src)
        {
            dst0 = vbc.task.leftView;
            dst1 = vbc.task.rightView;
            leftPoly.Run(vbc.task.leftView);
            dst2 = leftPoly.dst3;
            SetTrueText(leftPoly.strOut, 2);
            rightPoly.Run(vbc.task.rightView);
            dst3 = rightPoly.dst3;
            SetTrueText(rightPoly.strOut, 3);
        }
    }






    public class FeaturePoly_Core_CS : VB_Parent
    {
        public Stable_GoodFeatures stable = new Stable_GoodFeatures();
        public Point2f anchor;
        public Point2f startAnchor;
        public List<cv.Point2f> goodPoints = new List<cv.Point2f>();
        public List<List<cv.Point>> goodFacets = new List<List<cv.Point>>();
        Options_FPoly options = new Options_FPoly();
        Options_FPolyCore optionsCore = new Options_FPolyCore();
        public FeaturePoly_Core_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32F, cv.Scalar.All(0));
            FindSlider("Feature Sample Size").Value = 20;
            labels = new string[] { "", "Distance change from previous frame", "", "Feature Grid with anchor" };
            desc = "Feature Grid: compute distances between good features from frame to frame";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsCore.RunOpt();

            stable.Run(src);
            dst3 = stable.basics.dst3;
            Mat lastDistance = dst0.Clone();
            anchor = stable.basics.anchorPoint;
            Point2f lastAnchor = anchor;
            if (lastAnchor.DistanceTo(anchor) > optionsCore.anchorMovement)
                lastDistance.SetTo(0);
            dst0.SetTo(0);
            goodPoints.Clear();
            goodFacets.Clear();
            dst2.SetTo(0);
            cv.Vec3b white = new cv.Vec3b(255, 255, 255);
            for (int i = 0; i < stable.basics.facetGen.facet.facetList.Count; i++)
            {
                List<cv.Point> facet = stable.basics.facetGen.facet.facetList[i];
                Point2f pt = stable.basics.ptList[i];
                double d = anchor.DistanceTo(pt);
                dst0.FillConvexPoly(facet, cv.Scalar.All(d), vbc.task.lineType);
                float lastd = lastDistance.Get<float>((int)pt.Y, (int)pt.X);
                double absDiff = Math.Abs(lastd - d);
                if (absDiff < optionsCore.resyncThreshold)
                {
                    goodPoints.Add(pt);
                    goodFacets.Add(facet);
                    SetTrueText(pt.ToString(), new cv.Point(pt.X, pt.Y), 2);
                    Cv2.Line(dst3, anchor.ToPoint(), pt.ToPoint(), vbc.task.HighlightColor);
                    dst2.Set<Vec3b>((int)pt.Y, (int)pt.X, white);
                }
            }
            Point2f shift = new Point2f(startAnchor.X - anchor.X, startAnchor.Y - anchor.Y);
            if (goodPoints.Count == 0 || Math.Abs(shift.X) > optionsCore.maxShift || Math.Abs(shift.Y) > optionsCore.maxShift)
                startAnchor = anchor;
            labels[2] = "Distance change (after threshholding) since last reset = " + shift.ToString();
            lastAnchor = anchor;
        }
    }







    public class FeatureROI_Basics_CS : VB_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public List<cv.Rect> rects = new List<cv.Rect>();
        public List<float> meanList = new List<float>();
        public List<float> stdevList = new List<float>();
        public float stdevAverage;
        public FeatureROI_Basics_CS()
        {
            vbc.task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use roi's to compute the stdev for each roi.  If small (<10), mark as featureLess (white).";
        }
        public void RunAlg(Mat src)
        {
            dst1 = src.Channels() != 1 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            stdevList.Clear();
            meanList.Clear();
            Scalar mean, stdev;
            foreach (var roi in vbc.task.gridRects)
            {
                Cv2.MeanStdDev(dst1[roi], out mean, out stdev);
                stdevList.Add((float)stdev.Val0);
                meanList.Add((float)mean.Val0);
            }
            stdevAverage = stdevList.Average();
            dst3.SetTo(0);
            rects.Clear();
            for (int i = 0; i < stdevList.Count; i++)
            {
                var roi = vbc.task.gridRects[i];
                var depthCheck = vbc.task.noDepthMask[roi];
                if (stdevList[i] < stdevAverage || depthCheck.CountNonZero() / depthCheck.Total() > 0.5)
                {
                    dst3.Rectangle(roi, Scalar.White, -1);
                }
                else
                {
                    rects.Add(roi);
                }
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = $"{rects.Count} of {vbc.task.gridRects.Count} roi's had above average standard deviation (average = {stdevList.Average().ToString(vbc.fmt1)})";
            }
            addw.src2 = dst3;
            addw.Run(dst1);
            dst2 = addw.dst2;
        }
    }




    public class FeatureROI_Color_CS : VB_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public FeatureROI_Color_CS()
        {
            FindSlider("Add Weighted %").Value = 70;
            vbc.task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use roi's to compute the stdev for each roi.  If small (<10), mark as featureLess (white).";
        }
        public void RunAlg(Mat src)
        {
            var stdevList0 = new List<float>();
            var stdevList1 = new List<float>();
            var stdevList2 = new List<float>();
            Scalar mean, stdev;
            foreach (var roi in vbc.task.gridRects)
            {
                Cv2.MeanStdDev(src[roi], out mean, out stdev);
                stdevList0.Add((float)stdev.Val0);
                stdevList1.Add((float)stdev.Val1);
                stdevList2.Add((float)stdev.Val2);
            }
            float avg0 = stdevList0.Average();
            float avg1 = stdevList1.Average();
            float avg2 = stdevList2.Average();
            dst3.SetTo(0);
            for (int i = 0; i < stdevList0.Count; i++)
            {
                var roi = vbc.task.gridRects[i];
                if (stdevList0[i] < avg0 && stdevList1[i] < avg1 && stdevList2[i] < avg2)
                {
                    dst3.Rectangle(roi, Scalar.White, -1);
                }
            }
            labels[3] = $"Stdev average X/Y/Z = {(int)stdevList0.Average()}, {(int)stdevList1.Average()}, {(int)stdevList2.Average()}";
            addw.src2 = dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.Run(src);
            dst2 = addw.dst2;
        }
    }




    public class FeatureROI_Canny_CS : VB_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        FeatureROI_Basics devGrid = new FeatureROI_Basics();
        public FeatureROI_Canny_CS()
        {
            vbc.task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            desc = "Create the stdev grid with the input image, then create the stdev grid for the canny output, then combine them.";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(src);
            dst3 = canny.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            devGrid.Run(src | dst3);
            dst2 = devGrid.dst2;
        }
    }




    public class FeatureROI_Sorted_CS : VB_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public SortedList<float, cv.Rect> sortedStd = new SortedList<float, cv.Rect>(new compareAllowIdenticalSingle());
        public List<Vec3b> bgrList = new List<Vec3b>();
        public List<cv.Rect> roiList = new List<cv.Rect>();
        public int[] categories;
        public Options_StdevGrid options = new Options_StdevGrid();
        public int maskVal = 255;
        public FeatureROI_Sorted_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            if (!standalone) maskVal = 1;
            labels[2] = "Use the AddWeighted slider to observe where stdev is above average.";
            desc = "Sort the roi's by the sum of their bgr stdev's to find the least volatile regions";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Scalar meanS, stdev;
            sortedStd.Clear();
            bgrList.Clear();
            roiList.Clear();
            categories = new int[10];
            foreach (var roi in vbc.task.gridRects)
            {
                Cv2.MeanStdDev(src[roi], out meanS, out stdev);
                sortedStd.Add((float)(stdev.Val0 + stdev.Val1 + stdev.Val2), roi);
                int colorIndex = 1;
                Vec3i mean = new Vec3i((int)meanS.Val0, (int)meanS.Val1, (int)meanS.Val2);
                if (mean.Item0 < options.minThreshold && mean.Item1 < options.minThreshold && mean.Item2 < options.minThreshold)
                    colorIndex = 1;
                else if (mean.Item0 > options.maxThreshold && mean.Item1 > options.maxThreshold && mean.Item2 > options.maxThreshold)
                    colorIndex = 2;
                else if (Math.Abs(mean.Item0 - mean.Item1) < options.diffThreshold && Math.Abs(mean.Item1 - mean.Item2) < options.diffThreshold)
                    colorIndex = 3;
                else if (Math.Abs(mean.Item1 - mean.Item2) < options.diffThreshold)
                    colorIndex = 4;
                else if (Math.Abs(mean.Item0 - mean.Item2) < options.diffThreshold)
                    colorIndex = 5;
                else if (Math.Abs(mean.Item0 - mean.Item1) < options.diffThreshold)
                    colorIndex = 6;
                else if (Math.Abs(mean.Item0 - mean.Item1) > options.diffThreshold && Math.Abs(mean.Item0 - mean.Item2) > options.diffThreshold)
                    colorIndex = 7;
                else if (Math.Abs(mean.Item1 - mean.Item0) > options.diffThreshold && Math.Abs(mean.Item1 - mean.Item2) > options.diffThreshold)
                    colorIndex = 8;
                else if (Math.Abs(mean.Item2 - mean.Item0) > options.diffThreshold && Math.Abs(mean.Item2 - mean.Item1) > options.diffThreshold)
                    colorIndex = 9;

                Vec3b color = black;
                if (colorIndex == 1) color = black;
                if (colorIndex == 2) color = white;
                if (colorIndex == 3) color = grayColor;
                if (colorIndex == 4) color = yellow;
                if (colorIndex == 5) color = purple;
                if (colorIndex == 6) color = teal;
                if (colorIndex == 7) color = blue;
                if (colorIndex == 8) color = green;
                if (colorIndex == 9) color = red;

                categories[colorIndex]++;
                bgrList.Add(color);
                roiList.Add(roi);
            }
            float avg = sortedStd.Keys.Average();
            int count = 0;
            dst2.SetTo(0);
            for (int i = 0; i < sortedStd.Count; i++)
            {
                float nextStdev = sortedStd.ElementAt(i).Key;
                if (nextStdev < avg)
                {
                    cv.Rect roi = sortedStd.ElementAt(i).Value;
                    dst2[roi].SetTo(maskVal);
                    count++;
                }
            }
            if (standaloneTest())
            {
                addw.src2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
                addw.Run(src);
                dst3 = addw.dst2;
            }
            labels[3] = $"{count} roi's or {(float)count / sortedStd.Count:P0} have an average stdev sum of {avg.ToString(vbc.fmt1)} or less";
        }
    }




    public class FeatureROI_ColorSplit_CS : VB_Parent
    {
        FeatureROI_Sorted devGrid = new FeatureROI_Sorted();
        public FeatureROI_ColorSplit_CS()
        {
            devGrid.maskVal = 255;
            vbc.task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            desc = "Split each roi into one of 9 categories - black, white, gray, yellow, purple, teal, blue, green, or red - based on the stdev for the roi";
        }
        public void RunAlg(Mat src)
        {
            devGrid.Run(src);
            for (int i = 0; i < devGrid.bgrList.Count; i++)
            {
                cv.Rect roi = devGrid.roiList[i];
                Vec3b color = devGrid.bgrList[i];
                dst2[roi].SetTo(color);
            }
            dst2.SetTo(0, ~devGrid.dst2);
            string strOut = "Categories:\n";
            for (int i = 1; i < devGrid.categories.Length; i++)
            {
                string colorName = "black";
                if (i == 1) colorName = "black";
                if (i == 2) colorName = "white";
                if (i == 3) colorName = "gray";
                if (i == 4) colorName = "yellow";
                if (i == 5) colorName = "purple";
                if (i == 6) colorName = "blue";
                if (i == 7) colorName = "red";

                strOut += $"{colorName}\t{devGrid.categories[i]}\n";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class FeatureROI_Correlation_CS : VB_Parent
    {
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public Plot_OverTimeSingle plot = new Plot_OverTimeSingle();
        public Options_Features options = new Options_Features();
        Mat lastImage;
        public FeatureROI_Correlation_CS()
        {
            FindSlider("Feature Correlation Threshold").Value = 90;
            desc = "Use the grid-based correlations with the previous image to determine if there was camera motion";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst1 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            gather.Run(dst1);
            dst2 = gather.dst2;
            if (vbc.task.FirstPass) lastImage = dst1.Clone();
            Mat correlationMat = new Mat();
            int motionCount = 0;
            for (int i = 0; i < gather.stdevList.Count; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                if (gather.stdevList[i] >= gather.stdevAverage)
                {
                    Cv2.MatchTemplate(dst1[roi], lastImage[roi], correlationMat, TemplateMatchModes.CCoeffNormed);
                    float corr = correlationMat.Get<float>(0, 0);
                    if (corr < options.correlationMin) SetTrueText(corr.ToString(vbc.fmt3), roi.TopLeft);
                    if (corr < options.correlationMin) motionCount++;
                }
            }
            plot.plotData = motionCount;
            plot.min = -1;
            plot.Run(empty);
            dst3 = plot.dst2;
            labels[2] = gather.rects.Count + " of " + vbc.task.gridRects.Count + " roi's had above average standard deviation.";
            lastImage = dst1.Clone();
        }
    }




    public class FeatureROI_LowStdev_CS : VB_Parent
    {
        public List<cv.Rect> rects = new List<cv.Rect>();
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public FeatureROI_LowStdev_CS()
        {
            desc = "Isolate the roi's with low stdev";
        }
        public void RunAlg(Mat src)
        {
            dst1 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            gather.Run(dst1);
            dst2 = gather.dst2;
            rects.Clear();
            for (int i = 0; i < gather.stdevList.Count; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                if (gather.stdevList[i] < gather.stdevAverage)
                {
                    rects.Add(roi);
                    SetTrueText(gather.stdevList[i].ToString(vbc.fmt3), roi.TopLeft, 3);
                }
            }
            if (vbc.task.heartBeat) labels = new string[] { "", "", (vbc.task.gridRects.Count - gather.rects.Count).ToString() + " roi's had low standard deviation ", "Stdev average = " + gather.stdevList.Average().ToString(vbc.fmt3) };
        }
    }




    public class FeatureROI_LowStdevCorrelation_CS : VB_Parent
    {
        public FeatureROI_LowStdev gather = new FeatureROI_LowStdev();
        public List<float> correlations = new List<float>();
        public Options_Features options = new Options_Features();
        public List<float> saveStdev = new List<float>();
        Mat lastImage;
        List<float> saveCorrs;
        List<cv.Rect> saveRects;
        public FeatureROI_LowStdevCorrelation_CS()
        {
            FindSlider("Feature Correlation Threshold").Value = 50;
            desc = "Display the correlation coefficients for roi's with low standard deviation.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst1 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            gather.Run(dst1);
            dst2 = gather.dst2;
            if (vbc.task.FirstPass) lastImage = dst1.Clone();
            Mat correlationMat = new Mat();
            correlations.Clear();
            foreach (cv.Rect roi in gather.rects)
            {
                Cv2.MatchTemplate(dst1[roi], lastImage[roi], correlationMat, TemplateMatchModes.CCoeffNormed);
                float corr = correlationMat.Get<float>(0, 0);
                correlations.Add(corr);
            }
            if (vbc.task.heartBeat)
            {
                saveCorrs = new List<float>(correlations);
                saveRects = new List<cv.Rect>(gather.rects);
                saveStdev.Clear();
                Scalar mean, stdev;
                for (int i = 0; i < saveRects.Count; i++)
                {
                    Cv2.MeanStdDev(dst1[saveRects[i]], out mean, out stdev);
                    saveStdev.Add((float)stdev[0]);
                }
            }
            for (int i = 0; i < saveRects.Count; i++)
            {
                if (saveCorrs[i] < options.correlationMin) SetTrueText(saveCorrs[i].ToString(vbc.fmt3), saveRects[i].TopLeft);
                if (saveCorrs[i] < options.correlationMin) SetTrueText(saveStdev[i].ToString(vbc.fmt3), saveRects[i].TopLeft, 3);
            }
            lastImage = dst1.Clone();
        }
    }




    public class FeatureROI_LR_CS : VB_Parent
    {
        public FeatureROI_Basics gLeft = new FeatureROI_Basics();
        public FeatureROI_Basics gRight = new FeatureROI_Basics();
        public FeatureROI_LR_CS()
        {
            desc = "Capture the above average standard deviation roi's for the left and right images.";
        }
        public void RunAlg(Mat src)
        {
            gLeft.Run(vbc.task.leftView);
            dst2 = gLeft.dst2;
            labels[2] = gLeft.rects.Count + " roi's had above average standard deviation in the left image";
            gRight.Run(vbc.task.rightView);
            dst3 = gRight.dst2;
            labels[3] = gRight.rects.Count + " roi's had above average standard deviation in the right image";
        }
    }




    public class FeatureROI_LRClick_CS : VB_Parent
    {
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public cv.Point ClickPoint = new cv.Point();
        public int picTag = 0;
        public Options_Features options = new Options_Features();
        public FeatureROI_LRClick_CS()
        {
            vbc.task.gOptions.setGridSize(16);
            FindSlider("Feature Correlation Threshold").Value = 80;
            if (standalone) vbc.task.gOptions.setDisplay1();
            if (standalone) vbc.task.gOptions.setDisplay1();
            labels[2] = "Click the above average stdev roi's (the darker regions) to find corresponding roi in the right image.";
            desc = "Capture the above average standard deviation roi's for the left and right images.";
        }
        public void setClickPoint(cv.Point pt, int _pictag)
        {
            ClickPoint = pt;
            picTag = _pictag;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst0 = src.Clone();
            dst3 = (vbc.task.rightView.Channels() != 3) ? vbc.task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : vbc.task.rightView.Clone();

            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.rightView.Channels() != 1) vbc.task.rightView = vbc.task.rightView.CvtColor(ColorConversionCodes.BGR2GRAY);

            gather.Run(src);
            dst2 = gather.dst2;
            labels = gather.labels;
            if (gather.rects.Count == 0) return;
            if (vbc.task.mouseClickFlag) setClickPoint(vbc.task.ClickPoint, vbc.task.mousePicTag);
            if (ClickPoint == new cv.Point()) setClickPoint(gather.rects[gather.rects.Count / 2].TopLeft, 2);

            int gridIndex = vbc.task.gridMap.Get<int>(ClickPoint.Y, ClickPoint.X);
            cv.Rect roi = vbc.task.gridRects[gridIndex];
            dst2.Rectangle(roi, Scalar.White, vbc.task.lineWidth);

            Mat correlationMat = new Mat();
            List<float> corr = new List<float>();
            for (int j = 0; j < roi.X; j++)
            {
                cv.Rect r = new cv.Rect(j, roi.Y, roi.Width, roi.Height);
                Cv2.MatchTemplate(src[roi], vbc.task.rightView[r], correlationMat, TemplateMatchModes.CCoeffNormed);
                corr.Add(correlationMat.Get<float>(0, 0));
            }
            if (corr.Count == 0)
            {
                SetTrueText("No corresponding roi found", 2);
            }
            else
            {
                float maxCorr = corr.Max();
                if (maxCorr < options.correlationMin)
                {
                    SetTrueText("Correlation " + maxCorr.ToString(vbc.fmt3) + " is less than " + options.correlationMin.ToString(vbc.fmt3), 1);
                }
                else
                {
                    int index = corr.IndexOf(maxCorr);
                    cv.Rect rectRight = new cv.Rect(index, roi.Y, roi.Width, roi.Height);
                    int offset = roi.TopLeft.X - rectRight.TopLeft.X;
                    if (vbc.task.heartBeat)
                    {
                        strOut = "CoeffNormed max correlation = " + maxCorr.ToString(vbc.fmt3) + "\n";
                        strOut += "Left Mean = " + gather.meanList[gridIndex].ToString(vbc.fmt3) + " Left stdev = " + gather.stdevList[gridIndex].ToString(vbc.fmt3) + "\n";
                        Scalar mean, stdev;
                        Cv2.MeanStdDev(dst3[rectRight], out mean, out stdev);
                        strOut += "Right Mean = " + mean[0].ToString(vbc.fmt3) + " Right stdev = " + stdev[0].ToString(vbc.fmt3) + "\n";
                        strOut += "Right rectangle is offset " + offset.ToString() + " pixels from the left image rectangle";
                    }
                    dst3.Rectangle(rectRight, vbc.task.HighlightColor, vbc.task.lineWidth);
                    dst0.Rectangle(roi, vbc.task.HighlightColor, vbc.task.lineWidth);
                    dst1 = Mat.Zeros(src.Size(), src.Type());
                    Cv2.Circle(dst1, roi.TopLeft, vbc.task.DotSize, vbc.task.HighlightColor, -1);
                    Cv2.Circle(dst1, new cv.Point(rectRight.X, roi.Y + 5), vbc.task.DotSize + 2, vbc.task.HighlightColor, -1);
                    cv.Point pt = new cv.Point(rectRight.X, roi.Y + 5);
                    SetTrueText((offset + " pixel offset" + "\n" + "Larger = Right").ToString(), pt, 1);
                    SetTrueText(strOut, 1);
                    labels[3] = "Corresponding roi highlighted in yellow.  Average stdev = " + gather.stdevAverage.ToString(vbc.fmt3);
                }
            }
        }
    }




    public class FeatureROI_LRAll_CS : VB_Parent
    {
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public Options_Features options = new Options_Features();
        public SortedList<float, cv.Rect> sortedRects = new SortedList<float, cv.Rect>(new compareAllowIdenticalSingleInverted());
        public FeatureROI_LRAll_CS()
        {
            vbc.task.gOptions.setGridSize(16);
            FindSlider("Feature Correlation Threshold").Value = 95;
            labels[3] = "The highlighted roi's are those high stdev roi's with the highest correlation between left and right images.";
            desc = "Find all the roi's with high stdev and high correlation between left and right images.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst3 = (vbc.task.rightView.Channels() != 3) ? vbc.task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : vbc.task.rightView.Clone();
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.rightView.Channels() != 1) vbc.task.rightView = vbc.task.rightView.CvtColor(ColorConversionCodes.BGR2GRAY);
            gather.Run(src);
            dst2 = gather.dst2;
            if (gather.rects.Count == 0) return;
            Mat correlationMat = new Mat();
            sortedRects.Clear();
            foreach (cv.Rect roi in gather.rects)
            {
                if (roi.X == 0) continue;
                cv.Rect r = new cv.Rect(0, roi.Y, roi.X, roi.Height);
                Cv2.MatchTemplate(src[roi], vbc.task.rightView[r], correlationMat, TemplateMatchModes.CCoeffNormed);
                mmData mm = GetMinMax(correlationMat);
                if (mm.maxVal >= options.correlationMin) sortedRects.Add((float)mm.maxVal, new cv.Rect(mm.maxLoc.X, roi.Y, roi.Width, roi.Height));
            }
            labels[2] = sortedRects.Count + " roi's had left/right correlation higher than " + options.correlationMin.ToString(vbc.fmt3);
            foreach (cv.Rect roi in sortedRects.Values)
            {
                dst3.Rectangle(roi, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
        }
    }







    public class Fibonacci_Basics_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        double a = 0, b = 1;
        public Fibonacci_Basics_CS()
        {
            flow.parentData = this;
            desc = "Generate the fibonacci sequence using conventional code";
        }
        public void RunAlg(Mat src)
        {
            if (a == 1134903170)
            {
                a = 0;
                b = 1;
            }
            double t = a + b;
            a = b;
            b = t;
            flow.nextMsg = t.ToString();
            flow.Run(empty);
        }
    }




    public class Fibonacci_Yield_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        public Fibonacci_Yield_CS()
        {
            flow.parentData = this;
            desc = "Generate the fibonacci sequence using ienumerable's";
        }
        IEnumerable<double> NextFib()
        {
            double a = 0;
            double b = 1;
            double t;
            while (true)
            {
                yield return a;
                t = a + b;
                if (a == 806515533049393) // start to lose precision after this...
                {
                    a = 0;
                    b = 1;
                    t = a + b;
                }
                a = b;
                b = t;
            }
        }
        public void RunAlg(Mat src)
        {
            IEnumerable<double> fibs = NextFib();
            flow.nextMsg = $"{vbc.task.frameCount % 74:00} fibonacci number {fibs.ElementAt(vbc.task.frameCount):###,##0}";
            flow.Run(empty);
        }
    }






    public class Filter_Laplacian_CS : VB_Parent
    {
        public Filter_Laplacian_CS()
        {
            labels[2] = "Sharpened image using Filter2D output";
            labels[3] = "Output of Filter2D (approximated Laplacian)";
            desc = "Use a filter to approximate the Laplacian derivative.";
        }
        public void RunAlg(Mat src)
        {
            Mat imgLaplacian = src.Filter2D(MatType.CV_32F,
                cv.Mat.FromPixelData(3, 3, MatType.CV_32FC1, new float[] { 1, 1, 1, 1, -8, 1, 1, 1, 1 }));
            src.ConvertTo(dst1, MatType.CV_32F);
            dst0 = (dst1 - imgLaplacian).ToMat();
            dst0.ConvertTo(dst2, src.Type());
            imgLaplacian.ConvertTo(dst3, src.Type());
        }
    }




    public class Filter_NormalizedKernel_CS : VB_Parent
    {
        Options_FilterNorm options = new Options_FilterNorm();
        public Filter_NormalizedKernel_CS()
        {
            desc = "Create a normalized kernel and use it.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            double sum = 0;
            for (int i = 0; i < options.kernel.Width; i++)
            {
                sum += Math.Abs(options.kernel.Get<float>(0, i));
            }
            labels[2] = $"kernel sum = {sum:F3}";
            Mat dst32f = src.Filter2D(MatType.CV_32FC1, options.kernel, anchor: new cv.Point(0, 0));
            dst32f.ConvertTo(dst2, MatType.CV_8UC3);
        }
    }




    public class Filter_Normalized2D_CS : VB_Parent
    {
        Options_Filter options = new Options_Filter();
        public Filter_Normalized2D_CS()
        {
            desc = "Create and apply a normalized kernel.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int kernelSize = standaloneTest() ? (vbc.task.frameCount % 20) + 1 : options.kernelSize;
            Mat kernel = new Mat(kernelSize, kernelSize, MatType.CV_32F).SetTo(1.0 / (kernelSize * kernelSize));
            dst2 = src.Filter2D(-1, kernel);
            labels[2] = $"Normalized KernelSize = {kernelSize}";
        }
    }




    public class Filter_SepFilter2D_CS : VB_Parent
    {
        Options_SepFilter2D options = new Options_SepFilter2D();
        public Filter_SepFilter2D_CS()
        {
            labels[2] = "Gaussian Blur result";
            desc = "Apply kernel X then kernel Y with OpenCV's SepFilter2D and compare to Gaussian blur";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat kernel = Cv2.GetGaussianKernel(options.xDim, options.sigma);
            dst2 = src.GaussianBlur(new cv.Size(options.xDim, options.yDim), options.sigma);
            dst3 = src.SepFilter2D(MatType.CV_8UC3, kernel, kernel);
            if (options.diffCheck)
            {
                Mat graySep = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
                Mat grayGauss = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
                dst3 = (graySep - grayGauss).ToMat().Threshold(0, 255, ThresholdTypes.Binary);
                labels[3] = $"Gaussian - SepFilter2D {dst3.CountNonZero()} pixels different.";
            }
            else
            {
                labels[3] = "SepFilter2D Result";
            }
        }
    }




    public class Filter_Minimum_CS : VB_Parent
    {
        Options_Filter options = new Options_Filter();
        public Filter_Minimum_CS()
        {
            desc = "Implement the Minimum Filter - use minimum value in kernel";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int kernelSize = standaloneTest() ? (vbc.task.frameCount % 20) + 1 : options.kernelSize;
            Mat element = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(kernelSize, kernelSize));
            dst2 = src.Erode(element);
        }
    }




    public class Filter_Maximum_CS : VB_Parent
    {
        Options_Filter options = new Options_Filter();
        public Filter_Maximum_CS()
        {
            desc = "Implement the Maximum Filter - use maximum value in kernel";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int kernelSize = standaloneTest() ? (vbc.task.frameCount % 20) + 1 : options.kernelSize;
            Mat element = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(kernelSize, kernelSize));
            dst2 = src.Dilate(element);
        }
    }




    public class Filter_Mean_CS : VB_Parent
    {
        Options_Filter options = new Options_Filter();
        public Filter_Mean_CS()
        {
            desc = "Implement the Mean Filter - use mean value in kernel";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int kernelSize = standaloneTest() ? (vbc.task.frameCount % 20) + 1 : options.kernelSize;
            Mat kernel = (Mat.Ones(MatType.CV_32FC1, kernelSize, kernelSize) / (kernelSize * kernelSize)).ToMat();
            dst2 = src.Filter2D(-1, kernel);
        }
    }




    public class Filter_Median_CS : VB_Parent
    {
        Options_Filter options = new Options_Filter();
        public Filter_Median_CS()
        {
            desc = "Implement the Median Filter - use median value in kernel";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int kernelSize = standaloneTest() ? (vbc.task.frameCount % 20) + 1 : options.kernelSize;
            if (kernelSize % 2 == 0) kernelSize += 1;
            dst2 = src.MedianBlur(kernelSize);
        }
    }






    public class FitEllipse_Basics_CS : VB_Parent
    {
        Options_MinArea options = new Options_MinArea();
        public List<cv.Point2f> inputPoints = new List<cv.Point2f>();
        public RotatedRect box;
        public Point2f[] vertices;
        public FitEllipse_Basics_CS()
        {
            desc = "Use FitEllipse OpenCV API to draw around a set of points";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            if (standaloneTest())
            {
                options.RunOpt();
                inputPoints = options.srcPoints;
            }
            dst2.SetTo(0);
            foreach (var pt in inputPoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White, -1);
            }
            if (inputPoints.Count > 4)
            {
                box = Cv2.FitEllipse(inputPoints);
                vertices = box.Points();
                if (standaloneTest())
                {
                    for (int j = 0; j < vertices.Length; j++)
                    {
                        DrawLine(dst2, vertices[j], vertices[(j + 1) % 4], Scalar.Green, vbc.task.lineWidth);
                    }
                    Cv2.Ellipse(dst2, box, Scalar.Green, vbc.task.lineWidth, vbc.task.lineType);
                }
            }
        }
    }




    public class FitEllipse_AMS_CPP_CS : VB_Parent
    {
        Options_MinArea options = new Options_MinArea();
        public List<cv.Point2f> inputPoints = new List<cv.Point2f>();
        public FitEllipse_AMS_CPP_CS()
        {
            labels[2] = "FitEllipse_AMS_CS C++ ";
            desc = "Use FitEllipse_AMS to draw around a set of points";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            if (standaloneTest())
            {
                options.RunOpt();
                inputPoints = options.srcPoints;
            }
            dst2.SetTo(0);
            foreach (var pt in inputPoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White, -1);
            }
            Mat input = cv.Mat.FromPixelData(inputPoints.Count, 1, MatType.CV_32FC2, inputPoints.ToArray());
            float[] dataSrc = new float[inputPoints.Count * 2];
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            GCHandle srcHandle = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr boxPtr = FitEllipse_AMS(srcHandle.AddrOfPinnedObject(), inputPoints.Count);
            srcHandle.Free();
            float[] ellipse = new float[5];
            Marshal.Copy(boxPtr, ellipse, 0, ellipse.Length);
            float angle = ellipse[0];
            Point2f center = new Point2f(ellipse[1], ellipse[2]);
            Size2f size = new Size2f(ellipse[3], ellipse[4]);
            if (size.Width < vbc.task.lineWidth + 1 || size.Height < vbc.task.lineWidth + 1) return;
            RotatedRect box = new RotatedRect(center, size, angle);
            Cv2.Ellipse(dst2, box, Scalar.Yellow, vbc.task.lineWidth, vbc.task.lineType);
        }
    }




    public class FitEllipse_Direct_CPP_CS : VB_Parent
    {
        Options_MinArea options = new Options_MinArea();
        public FitEllipse_Direct_CPP_CS()
        {
            labels[2] = "The FitEllipse_Direct C++ ";
            desc = "Use FitEllipse to draw around a set of points";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            options.RunOpt();
            float[] dataSrc = new float[options.srcPoints.Count * 2];
            dst2.SetTo(0);
            foreach (var pt in options.srcPoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White, -1);
            }
            Mat input = cv.Mat.FromPixelData(options.srcPoints.Count, 1, MatType.CV_32FC2, options.srcPoints.ToArray());
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            GCHandle srcHandle = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr boxPtr = FitEllipse_Direct(srcHandle.AddrOfPinnedObject(), options.srcPoints.Count);
            srcHandle.Free();
            float[] ellipse = new float[5];
            Marshal.Copy(boxPtr, ellipse, 0, ellipse.Length);
            float angle = ellipse[0];
            Point2f center = new Point2f(ellipse[1], ellipse[2]);
            Size2f size = new Size2f(ellipse[3], ellipse[4]);
            if (size.Width < vbc.task.lineWidth + 1 || size.Height < vbc.task.lineWidth + 1) return;
            RotatedRect box = new RotatedRect(center, size, angle);
            Cv2.Ellipse(dst2, box, Scalar.Yellow, vbc.task.lineWidth, vbc.task.lineType);
        }
    }




    public class FitEllipse_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        FitEllipse_Basics fitE = new FitEllipse_Basics();
        public FitEllipse_RedCloud_CS()
        {
            desc = "Create an ellipse from a contour";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            redC.Run(src);
            dst2 = redC.dst2;
            if (vbc.task.rc.contour == null) return;
            fitE.inputPoints.Clear();
            foreach (var pt in vbc.task.rc.contour)
            {
                fitE.inputPoints.Add(new Point2f(pt.X, pt.Y));
            }
            fitE.Run(new Mat());
            dst3.SetTo(0);
            dst3[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
            Cv2.Rectangle(dst3, vbc.task.rc.rect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            Cv2.Ellipse(dst3[vbc.task.rc.rect], fitE.box, Scalar.Yellow, vbc.task.lineWidth, vbc.task.lineType);
        }
    }






    public class FitLine_Basics_CS : VB_Parent
    {
        Options_FitLine options = new Options_FitLine();
        public Draw_Lines draw = new Draw_Lines();
        public List<cv.Point> lines = new List<cv.Point>(); // there are always an even number - 2 points define the line.
        public FitLine_Basics_CS()
        {
            FindSlider("DrawCount").Value = 2;
            labels[3] = "FitLine_Basics_CS input";
            desc = "Show how Fitline API works. When the lines overlap the image has a single contour and the lines are occasionally not found.";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            options.RunOpt();
            if (standaloneTest())
            {
                draw.Run(src);
                dst3 = draw.dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(1, 255, ThresholdTypes.Binary);
                dst2 = dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            }
            else
            {
                lines.Clear();
            }
            cv.Point[][] contours = Cv2.FindContoursAsArray(dst3, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);
            for (int i = 0; i < contours.Length; i++)
            {
                cv.Point[] tour = contours[i];
                Line2D line2d = Cv2.FitLine(tour.ToArray(), DistanceTypes.L2, 0, options.radiusAccuracy, options.angleAccuracy);
                double slope = line2d.Vy / line2d.Vx;
                int leftY = (int)Math.Round(-line2d.X1 * slope + line2d.Y1);
                int rightY = (int)Math.Round((src.Cols - line2d.X1) * slope + line2d.Y1);
                cv.Point p1 = new cv.Point(0, leftY);
                cv.Point p2 = new cv.Point(src.Cols - 1, rightY);
                if (standaloneTest())
                {
                    lines.Add(p1);
                    lines.Add(p2);
                }
                DrawLine(dst2, p1, p2, Scalar.Red, vbc.task.lineWidth);
            }
        }
    }




    public class FitLine_Basics3D_CS : VB_Parent
    {
        Hough_Lines_MT hlines = new Hough_Lines_MT();
        public FitLine_Basics3D_CS()
        {
            desc = "Use visual lines to find 3D lines.  This algorithm is NOT working.";
            labels[3] = "White is featureless RGB, blue depth shadow";
        }
        public void houghShowLines3D(Mat dst, Line3D segment)
        {
            double x = segment.X1 * dst.Cols;
            double y = segment.Y1 * dst.Rows;
            double m = segment.Vx < 0.001 ? 0 : segment.Vy / segment.Vx; // vertical slope a no-no.
            double b = y - m * x;
            cv.Point pt1 = new cv.Point(x, y);
            cv.Point pt2 = m == 0 ? new cv.Point(x, dst.Rows) : new cv.Point((dst.Rows - b) / m, dst.Rows);
            DrawLine(dst, pt1, pt2, Scalar.Red, vbc.task.lineWidth + 2);
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            hlines.Run(src);
            dst3 = hlines.dst3;
            Mat mask = dst3.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(1, 255, ThresholdTypes.Binary);
            dst3 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            src.CopyTo(dst2);
            List<Line3D> lines = new List<Line3D>();
            Line3D nullLine = new Line3D(0, 0, 0, 0, 0, 0);
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                Mat depth = vbc.task.pcSplit[2][roi];
                Mat fMask = mask[roi];
                List<cv.Point3f> points = new List<cv.Point3f>();
                int rows = src.Rows, cols = src.Cols;
                for (int y = 0; y < roi.Height; y++)
                {
                    for (int x = 0; x < roi.Width; x++)
                    {
                        if (fMask.Get<byte>(y, x) > 0)
                        {
                            float d = depth.Get<float>(y, x);
                            if (d > 0 && d < 10000)
                            {
                                points.Add(new Point3f(x / (float)rows, y / (float)cols, d / 10000f));
                            }
                        }
                    }
                }
                Line3D line = nullLine;
                if (points.Count == 0)
                {
                    // save the average color for this roi
                    Scalar mean = vbc.task.depthRGB[roi].Mean();
                    mean[0] = 255 - mean[0];
                    Cv2.Rectangle(dst3, roi, mean);
                }
                else
                {
                    line = Cv2.FitLine(points.ToArray(), DistanceTypes.L2, 0, 0, 0.01);
                }
                lock (lines)
                {
                    lines.Add(line);
                }
            });
            // putting this in the parallel for above causes a memory leak - could not find it...
            for (int i = 0; i < vbc.task.gridRects.Count; i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                houghShowLines3D(dst2[roi], lines[i]);
            }
        }
    }






    public class FLANN_Test_CS : VB_Parent
    {
        public FLANN_Test_CS()
        {
            desc = "Test basics of FLANN - Fast Library for Approximate Nearest Neighbor. ";
            labels[2] = "FLANN Basics";
        }
        public void RunAlg(Mat src)
        {
            // creates data set
            using (var features = new Mat(10000, 2, MatType.CV_32FC1))
            {
                Cv2.Randu(features, 0, new Random().Next(9900, 10000));
                var queryPoint = new Point2f(new Random().Next(0, 10000), new Random().Next(0, 10000));
                var queries = new Mat(1, 2, MatType.CV_32FC1);
                queries.Set<float>(0, 0, queryPoint.X);
                queries.Set<float>(0, 1, queryPoint.Y);
                // knnSearch
                using (var nnIndex = new cv.Flann.Index(features, new cv.Flann.KDTreeIndexParams(4)))
                {
                    int knn = 1;
                    int[] indices;
                    float[] dists;
                    nnIndex.KnnSearch(queries, out indices, out dists, knn, new cv.Flann.SearchParams(32));
                    var output = "";
                    for (int i = 0; i < knn; i++)
                    {
                        int index = indices[i];
                        float dist = dists[i];
                        var pt = new Point2f(features.Get<float>(index, 0), features.Get<float>(index, 1));
                        output += $"No.{i}\t\n";
                        output += $"index:{index}\n";
                        output += $"distance:{dist}\n";
                        output += $"data:({pt.X}, {pt.Y})\n";
                    }
                    SetTrueText(output);
                }
            }
        }
    }




    public class FLANN_Basics_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();
        Point2f[] qArray;
        Distance_Point3D dist = new Distance_Point3D();
        Options_FLANN options = new Options_FLANN();
        public FLANN_Basics_CS()
        {
            FindSlider("Random Pixel Count").Value = 5;
            desc = "FLANN - Fast Library for Approximate Nearest Neighbor.  Find nearest neighbor";
            labels[2] = "Red is query, Nearest points blue";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.reuseData == false || vbc.task.frameCount < 2 || vbc.task.mouseClickFlag)
                random.Run(empty); // fill result1 with random points in x and y range of the image.
            var features = cv.Mat.FromPixelData(random.PointList.Count, 2, MatType.CV_32F, random.PointList.ToArray());
            int matchCount = Math.Min(options.matchCount, random.PointList.Count - 1);
            dst2.SetTo(Scalar.White);
            for (int i = 0; i < features.Rows; i++)
            {
                var pt = random.PointList[i];
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Blue);
            }
            if (options.reuseData == false || vbc.task.optionsChanged || vbc.task.mouseClickFlag)
            {
                qArray = new Point2f[options.queryCount];
                for (int i = 0; i < options.queryCount; i++)
                {
                    qArray[i] = new Point2f(new Random().Next(0, src.Width), new Random().Next(0, src.Height));
                }
            }
            var queries = cv.Mat.FromPixelData(options.queryCount, 2, MatType.CV_32F, qArray);
            using (var nnIndex = new cv.Flann.Index(features, new cv.Flann.KDTreeIndexParams(matchCount)))
            {
                int[] indices;
                float[] distances;
                for (int i = 0; i < options.queryCount; i++)
                {
                    var pt1 = queries.Get<cv.Point2f>(i);
                    var query = new Mat(1, 2, MatType.CV_32F);
                    query.Set<float>(0, 0, pt1.X);
                    query.Set<float>(0, 1, pt1.Y);
                    nnIndex.KnnSearch(query, out indices, out distances, matchCount, 
                                      new cv.Flann.SearchParams(options.searchCheck, (float)options.eps, options.sorted));
                    for (int j = 0; j < matchCount; j++)
                    {
                        int index = indices[j];
                        if (index >= 0 && index < random.PointList.Count)
                        {
                            var pt2 = random.PointList[index];
                            DrawLine(dst2, pt1, pt2, Scalar.Red, vbc.task.lineWidth);
                        }
                    }
                    DrawCircle(dst2, pt1, vbc.task.DotSize, Scalar.Red);
                }
            }
            string output = "FLANN does not appear to be working (most likely, it is my problem) but to show this:\n";
            output += "Set query count to 1 and set to reuse the same data (defaults.)\n";
            output += "The query (in red) is often not picking the nearest blue point.\n";
            output += "To try different inputs, click anywhere in the image.";
            output += "To test further, set the match count to a higher value and observe it will often switch blue dots.\n";
            output += "Play with the EPS and searchparams check count to see if that helps.\n\n";
            output += "If the 'Search check' is set to 25 and the 'Match count' is set to 4, it does appear to return to the top 4.\n";
            output += "Perhaps FLANN is only good enough to find a group of neighbors.  Use with caution.";
            SetTrueText(output, new cv.Point(10, 50), 3);
        }
    }






    public class Flood_Basics_CS : VB_Parent
    {
        RedCloud_CPP_VB redCPP = new RedCloud_CPP_VB();
        public Cell_Generate genCells = new Cell_Generate();
        Color8U_Basics color;
        public Flood_Basics_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            desc = "Build the RedCloud cells with the grayscale input.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
            {
                if (color == null) color = new Color8U_Basics();
                color.Run(src);
                src = color.dst2;
            }
            else
            {
                redCPP.inputMask = src;
            }
            redCPP.Run(src);
            if (redCPP.classCount == 0) return; // no data to process.
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.rectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.removeContour = false;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            vbc.task.setSelectedContour();
            labels[2] = genCells.labels[2];
        }
    }




    public class Flood_CellStatsPlot_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Cell_BasicsPlot stats = new Cell_BasicsPlot();
        public Flood_CellStatsPlot_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setHistogramBins(1000);
            labels[1] = "Histogram of the depth for the selected cell.  Click any cell in the lower left.";
            desc = "Provide cell stats on the flood_basics cells.  Identical to Cell_Floodfill";
        }
        public void RunAlg(Mat src)
        {
            flood.Run(src);
            stats.Run(src);
            dst1 = stats.dst1;
            dst2 = flood.dst2;
            SetTrueText(stats.strOut, 3);
            if (vbc.task.ClickPoint == new cv.Point())
            {
                if (vbc.task.redCells.Count > 1)
                {
                    vbc.task.rc = vbc.task.redCells[1];
                    vbc.task.ClickPoint = vbc.task.rc.maxDist;
                }
            }
        }
    }




    public class Flood_ContainedCells_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        public Flood_ContainedCells_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            desc = "Find cells that have only one neighbor.  They are likely to be completely contained in another cell.";
        }
        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                flood.Run(src);
                dst2 = flood.dst2;
                labels = flood.labels;
            }
            List<int> removeCells = new List<int>();
            for (int i = vbc.task.redCells.Count - 1; i >= vbc.task.redOptions.identifyCount; i--)
            {
                var rc = vbc.task.redCells[i];
                List<int> nabs = new List<int>();
                List<int> contains = new List<int>();
                int count = Math.Min(vbc.task.redOptions.identifyCount, vbc.task.redCells.Count);
                for (int j = 0; j < count; j++)
                {
                    var rcBig = vbc.task.redCells[j];
                    if (rcBig.rect.IntersectsWith(rc.rect)) nabs.Add(rcBig.index);
                    if (rcBig.rect.Contains(rc.rect)) contains.Add(rcBig.index);
                }
                if (contains.Count == 1) removeCells.Add(rc.index);
            }
            dst3.SetTo(0);
            foreach (int index in removeCells)
            {
                var rc = vbc.task.redCells[index];
                dst3[rc.rect].SetTo(rc.color, rc.mask);
            }
            if (vbc.task.heartBeat) labels[3] = $"{removeCells.Count} cells were completely contained in exactly one other cell's rect";
        }
    }




    public class Flood_BasicsMask_CS : VB_Parent
    {
        public Mat binarizedImage;
        public Mat inputMask;
        public Cell_Generate genCells = new Cell_Generate();
        RedCloud_CPP_VB redCPP = new RedCloud_CPP_VB();
        public bool buildInputMask;
        public bool showSelected = true;
        Color8U_Basics cvt = new Color8U_Basics();
        public Flood_BasicsMask_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            labels[3] = "The inputMask used to limit how much of the image is processed.";
            desc = "Floodfill by color as usual but this is run repeatedly with the different tiers.";
        }
        public void RunAlg(Mat src)
        {
            if (standalone || buildInputMask)
            {
                cvt.Run(src);
                inputMask = vbc.task.pcSplit[2].InRange(vbc.task.MaxZmeters, vbc.task.MaxZmeters).ConvertScaleAbs();
                src = cvt.dst2;
            }
            dst3 = inputMask;
            redCPP.inputMask = inputMask;
            redCPP.Run(src);
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.rectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            int cellCount = Math.Min(vbc.task.redOptions.identifyCount, vbc.task.redCells.Count);
            if (vbc.task.heartBeat) labels[2] = $"{vbc.task.redCells.Count} cells identified and the largest {cellCount} are numbered below.";
            if (showSelected) vbc.task.setSelectedContour();
        }
    }




    public class Flood_Tiers_CS : VB_Parent
    {
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Depth_Tiers tiers = new Depth_Tiers();
        Color8U_Basics cvt = new Color8U_Basics();
        public Flood_Tiers_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            desc = "Subdivide the Flood_Basics cells using depth tiers.";
        }
        public void RunAlg(Mat src)
        {
            int tier = vbc.task.gOptions.DebugSliderValue;
            tiers.Run(src);
            if (tier >= tiers.classCount) tier = 0;
            if (tier == 0)
            {
                dst1 = ~tiers.dst2.InRange(0, 1);
            }
            else
            {
                dst1 = ~tiers.dst2.InRange(tier, tier);
            }
            labels[2] = tiers.labels[2] + " in tier " + tier.ToString() + ".  Use the global options 'DebugSlider' to select different tiers.";
            cvt.Run(src);
            flood.inputMask = dst1;
            flood.Run(cvt.dst2);
            dst2 = flood.dst2;
            dst3 = flood.dst3;
            vbc.task.setSelectedContour();
        }
    }




    public class Flood_Motion_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        List<rcData> redCells = new List<rcData>();
        Mat cellMap = new Mat();
        List<cv.Point2f> maxDists = new List<cv.Point2f>();
        List<int> maxIndex = new List<int>();
        public Flood_Motion_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Create RedCloud cells every heartbeat and compare the results against RedCloud cells created with the current frame.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                flood.Run(src);
                redCells = new List<rcData>(vbc.task.redCells);
                cellMap = vbc.task.cellMap.Clone();
                dst2 = flood.dst2.Clone();
                dst3 = flood.dst2.Clone();
                labels[2] = flood.labels[2];
                labels[3] = flood.labels[2];
                maxDists.Clear();
                foreach (var rc in redCells)
                {
                    maxDists.Add(rc.maxDist);
                    maxIndex.Add(rc.index);
                }
            }
            else
            {
                flood.Run(src);
                dst1.SetTo(0);
                for (int i = 0; i < vbc.task.redCells.Count; i++)
                {
                    var rc = vbc.task.redCells[i];
                    if (maxDists.Contains(rc.maxDist))
                    {
                        var lrc = redCells[maxIndex[maxDists.IndexOf(rc.maxDist)]];
                        dst1[lrc.rect].SetTo(lrc.color, lrc.mask);
                    }
                }
                dst3 = flood.dst2;
                labels[3] = flood.labels[2];
            }
        }
    }




    public class Flood_Motion1_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Motion_Basics motion = new Motion_Basics();
        List<rcData> redCells = new List<rcData>();
        List<cv.Point2f> maxDists = new List<cv.Point2f>();
        List<int> maxIndex = new List<int>();
        public Flood_Motion1_CS()
        {
            desc = "Create RedCloud cells every heartbeat and compare the results against RedCloud cells created with the current frame.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                flood.Run(src);
                redCells = new List<rcData>(vbc.task.redCells);
                dst2 = flood.dst2.Clone();
                dst3 = flood.dst2.Clone();
                labels[2] = flood.labels[2];
                labels[3] = flood.labels[2];
                maxDists.Clear();
                foreach (var rc in redCells)
                {
                    maxDists.Add(rc.maxDist);
                    maxIndex.Add(rc.index);
                }
            }
            else
            {
                flood.Run(src);
                motion.Run(flood.dst2);
                for (int i = 0; i < vbc.task.redCells.Count; i++)
                {
                    var rc = vbc.task.redCells[i];
                    if (maxDists.Contains(rc.maxDist))
                    {
                        var lrc = redCells[maxIndex[maxDists.IndexOf(rc.maxDist)]];
                        dst1[lrc.rect].SetTo(lrc.color, lrc.mask);
                    }
                }
                dst3 = flood.dst2;
                labels[3] = flood.labels[2];
            }
        }
    }




    public class Flood_LeftRight_CS : VB_Parent
    {
        RedCloud_Basics redLeft = new RedCloud_Basics();
        RedCloud_Basics redRight = new RedCloud_Basics();
        public Mat mapLeft;
        public Mat mapRight;
        public List<rcData> cellsLeft = new List<rcData>();
        public List<rcData> cellsRight = new List<rcData>();
        public Flood_LeftRight_CS()
        {
            mapLeft = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            mapRight = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.redOptions.setIdentifyCells(false);
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Floodfill left and right images.";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.redCells = new List<rcData>(cellsLeft);
            vbc.task.cellMap = mapLeft.Clone();
            redLeft.genCells.useLeftImage = true;
            redLeft.Run(vbc.task.leftView);
            labels[2] = redLeft.labels[2];
            dst2 = redLeft.dst2;
            cellsLeft = new List<rcData>(vbc.task.redCells);
            mapLeft = vbc.task.cellMap.Clone();
            vbc.task.redCells = new List<rcData>(cellsRight);
            vbc.task.cellMap = mapRight.Clone();
            redRight.genCells.useLeftImage = false;
            redRight.Run(vbc.task.rightView);
            labels[3] = redRight.labels[2];
            dst3 = redRight.dst2;
            cellsRight = new List<rcData>(vbc.task.redCells);
            mapRight = vbc.task.cellMap.Clone();
            if (vbc.task.redOptions.getIdentifyCells())
            {
                if (vbc.task.mousePicTag == 2)
                {
                    vbc.task.setSelectedContour(ref cellsLeft, ref mapLeft);
                    vbc.task.color[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
                }
                else
                {
                    vbc.task.setSelectedContour(ref cellsRight, ref mapRight);
                    dst1 = vbc.task.rightView;
                    dst1[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
                }
            }
        }
    }




    public class Flood_MaxDistPoints_CS : VB_Parent
    {
        Boundary_RemovedRects bounds = new Boundary_RemovedRects();
        RedCloud_MaxDist_CPP_VB redCPP = new RedCloud_MaxDist_CPP_VB();
        public Cell_Generate genCells = new Cell_Generate();
        Color8U_Basics cvt = new Color8U_Basics();
        public Flood_MaxDistPoints_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            labels[3] = "Contour boundaries - input to RedCloud_Basics";
            desc = "Build the RedCloud cells by providing the maxDist floodpoints to the RedCell C++ code.";
        }
        public void RunAlg(Mat src)
        {
            cvt.Run(src);
            redCPP.Run(cvt.dst2);
            if (redCPP.classCount == 0) return; // no data to process.
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.RectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.removeContour = false;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            redCPP.maxList.Clear();
            for (int i = 1; i < vbc.task.redCells.Count; i++)
            {
                redCPP.maxList.Add(vbc.task.redCells[i].maxDist.X);
                redCPP.maxList.Add(vbc.task.redCells[i].maxDist.Y);
            }
            vbc.task.setSelectedContour();
            labels[2] = genCells.labels[2];
        }
    }







    public class Font_OpenCV_CS : VB_Parent
    {
        public Font_OpenCV_CS()
        {
            desc = "Display different font options available in OpenCV";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            HersheyFonts hersheyFont = (HersheyFonts)((vbc.task.frameCount % 7) + 1);
            string hersheyName = new string[] { "HersheyComplex", "HersheyComplexSmall", "HersheyDuplex", "HersheyPlain", "HersheyScriptComplex",
                                            "HersheyScriptSimplex", "HersheySimplex", "HersheyTriplex", "Italic" }[vbc.task.frameCount % 7];
            labels[2] = hersheyName;
            labels[3] = "Italicized " + hersheyName;
            dst2.SetTo(0);
            dst3.SetTo(0);
            for (int i = 1; i <= 10; i++)
            {
                double size = 1.5 - i * 0.1;
                Cv2.PutText(dst2, $"{hersheyName} {size:F1}", new cv.Point(10, 30 + i * 30), hersheyFont, size, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
                HersheyFonts hersheyFontItalics = hersheyFont | HersheyFonts.Italic;
                Cv2.PutText(dst3, $"{hersheyName} {size:F1}", new cv.Point(10, 30 + i * 30), hersheyFontItalics, size, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            }
        }
    }





    public class Font_FlowTextOld_CS : VB_Parent
    {
        public List<string> msgs = new List<string>();
        public int dst = 2;
        public Font_FlowTextOld_CS()
        {
            desc = "Show TrueType text flowing through an image.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                msgs.Add("-------------------------------------------------------------------------------------------------------------------");
                msgs.Add("To get text to flow across an image in any algorithm, add 'flow = new Font_FlowText()' to the class constructor.");
                msgs.Add("Also optionally indicate if you want result1 or result2 for text (the default is result1.)");
                msgs.Add("Then in your Run method, add a line 'flow.msgs.add('your next line of text')' - for as many msgs as you need on each pass.");
                msgs.Add("Then at the end of your Run method, invoke flow.Run(empty)");
            }
            int maxLines = 31;
            if (vbc.task.dst2.Height == 720 || vbc.task.dst2.Height == 360 || vbc.task.dst2.Height == 180) maxLines = 23;
            bool clearRequested = false;
            if (msgs.Count > maxLines)
            {
                if (msgs.Count < maxLines * 2)
                {
                    msgs.RemoveRange(0, msgs.Count - maxLines);
                }
                else
                {
                    clearRequested = true;
                }
            }
            string strOut = string.Join("\n", msgs.GetRange(0, Math.Min(maxLines, msgs.Count)));
            SetTrueText(strOut, dst);
            if (clearRequested) msgs.Clear();
        }
    }




    public class Font_FlowText_CS : VB_Parent
    {
        public List<string> flowText = new List<string>();
        public string nextMsg;
        public int maxLines = 23;
        public int dst = 2;
        public List<TrueText> textResult = new List<TrueText>();
        public object parentData;
        public Font_FlowText_CS()
        {
            desc = "Show TrueType text flowing through an image.";
        }
        public void RunAlg(Mat src)
        {
            string strOut;
            if (standaloneTest())
            {
                strOut = "-------------------------------------------------------------------------------------------------------------------\n" +
                         "To get text to flow across an image in any algorithm, add Font_FlowText_CS to your algorithm.\n" +
                         "Also optionally indicate if you want 2 or 3 for text (the default is 2.)\n" +
                         "NOTE: add 'flow.parentData = me to your constructor for the algorithm.\n" +
                         "Then in your Run method, add a line 'flow.nextMsg = 'your next line of text'\n" +
                         "Then at the end of your Run method, invoke flow.Run(empty)";
            }
            else
            {
                flowText.Add(nextMsg);
                if (flowText.Count > maxLines) flowText.RemoveAt(0);
                strOut = string.Join("\n", flowText);
            }
            SetTrueText(strOut, dst);
            if (!standalone) ((dynamic)parentData).trueData = trueData;
        }
    }






    public class Foreground_Basics_CS : VB_Parent
    {
        KMeans_Depth simK = new KMeans_Depth();
        public float fgDepth;
        public Mat fg = new Mat(), bg = new Mat();
        public int classCount;
        public Foreground_Basics_CS()
        {
            labels[3] = "Foreground - all the KMeans classes up to and including the first class over 1 meter.";
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find the first KMeans class with depth over 1 meter and use it to define foreground";
        }
        public void RunAlg(Mat src)
        {
            simK.Run(src);
            classCount = simK.classCount;
            // Order the KMeans classes from foreground to background using depth data.
            List<Mat> depthMats = new List<Mat>();
            SortedList<float, int> sortedMats = new SortedList<float, int>(new CompareAllowIdenticalSingle());
            for (int i = 0; i < classCount; i++)
            {
                Mat tmp = simK.dst2.InRange(i, i);
                depthMats.Add(tmp.Clone());
                float depth = (float)vbc.task.pcSplit[2].Mean(tmp)[0];
                sortedMats.Add(depth, i);
            }
            fgDepth = 0;
            foreach (float depth in sortedMats.Keys)
            {
                if (depth >= 1)
                {
                    fgDepth = depth;
                    break; // find all the regions closer than a meter (inclusive)
                }
            }
            foreach (int index in sortedMats.Values)
            {
                Mat tmp = depthMats[index];
                dst1.SetTo(index + 1, tmp);
            }
            dst2 = ShowPalette(dst1 * 255 / depthMats.Count);
            fg = vbc.task.pcSplit[2].Threshold(fgDepth, 255, ThresholdTypes.BinaryInv).ConvertScaleAbs();
            dst0 = fg;
            fg.SetTo(0, vbc.task.noDepthMask);
            bg = ~fg;
            dst3.SetTo(0);
            src.CopyTo(dst3, fg);
            SetTrueText("KMeans classes are in dst1 - ordered by depth\nfg = foreground mask", 3);
            labels[2] = $"KMeans output defining the {classCount} classes";
        }
    }




    public class Foreground_KMeans_CS : VB_Parent
    {
        KMeans_Image km = new KMeans_Image();
        public Foreground_KMeans_CS()
        {
            FindSlider("KMeans k").Value = 2;
            labels = new string[] { "", "", "Foreground Mask", "Background Mask" };
            dst2 = new Mat(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Separate foreground and background using Kmeans with k=2.";
        }
        public void RunAlg(Mat src)
        {
            km.Run(vbc.task.pcSplit[2]);
            float minDistance = float.MaxValue;
            int minIndex = 0;
            for (int i = 0; i < km.km.colors.Rows; i++)
            {
                float distance = km.km.colors.Get<float>(i, 0);
                if (minDistance > distance && distance > 0)
                {
                    minDistance = distance;
                    minIndex = i;
                }
            }
            dst2.SetTo(0);
            dst2.SetTo(255, km.masks[minIndex]);
            dst2.SetTo(0, vbc.task.noDepthMask);
            dst3 = ~dst2;
            dst3.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class Foreground_Contours_CS : VB_Parent
    {
        public Foreground_Hist3D fore = new Foreground_Hist3D();
        Contour_General contours = new Contour_General();
        public Foreground_Contours_CS()
        {
            desc = "Create contours for the foreground mask";
        }
        public void RunAlg(Mat src)
        {
            fore.Run(src);
            contours.Run(fore.dst2);
            dst2 = contours.dst2;
        }
    }




    public class Foreground_Hist3D_CS : VB_Parent
    {
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        public Foreground_Hist3D_CS()
        {
            hcloud.maskInput = vbc.task.noDepthMask;
            labels = new string[] { "", "", "Foreground", "Background" };
            desc = "Use the first class of hist3Dcloud_Basics as the definition of foreground";
        }
        public void RunAlg(Mat src)
        {
            hcloud.Run(src);
            dst2.SetTo(0);
            dst2 = hcloud.dst2.InRange(1, 1) | vbc.task.noDepthMask;
            dst3 = ~dst2;
        }
    }




    public class Foreground_RedCloud_CS : VB_Parent
    {
        Foreground_CellsFore fore = new Foreground_CellsFore();
        Foreground_CellsBack back = new Foreground_CellsBack();
        public Foreground_RedCloud_CS()
        {
            desc = "Isolate foreground from background, then segment each with RedCloud";
        }
        public void RunAlg(Mat src)
        {
            fore.Run(src);
            dst2 = fore.dst2;
            labels[2] = fore.labels[2];
            back.Run(src);
            dst3 = back.dst2;
            labels[3] = back.labels[2];
            if (vbc.task.redCells.Count > 0)
            {
                dst2[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
            }
        }
    }




    public class Foreground_CellsFore_CS : VB_Parent
    {
        Foreground_Hist3D fore = new Foreground_Hist3D();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public List<rcData> redCells = new List<rcData>();
        public Foreground_CellsFore_CS()
        {
            vbc.task.redOptions.setIdentifyCells(false);
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Get the foreground cells";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            fore.Run(src);
            dst3 = fore.dst2 & vbc.task.depthMask;
            dst2.SetTo(0);
            foreach (rcData rc in vbc.task.redCells)
            {
                Mat tmp = dst3[rc.rect] & rc.mask;
                if (Cv2.CountNonZero(tmp) > 0)
                    dst2[rc.rect].SetTo(rc.color, rc.mask);
            }
        }
    }




    public class Foreground_CellsBack_CS : VB_Parent
    {
        Foreground_Hist3D fore = new Foreground_Hist3D();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public List<rcData> redCells = new List<rcData>();
        public Foreground_CellsBack_CS()
        {
            vbc.task.redOptions.setIdentifyCells(false);
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Get the background cells";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            fore.Run(src);
            dst3 = ~fore.dst2 & vbc.task.depthMask;
            dst2.SetTo(0);
            foreach (rcData rc in vbc.task.redCells)
            {
                Mat tmp = dst3[rc.rect] & rc.mask;
                if (Cv2.CountNonZero(tmp) > 0)
                    dst2[rc.rect].SetTo(rc.color, rc.mask);
            }
        }
    }






    public class Fractal_Mandelbrot_CS : VB_Parent
    {
        public float startX = -2;
        public float endX = 2;
        public float startY = -1.5f;
        public float endY = 1.5f;
        float incrX;
        float incrY;
        public Options_Fractal options = new Options_Fractal();
        public Fractal_Mandelbrot_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[2] = "Use the iteration slider to see the impact of the number of iterations.";
            desc = "Run the classic Mandalbrot algorithm";
        }
        public void reset()
        {
            startX = -2;
            endX = 2;
            startY = -1.5f;
            endY = 1.5f;
            vbc.task.drawRectClear = true;
        }
        public void mandelbrotLoop(int y)
        {
            incrX = (endX - startX) / dst2.Width;
            incrY = (endY - startY) / dst2.Height;
            for (int x = 0; x < dst2.Width; x++)
            {
                var c = new Complex((double)(startX + x * incrX), (double)(startY + y * incrY));
                var z = new Complex(0, 0);
                int iter = 0;
                while (Complex.Abs(z) < 2 && iter < options.iterations)
                {
                    z = z * z + c;
                    iter++;
                }
                dst2.Set<byte>(y, x, (byte)(iter < options.iterations ? 255 * iter / (options.iterations - 1) : 0));
            }
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            for (int y = 0; y < src.Height; y++)
            {
                mandelbrotLoop(y);
            }
        }
    }




    public class Fractal_MandelbrotZoom_CS : VB_Parent
    {
        public Fractal_Mandelbrot mandel = new Fractal_Mandelbrot();
        cv.Rect saveDrawRect = new cv.Rect(1, 1, 1, 1);
        public Fractal_MandelbrotZoom_CS()
        {
            desc = "Run the classic Mandalbrot algorithm and allow zooming in";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.drawRect.Width != 0)
            {
                float newStartX = mandel.startX + (mandel.endX - mandel.startX) * vbc.task.drawRect.X / src.Width;
                mandel.endX = mandel.startX + (mandel.endX - mandel.startX) * (vbc.task.drawRect.X + vbc.task.drawRect.Width) / src.Width;
                mandel.startX = newStartX;
                float newStartY = mandel.startY + (mandel.endY - mandel.startY) * vbc.task.drawRect.Y / src.Height;
                float height = vbc.task.drawRect.Width * src.Height / src.Width; // maintain aspect ratio across zooms...
                mandel.endY = mandel.startY + (mandel.endY - mandel.startY) * (vbc.task.drawRect.Y + height) / src.Height;
                mandel.startY = newStartY;
                vbc.task.drawRectClear = true;
            }
            if (mandel.options.resetCheck.Checked) mandel.reset();
            if (vbc.task.optionsChanged || saveDrawRect != vbc.task.drawRect)
            {
                saveDrawRect = vbc.task.drawRect;
                mandel.Run(src);
                mandel.options.resetCheck.Checked = false;
            }
            dst2 = mandel.dst2;
            labels[2] = mandel.endX - mandel.startX >= 3.999 ? "Mandelbrot Zoom - draw anywhere" : "Mandelbrot Zoom = ~" +
                string.Format("{0:###,###.0}X zoom", 4 / (mandel.endX - mandel.startX));
        }
    }




    public class Fractal_MandelbrotZoomColor_CS : VB_Parent
    {
        public Fractal_MandelbrotZoom zoom = new Fractal_MandelbrotZoom();
        public Fractal_MandelbrotZoomColor_CS()
        {
            desc = "Classic Mandelbrot in color";
        }
        public void RunAlg(Mat src)
        {
            if (zoom.mandel.options.resetCheck.Checked) zoom.mandel.reset();
            zoom.Run(src);
            dst2 = ShowPalette(zoom.dst2);
            labels[2] = zoom.labels[2];
        }
    }




    public class Fractal_Julia_CS : VB_Parent
    {
        Fractal_MandelbrotZoomColor mandel = new Fractal_MandelbrotZoomColor();
        double rt = 0.282;
        double mt = -0.58;
        cv.Point savedMouse = new cv.Point(-1, -1);
        System.Windows.Forms.CheckBox resetCheck;
        public Fractal_Julia_CS()
        {
            resetCheck = FindCheckBox("Reset to original Mandelbrot");
            labels[3] = "Mouse selects different Julia Sets - zoom for detail";
            desc = "Build Julia set from any point in the Mandelbrot fractal";
        }
        int julia_point(float x, float y, int r, int depth, int max, Complex c, Complex z)
        {
            if (Complex.Abs(z) > r)
            {
                int mt = (int)((255 * Math.Pow(max - depth, 2) % (max * max)) % 256);
                dst2.Set<byte>((int)y, (int)x, (byte)(255 - mt));
                depth = 0;
            }
            if (Math.Sqrt(Math.Pow(x - dst2.Width / 2, 2) + Math.Pow(y - dst2.Height / 2, 2)) > dst2.Height / 2)
                dst2.Set<byte>((int)y, (int)x, 0);
            if (depth < max / 4) return 0;
            return julia_point(x, y, r, depth - 1, max, c, Complex.Pow(z, 2) + c);
        }
        public void RunAlg(Mat src)
        {
            if (savedMouse != vbc.task.mouseMovePoint || resetCheck.Checked)
            {
                savedMouse = vbc.task.mouseMovePoint;
                mandel.Run(src);
                dst3 = mandel.dst2.Clone();
                int detail = 1;
                int depth = 100;
                int r = 2;
                dst2 = new Mat(src.Size(), MatType.CV_8U, cv.Scalar.All(0));
                Fractal_Mandelbrot m = mandel.zoom.mandel;
                rt = m.startX + (m.endX - m.startX) * vbc.task.mouseMovePoint.X / src.Width;
                mt = m.startY + (m.endY - m.startY) * vbc.task.mouseMovePoint.Y / src.Height;
                Complex c = new Complex(rt, mt);
                Parallel.For((int)(src.Width / 2 - src.Height / 2), (int)(src.Width / 2 + src.Height / 2),
                    x =>
                    {
                        for (int y = 0; y < src.Height; y += detail)
                        {
                            Complex z = new Complex(2 * r * (x - src.Width / 2) / src.Height, 2 * r * (y - src.Height / 2) / src.Height);
                            julia_point(x, y, r, depth, depth, c, z);
                        }
                    });
                dst2 = ShowPalette(dst2);
            }
        }
    }




    public class Fractal_Dimension_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Fractal_Dimension_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "RedCloud_Basics output - select any region.", "The selected region (as a square)" };
            desc = "Compute the fractal dimension of the provided (square) image.  Algorithm is incomplete.";
        }
        public double dimension(Mat Input)
        {
            Mat tmp64f = new Mat();
            Input.ConvertTo(tmp64f, MatType.CV_64F, 0, 0);
            int G = 256;
            double d = 0;
            for (int j = 2; j < Input.Width / 2 - 1; j++)
            {
                int h = Math.Max(1, (int)Math.Floor(G / (Math.Floor((double)(Input.Width / j)))));
                double r = (double)j / Input.Width;
                for (int i = 0; i < Input.Width; i += j)
                {
                    //Dim boxes() As 
                }
            }
            //    For L in range(2, (M // 2) + 1)
            //    h = max(1, g // (M // L))  # minimum box height Is 1
            //    N_r = 0
            //        r = L / M
            //        For i in range(0, M, L)
            //        boxes = [[]] * ((G + h - 1) // h)  # create enough boxes with height h to fill the fractal space
            //        For row in image[i:i +L]:   # boxes that exceed bounds are shrunk to fit
            //            For pixel in row[i:i +L]
            //                height = (pixel - G_min) // h  # lowest box Is at G_min And Each Is h gray levels tall
            //                boxes[height].append(pixel)  # assign the pixel intensity to the correct box
            //        stddev = np.sqrt(np.var(boxes, axis = 1))  # calculate the standard deviation Of Each box
            //        stddev = stddev[~np.isnan(stddev)]  # remove boxes With NaN standard deviations (empty)
            //        nBox_r = 2 * (stddev // h) + 1
            //                    N_r += sum(nBox_r)
            //                    If N_r!= prev Then :
            //                          # check for plateauing
            //        r_Nr.append([r, N_r])
            //                        prev = N_r
            //                        x = np.array([np.log(1 / point[0]) For point In r_Nr])  # log(1/r)
            //y = np.array([np.log(point[1]) For point In r_Nr])  # log(Nr)
            //D = np.polyfit(x, y, 1)[0]  # D = lim r -> 0 log(Nr)/log(1/r)
            return d;
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3.SetTo(0);
            cv.Rect rect = new cv.Rect(0, 0, vbc.task.rc.rect.Width, vbc.task.rc.rect.Height);
            if (vbc.task.optionsChanged || vbc.task.mouseClickFlag)
            {
                rect = new cv.Rect(0, 0, vbc.task.rc.rect.Width, vbc.task.rc.rect.Height);
            }
            if (vbc.task.rc.rect.Width == 0 || vbc.task.rc.rect.Height == 0) return;
            vbc.task.rc.mask.CopyTo(dst3[new cv.Rect(0, 0, vbc.task.rc.rect.Width, vbc.task.rc.rect.Height)]);
            if (rect.Width < rect.Height) rect.Width = rect.Height; else rect.Height = rect.Width;
            dst3.Rectangle(rect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
        }
    }





    public class FrameRate_Basics_CS : VB_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        int[] frameCounts = new int[4];
        Mat[] lastImages;
        public FrameRate_Basics_CS()
        {
            desc = "Compare each frame to its last to figure out which frames really changed for each invocation.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) lastImages = new Mat[] { vbc.task.color.Clone(), vbc.task.leftView.Clone(), vbc.task.rightView.Clone(), vbc.task.depthRGB.Clone() };
            for (int i = 0; i < frameCounts.Length; i++)
            {
                mats.mat[i] = vbc.task.color.Clone();
                if (i == 1) mats.mat[i] = vbc.task.leftView.Clone();
                if (i == 2) mats.mat[i] = vbc.task.rightView.Clone();
                if (i == 3) mats.mat[i] = vbc.task.depthRGB.Clone();
                mats.mat[i] -= lastImages[i];
                var count = mats.mat[i].Sum();
                if (count[0] > 0 || count[1] > 0 || count[2] > 0) frameCounts[i]++;
                mats.mat[i] = mats.mat[i].Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            }
            if (vbc.task.heartBeat)
            {
                strOut = "";
                for (int i = 0; i < frameCounts.Length; i++)
                {
                    if (i == 0) strOut += "Color";
                    if (i == 1) strOut += "Left";
                    if (i == 2) strOut += "Right";
                    if (i == 3) strOut += "Depth";
                    strOut += "\t" + " image frameCount = " + "\t";
                    strOut += string.Format("{0}\t frameCount = {1}\n", frameCounts[i], vbc.task.frameCount);
                }
            }
            SetTrueText(strOut, 3);
            mats.Run(empty);
            dst2 = mats.dst2;
            lastImages = new Mat[] { vbc.task.color.Clone(), vbc.task.leftView.Clone(), vbc.task.rightView.Clone(), vbc.task.depthRGB.Clone() };
        }
    }




    public class FrameRate_BasicsGray_CS : VB_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        int[] frameCounts = new int[4];
        Mat[] lastImages;
        public FrameRate_BasicsGray_CS()
        {
            desc = "Compare each frame to its last to figure out which frames really changed for each invocation.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) lastImages = new Mat[] { vbc.task.color.Clone(), vbc.task.leftView.Clone(), vbc.task.rightView.Clone(), vbc.task.depthRGB.Clone() };
            for (int i = 0; i < frameCounts.Length; i++)
            {
                mats.mat[i] = vbc.task.color.Clone();
                if (i == 1) mats.mat[i] = vbc.task.leftView.Clone();
                if (i == 2) mats.mat[i] = vbc.task.rightView.Clone();
                if (i == 3) mats.mat[i] = vbc.task.depthRGB.Clone();
                if (mats.mat[i].Channels() > 1)
                {
                    mats.mat[i] = mats.mat[i].CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                    lastImages[i] = lastImages[i].CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                } else
                {
                    mats.mat[i] = mats.mat[i];
                    lastImages[i] = lastImages[i];
                }

                mats.mat[i] -= lastImages[i];
                var count = mats.mat[i].CountNonZero();
                if (count > 0) frameCounts[i]++;
                mats.mat[i] = mats.mat[i].Threshold(0, 255, ThresholdTypes.Binary);
            }
            if (vbc.task.heartBeat)
            {
                strOut = "";
                for (int i = 0; i < frameCounts.Length; i++)
                {
                    if (i == 0) strOut += "Color";
                    if (i == 1) strOut += "Left";
                    if (i == 2) strOut += "Right";
                    if (i == 3) strOut += "Depth";
                    strOut += "\t" + " image frameCount = " + "\t";
                    strOut += string.Format("{0}\t frameCount = {1}\n", frameCounts[i], vbc.task.frameCount);
                }
            }
            SetTrueText(strOut, 3);
            mats.Run(empty);
            dst2 = mats.dst2;
            lastImages = new Mat[] { vbc.task.color.Clone(), vbc.task.leftView.Clone(), vbc.task.rightView.Clone(), vbc.task.depthRGB.Clone() };
        }
    }





    public class FREAK_Basics_CS : VB_Parent
    {
        ORB_Basics orb = new ORB_Basics();
        public FREAK_Basics_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Find keypoints using FREAK algorithm";
        }
        public void RunAlg(Mat src)
        {
            orb.Run(src);
            dst1 = orb.dst2;
            var freak = cv.XFeatures2D.FREAK.Create();
            Mat fdesc = new Mat();
            List<KeyPoint> keypoints = orb.keypoints.ToList();
            freak.Compute(src.CvtColor(ColorConversionCodes.BGR2GRAY), ref orb.keypoints, fdesc);
            dst2 = src.Clone();
            foreach (var kpt in keypoints)
            {
                var r = kpt.Size / 8;
                DrawCircle(dst2, kpt.Pt, (int)r, Scalar.Green);
                DrawLine(dst2, new cv.Point(kpt.Pt.X + r, kpt.Pt.Y + r), new cv.Point(kpt.Pt.X - r, kpt.Pt.Y - r), Scalar.Green, vbc.task.lineWidth);
                DrawLine(dst2, new cv.Point(kpt.Pt.X + r, kpt.Pt.Y - r), new cv.Point(kpt.Pt.X - r, kpt.Pt.Y + r), Scalar.Green, vbc.task.lineWidth);
            }
            labels[2] = orb.keypoints.Count().ToString() + " key points were identified";
            labels[3] = orb.keypoints.Count().ToString() + " FREAK Descriptors (resized) One row = keypoint";
            if (fdesc.Width > 0 && fdesc.Height > 0)
                dst3 = fdesc.Resize(dst3.Size());
        }
    }




    public class Fuzzy_Basics_CPP_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Options_Contours options = new Options_Contours();
        public cv.Point[][] contours;
        public SortedList<int, Vec2i> sortContours = new SortedList<int, Vec2i>(new compareAllowIdenticalIntegerInverted());
        public Fuzzy_Basics_CPP_CS()
        {
            var floodRadio = FindRadio("FloodFill");
            if (floodRadio.Enabled) floodRadio.Enabled = false; // too much special handling - cv_32SC1 image 
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.redOptions.setSimpleReductionBar(32);
            cPtr = Fuzzy_Open();
            FindRadio("CComp").Checked = true;
            labels = new[] { "", "Solid regions", "8-Bit output of Fuzzy_Basics_CS", "Fuzzy edges" };
            desc = "That which is not solid is fuzzy";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            reduction.Run(src);
            dst0 = reduction.dst2;
            if (dst0.Channels() != 1) dst0 = dst0.CvtColor(ColorConversionCodes.BGR2GRAY);
            var dataSrc = new byte[dst0.Total()];
            Marshal.Copy(dst0.Data, dataSrc, 0, dataSrc.Length);
            var handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            var imagePtr = Fuzzy_Run(cPtr, handleSrc.AddrOfPinnedObject(), dst0.Rows, dst0.Cols);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(dst0.Rows, dst0.Cols, MatType.CV_8UC1, imagePtr).Clone();
            dst3 = dst2.Threshold(0, 255, ThresholdTypes.BinaryInv);
            Mat tmp = new Mat();
            if (options.retrievalMode == RetrievalModes.CComp || options.retrievalMode == RetrievalModes.FloodFill)
            {
                dst3.ConvertTo(tmp, MatType.CV_32S);
            }
            else
            {
                dst3.ConvertTo(tmp, MatType.CV_8U);
            }
            contours = Cv2.FindContoursAsArray(tmp, options.retrievalMode, options.ApproximationMode);
            sortContours.Clear();
            for (int i = 0; i < contours.Length; i++)
            {
                // get this region's ID
                int maskID = 0;
                var pt = contours[i][0];
                for (int y = pt.Y - 1; y <= pt.Y + 1; y++)
                {
                    for (int x = pt.X - 1; x <= pt.X + 1; x++)
                    {
                        if (x < src.Width && y < src.Height && x >= 0 && y >= 0)
                        {
                            var val = dst2.Get<byte>(y, x);
                            if (val != 0)
                            {
                                maskID = val;
                                break;
                            }
                        }
                    }
                    if (maskID != 0) break;
                }
                sortContours.Add(contours[i].Length, new cv.Point(i, maskID));
            }
            dst1 = ShowPalette(dst2 * 255 / reduction.classCount);
            dst1.SetTo(0, dst3);
            labels[1] = "There were " + sortContours.Count + " contour > 100 points.";
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Fuzzy_Close(cPtr);
        }
    }




    public class Fuzzy_Filter_CS : VB_Parent
    {
        Mat kernel;
        Reduction_Basics reduction = new Reduction_Basics();
        public cv.Point[][] contours;
        public SortedList<int, Vec2i> sortContours = new SortedList<int, Vec2i>(new compareAllowIdenticalIntegerInverted());
        Options_Contours options = new Options_Contours();
        public Fuzzy_Filter_CS()
        {
            float[] array = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };
            kernel = cv.Mat.FromPixelData(3, 3, MatType.CV_32F, array);
            kernel *= 1 / 9.0;
            desc = "Use a 2D filter to find smooth areas";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            reduction.Run(src);
            Mat src32f = new Mat();
            reduction.dst2.ConvertTo(src32f, MatType.CV_32F);
            dst2 = src32f.Filter2D(-1, kernel);
            dst3 = dst2.Subtract(src32f);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.BinaryInv);
            dst3.ConvertTo(dst3, MatType.CV_8U);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.BinaryInv);
            if (options.retrievalMode == RetrievalModes.FloodFill)
            {
                Mat tmp = new Mat();
                dst3.ConvertTo(tmp, MatType.CV_32S);
                contours = Cv2.FindContoursAsArray(tmp, options.retrievalMode, options.ApproximationMode);
            }
            else
            {
                contours = Cv2.FindContoursAsArray(dst3, options.retrievalMode, options.ApproximationMode);
            }
            sortContours.Clear();
            for (int i = 0; i < contours.Length; i++)
            {
                int maskID = 0;
                var pt = contours[i][0];
                for (int y = pt.Y - 1; y <= pt.Y + 1; y++)
                {
                    for (int x = pt.X - 1; x <= pt.X + 1; x++)
                    {
                        if (x < src.Width && y < src.Height && x >= 0 && y >= 0)
                        {
                            var val = reduction.dst2.Get<byte>(y, x);
                            if (val != 0)
                            {
                                maskID = val;
                                break;
                            }
                        }
                    }
                    if (maskID != 0) break;
                }
                sortContours.Add(contours[i].Length, new cv.Point(i, maskID));
            }
            dst2 = ShowPalette(reduction.dst2 * 255 / reduction.classCount);
            dst2.SetTo(0, dst3);
        }
    }




    public class Fuzzy_ContoursDepth_CS : VB_Parent
    {
        public Fuzzy_Basics fuzzyD = new Fuzzy_Basics();
        public Fuzzy_ContoursDepth_CS()
        {
            desc = "Use contours to outline solids in the depth data";
        }
        public void RunAlg(Mat src)
        {
            fuzzyD.Run(vbc.task.depthRGB);
            dst2 = fuzzyD.dst1;
        }
    }




    public class Fuzzy_NeighborProof_CS : VB_Parent
    {
        Fuzzy_Basics fuzzy = new Fuzzy_Basics();
        bool proofFailed = false;
        public Fuzzy_NeighborProof_CS()
        {
            desc = "Prove that every contour point has at one and only one neighbor with the mask ID and that the rest are zero";
        }
        public void RunAlg(Mat src)
        {
            if (proofFailed) return;
            fuzzy.Run(src);
            dst2 = fuzzy.dst1;
            for (int i = 0; i < fuzzy.contours.Length; i++)
            {
                int len = fuzzy.contours[i].Length;
                for (int j = 0; j < len; j++)
                {
                    var pt = fuzzy.contours[i][j];
                    int maskID = 0;
                    for (int y = Math.Max(0, pt.Y - 1); y <= pt.Y + 1; y++)
                    {
                        for (int x = Math.Max(0, pt.X - 1); x <= pt.X + 1; x++)
                        {
                            if (x < src.Width && y < src.Height)
                            {
                                var val = dst2.Get<byte>(y, x);
                                if (val != 0) maskID = val;
                                if (maskID != 0 && val != 0 && maskID != val)
                                {
                                    System.Windows.Forms.MessageBox.Show("Proof has failed!  There is more than one mask ID identified by this contour point.");
                                    proofFailed = true;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
            SetTrueText("Results are valid.\nMask ID's for all contour points in each region identified only one region.", new cv.Point(10, 50), 3);
        }
    }




    public class Fuzzy_TrackerDepth_CS : VB_Parent
    {
        public Fuzzy_Basics fuzzy = new Fuzzy_Basics();
        public List<cv.Point> centroids = new List<cv.Point>();
        public List<cv.Rect> rects = new List<cv.Rect>();
        public List<int> layoutColor = new List<int>();
        public cv.Point highlightPoint;
        public cv.Rect highlightRect;
        public int highlightRegion = -1;
        Options_TrackerDepth options = new Options_TrackerDepth();
        public Fuzzy_TrackerDepth_CS()
        {
            desc = "Create centroids and rect's for solid regions and track them - tracker";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            fuzzy.Run(vbc.task.depthRGB);
            dst2 = fuzzy.dst1;
            centroids.Clear();
            rects.Clear();
            layoutColor.Clear();
            double minX, maxX, minY, maxY;
            foreach (var vec in fuzzy.sortContours.Values)
            {
                var contours = fuzzy.contours[vec[0]];
                var points = cv.Mat.FromPixelData(contours.Length, 1, MatType.CV_32SC2, contours);
                var center = points.Sum();
                points = cv.Mat.FromPixelData(contours.Length, 2, MatType.CV_32S, contours);
                points.Col(0).MinMaxIdx(out minX, out maxX);
                points.Col(1).MinMaxIdx(out minY, out maxY);
                var rect = new cv.Rect((int)minX, (int)minY, (int)(maxX - minX), (int)(maxY - minY));
                if (rect.Width * rect.Height > options.minRectSize)
                {
                    var centroid = new cv.Point((int)(center[0] / contours.Length), (int)(center[1] / contours.Length));
                    centroids.Add(centroid);
                    rects.Add(rect);
                    layoutColor.Add(vec[1]);
                    if (options.displayRect)
                    {
                        DrawCircle(dst2, centroid, vbc.task.DotSize + 3, Scalar.Yellow);
                        DrawCircle(dst2, centroid, vbc.task.DotSize, Scalar.Red);
                        dst2.Rectangle(rect, Scalar.Yellow, 2);
                    }
                }
            }
            labels[2] = fuzzy.sortContours.Count + " regions were found in the image.";
        }
    }




    public class Fuzzy_TrackerDepthClick_CS : VB_Parent
    {
        public Fuzzy_TrackerDepth tracker = new Fuzzy_TrackerDepth();
        public cv.Point highlightPoint;
        public cv.Rect highlightRect;
        public int highlightRegion = -1;
        public Mat regionMask;
        public Fuzzy_TrackerDepthClick_CS()
        {
            desc = "Create centroids and rect's for solid regions and track them - tracker";
        }
        public void RunAlg(Mat src)
        {
            tracker.Run(src);
            dst2 = tracker.dst2;
            if (highlightRegion < 0) SetTrueText("Click any color region to get more details and track it", new cv.Point(10, 50), 3);
            dst3 = tracker.fuzzy.dst1;
            if (vbc.task.mouseClickFlag)
            {
                highlightPoint = vbc.task.ClickPoint;
                highlightRegion = tracker.fuzzy.dst2.Get<byte>(highlightPoint.Y, highlightPoint.X);
            }
            if (highlightRegion >= 0)
            {
                regionMask = tracker.fuzzy.dst2.InRange(highlightRegion, highlightRegion + 1);
                dst3.SetTo(Scalar.Yellow, regionMask);
            }
            labels[2] = tracker.fuzzy.sortContours.Count + " regions were found in the image.";
        }
    }




    public class Gabor_Basics_CS : VB_Parent
    {
        public Options_Gabor options = new Options_Gabor();
        public Gabor_Basics_CS()
        {
            desc = "Explore Gabor kernel";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Filter2D(MatType.CV_8UC3, options.gKernel);
        }
    }




    public class GrabCut_Basics_CS : VB_Parent
    {
        public Mat fgFineTune;
        public Mat bgFineTune;
        public Foreground_Basics fore = new Foreground_Basics();
        Mat bgModel = new Mat(1, 65, MatType.CV_64F, cv.Scalar.All(0));
        Mat fgModel = new Mat(1, 65, MatType.CV_64F, cv.Scalar.All(0));
        public GrabCut_Basics_CS()
        {
            desc = "Use Foreground_Basics to define the foreground for use in GrabCut.";
        }
        public void RunAlg(Mat src)
        {
            fore.Run(src);
            dst2 = fore.dst2;
            dst3 = fore.dst3;
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, cv.Scalar.All((double)GrabCutClasses.PR_BGD));
            dst0.SetTo((double)GrabCutClasses.FGD, fore.fg);
            dst0.SetTo((double)GrabCutClasses.BGD, fore.bg);
            // Cv2.GrabCut(src, dst0, new cv.Rect(), bgModel, fgModel, 1, GrabCutModes.InitWithMask);
            fore.bg = ~fore.fg;
            if (Cv2.CountNonZero(fore.fg) > 0)
            {
                if (fgFineTune != null) dst0.SetTo((double)GrabCutClasses.FGD, fgFineTune);
                if (bgFineTune != null) dst0.SetTo((double)GrabCutClasses.BGD, bgFineTune);
                Cv2.GrabCut(src, dst0, new cv.Rect(), bgModel, fgModel, 1, GrabCutModes.Eval);
            }
            dst3.SetTo(0);
            src.CopyTo(dst3, dst0);
            labels[2] = "KMeans output defining the " + fore.classCount.ToString() + " classes.";
        }
    }





    public class GrabCut_ImageRect_CS : VB_Parent
    {
        Mat image;
        Mat bgModel = new Mat();
        Mat fgModel = new Mat();
        cv.Rect bgRect1 = new cv.Rect(482, 0, 128, 640);
        cv.Rect bgRect2 = new cv.Rect(0, 0, 162, 320);
        cv.Rect fgRect1 = new cv.Rect(196, 134, 212, 344);
        cv.Rect fgRect2 = new cv.Rect(133, 420, 284, 60);
        public GrabCut_ImageRect_CS()
        {
            var fileInputName = new FileInfo(vbc.task.HomeDir + "data/cat.jpg");
            image = Cv2.ImRead(fileInputName.FullName);
            desc = "Grabcut example using a single image.  Fix this.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = image;
            dst0 = new Mat(image.Size(), MatType.CV_8U, cv.Scalar.All((double)GrabCutClasses.PR_BGD));
            dst0[bgRect1].SetTo((double)GrabCutClasses.BGD);
            dst0[bgRect2].SetTo((double)GrabCutClasses.BGD);
            dst0[fgRect1].SetTo((double)GrabCutClasses.FGD);
            dst0[fgRect2].SetTo((double)GrabCutClasses.FGD);
            if (vbc.task.FirstPass)
            {
                Cv2.GrabCut(dst2, dst0, bgRect1, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
                Cv2.GrabCut(dst2, dst0, bgRect2, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
                Cv2.GrabCut(dst2, dst0, fgRect1, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
                Cv2.GrabCut(dst2, dst0, fgRect2, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
            }
            var rect = new cv.Rect();
            Cv2.GrabCut(dst2, dst0, rect, bgModel, fgModel, 1, GrabCutModes.Eval);
            dst3.SetTo(0);
            dst2.CopyTo(dst3, dst0 + cv.Scalar.All(1));
        }
    }




    public class GrabCut_ImageMask_CS : VB_Parent
    {
        Mat image;
        Mat bgModel = new Mat(), fgModel = new Mat();
        public GrabCut_ImageMask_CS()
        {
            var fileInputName = new FileInfo(vbc.task.HomeDir + "data/cat.jpg");
            image = Cv2.ImRead(fileInputName.FullName);
            desc = "Grabcut example using a single image. ";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                dst2 = image;
                dst0 = dst2.CvtColor(cv.ColorConversionCodes.BGR2GRAY).Threshold(50, 255, ThresholdTypes.Binary);
                dst1 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All((double)GrabCutClasses.PR_BGD));
                dst1.SetTo((double)GrabCutClasses.FGD, dst0);
                Cv2.GrabCut(dst2, dst1, new cv.Rect(), bgModel, fgModel, 1, GrabCutModes.InitWithMask);
            }
            else
            {
                Cv2.GrabCut(dst2, dst1, new cv.Rect(), bgModel, fgModel, 5, GrabCutModes.Eval);
            }
            dst3.SetTo(0);
            dst2.CopyTo(dst3, dst1 + cv.Scalar.All(1));
        }
    }





    public class GrabCut_FineTune_CS : VB_Parent
    {
        GrabCut_Basics basics = new GrabCut_Basics();
        Mat_4to1 mats = new Mat_4to1();
        Options_GrabCut options = new Options_GrabCut();
        bool saveRadio = true;
        public GrabCut_FineTune_CS()
        {
            labels[2] = "Foreground Mask, fg fine tuning, bg fine tuning, blank";
            labels[3] = "Grabcut results after adding fine tuning selections";
            desc = "There are probably mistakes in the initial Grabcut_Basics.  Use the checkbox to fine tune what is background and foreground";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.clearAll || basics.fgFineTune == null)
            {
                basics.fgFineTune = new Mat(src.Size(), MatType.CV_8U, cv.Scalar.All(0));
                basics.bgFineTune = new Mat(src.Size(), MatType.CV_8U, cv.Scalar.All(0));
            }
            if (saveRadio != options.fineTuning)
            {
                saveRadio = options.fineTuning;
                vbc.task.drawRectClear = true;
                return;
            }
            if (vbc.task.drawRect.Width != 0)
            {
                if (options.fineTuning)
                {
                    basics.fgFineTune[vbc.task.drawRect].SetTo(255);
                }
                else
                {
                    basics.bgFineTune[vbc.task.drawRect].SetTo(255);
                }
            }
            basics.Run(src);
            mats.mat[0] = basics.dst2;
            mats.mat[1] = basics.fgFineTune;
            mats.mat[2] = basics.bgFineTune;
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = basics.dst3;
        }
    }





    public class Gradient_Basics_CS : VB_Parent
    {
        public Edge_Sobel sobel = new Edge_Sobel();
        public Gradient_Basics_CS()
        {
            dst3 = new Mat(dst2.Size(), MatType.CV_32F, cv.Scalar.All(0));
            labels = new string[] { "", "", "Gradient_Basics_CS - Sobel output", "Phase Output" };
            desc = "Use phase to compute gradient";
        }
        public void RunAlg(Mat src)
        {
            sobel.Run(src);
            Cv2.Phase(sobel.dst0, sobel.dst1, dst3);
            dst2 = sobel.dst0;
        }
    }




    public class Gradient_Depth_CS : VB_Parent
    {
        Edge_Sobel sobel = new Edge_Sobel();
        public Gradient_Depth_CS()
        {
            labels[3] = "Phase Output";
            desc = "Use phase to compute gradient on depth image";
        }
        public void RunAlg(Mat src)
        {
            sobel.Run(vbc.task.pcSplit[2]);
            Cv2.Phase(sobel.dst0, sobel.dst1, dst3);
            dst2 = sobel.dst0;
        }
    }





    public class Gradient_Color_CS : VB_Parent
    {
        public Scalar color1 = Scalar.Blue;
        public Scalar color2 = Scalar.Yellow;
        public int gradientWidth;
        public Mat gradient;
        public Gradient_Color_CS()
        {
            desc = "Provide a spectrum that is a gradient from one color to another.";
        }
        public void RunAlg(Mat src)
        {
            gradientWidth = dst2.Width;
            double f = 1.0;
            Mat gradientColors = new Mat(1, gradientWidth, MatType.CV_64FC3);
            for (int i = 0; i < gradientWidth; i++)
            {
                gradientColors.Set(0, i, new Scalar(f * color2[0] + (1 - f) * color1[0], f * color2[1] + (1 - f) * color1[1],
                    f * color2[2] + (1 - f) * color1[2]));
                f -= 1.0 / gradientWidth;
            }
            gradient = new Mat(1, gradientWidth, MatType.CV_8UC3);
            for (int i = 0; i < gradientWidth; i++)
            {
                gradient.Col(i).SetTo(gradientColors.Get<Scalar>(0, i));
            }
            dst2 = gradient.Resize(dst2.Size());
        }
    }




    public class Gradient_CartToPolar_CS : VB_Parent
    {
        public Gradient_Basics basics = new Gradient_Basics();
        public Mat magnitude = new Mat();
        public Mat angle = new Mat();
        Options_Gradient options = new Options_Gradient();
        public Gradient_CartToPolar_CS()
        {
            FindSlider("Sobel kernel Size").Value = 1;
            labels[2] = "CartToPolar Magnitude Output Normalized";
            labels[3] = "CartToPolar Angle Output";
            desc = "Compute the gradient and use CartToPolar to image the magnitude and angle";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat tmp = new Mat();
            src.ConvertTo(tmp, MatType.CV_32FC3, 1.0 / 255);
            basics.Run(tmp);
            basics.sobel.dst2.ConvertTo(dst2, MatType.CV_32F);
            basics.sobel.dst2.ConvertTo(dst3, MatType.CV_32F);
            magnitude = new Mat();
            angle = new Mat();
            Cv2.CartToPolar(dst2, dst3, magnitude, angle, true);
            magnitude = magnitude.Normalize();
            magnitude = magnitude.Pow(options.exponent);
            dst2 = magnitude;
        }
    }




    public class Gravity_Basics_CS : VB_Parent
    {
        public List<cv.Point> points = new List<cv.Point>();
        int resizeRatio = 1;
        public PointPair vec = new PointPair();
        public bool autoDisplay;
        public Gravity_Basics_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find all the points where depth X-component transitions from positive to negative";
        }
        public void displayResults(Point2f p1, cv.Point2f p2)
        {
            if (vbc.task.heartBeat)
            {
                if (p1.Y >= 1 && p1.Y <= dst2.Height - 1)
                    strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n";
            }
            dst2.SetTo(0);
            dst3.SetTo(0);
            foreach (var pt in points)
            {
                var newPt = new cv.Point(pt.X * resizeRatio, pt.Y * resizeRatio);
                DrawCircle(dst2, newPt, vbc.task.DotSize, Scalar.White);
            }
            DrawLine(dst2, vec.p1, vec.p2, Scalar.White, vbc.task.lineWidth);
            DrawLine(dst3, vec.p1, vec.p2, Scalar.White, vbc.task.lineWidth);
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F)
                dst0 = PrepareDepthInput(0);
            else
                dst0 = src;
            var resolution = vbc.task.quarterRes;
            if (dst0.Size() != resolution)
            {
                dst0 = dst0.Resize(resolution, 0, 0, InterpolationFlags.Nearest);
                resizeRatio = (int)(dst2.Height / resolution.Height);
            }
            dst0 = dst0.Abs();
            dst1 = dst0.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst0.SetTo(vbc.task.MaxZmeters, ~dst1);
            points.Clear();
            for (int i = dst0.Height / 3; i < dst0.Height * 2 / 3 - 1; i++)
            {
                var mm1 = GetMinMax(dst0.Row(i));
                if (mm1.minVal > 0 && mm1.minVal < 0.005)
                {
                    dst0.Row(i).Set<float>(mm1.minLoc.Y, mm1.minLoc.X, 10);
                    var mm2 = GetMinMax(dst0.Row(i));
                    if (mm2.minVal > 0 && Math.Abs(mm1.minLoc.X - mm2.minLoc.X) <= 1)
                        points.Add(new cv.Point(mm1.minLoc.X, i));
                }
            }
            labels[2] = points.Count.ToString() + " points found. ";
            cv.Point p1 = new cv.Point();
            cv.Point p2 = new cv.Point();
            if (points.Count >= 2)
            {
                p1 = new cv.Point(resizeRatio * points[points.Count - 1].X, resizeRatio * points[points.Count - 1].Y);
                p2 = new cv.Point(resizeRatio * points[0].X, resizeRatio * points[0].Y);
            }
            var distance = p1.DistanceTo(p2);
            if (distance < 10) // enough to get a line with some credibility
            {
                points.Clear();
                vec = new PointPair();
                strOut = "Gravity vector not found " + "\n" + "The distance of p1 to p2 is " + (int)distance + " pixels.";
            }
            else
            {
                var lp = new PointPair(p1, p2);
                vec = lp.edgeToEdgeLine(dst2.Size());
                if (standaloneTest() || autoDisplay)
                    displayResults(p1, p2);
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Gravity_BasicsOriginal_CS : VB_Parent
    {
        public PointPair vec = new PointPair();
        public Gravity_BasicsOriginal_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Search for the transition from positive to negative to find the gravity vector.";
        }
        Point2f findTransition(int startRow, int stopRow, int stepRow)
        {
            float val = 0, lastVal = 0;
            var ptX = new List<float>();
            var ptY = new List<float>();
            for (int y = startRow; y <= stopRow; y += stepRow)
            {
                for (int x = 0; x < dst0.Cols; x++)
                {
                    lastVal = val;
                    val = dst0.Get<float>(y, x);
                    if (val > 0 && lastVal < 0)
                    {
                        // change to sub-pixel accuracy here 
                        var pt = new Point2f(x + Math.Abs(val) / Math.Abs(val - lastVal), y);
                        ptX.Add(pt.X);
                        ptY.Add(pt.Y);
                        if (ptX.Count >= vbc.task.frameHistoryCount)
                            return new Point2f(ptX.Average(), ptY.Average());
                    }
                }
            }
            return new cv.Point();
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F)
                dst0 = PrepareDepthInput(0);
            else
                dst0 = src;
            var p1 = findTransition(0, dst0.Height - 1, 1);
            var p2 = findTransition(dst0.Height - 1, 0, -1);
            var lp = new PointPair(p1, p2);
            vec = lp.edgeToEdgeLine(dst2.Size());
            if (p1.X >= 1)
            {
                strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n" + "      val =  " +
                          dst0.Get<float>((int)p1.Y, (int)p1.X).ToString() + "\n" + "lastVal = " + dst0.Get<float>((int)p1.Y, (int)p1.X - 1).ToString();
            }
            SetTrueText(strOut, 3);
            if (standaloneTest())
            {
                dst2.SetTo(0);
                DrawLine(dst2, vec.p1, vec.p2, cv.Scalar.All(255), vbc.task.lineWidth);
            }
        }
    }




    public class Gravity_HorizonCompare_CS : VB_Parent
    {
        Gravity_Basics gravity = new Gravity_Basics();
        Horizon_Basics horizon = new Horizon_Basics();
        public Gravity_HorizonCompare_CS()
        {
            gravity.autoDisplay = true;
            horizon.autoDisplay = true;
            desc = "Collect results from Horizon_Basics with Gravity_Basics";
        }
        public void RunAlg(Mat src)
        {
            gravity.Run(src);
            var g1 = gravity.vec;
            var h1 = gravity.vec;
            horizon.Run(src);
            var g2 = horizon.vec;
            var h2 = horizon.vec;
            if (standaloneTest())
            {
                SetTrueText("Gravity vector (yellow):" + "\n" + gravity.strOut + "\n" + "\n" + "Horizon Vector (red): " + "\n" + horizon.strOut, 3);
                dst2.SetTo(0);
                DrawLine(dst2, g1.p1, g1.p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                DrawLine(dst2, g2.p1, g2.p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                DrawLine(dst2, h1.p1, h1.p2, Scalar.Red, vbc.task.lineWidth);
                DrawLine(dst2, h2.p1, h2.p2, Scalar.Red, vbc.task.lineWidth);
            }
        }
    }




    public class Gravity_Horizon_CS : VB_Parent
    {
        Gravity_Basics gravity = new Gravity_Basics();
        Horizon_Basics horizon = new Horizon_Basics();
        PointPair lastVec;
        public Gravity_Horizon_CS()
        {
            gravity.autoDisplay = true;
            horizon.autoDisplay = true;
            labels[2] = "Gravity vector in yellow and Horizon vector in red.";
            desc = "Compute the gravity vector and the horizon vector separately";
        }
        public void RunAlg(Mat src)
        {
            gravity.Run(src);
            if (gravity.vec.p2.Y > 0 || gravity.vec.p1.Y > 0)
                vbc.task.gravityVec = gravity.vec; // don't update if not found
            horizon.Run(src);
            if (vbc.task.FirstPass) lastVec = horizon.vec;
            if (horizon.vec.p1.Y > 0)
                lastVec = horizon.vec;
            if (horizon.vec.p1.Y == 0)
                horizon.vec = lastVec;
            vbc.task.horizonVec = horizon.vec;
            if (standaloneTest())
            {
                SetTrueText("Gravity vector (yellow):" + "\n" + gravity.strOut + "\n" + "\n" + "Horizon Vector (red): " + "\n" + horizon.strOut, 3);
                dst2.SetTo(0);
                DrawLine(dst2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, vbc.task.HighlightColor, vbc.task.lineWidth);
                DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, Scalar.Red, vbc.task.lineWidth);
            }
        }
    }




    public class GrayToColor_Palette_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        public GrayToColor_Palette_CS()
        {
            labels = new string[] { "", "Right View", "", "Grayscale left view after palette applied." };
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Identify the main colors in an image using RedCloud";
        }
        public void RunAlg(Mat src)
        {
            flood.Run(src);
            dst2 = flood.dst2;
            labels[2] = flood.labels[2];
            byte[] indices = new byte[256];
            Vec3b[] colors = new Vec3b[256];
            SortedList<int, Vec3b> sorted = new SortedList<int, Vec3b>(new CompareAllowIdenticalInteger());
            foreach (var rc in vbc.task.redCells)
            {
                int index = rc.naturalGray;
                if (index == 0) continue;
                colors[index] = rc.naturalColor;
                indices[index] = (byte)index;
                sorted.Add(index, rc.naturalColor);
            }
            int firstIndex = sorted.Keys[0];
            Vec3b lastColor = colors[firstIndex];
            for (int i = 0; i < colors.Length; i++)
            {
                if (indices[i] == 0) colors[i] = lastColor;
                else lastColor = colors[i];
            }
            dst1 = vbc.task.rightView;
            Mat colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, colors);
            Cv2.ApplyColorMap(vbc.task.leftView, dst3, colorMap);
        }
    }




    public class Grid_Basics_CS : VB_Parent
    {
        public List<cv.Rect> gridRects = new List<cv.Rect>();
        public Grid_Basics_CS()
        {
            desc = "Create a grid of squares covering the entire image.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.mouseClickFlag && !vbc.task.FirstPass)
            {
                vbc.task.gridROIclicked = vbc.task.gridMap.At<int>(vbc.task.ClickPoint.Y, vbc.task.ClickPoint.X);
            }
            if (vbc.task.optionsChanged)
            {
                vbc.task.gridSize = vbc.task.gOptions.getGridSize();
                vbc.task.gridMask = new Mat(src.Size(), MatType.CV_8U);
                vbc.task.gridMap = new Mat(src.Size(), MatType.CV_32S, cv.Scalar.All(255));
                gridRects.Clear();
                vbc.task.gridIndex.Clear();
                vbc.task.gridRows = 0;
                vbc.task.gridCols = 0;
                int index = 0;
                for (int y = 0; y < src.Height; y += vbc.task.gridSize)
                {
                    for (int x = 0; x < src.Width; x += vbc.task.gridSize)
                    {
                        var roi = ValidateRect(new cv.Rect(x, y, vbc.task.gridSize, vbc.task.gridSize));
                        if (roi.Width > 0 && roi.Height > 0)
                        {
                            if (x == 0) vbc.task.gridRows += 1;
                            if (y == 0) vbc.task.gridCols += 1;
                            gridRects.Add(roi);
                            vbc.task.gridIndex.Add(index);
                            index++;
                        }
                    }
                }
                vbc.task.subDivisionCount = 9;
                if (vbc.task.color == null) return; // startup condition.
                if (src.Size() == vbc.task.color.Size())
                {
                    vbc.task.gridMask.SetTo(0);
                    for (int x = vbc.task.gridSize; x < src.Width; x += vbc.task.gridSize)
                    {
                        var p1 = new cv.Point(x, 0);
                        var p2 = new cv.Point(x, src.Height);
                        vbc.task.gridMask.Line(p1, p2, cv.Scalar.All(255), vbc.task.lineWidth);
                    }
                    for (int y = vbc.task.gridSize; y < src.Height; y += vbc.task.gridSize)
                    {
                        var p1 = new cv.Point(0, y);
                        var p2 = new cv.Point(src.Width, y);
                        vbc.task.gridMask.Line(p1, p2, cv.Scalar.All(255), vbc.task.lineWidth);
                    }
                    for (int i = 0; i < gridRects.Count; i++)
                    {
                        cv.Rect roi = gridRects[i];
                        vbc.task.gridMap.Rectangle(roi, cv.Scalar.All(i), -1);
                    }
                    vbc.task.gridNeighbors.Clear();
                    int xx = 0, yy = 0;
                    foreach (var roi in gridRects)
                    {
                        vbc.task.gridNeighbors.Add(new List<int>());
                        for (int i = 0; i < 9; i++)
                        {
                            if (i == 0) xx = roi.X - 1;
                            if (i == 1) xx = roi.X;
                            if (i == 2) xx = roi.X + roi.Width + 1;
                            if (i == 3) xx = roi.X - 1;
                            if (i == 4) xx = roi.X;
                            if (i == 5) xx = roi.X + roi.Width + 1;
                            if (i == 6) xx = roi.X - 1;
                            if (i == 7) xx = roi.X;
                            if (i == 8) xx = roi.X + roi.Width + 1;

                            if (i == 0) yy = roi.Y - 1;
                            if (i == 1) yy = roi.Y - 1;
                            if (i == 2) yy = roi.Y - 1;
                            if (i == 3) yy = roi.Y;
                            if (i == 4) yy = roi.Y;
                            if (i == 5) yy = roi.Y;
                            if (i == 6) yy = roi.Y + roi.Height + 1;
                            if (i == 7) yy = roi.Y + roi.Height + 1;
                            if (i == 8) yy = roi.Y + roi.Height + 1;

                            if (xx >= 0 && xx < src.Width && yy >= 0 && yy < src.Height)
                            {
                                vbc.task.gridNeighbors.Last().Add(vbc.task.gridMap.At<int>(yy, xx));
                            }
                        }
                    }
                }
                foreach (var roi in gridRects)
                {
                    int xSub = roi.X + roi.Width;
                    int ySub = roi.Y + roi.Height;
                    if (ySub <= dst2.Height / 3)
                    {
                        if (xSub <= dst2.Width / 3) vbc.task.subDivisions.Add(0);
                        if (xSub >= dst2.Width / 3 && xSub <= dst2.Width * 2 / 3) vbc.task.subDivisions.Add(1);
                        if (xSub > dst2.Width * 2 / 3) vbc.task.subDivisions.Add(2);
                    }
                    if (ySub > dst2.Height / 3 && ySub <= dst2.Height * 2 / 3)
                    {
                        if (xSub <= dst2.Width / 3) vbc.task.subDivisions.Add(3);
                        if (xSub >= dst2.Width / 3 && xSub <= dst2.Width * 2 / 3) vbc.task.subDivisions.Add(4);
                        if (xSub > dst2.Width * 2 / 3) vbc.task.subDivisions.Add(5);
                    }
                    if (ySub > dst2.Height * 2 / 3)
                    {
                        if (xSub <= dst2.Width / 3) vbc.task.subDivisions.Add(6);
                        if (xSub >= dst2.Width / 3 && xSub <= dst2.Width * 2 / 3) vbc.task.subDivisions.Add(7);
                        if (xSub > dst2.Width * 2 / 3) vbc.task.subDivisions.Add(8);
                    }
                }
                if (vbc.task.gridRects.Count() != gridRects.Count()) vbc.task.gridRects = gridRects;
            }
            if (standaloneTest())
            {
                dst2 = new Mat(src.Size(), MatType.CV_8U);
                vbc.task.color.CopyTo(dst2);
                dst2.SetTo(Scalar.White, vbc.task.gridMask);
                labels[2] = "Grid_Basics_CS " + gridRects.Count + " (" + vbc.task.gridRows + "X" + vbc.task.gridCols + ") " +
                            vbc.task.gridSize + "X" + vbc.task.gridSize + " regions";
            }
        }
    }




    public class Grid_BasicsTest_CS : VB_Parent
    {
        public Grid_BasicsTest_CS()
        {
            labels = new[] { "", "", "Each grid element is assigned a value below", "The line is the diagonal for each roi.  Bottom might be a shortened roi." };
            if (standaloneTest()) desc = "Validation test for Grid_Basics algorithm";
        }
        public void RunAlg(Mat src)
        {
            var mean = Cv2.Mean(src);
            dst2.SetTo(0);
            for (int i = 0; i < vbc.task.gridRects.Count; i++)
            {
                var roi = vbc.task.gridRects[i];
                Cv2.Subtract(mean, src[roi], dst2[roi]);
                SetTrueText(i.ToString(), new cv.Point(roi.X, roi.Y));
            }
            dst2.SetTo(Scalar.White, vbc.task.gridMask);
            dst3.SetTo(0);
            Parallel.For(0, vbc.task.gridRects.Count, i =>
            {
                var roi = vbc.task.gridRects[i];
                Cv2.Subtract(mean, src[roi], dst3[roi]);
                DrawLine(dst3[roi], new cv.Point(0, 0), new cv.Point(roi.Width, roi.Height), Scalar.White, vbc.task.lineWidth);
            });
        }
    }




    public class Grid_List_CS : VB_Parent
    {
        public Grid_List_CS()
        {
            labels[2] = "Adjust grid width/height to increase thread count.";
            if (standaloneTest()) desc = "List the active threads";
        }
        public void RunAlg(Mat src)
        {
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                dst3[roi].SetTo(0);
            });
            try
            {
                var currentProcess = Process.GetCurrentProcess();
                var myThreads = currentProcess.Threads;
                string str = "";
                int threadCount = 0;
                int notIdle = 0;
                foreach (ProcessThread thread in myThreads)
                {
                    str += thread.Id + " state = " + thread.ThreadState + ", ";
                    threadCount++;
                    if (threadCount % 5 == 0) str += "\n";
                    if (thread.ThreadState != System.Diagnostics.ThreadState.Wait) notIdle++;
                }
                SetTrueText("There were " + threadCount + " threads in OpenCVB with " + notIdle + " of them not idle when traversing the gridRects" + "\n" + str);
            }
            catch (Exception e)
            {
                System.Windows.Forms.MessageBox.Show(e.Message);
            }
        }
    }




    public class Grid_Rectangles_CS : VB_Parent
    {
        public int tilesPerRow;
        public int tilesPerCol;
        Options_Grid options = new Options_Grid();
        Mat gridMask, gridMap;
        public List<cv.Rect> gridRects = new List<cv.Rect>();
        public Grid_Rectangles_CS()
        {
            gridMask = new Mat(dst2.Size(), MatType.CV_8U);
            gridMap = new Mat(dst2.Size(), MatType.CV_32S);
            if (standaloneTest()) desc = "Create a grid of rectangles (not necessarily squares) for use with parallel.For";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.mouseClickFlag) 
                vbc.task.gridROIclicked = gridMap.At<int>(vbc.task.ClickPoint.Y, vbc.task.ClickPoint.X);
            if (vbc.task.optionsChanged)
            {
                gridRects.Clear();
                for (int y = 0; y < dst2.Height; y += options.height)
                {
                    for (int x = 0; x < dst2.Width; x += options.width)
                    {
                        var roi = new cv.Rect(x, y, options.width, options.height);
                        if (x + roi.Width >= dst2.Width) roi.Width = dst2.Width - x;
                        if (y + roi.Height >= dst2.Height) roi.Height = dst2.Height - y;
                        if (roi.Width > 0 && roi.Height > 0)
                        {
                            if (y == 0) tilesPerRow += 1;
                            if (x == 0) tilesPerCol += 1;
                            gridRects.Add(roi);
                        }
                    }
                }
                gridMask.SetTo(0);
                for (int x = options.width; x < dst2.Width; x += options.width)
                {
                    var p1 = new cv.Point(x, 0);
                    var p2 = new cv.Point(x, dst2.Height);
                    gridMask.Line(p1, p2, cv.Scalar.All(255), vbc.task.lineWidth);
                }
                for (int y = options.height; y < dst2.Height; y += options.height)
                {
                    var p1 = new cv.Point(0, y);
                    var p2 = new cv.Point(dst2.Width, y);
                    gridMask.Line(p1, p2, cv.Scalar.All(255), vbc.task.lineWidth);
                }
                for (int i = 0; i < gridRects.Count; i++)
                {
                    var roi = gridRects[i];
                    gridMap.Rectangle(roi, cv.Scalar.All(i), -1);
                }
            }
            if (standaloneTest())
            {
                vbc.task.color.CopyTo(dst2);
                dst2.SetTo(Scalar.White, gridMask);
                labels[2] = "Grid_Basics " + gridRects.Count + " (" + tilesPerRow + "X" + tilesPerCol + ") " +
                            options.width + "X" + options.height + " regions";
            }
        }
    }




    public class Grid_FPS_CS : VB_Parent
    {
        public bool heartBeat;
        public TrackBar fpsSlider;
        int skipCount;
        int saveSkip;
        Options_Grid options = new Options_Grid();
        public Grid_FPS_CS()
        {
            fpsSlider = FindSlider("Desired FPS rate");
            desc = "Provide a service that lets any algorithm control its frame rate";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            int fps = (int)(vbc.task.fpsRate / options.desiredFPS);
            if (fps == 0) fps = 1;
            heartBeat = (vbc.task.frameCount % fps) == 0;
            if (heartBeat)
            {
                saveSkip = skipCount;
                skipCount = 0;
                if (standaloneTest()) dst2 = src;
            }
            else
            {
                skipCount++;
            }
            strOut = "Grid heartbeat set to " + fpsSlider.Value + " times per second.  " + saveSkip + " frames skipped";
        }
    }




    public class Grid_Neighbors_CS : VB_Parent
    {
        Mat mask = new Mat();
        public Grid_Neighbors_CS()
        {
            labels = new[] { "", "", "Grid_Basics output", "" };
            desc = "Click any grid element to see its neighbors";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.gridRows != (int)(dst2.Height / 10))
            {
                vbc.task.gOptions.setGridSize((int)(dst2.Height / 10));
                vbc.task.gridRows = vbc.task.gridSize;
                vbc.task.grid.Run(src);
            }
            dst2 = src;
            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    vbc.task.mouseClickFlag = true;
                    vbc.task.ClickPoint = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                }
            }
            SetTrueText("Click any grid entry to see its neighbors", 3);
            if (vbc.task.optionsChanged) mask = vbc.task.gridMask.Clone();
            if (vbc.task.mouseClickFlag)
            {
                mask = vbc.task.gridMask.Clone();
                int roiIndex = vbc.task.gridMap.At<int>(vbc.task.ClickPoint.Y, vbc.task.ClickPoint.X);
                foreach (int index in vbc.task.gridNeighbors[roiIndex])
                {
                    var roi = vbc.task.gridRects[index];
                    mask.Rectangle(roi, Scalar.White);
                }
            }
            dst2.SetTo(Scalar.White, mask);
        }
    }




    public class Grid_Special_CS : VB_Parent
    {
        public int gridWidth = 10;
        public int gridHeight = 10;
        public List<cv.Rect> gridRects = new List<cv.Rect>();
        public int gridRows;
        public int gridCols;
        public Mat gridMask;
        public List<List<int>> gridNeighbors = new List<List<int>>();
        public Mat gridMap;
        public Grid_Special_CS()
        {
            gridMask = new Mat(dst2.Size(), MatType.CV_8U);
            gridMap = new Mat(dst2.Size(), MatType.CV_32S);
            desc = "Grids are normally square.  Grid_Special_CS allows grid elements to be rectangles.  Specify the Y size.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
            {
                gridWidth = vbc.task.gridSize;
                gridRects.Clear();
                gridRows = 0;
                gridCols = 0;
                for (int y = 0; y < dst2.Height; y += gridHeight)
                {
                    for (int x = 0; x < dst2.Width; x += gridWidth)
                    {
                        var roi = new cv.Rect(x, y, gridWidth, gridHeight);
                        if (x + roi.Width >= dst2.Width) roi.Width = dst2.Width - x;
                        if (y + roi.Height >= dst2.Height) roi.Height = dst2.Height - y;
                        if (roi.Width > 0 && roi.Height > 0)
                        {
                            if (x == 0) gridRows += 1;
                            if (y == 0) gridCols += 1;
                            gridRects.Add(roi);
                        }
                    }
                }
                gridMask.SetTo(0);
                for (int x = gridWidth; x < dst2.Width; x += gridWidth)
                {
                    var p1 = new cv.Point(x, 0);
                    var p2 = new cv.Point(x, dst2.Height);
                    gridMask.Line(p1, p2, cv.Scalar.All(255), vbc.task.lineWidth);
                }
                for (int y = gridHeight; y < dst2.Height; y += gridHeight)
                {
                    var p1 = new cv.Point(0, y);
                    var p2 = new cv.Point(dst2.Width, y);
                    gridMask.Line(p1, p2, cv.Scalar.All(255), vbc.task.lineWidth);
                }
                for (int i = 0; i < vbc.task.gridRects.Count; i++)
                {
                    var roi = gridRects[i];
                    gridMap.Rectangle(roi, cv.Scalar.All(i), -1);
                }
                gridNeighbors.Clear();
                foreach (var roi in gridRects)
                {
                    gridNeighbors.Add(new List<int>());
                    int x = 0, y = 0;
                    for (int i = 0; i < 9; i++)
                    {
                        if (i == 0) x = roi.X - 1;
                        if (i == 1) x = roi.X;
                        if (i == 2) x = roi.X + roi.Width + 1;
                        if (i == 3) x = roi.X - 1;
                        if (i == 4) x = roi.X;
                        if (i == 5) x = roi.X + roi.Width + 1;
                        if (i == 6) x = roi.X - 1;
                        if (i == 7) x = roi.X;
                        if (i == 8) x = roi.X + roi.Width + 1;

                        if (i == 0) x = roi.Y - 1;
                        if (i == 1) x = roi.Y - 1;
                        if (i == 2) x = roi.Y - 1;
                        if (i == 3) x = roi.Y;
                        if (i == 4) x = roi.Y;
                        if (i == 5) x = roi.Y;
                        if (i == 6) x = roi.Y + roi.Height + 1;
                        if (i == 7) x = roi.Y + roi.Height + 1;
                        if (i == 8) x = roi.Y + roi.Height + 1;

                        if (x >= 0 && x < dst2.Width && y >= 0 && y < dst2.Height)
                        {
                            gridNeighbors.Last().Add(gridMap.At<int>(y, x));
                        }
                    }
                }
            }
            if (standaloneTest())
            {
                vbc.task.color.CopyTo(dst2);
                dst2.SetTo(Scalar.White, gridMask);
                labels[2] = "Grid_Basics " + gridRects.Count + " (" + gridRows + "X" + gridCols + ") " +
                            gridWidth + "X" + gridHeight + " regions";
            }
        }
    }






    public class Grid_MinMaxDepth_CS : VB_Parent
    {
        public PointPair[] minMaxLocs = new PointPair[1];
        public Vec2f[] minMaxVals = new Vec2f[1];
        public Grid_MinMaxDepth_CS()
        {
            vbc.task.gOptions.setGridSize(8);
            UpdateAdvice(traceName + ": goptions 'grid Square Size' has direct impact.");
            desc = "Find the min and max depth within each grid roi.";
        }
        public void RunAlg(Mat src)
        {
            if (minMaxLocs.Length != vbc.task.gridRects.Count) Array.Resize(ref minMaxLocs, vbc.task.gridRects.Count);
            if (minMaxVals.Length != vbc.task.gridRects.Count) Array.Resize(ref minMaxVals, vbc.task.gridRects.Count);
            mmData mm = new mmData();
            for (int i = 0; i < minMaxLocs.Length; i++)
            {
                var roi = vbc.task.gridRects[i];
                vbc.task.pcSplit[2][roi].MinMaxLoc(out mm.minVal, out mm.maxVal, out mm.minLoc, out mm.maxLoc, vbc.task.depthMask[roi]);
                minMaxLocs[i] = new PointPair(mm.minLoc, mm.maxLoc);
                minMaxVals[i] = new Vec2f((float)mm.minVal, (float)mm.maxVal);
            }
            if (standaloneTest())
            {
                dst2.SetTo(0);
                for (int i = 0; i < minMaxLocs.Length; i++)
                {
                    var lp = minMaxLocs[i];
                    DrawCircle(dst2[vbc.task.gridRects[i]], lp.p2, vbc.task.DotSize, Scalar.Red);
                    DrawCircle(dst2[vbc.task.gridRects[i]], lp.p1, vbc.task.DotSize, Scalar.White);
                }
                dst2.SetTo(Scalar.White, vbc.task.gridMask);
            }
        }
    }




    public class Grid_TrackCenter_CS : VB_Parent
    {
        public cv.Point center;
        Match_Basics match = new Match_Basics();
        public Grid_TrackCenter_CS()
        {
            if (standalone) vbc.task.gOptions.setShowGrid(true);
            desc = "Track a cell near the center of the grid";
        }
        public void RunAlg(Mat src)
        {
            if (match.correlation < match.options.correlationMin || vbc.task.gOptions.getDebugCheckBox())
            {
                vbc.task.gOptions.setDebugCheckBox(false);
                int index = vbc.task.gridMap.Get<int>(dst2.Height / 2, dst2.Width / 2);
                var roi = vbc.task.gridRects[index];
                match.template = src[roi].Clone();
                center = new cv.Point(roi.X + roi.Width / 2, roi.Y + roi.Height / 2);
            }
            int templatePad = match.options.templatePad;
            int templateSize = match.options.templateSize;
            match.searchRect = ValidateRect(new cv.Rect(center.X - templatePad, center.Y - templatePad, templateSize, templateSize));
            match.Run(src);
            center = match.matchCenter;
            if (standaloneTest())
            {
                dst2 = src;
                dst2.Rectangle(match.matchRect, vbc.task.HighlightColor, vbc.task.lineWidth + 1, vbc.task.lineType);
                DrawCircle(dst2, center, vbc.task.DotSize, Scalar.White);
                if (vbc.task.heartBeat) dst3.SetTo(0);
                DrawCircle(dst3, center, vbc.task.DotSize, vbc.task.HighlightColor);
                SetTrueText(match.correlation.ToString(vbc.fmt3), center, 3);
                labels[3] = "Match correlation = " + match.correlation.ToString(vbc.fmt3);
            }
        }
    }




    public class Grid_ShowMap_CS : VB_Parent
    {
        public Grid_ShowMap_CS()
        {
            desc = "Verify that vbc.task.gridMap is laid out correctly";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.gridMap.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2);
        }
    }




    public class GuidedBP_Basics_CS : VB_Parent
    {
        public GuidedBP_HotPoints ptHot = new GuidedBP_HotPoints();
        Mat topMap = new Mat();
        Mat sideMap = new Mat();
        public GuidedBP_Basics_CS()
        {
            topMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            sideMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Correlate the hot points with the previous generation using a Map";
        }
        void runMap(List<cv.Rect> rectList, int dstindex, Mat map)
        {
            var sortRects = new SortedList<int, cv.Rect>(new compareAllowIdenticalIntegerInverted());
            foreach (cv.Rect r in rectList)
            {
                sortRects.Add(r.Width * r.Height, r);
            }
            var ptList = new List<cv.Point>();
            var indices = new List<int>();
            foreach (var r in sortRects.Values)
            {
                var pt = new cv.Point((int)(r.X + r.Width / 2), (int)(r.Y + r.Height / 2));
                int index = (int)map.At<byte>(pt.Y, pt.X);
                if (index == 0 || indices.Contains(index))
                {
                    index = (index == ptList.Count) ? ptList.Count + 1 : ptList.Count;
                }
                ptList.Add(pt);
                indices.Add(index);
            }
            map.SetTo(0);
            foreach (var r in sortRects.Values)
            {
                var pt = new cv.Point((int)(r.X + r.Width / 2), (int)(r.Y + r.Height / 2));
                var index = indices[ptList.IndexOf(pt)];
                map.Rectangle(r, cv.Scalar.All(index), -1);
                SetTrueText(index.ToString(), pt, dstindex);
            }
        }
        public void RunAlg(Mat src)
        {
            ptHot.Run(src);
            dst2 = ptHot.dst2;
            dst3 = ptHot.dst3;
            runMap(ptHot.topRects, 2, topMap);
            runMap(ptHot.sideRects, 3, sideMap);
            labels[2] = ptHot.topRects.Count.ToString() + " objects found in the top view";
            labels[3] = ptHot.sideRects.Count.ToString() + " objects found in the Side view";
        }
    }




    public class GuidedBP_HotPointsKNN_CS : VB_Parent
    {
        GuidedBP_HotPoints ptHot = new GuidedBP_HotPoints();
        KNN_Basics knnSide = new KNN_Basics();
        KNN_Basics knnTop = new KNN_Basics();
        public GuidedBP_HotPointsKNN_CS()
        {
            desc = "Correlate the hot points with the previous generation to ID each object";
        }
        void runKNN(KNN_Basics knn, List<cv.Rect> rectList, Mat dst, int dstindex)
        {
            knn.queries.Clear();
            foreach (var r in rectList)
            {
                knn.queries.Add(new Point2f((float)(r.X + r.Width / 2), (float)(r.Y + r.Height / 2)));
            }
            if (vbc.task.FirstPass) knn.trainInput = new List<cv.Point2f>(knn.queries);
            knn.Run(empty);
            for (int i = 0; i < knn.queries.Count; i++)
            {
                var p1 = knn.queries[i];
                var index = knn.result[i, 0];
                var p2 = knn.trainInput[index];
                var dist = p1.DistanceTo(p2);
                var r = rectList[i];
                if (dist < r.Width / 2 && dist < r.Height / 2)
                {
                    dst.Rectangle(r, Scalar.White, vbc.task.lineWidth);
                    var pt = new cv.Point(r.X + r.Width, r.Y + r.Height);
                    SetTrueText(index.ToString(), pt, dstindex);
                }
            }
            knn.trainInput = new List<cv.Point2f>(knn.queries);
        }
        public void RunAlg(Mat src)
        {
            ptHot.Run(src);
            dst2 = ptHot.dst2;
            dst3 = ptHot.dst3;
            runKNN(knnTop, ptHot.topRects, dst2, 2);
            runKNN(knnSide, ptHot.sideRects, dst3, 3);
            labels[2] = ptHot.topRects.Count.ToString() + " objects found in the top view";
            labels[3] = ptHot.sideRects.Count.ToString() + " objects found in the Side view";
        }
    }




    public class GuidedBP_HotPoints_CS : VB_Parent
    {
        public Projection_HistTop histTop = new Projection_HistTop();
        public Projection_HistSide histSide = new Projection_HistSide();
        public List<cv.Rect> topRects = new List<cv.Rect>();
        public List<cv.Rect> sideRects = new List<cv.Rect>();
        cv.Rect floodRect;
        Mat mask;
        public GuidedBP_HotPoints_CS()
        {
            floodRect = new cv.Rect(1, 1, dst2.Width - 2, dst2.Height - 2);
            mask = new Mat(new cv.Size(dst2.Width + 2, dst2.Height + 2), MatType.CV_8U);
            vbc.task.useXYRange = false;
            desc = "Use floodfill to identify all the objects in both the top and side views.";
        }
        List<cv.Rect> hotPoints(ref Mat view)
        {
            cv.Rect rect = new cv.Rect();
            var points = view.FindNonZero();
            var viewList = new SortedList<int, cv.Point>(new compareAllowIdenticalIntegerInverted());
            mask.SetTo(0);
            for (int i = 0; i < points.Rows; i++)
            {
                var pt = points.At<cv.Point>(i, 0);
                int maskOnly = (int)FloodFillFlags.MaskOnly;
                int count = view.FloodFill(mask, pt, cv.Scalar.All(0), out rect, cv.Scalar.All(0), cv.Scalar.All(0), (cv.FloodFillFlags)(4 | maskOnly | (255 << 8)));
                if (count > 0) viewList.Add(count, pt);
            }
            mask.SetTo(0);
            var rectList = new List<cv.Rect>();
            for (int i = 0; i < Math.Min(viewList.Count, 10); i++)
            {
                var pt = viewList.ElementAt(i).Value;
                int fixedRange = (int)FloodFillFlags.FixedRange;
                view.FloodFill(mask, pt, cv.Scalar.All(0), out rect, cv.Scalar.All(0), cv.Scalar.All(0), (cv.FloodFillFlags)(4 | fixedRange | ((i + 1) << 8)));
                rectList.Add(new cv.Rect(rect.X - 1, rect.Y - 1, rect.Width, rect.Height));
            }
            mask[floodRect].CopyTo(view);
            return rectList;
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src.Clone());
            topRects = hotPoints(ref histTop.dst3);
            dst2 = ShowPalette(histTop.dst3 * 255 / topRects.Count);
            histSide.Run(src);
            sideRects = hotPoints(ref histSide.dst3);
            dst3 = ShowPalette(histSide.dst3 * 255 / sideRects.Count);
            if (vbc.task.heartBeat) labels[2] = "Top " + topRects.Count.ToString() + " objects identified in the top view.";
            if (vbc.task.heartBeat) labels[3] = "Top " + sideRects.Count.ToString() + " objects identified in the side view.";
        }
    }




    public class GuidedBP_PlanesPlot_CS : VB_Parent
    {
        Projection_HistSide histSide = new Projection_HistSide();
        public GuidedBP_PlanesPlot_CS()
        {
            labels = new string[] { "", "", "Side view", "Plot of nonzero rows in the side view" };
            desc = "Plot the likely floor or ceiling areas.";
        }
        public void RunAlg(Mat src)
        {
            histSide.Run(src);
            dst2 = histSide.dst3;
            var sumList = new List<int>();
            dst3.SetTo(0);
            for (int i = 0; i < dst2.Rows; i++)
            {
                int x = dst2.Row(i).CountNonZero();
                sumList.Add(x);
                DrawLine(dst3, new cv.Point(0, i), new cv.Point(x, i), Scalar.White, vbc.task.lineWidth);
            }
            var flatSurfacesInRow = new List<int>();
            for (int i = 0; i < sumList.Count; i++)
            {
                if (sumList[i] > 5)
                {
                    int maxSpike = sumList[i];
                    int maxRow = i;
                    for (int j = i + 1; j < sumList.Count; j++)
                    {
                        if (maxSpike < sumList[j])
                        {
                            maxSpike = sumList[j];
                            maxRow = j;
                        }
                        if (sumList[j] == 0)
                        {
                            i = j;
                            flatSurfacesInRow.Add(maxRow);
                            break;
                        }
                    }
                }
            }
            labels[2] = "There were " + flatSurfacesInRow.Count.ToString() + " flat surface candidates found.";
        }
    }




    public class GuidedBP_Points_CS : VB_Parent
    {
        public GuidedBP_Basics hotPoints = new GuidedBP_Basics();
        public int classCount;
        public cv.Point selectedPoint;
        public List<cv.Rect> topRects = new List<cv.Rect>();
        public List<cv.Rect> sideRects = new List<cv.Rect>();
        public Mat histogramTop = new Mat();
        public Mat histogramSide = new Mat();
        public Mat backP = new Mat();
        public GuidedBP_Points_CS()
        {
            desc = "Use floodfill to identify all the objects in the selected view then build a backprojection that identifies k objects in the image view.";
        }
        public void RunAlg(Mat src)
        {
            hotPoints.Run(src);
            hotPoints.ptHot.histTop.dst3.ConvertTo(histogramTop, MatType.CV_32F);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, histogramTop, backP, vbc.task.rangesTop);
            topRects = new List<cv.Rect>(hotPoints.ptHot.topRects);
            sideRects = new List<cv.Rect>(hotPoints.ptHot.sideRects);
            dst2 = ShowPalette(backP * 255 / topRects.Count);
            hotPoints.ptHot.histSide.dst3.ConvertTo(histogramSide, MatType.CV_32F);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, histogramSide, dst3, vbc.task.rangesSide);
            dst3 = ShowPalette(dst3 * 255 / sideRects.Count);
            classCount = topRects.Count + sideRects.Count;
            if (vbc.task.mouseClickFlag) selectedPoint = vbc.task.ClickPoint;
            if (vbc.task.heartBeat) labels[2] = topRects.Count.ToString() + " objects were identified in the top view.";
            if (vbc.task.heartBeat) labels[3] = sideRects.Count.ToString() + " objects were identified in the side view.";
        }
    }




    public class GuidedBP_Lookup_CS : VB_Parent
    {
        GuidedBP_Basics guided = new GuidedBP_Basics();
        public GuidedBP_Lookup_CS()
        {
            vbc.task.ClickPoint = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            desc = "Given a point cloud pixel, look up which object it is in.  Click in the Depth RGB image to test.";
        }
        public void RunAlg(Mat src)
        {
            guided.Run(src);
            dst2 = guided.dst2;
            labels[2] = guided.labels[2];
        }
    }




    public class GuidedBP_Depth_CS : VB_Parent
    {
        public PointCloud_Histograms hist = new PointCloud_Histograms();
        Palette_Random myPalette = new Palette_Random();
        public int classCount;
        public GuidedBP_Depth_CS()
        {
            vbc.task.gOptions.setHistogramBins(16);
            desc = "Backproject the 2D histogram of depth for selected channels to discretize the depth data.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            hist.Run(src);
            float[] histArray = new float[hist.histogram.Total()];
            Marshal.Copy(hist.histogram.Data, histArray, 0, histArray.Length);
            var histList = histArray.ToList();
            histArray[histList.IndexOf(histList.Max())] = 0;
            var sortedHist = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
            for (int i = 0; i < histArray.Length; i++)
            {
                sortedHist.Add(histArray[i], i);
            }
            classCount = 0;
            int count = 0;
            float[] newSamples = new float[histArray.Length];
            for (int i = 0; i < sortedHist.Count; i++)
            {
                int index = sortedHist.ElementAt(i).Value;
                count += (int)sortedHist.ElementAt(i).Key;
                newSamples[index] = classCount;
                classCount++;
                if (classCount >= 255) break;
            }
            Marshal.Copy(newSamples, 0, hist.histogram.Data, newSamples.Length);
            Cv2.CalcBackProject(new Mat[] { src }, vbc.task.redOptions.channels, hist.histogram, dst2, vbc.task.redOptions.ranges);
            dst2.ConvertTo(dst2, MatType.CV_8U);
            if (standaloneTest())
            {
                labels[3] = "Note that colors are shifting because this is before any matching.";
                dst2 += cv.Scalar.All(1);
                dst2.SetTo(0, vbc.task.noDepthMask);
                myPalette.Run(dst2);
                dst3 = myPalette.dst2;
            }
            int depthCount = vbc.task.depthMask.CountNonZero();
            labels[2] = classCount.ToString() + " regions detected in the backprojection - " + string.Format("{0:0%}", (float)count / depthCount);
        }
    }




    public class HeatMap_Basics_CS : VB_Parent
    {
        public History_Basics topframes = new History_Basics();
        public History_Basics sideframes = new History_Basics();
        public Mat histogramTop = new Mat();
        public Mat histogramSide = new Mat();
        Options_HeatMap options = new Options_HeatMap();
        public HeatMap_Basics_CS()
        {
            desc = "Highlight concentrations of depth pixels in the side view";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsTop, new Mat(), histogramTop, 2, vbc.task.bins2D, vbc.task.rangesTop);
            histogramTop.Row(0).SetTo(0);
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsSide, new Mat(), histogramSide, 2, vbc.task.bins2D, vbc.task.rangesSide);
            histogramSide.Col(0).SetTo(0);
            topframes.Run(histogramTop);
            dst0 = topframes.dst2;
            sideframes.Run(histogramSide);
            dst1 = sideframes.dst2;
            dst2 = ShowPalette(dst0.ConvertScaleAbs());
            dst3 = ShowPalette(dst1.ConvertScaleAbs());
            labels[2] = "Top view of heat map with the last " + vbc.task.frameHistoryCount.ToString() + " frames";
            labels[3] = "Side view of heat map with the last " + vbc.task.frameHistoryCount.ToString() + " frames";
        }
    }




    public class HeatMap_Grid_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        public HeatMap_Grid_CS()
        {
            vbc.task.gOptions.setGridSize(5);
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Histogram mask for top-down view - original histogram in dst0", "Histogram mask for side view - original histogram in dst1" };
            desc = "Apply a grid to the HeatMap_OverTime to isolate objects.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            heat.Run(src);
            dst2.SetTo(0);
            dst3.SetTo(0);
            int maxCount1 = 0, maxCount2 = 0;
            object sync1 = new object(), sync2 = new object();
            if (vbc.task.gOptions.getMultiThreading())
            {
                Parallel.ForEach(vbc.task.gridRects, roi =>
                {
                    int count1 = heat.histogramTop[roi].CountNonZero();
                    dst2[roi].SetTo(count1);
                    if (count1 > maxCount1)
                    {
                        lock (sync1)
                        {
                            maxCount1 = count1;
                        }
                    }
                    int count2 = heat.histogramSide[roi].CountNonZero();
                    dst3[roi].SetTo(count2);
                    if (count2 > maxCount2)
                    {
                        lock (sync2)
                        {
                            maxCount2 = count2;
                        }
                    }
                });
            }
            else
            {
                foreach (var roi in vbc.task.gridRects)
                {
                    int count1 = heat.histogramTop[roi].CountNonZero();
                    dst2[roi].SetTo(count1);
                    if (count1 > maxCount1) maxCount1 = count1;
                    int count2 = heat.histogramSide[roi].CountNonZero();
                    dst3[roi].SetTo(count2);
                    if (count2 > maxCount2) maxCount2 = count2;
                }
            }
            dst2 *= 255.0 / maxCount1;
            dst3 *= 255.0 / maxCount2;
        }
    }




    public class HeatMap_HotNot_CS : VB_Parent
    {
        HeatMap_Hot heat = new HeatMap_Hot();
        public HeatMap_HotNot_CS()
        {
            labels = new string[] { "", "", "Mask of cool areas in the heat map - top view", "Mask of cool areas in the heat map - side view" };
            desc = "Isolate points with low histogram values in side and top views";
        }
        public void RunAlg(Mat src)
        {
            heat.Run(src);
            dst0 = heat.dst2.ConvertScaleAbs();
            dst1 = heat.dst3.ConvertScaleAbs();
            dst2 = dst0.Threshold(vbc.task.redOptions.getProjection(), 255, ThresholdTypes.Binary);
            dst3 = dst1.Threshold(vbc.task.redOptions.getProjection(), 255, ThresholdTypes.Binary);
        }
    }




    public class HeatMap_Hot_CS : VB_Parent
    {
        Projection_HistTop histTop = new Projection_HistTop();
        Projection_HistSide histSide = new Projection_HistSide();
        public HeatMap_Hot_CS()
        {
            labels = new string[] { "", "", "Mask of hotter areas for the Top View", "Mask of hotter areas for the Side View" };
            desc = "Isolate masks for just the hotspots in the heat map";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            dst2 = histTop.histogram;
            histSide.Run(src);
            dst3 = histSide.histogram;
            var mmTop = GetMinMax(dst2);
            var mmSide = GetMinMax(dst3);
            if (vbc.task.heartBeat) labels[2] = mmTop.maxVal.ToString() + " max count " + dst2.CountNonZero() + " pixels in the top down view";
            if (vbc.task.heartBeat) labels[3] = mmSide.maxVal.ToString() + " max count " + dst3.CountNonZero() + " pixels in the side view";
        }
    }




    public class HeatMap_Cell_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        HeatMap_Hot heat = new HeatMap_Hot();
        public HeatMap_Cell_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Display the heat map for the selected cell";
        }
        public void RunAlg(Mat src)
        {
            flood.Run(src);
            dst2 = flood.dst2;
            labels[2] = flood.labels[2];
            dst0 = new Mat(dst2.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            vbc.task.pointCloud[vbc.task.rc.rect].CopyTo(dst0[vbc.task.rc.rect], vbc.task.rc.mask);
            heat.Run(dst0);
            dst1 = heat.dst2;
            dst3 = heat.dst3;
            labels[1] = heat.labels[2];
            labels[3] = heat.labels[3];
        }
    }




    public class HeatMap_GuidedBP_CS : VB_Parent
    {
        GuidedBP_Basics guided = new GuidedBP_Basics();
        public HeatMap_GuidedBP_CS()
        {
            vbc.task.redOptions.setProjection(1);
            desc = "This is just a placeholder to make it easy to find the GuidedBP_Basics which shows objects in top/side views.";
        }
        public void RunAlg(Mat src)
        {
            guided.Run(src);
            dst2 = guided.dst2;
            dst3 = guided.dst3;
            labels = guided.labels;
        }
    }




    public class Hist_Basics_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public mmData mm;
        public Plot_Histogram plot = new Plot_Histogram();
        public Rangef[] ranges;
        public float[] histArray;
        public Mat inputMask = new Mat();
        public Rangef[] fixedRanges;
        public int bins;
        public bool removeMax;
        public bool autoDisplay;
        int splitIndex;
        public Hist_Basics_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(255);
            desc = "Create a histogram (no Kalman)";
        }
        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                if (vbc.task.heartBeat) splitIndex = (splitIndex + 1) % 3;
                mm = GetMinMax(src.ExtractChannel(splitIndex));
                if (splitIndex == 0)
                    plot.backColor = Scalar.Blue;
                else if (splitIndex == 1)
                    plot.backColor = Scalar.Green;
                else
                    plot.backColor = Scalar.Red;

            }
            else
            {
                if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                mm = GetMinMax(src);
            }
            if (fixedRanges == null)
            {
                ranges = new Rangef[] { new Rangef((float)(mm.minVal - histDelta), (float)(mm.maxVal + histDelta)) };
            }
            else
            {
                ranges = fixedRanges;
            }
            // ranges are exclusive in OpenCV!!!
            if (bins == 0)
            {
                Cv2.CalcHist(new Mat[] { src }, new int[] { splitIndex }, inputMask, histogram, 1, new int[] { vbc.task.histogramBins }, ranges);
            }
            else
            {
                Cv2.CalcHist(new Mat[] { src }, new int[] { splitIndex }, inputMask, histogram, 1, new int[] { bins }, ranges);
            }
            if (removeMax)
            {
                var mmMax = GetMinMax(histogram);
                histogram.Set<float>(mmMax.maxLoc.Y, mmMax.maxLoc.X, 0);
            }
            histArray = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            plot.Run(histogram);
            histogram = plot.histogram; // reflect any updates to the 0 entry...  
            dst2 = plot.dst2;
            if (standalone)
            {
                string colorName;
                if (splitIndex == 0)
                    colorName = "Blue";
                else if (splitIndex == 1)
                    colorName = "Green";
                else
                    colorName = "Red";

                labels[2] = colorName + " histogram, bins = " +
                               vbc.task.histogramBins.ToString() + ", X ranges from " +
                               mm.minVal.ToString("0.0") + " to " +
                               mm.maxVal.ToString("0.0") + ", y is sample count";
            }
            else
            {
                labels[2] = "Range = " + ranges[0].Start.ToString(vbc.fmt3) + " To " + ranges[0].End.ToString(vbc.fmt3);
            }
        }
    }





    public class Hist_DepthSimple_CS : VB_Parent
    {
        public List<float> histList = new List<float>();
        public float[] histArray;
        public Mat histogram = new Mat();
        Plot_Histogram plotHist = new Plot_Histogram();
        mmData mm;
        public Mat inputMask = new Mat();
        public Rangef[] ranges;
        public Hist_DepthSimple_CS()
        {
            labels[2] = "Histogram of depth from 0 to maxZMeters.";
            plotHist.addLabels = false;
            desc = "Use Kalman to smooth the histogram results.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                mm = GetMinMax(vbc.task.pcSplit[2]);
                ranges = new[] { new Rangef((float)mm.minVal, (float)mm.maxVal) };
            }
            Cv2.CalcHist(new[] { vbc.task.pcSplit[2] }, new[] { 0 }, inputMask, histogram, 1, new[] { vbc.task.histogramBins }, ranges);
            histArray = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            if (standaloneTest())
            {
                plotHist.Run(histogram);
                dst2 = plotHist.dst2;
            }
            histList = new List<float>(histArray);
        }
    }





    public class Hist_Grayscale_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public Hist_Grayscale_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(255);
            desc = "Create a histogram of the grayscale image";
        }
        public void RunAlg(Mat src)
        {
            hist.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = hist.dst2;
            dst3 = hist.dst3;
            labels = hist.labels;
        }
    }




    public class Hist_Graph_CS : VB_Parent
    {
        public Mat[] histRaw = new Mat[3];
        public Mat[] histNormalized = new Mat[3];
        public float minRange = 0;
        public float maxRange = 255;
        public Scalar backColor = Scalar.Gray;
        public bool plotRequested;
        public Scalar[] plotColors = { Scalar.Blue, Scalar.Green, Scalar.Red };
        public float plotMaxValue;
        public Hist_Graph_CS()
        {
            desc = "Plot histograms for up to 3 channels.";
        }
        public void RunAlg(Mat src)
        {
            int[] dimensions = { vbc.task.histogramBins };
            Rangef[] ranges = new Rangef[] { new Rangef(minRange, maxRange) };
            float plotWidth = dst2.Width / vbc.task.histogramBins;
            mmData mm = new mmData();
            dst2.SetTo(backColor);
            for (int i = 0; i < src.Channels(); i++)
            {
                Mat hist = new Mat();
                Cv2.CalcHist(new Mat[] { src }, new int[] { i }, new Mat(), hist, 1, dimensions, ranges);
                histRaw[i] = hist.Clone();
                mm = GetMinMax(histRaw[i]);
                histNormalized[i] = hist.Normalize(0, hist.Rows, NormTypes.MinMax);
                if (standaloneTest() || plotRequested)
                {
                    List<cv.Point> points = new List<cv.Point>();
                    List<List<cv.Point>> listOfPoints = new List<List<cv.Point>>();
                    for (int j = 0; j < vbc.task.histogramBins; j++)
                    {
                        points.Add(new cv.Point((int)(j * plotWidth), dst2.Rows - dst2.Rows * histRaw[i].Get<float>(j, 0) / mm.maxVal));
                    }
                    listOfPoints.Add(points);
                    dst2.Polylines(listOfPoints, false, plotColors[i], vbc.task.lineWidth, vbc.task.lineType);
                }
            }
            if (standaloneTest() || plotRequested)
            {
                plotMaxValue = (float)Math.Round((float)(mm.maxVal / 1000), 0) * 1000 + 1000; // smooth things out a little for the scale below
                AddPlotScale(dst2, 0, plotMaxValue);
                labels[2] = "Histogram for src image (default color) - " + vbc.task.histogramBins.ToString() + " bins";
            }
        }
    }




    public class Hist_NormalizeGray_CS : VB_Parent
    {
        public Hist_Basics histogram = new Hist_Basics();
        private Options_Histogram options = new Options_Histogram();

        public Hist_NormalizeGray_CS()
        {
            labels[2] = "Use sliders to adjust the image and create a histogram of the results";
            desc = "Create a histogram of a normalized image";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst3 = src.Normalize(options.minGray, options.maxGray, NormTypes.MinMax); // only minMax is working...
            histogram.Run(dst3);
            dst2 = histogram.dst2;
        }
    }




    public class Hist_EqualizeGray_CS : VB_Parent
    {
        public Hist_Basics histogramEQ = new Hist_Basics();
        public Hist_Basics histogram = new Hist_Basics();
        Mat_4to1 mats = new Mat_4to1();
        public Hist_EqualizeGray_CS()
        {
            histogramEQ.plot.addLabels = false;
            histogram.plot.addLabels = false;
            labels[2] = "Equalized image";
            labels[3] = "Orig. Hist, Eq. Hist, Orig. Image, Eq. Image";
            desc = "Create an equalized histogram of the grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            histogram.Run(src);
            Cv2.EqualizeHist(src, dst2);
            histogramEQ.Run(dst2);
            mats.mat[0] = histogram.dst2.Clone();
            mats.mat[1] = histogramEQ.dst2;
            mats.mat[2] = src;
            mats.mat[3] = dst2;
            mats.Run(empty);
            dst3 = mats.dst2;
        }
    }




    public class Hist_Simple_CS : VB_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        public Hist_Simple_CS()
        {
            labels[2] = "Histogram of the grayscale video stream";
            desc = "Build a simple and reusable histogram for grayscale images.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Rangef[] ranges = new Rangef[] { new Rangef(plot.minRange, plot.maxRange) };
            Mat hist = new Mat();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), hist, 1, new int[] { vbc.task.histogramBins }, ranges);
            plot.Run(hist);
            dst2 = plot.dst2;
        }
    }




    public class Hist_ColorsAndGray_CS : VB_Parent
    {
        Hist_Basics histogram = new Hist_Basics();
        Mat_4Click mats = new Mat_4Click();
        public Hist_ColorsAndGray_CS()
        {
            labels[2] = "Click any quadrant at right to view it below";
            desc = "Create a histogram of a normalized image";
        }
        public void RunAlg(Mat src)
        {
            Mat[] split = src.Split();
            Array.Resize(ref split, 4);
            split[3] = src.CvtColor(ColorConversionCodes.BGR2GRAY); // add a 4th image - the grayscale image to the R G and B images.
            for (int i = 0; i < split.Length; i++)
            {
                Mat histSrc = split[i];
                if (i == 0)
                    histogram.plot.backColor = Scalar.Blue;
                else if (i == 1)
                    histogram.plot.backColor = Scalar.Green;
                else
                    histogram.plot.backColor = Scalar.Red;
                histogram.Run(histSrc);
                mats.mat[i] = histogram.plot.dst2.Clone();
            }
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Hist_Frustrum_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        public Hist_Frustrum_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setGravityUsage(false);
            desc = "Options for the side and top view.  See OptionCommon_Histogram to make settings permanent.";
        }
        public void RunAlg(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst2;
            dst3 = heat.dst3;
            SetTrueText("This algorithm was created to tune the frustrum and camera locations." + "\n" +
                        "Without these tuning parameters the side and top views will look correct." + "\n" +
                        "To see how these adjustments work or to add a new camera, " + "\n" +
                        "use the HeatMap_Basics algorithm." + "\n" +
                        "For new cameras, make the adjustments needed, note the value, and update " + "\n" +
                        "the Select statement in the constructor for Options_CameraDetails.", new cv.Point(10, 80), 1);
        }
    }




    public class Hist_PeakMax_CS : VB_Parent
    {
        Hist_Basics hist;
        public Hist_PeakMax_CS()
        {
            desc = "Create a histogram and back project into the image the grayscale color with the highest occurance.";
            labels[3] = "Grayscale Histogram";
            hist = new Hist_Basics();
        }
        public void RunAlg(Mat src)
        {
            vbc.task.gOptions.SetUseKalman(false);
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst3 = hist.dst2;
            mmData mm = GetMinMax(hist.histogram);
            int brickWidth = dst2.Width / vbc.task.histogramBins;
            int brickRange = 255 / vbc.task.histogramBins;
            int histindex = mm.maxLoc.Y;
            int pixelMin = (int)(histindex * brickRange);
            int pixelMax = (int)((histindex + 1) * brickRange);
            Mat mask = src.InRange(pixelMin, pixelMax).Threshold(1, 255, ThresholdTypes.Binary);
            Mat tmp = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            src.CopyTo(tmp, mask);
            dst2 = tmp.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "BackProjection of most frequent gray pixel";
            Cv2.Rectangle(dst3, new cv.Rect(brickWidth * histindex, 0, brickWidth, dst2.Height), Scalar.Yellow, 1);
        }
    }




    public class Hist_PeakFinder_CS : VB_Parent
    {
        public Hist_Basics hist;
        public int peakCount;
        public bool resetPeaks;
        public List<int> histogramPeaks = new List<int>();
        public float[] hCount;
        int saveHistBins;
        float[] peakCounts;
        List<int> allPCounts;
        List<int> maxList;
        public Hist_PeakFinder_CS()
        {
            desc = "Find the peaks - columns taller that both neighbors - in the histogram";
            hist = new Hist_Basics();
            allPCounts = new List<int>();
            maxList = new List<int>();
            peakCounts = new float[vbc.task.histogramBins];
            saveHistBins = vbc.task.histogramBins;
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = vbc.task.pcSplit[2];
            hist.Run(src);
            dst2 = hist.dst2;
            resetPeaks = false;
            if (saveHistBins != vbc.task.histogramBins)
            {
                resetPeaks = true;
                allPCounts.Clear();
                maxList.Clear();
                saveHistBins = vbc.task.histogramBins;
                Array.Resize(ref peakCounts, vbc.task.histogramBins);
            }
            hCount = new float[vbc.task.histogramBins];
            Mat histogram = hist.histogram;
            List<int> peaks = new List<int>();
            float maxPeak = float.MinValue;
            int maxIndex = 0;
            for (int i = 0; i < histogram.Rows; i++)
            {
                float prev = histogram.Get<float>(Math.Max(i - 1, 0), 0);
                float curr = histogram.Get<float>(i, 0);
                float nextVal = histogram.Get<float>(Math.Min(i + 1, histogram.Rows - 1), 0);
                hCount[i] = curr;
                if (i == 0)
                {
                    if (prev >= nextVal)
                    {
                        peaks.Add(i);
                        peakCounts[i] += 1;
                    }
                }
                else
                {
                    if (prev <= curr && curr > nextVal)
                    {
                        peaks.Add(i);
                        peakCounts[i] += 1;
                    }
                }
                if (curr > maxPeak)
                {
                    maxPeak = curr;
                    maxIndex = i;
                }
            }
            allPCounts.Add(peaks.Count);
            maxList.Add(maxIndex);

            peakCount = (int)allPCounts.Average();
            SetTrueText("/t" + "Avg peaks: " + peakCount + ".  Current: " + peaks.Count + " peaks.", new cv.Point(0, 10), 3);
            var sortedPeaks = new SortedDictionary<int, int>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < peakCounts.Length; i++)
            {
                sortedPeaks.Add((int)peakCounts[i], i);
            }
            mmData mm = GetMinMax(histogram);
            if (mm.maxVal == 0) return; // entries are all zero?  Likely camera trouble.
            int brickWidth = dst2.Width / histogram.Rows;
            histogramPeaks.Clear();
            for (int i = 0; i < Math.Min(sortedPeaks.Count, peakCount); i++)
            {
                int index = sortedPeaks.ElementAt(i).Value;
                histogramPeaks.Add(index);
                int h = (int)(hCount[index] * dst2.Height / mm.maxVal);
                Cv2.Rectangle(dst2, new cv.Rect(index * brickWidth, dst2.Height - h, brickWidth, h), Scalar.Yellow, vbc.task.lineWidth);
            }
            if (allPCounts.Count > 100)
            {
                allPCounts.RemoveAt(0);
                maxList.RemoveAt(0);
            }
            if (Math.Abs(maxList.Average() - maxIndex) > saveHistBins / 10) saveHistBins = 0;
            labels[2] = "There were " + peakCount + " depth peaks (highlighted) up to " + vbc.task.MaxZmeters + " meters.  " +
                        "Use global option Histogram Bins to set the number of bins.";
        }
    }




    public class Hist_PeaksDepth_CS : VB_Parent
    {
        Hist_PeakFinder peaks;
        public Hist_PeaksDepth_CS()
        {
            desc = "Find the peaks - columns taller that both neighbors - in the histogram";
            peaks = new Hist_PeakFinder();
        }
        public void RunAlg(Mat src)
        {
            peaks.Run(vbc.task.pcSplit[2]);
            dst2 = peaks.dst2;
            labels[2] = peaks.labels[2];
        }
    }




    public class Hist_PeaksRGB_CS : VB_Parent
    {
        Mat_4Click mats;
        Hist_PeakFinder[] peaks;
        public Hist_PeaksRGB_CS()
        {
            peaks = new Hist_PeakFinder[3];
            for (int i = 0; i < 3; i++)
            {
                peaks[i] = new Hist_PeakFinder();
            }
            labels[2] = "Upper left is Blue, upper right is Green, bottom left is Red";
            desc = "Find the peaks and valleys for each of the BGR channels.";
            mats = new Mat_4Click();
        }
        public void RunAlg(Mat src)
        {
            Mat[] split = src.Split();
            for (int i = 0; i < 3; i++)
            {
                peaks[i].hist.plot.backColor = new Scalar(i == 0 ? 255 : 0, i == 1 ? 255 : 0, i == 2 ? 255 : 0);
                peaks[i].hist.plot.addLabels = false;
                peaks[i].Run(split[i]);
                mats.mat[i] = peaks[i].dst2.Clone();
            }
            if (vbc.task.optionsChanged)
            {
                vbc.task.mouseClickFlag = true;
                vbc.task.mousePicTag = 2;
            }
            mats.Run(new Mat());
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Hist_Color_CS : VB_Parent
    {
        Mat histogram = new cv.Mat();
        Plot_Histogram plot = new Plot_Histogram();
        Rangef[] ranges;
        public Hist_Color_CS()
        {
            desc = "Create a histogram of green and red.";
        }
        public void RunAlg(Mat src)
        {
            ranges = new Rangef[2] { new Rangef(0, 255), new Rangef(0, 255) };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 1, 2 }, new Mat(), histogram, 1, new int[] { vbc.task.histogramBins, vbc.task.histogramBins }, ranges);
            Mat test = histogram.Clone();
            test.Normalize(0, 255, NormTypes.MinMax);
            Mat input = new cv.Mat();
            src.ConvertTo(input, MatType.CV_32FC3);
            Mat mask = new Mat();
            Cv2.CalcBackProject(new Mat[] { input }, new int[] { 1, 2 }, histogram, mask, ranges);
            mmData mm = GetMinMax(mask);
            plot.Run(test);
            dst2 = plot.dst2;
        }
    }




    public class Hist_KalmanAuto_CS : VB_Parent
    {
        Mat histogram = new Mat();
        Kalman_Basics kalman = new Kalman_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        mmData mm;
        Rangef[] ranges;
        int splitIndex = 0;
        string colorName = "Gray";
        public Hist_KalmanAuto_CS()
        {
            desc = "Create a histogram of the grayscale image and smooth the bar chart with a kalman filter.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.heartBeat) splitIndex = (splitIndex + 1) % 3;
                if (splitIndex == 0)
                    colorName = "Blue";
                else if (splitIndex == 1)
                    colorName = "Green";
                else
                    colorName = "Red";
                Mat[] split = src.Split();
                src = split[splitIndex];
            }
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            mm = GetMinMax(src);
            ranges = new Rangef[1] { new Rangef((float)mm.minVal, (float)mm.maxVal) };
            if (mm.minVal == mm.maxVal)
            {
                SetTrueText("The input image is empty - minVal and maxVal are both zero...");
                return;
            }
            int[] dimensions = { vbc.task.histogramBins };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), histogram, 1, dimensions, ranges);
            if (kalman.kInput.Length != vbc.task.histogramBins) Array.Resize(ref kalman.kInput, vbc.task.histogramBins);
            for (int i = 0; i < vbc.task.histogramBins; i++)
            {
                kalman.kInput[i] = histogram.Get<float>(i, 0);
            }
            kalman.Run(src);
            histogram = cv.Mat.FromPixelData(kalman.kOutput.Length, 1, MatType.CV_32FC1, kalman.kOutput);
            if (standaloneTest())
            {
                if (splitIndex == 0)
                    plot.backColor = Scalar.Blue;
                else if (splitIndex == 1)
                    plot.backColor = Scalar.Green;
                else
                    plot.backColor = Scalar.Red;
            }
            plot.Run(histogram);
            dst2 = plot.dst2;
            labels[2] = colorName + " histogram, bins = " + vbc.task.histogramBins + ", X ranges from " + mm.minVal + " to " + mm.maxVal + ", y is occurances";
        }
    }




    public class Hist_EqualizeColor_CS : VB_Parent
    {
        Hist_Basics kalmanEq = new Hist_Basics();
        Hist_Basics kalman = new Hist_Basics();
        Mat_2to1 mats = new Mat_2to1();
        public bool displayHist;
        public int channel;
        public Hist_EqualizeColor_CS()
        {
            kalmanEq.plot.addLabels = false;
            kalman.plot.addLabels = false;
            desc = "Create an equalized histogram of the color image.";
            labels[2] = "Image Enhanced with Equalized Histogram";
        }
        public void RunAlg(Mat src)
        {
            Mat[] rgb = src.Split();
            Mat[] rgbEq = src.Split();
            for (int i = 0; i < rgb.Length; i++)
            {
                Cv2.EqualizeHist(rgbEq[i], rgbEq[i]);
            }
            if (standaloneTest() || displayHist)
            {
                Cv2.Split(src, out rgb); // equalizehist alters the input...
                kalman.plot.backColor = Scalar.Red;
                kalman.Run(rgb[channel].Clone());
                mats.mat[0] = kalman.dst2.Clone();
                kalmanEq.Run(rgbEq[channel].Clone());
                mats.mat[1] = kalmanEq.dst2.Clone();
                mats.Run(new Mat());
                dst3 = mats.dst2;
                labels[3] = "Before (top) and After Red Histogram";
            }
            Cv2.Merge(rgbEq, dst2);
        }
    }




    public class Hist_CompareGray_CS : VB_Parent
    {
        Hist_Kalman histK = new Hist_Kalman();
        Options_HistCompare options = new Options_HistCompare();
        Mat histDiff;
        Mat histDiffAbs = new cv.Mat();
        Mat normHistDiff;
        Mat normHistDiffAbs = new cv.Mat();
        Mat lastHist;
        Mat lastHistNorm;
        public Hist_CompareGray_CS()
        {
            labels[2] = "Kalman-smoothed current histogram";
            desc = "Compare grayscale histograms for successive frames";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            histK.Run(src);
            dst2 = histK.dst2.Clone();
            if (vbc.task.FirstPass) lastHist = histK.hist.histogram.Clone();
            Mat histNorm = histK.hist.histogram.Clone();
            histNorm.Normalize(0, 1, NormTypes.MinMax);
            if (vbc.task.FirstPass) lastHistNorm = histNorm.Clone();
            if (lastHistNorm.Size() == histK.hist.histogram.Size())
            {
                double Comparison = Cv2.CompareHist(histNorm, lastHistNorm, options.compareMethod);
                if (double.IsNaN(Comparison)) Comparison = 0;
                labels[3] = "CompareHist output = " + Comparison.ToString(vbc.fmt3) + " using " + options.compareName + " method";
                trueData = histK.hist.plot.trueData.ToList();
                SetTrueText(labels[3], 2);
            }
            else
            {
                lastHistNorm = histNorm.Clone();
            }
            if (histNorm.Size() == lastHistNorm.Size())
            {
                normHistDiff = histNorm - lastHistNorm;
                Cv2.Absdiff(histNorm, lastHistNorm, normHistDiffAbs);
            }
            lastHistNorm = histNorm.Clone();
            if (histK.hist.histogram.Size() == lastHist.Size())
            {
                histDiff = histK.hist.histogram - lastHist;
                Cv2.Absdiff(histK.hist.histogram, lastHist, histDiffAbs);
            }
            lastHist = histK.hist.histogram.Clone();
        }
    }




    public class Hist_ComparePlot_CS : VB_Parent
    {
        Hist_CompareGray comp = new Hist_CompareGray();
        List<TrueText> ttLabels;
        public Hist_ComparePlot_CS()
        {
            labels[3] = "Differences have been multiplied by 1000 to build scale at the left";
            desc = "Compare grayscale histograms for successive frames and plot the difference as a histogram.";
        }
        public void RunAlg(Mat src)
        {
            comp.Run(src);
            dst2 = comp.dst2.Clone();
            if (vbc.task.heartBeat)
            {
                ttLabels = comp.trueData.ToList();
                Mat histX = comp.histDiffAbs;
                comp.histK.hist.plot.Run(histX);
                dst3 = comp.histK.hist.plot.dst2.Clone();
                mmData mm = GetMinMax(histX);
                AddPlotScale(dst2, 0, mm.maxVal);
            }
            trueData = ttLabels;
        }
    }




    public class Hist_CompareNumber_CS : VB_Parent
    {
        Hist_CompareGray comp = new Hist_CompareGray();
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public Hist_CompareNumber_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            plot.plotCount = 2;
            labels = new string[] { "", "", "Kalman-smoothed normalized histogram output", "Plot of the sum of the differences between recent normalized histograms" };
            desc = "The idea is to reduce a comparison of 2 histograms to a single number";
        }
        public void RunAlg(Mat src)
        {
            comp.Run(src);
            dst1 = comp.dst2.Clone();
            double sum = Cv2.Sum(comp.normHistDiff)[0] * 100;
            double sumAbs = Cv2.Sum(comp.normHistDiffAbs)[0] * 100;
            plot.plotData = new Scalar(sum, sumAbs, 0);
            plot.Run(new Mat());
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            SetTrueText("Upper left is the sum * 100 of the difference\nUpper right is the sum of the absolute values * 100", new cv.Point(0, dst2.Height / 2), 2);
        }
    }




    public class Hist_CompareEMD_hsv_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Mat lastHSV;
        public Hist_CompareEMD_hsv_CS()
        {
            labels = new string[] { "", "", "Kalman-smoothed normalized histogram output", "Plot of the sum of the differences between recent normalized histograms" };
            desc = "Use OpenCV's Earth Mover Distance to compare 2 images.";
        }
        public void RunAlg(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            if (vbc.task.FirstPass) lastHSV = hsv.Clone();
            int hBins = 30, sBins = 32;
            Mat histA = new Mat(), histB = new Mat();
            Rangef[] ranges = new Rangef[2] { new Rangef(0, 180), new Rangef(0, 256) };
            Cv2.CalcHist(new Mat[] { hsv }, new int[] { 0, 1 }, new Mat(), histA, 2, new int[] { hBins, sBins }, ranges);
            Mat histNormA = histA.Clone();
            histNormA.Normalize(0, 1, NormTypes.MinMax);
            Cv2.CalcHist(new Mat[] { lastHSV }, new int[] { 0, 1 }, new Mat(), histB, 2, new int[] { hBins, sBins }, ranges);
            Mat histNormB = histB.Clone();
            histNormB.Normalize(0, 1, NormTypes.MinMax);
            Mat sig1 = new Mat(sBins * hBins, 3, MatType.CV_32F, Scalar.All(0));
            Mat sig2 = new Mat(sBins * hBins, 3, MatType.CV_32F, Scalar.All(0));
            for (int h = 0; h < hBins; h++)
            {
                for (int s = 0; s < sBins; s++)
                {
                    sig1.Set<float>(h * sBins + s, 0, histNormA.Get<float>(h, s));
                    sig1.Set<float>(h * sBins + s, 1, h);
                    sig1.Set<float>(h * sBins + s, 2, s);
                    sig2.Set<float>(h * sBins + s, 0, histNormB.Get<float>(h, s));
                    sig2.Set<float>(h * sBins + s, 1, h);
                    sig2.Set<float>(h * sBins + s, 2, s);
                }
            }
            double emd = Cv2.EMD(sig1, sig2, DistanceTypes.L2);
            SetTrueText("EMD similarity from the current image to the last is " + (1 - emd).ToString("F0%"), 2);
            lastHSV = hsv.Clone();
        }
    }




    public class Hist_Peaks_CS : VB_Parent
    {
        BackProject_Masks masks;
        public Hist_Peaks_CS()
        {
            desc = "Interactive Histogram";
            masks = new BackProject_Masks();
        }
        public void RunAlg(Mat src)
        {
            masks.Run(src);
            dst2 = masks.dst2;
            dst3 = masks.dst3;
        }
    }




    public class Hist_Lab_CS : VB_Parent
    {
        Hist_Basics hist;
        public Hist_Lab_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "Lab Colors ", "Lab Channel 0", "Lab Channel 1", "Lab Channel 2" };
            desc = "Create a histogram from a BGR image converted to LAB.";
            hist = new Hist_Basics();
        }
        public void RunAlg(Mat src)
        {
            dst0 = src.CvtColor(ColorConversionCodes.BGR2Lab);
            Mat[] split = dst0.Split();
            hist.Run(split[0]);
            dst1 = hist.dst2.Clone();
            hist.Run(split[1]);
            dst2 = hist.dst2.Clone();
            hist.Run(split[2]);
            dst3 = hist.dst2.Clone();
        }
    }




    public class Hist_PointCloudXYZ_CS : VB_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        List<List<TrueText>> ttlists;
        public Hist_PointCloudXYZ_CS()
        {
            plot.createHistogram = true;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Histogram of the X channel", "Histogram of the Y channel", "Histogram of the Z channel" };
            desc = "Show individual channel of the point cloud data as a histogram.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) ttlists = new List<List<TrueText>> { new List<TrueText>(), new List<TrueText>(), new List<TrueText>() };
            for (int i = 0; i <= 2; i++)
            {
                dst0 = vbc.task.pcSplit[i];
                mmData mm = GetMinMax(dst0);
                switch (i)
                {
                    case 0:
                        plot.removeZeroEntry = false;
                        plot.minRange = -vbc.task.xRange;
                        plot.maxRange = vbc.task.xRange;
                        break;
                    case 1:
                        plot.removeZeroEntry = false;
                        plot.minRange = -vbc.task.yRange;
                        plot.maxRange = vbc.task.yRange;
                        break;
                    case 2:
                        plot.removeZeroEntry = true;
                        plot.minRange = 0;
                        plot.maxRange = vbc.task.MaxZmeters;
                        break;
                }
                plot.Run(dst0);
                switch (i)
                {
                    case 0:
                        dst1 = plot.dst2.Clone();
                        break;
                    case 1:
                        dst2 = plot.dst2.Clone();
                        break;
                    case 2:
                        dst3 = plot.dst2.Clone();
                        break;
                }
                string xyzStr = "X";
                if (i == 1) xyzStr = "Y";
                if (i == 2) xyzStr = "Z";
                if (vbc.task.heartBeat)
                {
                    labels[i + 1] = "Histogram " + xyzStr + " ranges from " + plot.minRange.ToString("0.0") + "m to " + plot.maxRange.ToString("0.0") + "m";
                }
            }
        }
    }




    public class Hist_FlatSurfaces_CS : VB_Parent
    {
        BackProject_Masks masks = new BackProject_Masks();
        float saveMinVal, saveMaxVal;
        public Hist_FlatSurfaces_CS()
        {
            desc = "Find flat surfaces with the histogram";
        }
        public void RunAlg(Mat src)
        {
            int maxRange = 4;
            Mat cloudY = vbc.task.pcSplit[1].Clone();
            mmData mm = GetMinMax(cloudY);
            cloudY = cloudY.Threshold(maxRange, mm.maxVal, ThresholdTypes.Trunc);
            if (vbc.task.FirstPass)
            {
                saveMinVal = (float)mm.minVal;
                saveMaxVal = (float)mm.maxVal;
            }
            if (vbc.task.heartBeat)
            {
                saveMinVal = (float)mm.minVal;
                saveMaxVal = (float)mm.maxVal;
            }
            if (saveMinVal > mm.minVal) saveMinVal = (float)mm.minVal;
            if (saveMaxVal < mm.maxVal) saveMaxVal = (float)mm.maxVal;
            cloudY.Set<float>(mm.minLoc.Y, mm.minLoc.X, -saveMinVal);
            cloudY.Set<float>(mm.maxLoc.Y, mm.maxLoc.X, saveMaxVal);
            cloudY -= cv.Scalar.All(saveMinVal);
            cloudY = cloudY.ConvertScaleAbs(255 / (-saveMinVal + saveMaxVal));
            mm = GetMinMax(cloudY);
            cloudY.SetTo(0, vbc.task.noDepthMask);
            masks.Run(cloudY);
            dst2 = masks.dst2;
            dst3 = src;
            dst3 = dst3.SetTo(new Scalar(255, 255, 255), masks.dst1);
            labels[2] = "Range for the histogram is from " + saveMinVal.ToString(vbc.fmt1) + " to " + saveMaxVal.ToString(vbc.fmt1);
        }
    }




    public class Hist_ShapeSide_CS : VB_Parent
    {
        public rcData rc = new rcData();
        public Hist_ShapeSide_CS()
        {
            vbc.task.gOptions.setHistogramBins(60);
            labels = new string[] { "", "", "ZY Side View", "ZY Side View Mask" };
            desc = "Create a 2D side view for ZY histogram of depth";
        }
        public void RunAlg(Mat src)
        {
            if (rc.pixels == 0) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsSide, new Mat(), dst0, 2,
                          new int[] { vbc.task.histogramBins, vbc.task.histogramBins }, vbc.task.rangesSide);
            dst0.Col(0).SetTo(0); // too many zero depth points...
            dst0 = Convert32f_To_8UC3(dst0);
            dst0.ConvertTo(dst0, MatType.CV_8UC1);
            cv.Rect r = new cv.Rect(0, 0, dst2.Height, dst2.Height);
            dst2[r] = dst0.Resize(new cv.Size(dst2.Height, dst2.Height), 0, 0, InterpolationFlags.Nearest);
            dst3 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }




    public class Hist_ShapeTop_CS : VB_Parent
    {
        public rcData rc = new rcData();
        public Hist_ShapeTop_CS()
        {
            vbc.task.gOptions.setHistogramBins(60);
            labels = new string[] { "", "", "ZY Side View", "ZY Side View Mask" };
            desc = "Create a 2D top view for XZ histogram of depth";
        }
        public void RunAlg(Mat src)
        {
            if (rc.pixels == 0) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsTop, new Mat(), dst0, 2,
                          new int[] { vbc.task.histogramBins, vbc.task.histogramBins }, vbc.task.rangesTop);
            dst0.Row(0).SetTo(0); // too many zero depth points...
            dst0 = Convert32f_To_8UC3(dst0);
            dst0.ConvertTo(dst0, MatType.CV_8UC1);
            cv.Rect r = new cv.Rect(0, 0, dst2.Height, dst2.Height);
            dst2[r] = dst0.Resize(new cv.Size(dst2.Height, dst2.Height), 0, 0, InterpolationFlags.Nearest);
            dst3 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }




    public class Hist_Gotcha2D_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Hist_Gotcha2D_CS()
        {
            labels[2] = "ZY (Side View)";
            desc = "Create a 2D side view for ZY histogram of depth using integer values.  Testing calcHist gotcha.";
        }
        public void RunAlg(Mat src)
        {
            int expected = vbc.task.pcSplit[2].CountNonZero();
            Rangef[] ranges = vbc.task.rangesSide;
            if (vbc.task.toggleOnOff)
            {
                ranges = new Rangef[] { new Rangef(-10, +10), new Rangef(-1, 20) };
            }
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesSide);
            var actual = histogram.Sum().Val0;
            if (vbc.task.heartBeat)
            {
                strOut = "Expected sample count:" + "\t" + expected + "\n" +
                         "Actual sample count:" + "\t" + actual + "\n" +
                         "The number of samples input is the expected value." + "\n" +
                         "The number of entries in the histogram is the 'actual' number of samples." + "\n" +
                         "How can the values not be equal?  The ranges of the histogram are exclusive." + "\n" +
                         "Another way that samples may be lost: X or Y range.  Use Y-Range slider to show impact." +
                         "A third way samples may not match: max depth can toss samples as well.";
            }
            SetTrueText(strOut, 3);
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class Hist_Gotcha_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        Hist_Basics hist = new Hist_Basics();
        public Hist_Gotcha_CS()
        {
            labels[2] = "Grayscale histogram";
            desc = "Simple test: input samples should equal histogram samples.  What is wrong?  Exclusive ranges!";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            long expected = src.Total();
            hist.Run(src);
            double actual = hist.histogram.Sum().Val0;
            if (vbc.task.heartBeat)
            {
                strOut = "Expected sample count:" + "\t" + expected + "\n" +
                         "Actual sample count:" + "\t" + actual + "\n" +
                         "Difference:" + "\t" + Math.Abs(actual - expected) + "\n" +
                         "The number of samples input is the expected value." + "\n" +
                         "The number of entries in the histogram is the 'actual' number of samples." + "\n" +
                         "How can the values not be equal?  The ranges in the histogram are exclusive!";
            }
            SetTrueText(strOut, 2);
        }
    }




    public class Hist_GotchaFixed_CPP_CS : VB_Parent
    {
        public Hist_GotchaFixed_CPP_CS()
        {
            cPtr = Hist_1D_Open();
            desc = "Testing the C++ CalcHist to investigate gotcha with sample counts";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Hist_1D_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, vbc.task.histogramBins);
            handleSrc.Free();
            if (vbc.task.heartBeat)
            {
                int actual = (int)Hist_1D_Sum(cPtr);
                strOut = "Expected sample count:" + "\t" + dst2.Total() + "\n" +
                         "Actual sample count:" + "\t" + actual + "\n" +
                         "Difference:" + "\t" + Math.Abs(actual - dst2.Total()) + "\n" +
                         "The number of samples input is the expected value." + "\n" +
                         "The number of entries in the histogram is the 'actual' number of samples." + "\n" +
                         "How can the values not be equal?  The ranges in the histogram are exclusive!";
            }
            SetTrueText(strOut, 2);
        }
        public void Close()
        {
            Hist_1D_Close(cPtr);
        }
    }




    public class Hist_Byte_CPP_CS : VB_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        public Hist_Byte_CPP_CS()
        {
            cPtr = Hist_1D_Open();
            desc = "For Byte histograms, the C++ code works but the .Net interface doesn't honor exclusive ranges.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Hist_1D_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, vbc.task.histogramBins);
            handleSrc.Free();
            Mat histogram = cv.Mat.FromPixelData(vbc.task.histogramBins, 1, MatType.CV_32F, imagePtr);
            plot.Run(histogram);
            dst2 = plot.dst2;
            SetTrueText(strOut, 2);
        }
        public void Close()
        {
            Hist_1D_Close(cPtr);
        }
    }




    public class Hist_Xdimension_CS : VB_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public Hist_Xdimension_CS()
        {
            desc = "Plot the histogram of the X layer of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            plot.Run(vbc.task.pcSplit[0]);
            dst2 = plot.dst2;
            SetTrueText("Chart left = " + string.Format(vbc.fmt0, plot.mm.minVal) + "\n" +
                        "Chart right = " + string.Format(vbc.fmt0, plot.mm.maxVal), 2);
        }
    }




    public class Hist_Ydimension_CS : VB_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public Hist_Ydimension_CS()
        {
            desc = "Plot the histogram of the Y layer of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            plot.Run(vbc.task.pcSplit[1]);
            dst2 = plot.dst2;
            SetTrueText("Chart left = " + string.Format(vbc.fmt0, plot.mm.minVal) + "\n" +
                        "Chart right = " + string.Format(vbc.fmt0, plot.mm.maxVal), 2);
        }
    }




    public class Hist_Zdimension_CS : VB_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public Hist_Zdimension_CS()
        {
            desc = "Plot the histogram of the Z layer of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            plot.Run(vbc.task.pcSplit[2]);
            dst2 = plot.dst2;
            SetTrueText("Chart left = " + string.Format(vbc.fmt0, plot.mm.minVal) + "\n" +
                        "Chart right = " + string.Format(vbc.fmt0, plot.mm.maxVal), 2);
        }
    }




    public class Hist_Depth_CS : VB_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        public rcData rc;
        public mmData mm;
        public Mat histogram = new Mat();
        public Hist_Depth_CS()
        {
            desc = "Show depth data as a histogram.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Rows <= 0) return;
            plot.minRange = 0;
            plot.maxRange = vbc.task.MaxZmeters;
            if (rc != null)
            {
                if (rc.index == 0) return;
                src = vbc.task.pcSplit[2][rc.rect].Clone();
            }
            else
            {
                if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
                mm = GetMinMax(src);
                plot.minRange = (float)mm.minVal; // because OpenCV's histogram makes the ranges exclusive.
                plot.maxRange = (float)mm.maxVal;
            }
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), histogram, 1, new int[] { vbc.task.histogramBins }, new Rangef[] { new Rangef(plot.minRange, plot.maxRange) });
            plot.histogram = histogram;
            plot.Run(plot.histogram);
            dst2 = plot.dst2;
            float stepsize = dst2.Width / vbc.task.MaxZmeters;
            for (int i = 1; i < (int)vbc.task.MaxZmeters; i++)
            {
                dst2.Line(new cv.Point(stepsize * i, 0), new cv.Point(stepsize * i, dst2.Height), Scalar.White, vbc.task.cvFontThickness);
            }
            if (standaloneTest())
            {
                int expected = src.CountNonZero();
                int actual = (int)plot.histogram.Sum().Val0;
                strOut = "Expected sample count (non-zero vbc.task.pcSplit[2]] entries):" + "\t" + expected + "\n";
                strOut += "Histogram sum (ranges can reduce):" + "\t\t\t" + actual + "\n";
                strOut += "Difference:" + "\t\t\t\t\t\t" + Math.Abs(actual - expected) + "\n";
            }
            SetTrueText(strOut, 3);
            labels[2] = "Histogram Depth to " + string.Format("0.0", vbc.task.MaxZmeters) + " m";
        }
    }




    public class Hist_Cell_CS : VB_Parent
    {
        Hist_Depth hist = new Hist_Depth();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Hist_Cell_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_32F, cv.Scalar.All(0));
            labels = new string[] { "", "", "RedCloud cells", "Histogram of the depth for the selected cell." };
            desc = "Review depth data for a RedCloud Cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            hist.rc = vbc.task.rc;
            if (hist.rc.index == 0 || hist.rc.maxVec.Z == 0) return;
            dst1.SetTo(0);
            vbc.task.pcSplit[2][hist.rc.rect].CopyTo(dst1);
            hist.Run(dst1);
            dst3 = hist.dst2;
        }
    }




    public class Hist_PointCloud_CS : VB_Parent
    {
        public Rangef[] rangesX;
        public Rangef[] rangesY;
        public Options_HistPointCloud options = new Options_HistPointCloud();
        public Hist_PointCloud_CS()
        {
            labels = new string[] { "", "", "Histogram of XZ - X on the Y-Axis and Z on the X-Axis", "Histogram of YZ with Y on the Y-Axis and Z on the X-Axis" };
            desc = "Create a 2D histogram for the pointcloud in XZ and YZ.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            rangesX = new Rangef[] { new Rangef(-vbc.task.xRange, vbc.task.xRange), new Rangef(0, vbc.task.MaxZmeters) };
            rangesY = new Rangef[] { new Rangef(-vbc.task.yRange, vbc.task.yRange), new Rangef(0, vbc.task.MaxZmeters) };
            int[] sizesX = new int[] { options.xBins, options.zBins };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 2 }, new Mat(), dst2, 2, sizesX, rangesX);
            dst2.Set<cv.Point3f>(dst2.Height / 2, 0, new Point3f());
            int[] sizesY = new int[] { options.yBins, options.zBins };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 1, 2 }, new Mat(), dst3, 2, sizesY, rangesY);
            dst3.Set<cv.Point3f>(dst3.Height / 2, 0, new Point3f());
        }
    }




    public class Hist_Kalman_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        public Hist_Kalman_CS()
        {
            labels = new string[] { "", "", "With Kalman", "Without Kalman" };
            desc = "Use Kalman to smooth the histogram results.";
        }
        public void RunAlg(Mat src)
        {
            hist.Run(src);
            dst3 = hist.dst2.Clone();
            if (hist.histogram.Rows == 0) hist.histogram = new Mat(vbc.task.histogramBins, 1, MatType.CV_32F, cv.Scalar.All(0));
            if (kalman.kInput.Length != vbc.task.histogramBins) Array.Resize(ref kalman.kInput, vbc.task.histogramBins);
            for (int i = 0; i < vbc.task.histogramBins; i++)
            {
                kalman.kInput[i] = hist.histogram.Get<float>(i, 0);
            }
            kalman.Run(src);
            hist.histogram = cv.Mat.FromPixelData(kalman.kOutput.Length, 1, MatType.CV_32FC1, kalman.kOutput);
            hist.plot.Run(hist.histogram);
            dst2 = hist.dst2;
        }
    }




    public class Guess_Depth_CPP_CS : VB_Parent
    {
        public Guess_Depth_CPP_CS()
        {
            cPtr = Guess_Depth_Open();
            labels = new string[] { "", "", "Updated point cloud (holes filled)", "Original point cloud" };
            desc = "Fill single pixel holes in the point cloud.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Guess_Depth_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_32FC3, imagePtr).Clone();
            if (standaloneTest()) dst3 = vbc.task.pointCloud;
        }
        public void Close()
        {
            Guess_Depth_Close(cPtr);
        }
    }




    public class Guess_ImageEdges_CPP_CS : VB_Parent
    {
        Options_Guess options = new Options_Guess();
        public Guess_ImageEdges_CPP_CS()
        {
            cPtr = Guess_ImageEdges_Open();
            labels = new string[] { "", "", "Updated point cloud - nearest depth to each edge is replicated to the image boundary", "Original point cloud" };
            desc = "Replicate the nearest depth measurement at all the image edges";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.cameraName == "Oak-D camera" || vbc.task.cameraName == "Azure Kinect 4K")
            {
                SetTrueText("Only RealSense cameras are likely to benefit from enhanced depth at the image edges.");
                return;
            }
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Guess_ImageEdges_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.MaxDistance);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_32FC3, cppData).Clone();
            if (standaloneTest()) dst3 = vbc.task.pointCloud;
        }
        public void Close()
        {
            Guess_ImageEdges_Close(cPtr);
        }
    }




    public class Hist2D_Basics_CS : VB_Parent
    {
        public int[] histRowsCols;
        public Rangef[] ranges;
        public Mat histogram = new cv.Mat();
        public int[] channels = { 0, 2 };
        public Hist2D_Basics_CS()
        {
            histRowsCols = new int[] { dst2.Height, dst2.Width };
            labels = new string[] { "", "", "All non-zero entries in the 2D histogram", "" };
            desc = "Create a 2D histogram from the input.";
        }
        public void RunAlg(Mat src)
        {
            ranges = GetHist2Dminmax(src, channels[0], channels[1]);
            Cv2.CalcHist(new Mat[] { src }, channels, new Mat(), histogram, 2, histRowsCols, ranges);
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary);
            dst2.ConvertTo(dst2, MatType.CV_8U);
        }
    }




    public class Hist2D_Cloud_CS : VB_Parent
    {
        Plot_Histogram2D plot1D = new Plot_Histogram2D();
        int[] channels;
        public Rangef[] ranges;
        public Mat histogram = new Mat();
        public Hist2D_Cloud_CS()
        {
            labels = new string[] { "", "", "Plot of 2D histogram", "All non-zero entries in the 2D histogram" };
            desc = "Create a 2D histogram of the point cloud data - which 2D inputs is in options.";
        }
        public void RunAlg(Mat src)
        {
            Vec2f r1 = new Vec2f(), r2 = new Vec2f();
            if (vbc.task.redOptions.channels[0] == 0 || vbc.task.redOptions.channels[0] == 1)
            {
                r1 = new Vec2f(-vbc.task.xRangeDefault, vbc.task.xRangeDefault);
            }
            if (vbc.task.redOptions.channels[1] == 1) r2 = new Vec2f(-vbc.task.yRangeDefault, vbc.task.yRangeDefault);
            if (vbc.task.redOptions.channels[1] == 2) r2 = new Vec2f(0, vbc.task.MaxZmeters);
            ranges = new Rangef[] { new Rangef(r1.Item0, r1.Item1), new Rangef(r2.Item0, r2.Item1) };
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.redOptions.channels, new Mat(),
                          histogram, 2, new int[] { vbc.task.histogramBins, vbc.task.histogramBins }, ranges);
            plot1D.Run(histogram);
            dst2 = plot1D.dst2;
            channels = vbc.task.redOptions.channels;
        }
    }




    public class Hist2D_Depth_CS : VB_Parent
    {
        Hist2D_Cloud hist2d = new Hist2D_Cloud();
        public int[] channels;
        public Rangef[] ranges;
        public Mat histogram = new Mat();
        public Hist2D_Depth_CS()
        {
            desc = "Create 2D histogram from the 3D pointcloud - use options to select dimensions.";
        }
        public void RunAlg(Mat src)
        {
            hist2d.Run(vbc.task.pointCloud);
            histogram = hist2d.histogram;
            ranges = hist2d.ranges;
            channels = vbc.task.redOptions.channels;
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst3 = histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            labels = new string[] { "", "", "Mask of the 2D histogram for selected channels", "Mask of 2D histogram after thresholding" };
        }
    }




    public class Hist2D_Zoom_CS : VB_Parent
    {
        Hist2D_Basics hist2d = new Hist2D_Basics();
        Magnify_Basics zoom = new Magnify_Basics();
        public Hist2D_Zoom_CS()
        {
            labels = new string[] { "", "", "Mask of histogram", "DrawRect area from the histogram" };
            desc = "Draw a rectangle on an area to zoom in on...";
        }
        public void RunAlg(Mat src)
        {
            hist2d.Run(src);
            dst2 = hist2d.dst2;
            zoom.Run(hist2d.histogram);
            dst3 = zoom.dst3;
        }
    }




    public class Hist2D_HSV_CS : VB_Parent
    {
        public Mat histogram01 = new Mat();
        public Mat histogram02 = new Mat();
        public Hist2D_HSV_CS()
        {
            labels = new string[] { "", "HSV image", "", "" };
            desc = "Create a 2D histogram for Hue to Saturation and Hue to Value.";
        }
        public void RunAlg(Mat src)
        {
            int[] histRowsCols = new int[] { dst2.Height, dst2.Width };
            src = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 2 }, vbc.task.depthMask, histogram02, 2, histRowsCols, vbc.task.redOptions.rangesHSV);
            dst2 = histogram02.Threshold(0, 255, ThresholdTypes.Binary);
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1 }, vbc.task.depthMask, histogram01, 2, histRowsCols, vbc.task.redOptions.rangesHSV);
            dst3 = histogram01.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "Hue is on the X-Axis and Value is on the Y-Axis";
            labels[3] = "Hue is on the X-Axis and Saturation is on the Y-Axis";
        }
    }




    public class Hist2D_BGR_CS : VB_Parent
    {
        public Mat histogram01 = new Mat();
        public Mat histogram02 = new Mat();
        public Hist2D_BGR_CS()
        {
            vbc.task.gOptions.setHistogramBins(256);
            desc = "Create a 2D histogram for blue to red and blue to green.";
        }
        public void RunAlg(Mat src)
        {
            int[] histRowsCols = new int[] { dst2.Height, dst2.Width };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 2 }, vbc.task.depthMask, histogram02, 2, histRowsCols, vbc.task.redOptions.rangesBGR);
            dst2 = histogram02.Threshold(0, 255, ThresholdTypes.Binary);
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1 }, vbc.task.depthMask, histogram01, 2, histRowsCols, vbc.task.redOptions.rangesBGR);
            dst3 = histogram01.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "Blue is on the X-Axis and Red is on the Y-Axis";
            labels[3] = "Blue is on the X-Axis and Green is on the Y-Axis";
        }
    }




    public class Hist2D_PlotHistogram1D_CS : VB_Parent
    {
        Mat histogram = new Mat();
        Plot_Histogram plot = new Plot_Histogram();
        public float[] histArray;
        public Hist2D_PlotHistogram1D_CS()
        {
            plot.removeZeroEntry = false;
            labels[2] = "Hist2D_PlotHistogram1D_CS output shown with plot_histogram";
            desc = "Create a 2D histogram for blue to red and blue to green.";
        }
        public void RunAlg(Mat src)
        {
            Cv2.CalcHist(new Mat[] { src }, vbc.task.redOptions.channels, vbc.task.depthMask, histogram, 2, new int[] { vbc.task.histogramBins, vbc.task.histogramBins },
                          vbc.task.redOptions.rangesBGR);
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary);
            plot.Run(histogram);
            dst3 = plot.dst2;
            // histArray = new float[histogram.Total()];
            // Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
        }
    }




    public class Hist3D_Basics_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Hist3Dcloud_Basics hCloud = new Hist3Dcloud_Basics();
        public int classCount;
        Options_Hist3D options = new Options_Hist3D();
        public Hist3D_Basics_CS()
        {
            labels = new string[] { "", "", "Sum of 8UC1 outputs of Hist3Dcolor_Basics and Hist3Dcloud_basics", "" };
            desc = "Build an 8UC1 image by adding Hist3Dcolor_Basics and Hist3Dcloud_Basics output";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            hColor.Run(src);
            dst2 = hColor.dst2;
            hCloud.Run(src);
            hCloud.dst2 += cv.Scalar.All(hColor.classCount + 1);
            hCloud.dst2.SetTo(0, vbc.task.noDepthMask);
            if (options.addCloud)
                dst2 += hCloud.dst2;
            else
                hCloud.dst2.CopyTo(dst2, vbc.task.depthMask);
            classCount = hColor.classCount + hCloud.classCount;
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[3] = classCount.ToString() + " classes ";
        }
    }






    public class Hist3D_BuildHistogram_CS : VB_Parent
    {
        public int threshold;
        public int classCount;
        public float[] histArray;
        Hist_Depth plot = new Hist_Depth();
        public Hist3D_BuildHistogram_CS()
        {
            desc = "Build a guided 3D histogram from the 3D histogram supplied in src.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                vbc.task.gOptions.setHistogramBins(100);
                plot.Run(src);
                src = plot.histogram;
            }
            histArray = new float[src.Total() - 1];
            Marshal.Copy(src.Data, histArray, 0, histArray.Length);
            classCount = 1;
            int index = 0;
            for (int i = index; i < histArray.Length; i++)
            {
                for (; index < histArray.Length; index++)
                {
                    if (histArray[index] > threshold) break;
                    histArray[index] = classCount;
                }
                classCount++;
                for (; index < histArray.Length; index++)
                {
                    if (histArray[index] <= threshold) break;
                    histArray[index] = classCount;
                }
                if (index >= histArray.Length) break;
            }
            int minClass = (int)(histArray.Min() - 1);
            if (minClass != 0)
            {
                src -= cv.Scalar.All(minClass);
                for (int i = 0; i < histArray.Length; i++)
                {
                    histArray[i] -= minClass;
                }
                classCount -= minClass;
            }
            dst2 = src.Clone();
            Marshal.Copy(histArray, 0, dst2.Data, histArray.Length);
            labels[2] = "Histogram entries vary from " + histArray.Min() + " to " + classCount + " inclusive";
        }
    }




    public class Hist3D_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Hist3D_Basics hist3D = new Hist3D_Basics();
        public Hist3D_RedCloud_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Run RedCloud_Basics on the combined Hist3D color/cloud output.";
        }
        public void RunAlg(Mat src)
        {
            hist3D.Run(src);
            dst2 = hist3D.dst3;
            labels[2] = hist3D.labels[3];
            redC.Run(hist3D.dst2);
            dst3 = redC.dst2;
            labels[3] = redC.labels[2];
        }
    }




    public class Hist3D_RedColor_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public Hist3D_RedColor_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Use the Hist3D color classes to segment the image with RedCloud_Basics";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            dst3 = hColor.dst3;
            labels[3] = hColor.labels[3];
            redC.Run(hColor.dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
            if (vbc.task.redCells.Count > 0)
            {
                dst2[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
            }
        }
    }




    public class Hist3D_DepthWithMask_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public Mat depthMask = new Mat();
        Foreground_KMeans fore = new Foreground_KMeans();
        public Hist3D_DepthWithMask_CS()
        {
            desc = "Isolate the foreground and no depth in the image and run it through Hist3D_Basics";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                fore.Run(src);
                depthMask = fore.dst2 | vbc.task.noDepthMask;
            }
            hColor.inputMask = depthMask;
            dst0 = ~depthMask;
            src.SetTo(0, dst0);
            hColor.Run(src);
            dst2 = hColor.dst2;
            dst2.SetTo(0, dst0);
            dst3 = hColor.dst3;
            dst3.SetTo(0, dst0);
            labels = hColor.labels;
        }
    }




    public class Hist3D_Pixel_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public float[] histArray;
        public int classCount;
        public Hist3D_Pixel_CS()
        {
            desc = "Classify each pixel using a 3D histogram backprojection.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 3) src = vbc.task.color;
            var bins = vbc.task.redOptions.getHistBinBar3D();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, new Mat(), histogram, 3, new int[] { bins, bins, bins }, vbc.task.redOptions.rangesBGR);
            histArray = new float[histogram.Total() - 1];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            for (int i = 0; i < histArray.Length; i++)
            {
                histArray[i] = i + 1;
            }
            classCount = vbc.task.redOptions.histBins3D;
            Marshal.Copy(histArray, 0, histogram.Data, histArray.Length);
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, vbc.task.redOptions.rangesBGR);
            dst3 = classCount < 256 ? ShowPalette(dst2 * 255 / classCount) : ShowPalette(dst2);
        }
    }




    public class Hist3D_PixelCells_CS : VB_Parent
    {
        Hist3D_Pixel pixel = new Hist3D_Pixel();
        Flood_Basics redC = new Flood_Basics();
        public Hist3D_PixelCells_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Cell-by-cell backprojection of the Hist3D_Pixel algorithm", "Palette version of dst2" };
            desc = "After classifying each pixel, backproject each redCell using the same 3D histogram.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            pixel.Run(src);
            foreach (var cell in vbc.task.redCells)
            {
                Cv2.CalcBackProject(new Mat[] { src[cell.rect] }, new int[] { 0, 1, 2 }, pixel.histogram, dst2[cell.rect], vbc.task.redOptions.rangesBGR);
            }
            dst3 = ShowPalette(dst2 * 255 / vbc.task.redOptions.histBins3D);
        }
    }




    public class Hist3D_PixelClassify_CS : VB_Parent
    {
        Hist3D_Pixel pixel = new Hist3D_Pixel();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Hist3D_PixelClassify_CS()
        {
            desc = "Classify each pixel with a 3D histogram backprojection and run RedCloud_Basics on the output.";
        }
        public void RunAlg(Mat src)
        {
            pixel.Run(src);
            redC.Run(pixel.dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            if (vbc.task.redCells.Count > 0)
            {
                dst2[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
            }
        }
    }




    public class Hist3D_PixelDiffMask_CS : VB_Parent
    {
        Hist3D_Pixel pixel = new Hist3D_Pixel();
        RedCloud_Basics redC = new RedCloud_Basics();
        Mat lastImage = new cv.Mat();
        public Hist3D_PixelDiffMask_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Build better image segmentation - remove unstable pixels from 3D color histogram backprojection";
        }
        public void RunAlg(Mat src)
        {
            pixel.Run(src);
            if (vbc.task.FirstPass) lastImage = pixel.dst2.Clone();
            Cv2.Absdiff(lastImage, pixel.dst2, dst3);
            dst2 = dst3.Threshold(0, 255, ThresholdTypes.Binary);
            lastImage = pixel.dst2.Clone();
        }
    }




    public class Hist3D_RedCloudGrid_CS : VB_Parent
    {
        Pixel_Vectors pixels = new Pixel_Vectors();
        Hist3Dcolor_Vector hVector = new Hist3Dcolor_Vector();
        public Hist3D_RedCloudGrid_CS()
        {
            vbc.task.gOptions.setGridSize(8);
            desc = "Build RedCloud pixel vectors and then measure each grid element's distance to those vectors.";
        }
        double distanceN(List<float> vec1, List<float> vec2)
        {
            double accum = 0;
            for (int i = 0; i < vec1.Count; i++)
            {
                accum += (vec1[i] - vec2[i]) * (vec1[i] - vec2[i]);
            }
            return Math.Sqrt(accum);
        }
        double distanceN(float[] vec1, float[] vec2)
        {
            double accum = 0;
            for (int i = 0; i < vec1.Length; i++)
            {
                accum += (vec1[i] - vec2[i]) * (vec1[i] - vec2[i]);
            }
            return Math.Sqrt(accum);
        }
        public void RunAlg(Mat src)
        {
            pixels.Run(src);
            dst2 = vbc.task.cellMap;
            dst3 = dst2.InRange(0, 0);
            if (pixels.pixelVector.Count == 0) return;
            dst1.SetTo(0);
            dst0 = vbc.task.cellMap;
            foreach (var roi in vbc.task.gridRects)
            {
                if (dst3[roi].CountNonZero() > 0)
                {
                    var candidates = new List<int>();
                    for (int y = 0; y < roi.Height; y++)
                    {
                        for (int x = 0; x < roi.Width; x++)
                        {
                            var val = dst0[roi].Get<byte>(y, x);
                            if (val == 0) continue;
                            if (!candidates.Contains(val)) candidates.Add(val);
                        }
                    }
                    if (candidates.Count > 1)
                    {
                        hVector.inputMask = dst3[roi];
                        hVector.Run(src[roi]);
                        var distances = new List<double>();
                        foreach (var index in candidates)
                        {
                            var vec = pixels.pixelVector[index - 1];
                            distances.Add(distanceN(vec, hVector.histArray));
                        }
                        var cell = pixels.redCells[candidates[distances.IndexOf(distances.Min())] - 1];
                        dst1[roi].SetTo(cell.color, dst3[roi]);
                    }
                    else if (candidates.Count == 1)
                    {
                        var cell = pixels.redCells[candidates[0] - 1];
                        dst1[roi].SetTo(cell.color, dst3[roi]);
                    }
                }
            }
        }
    }




    public class Hist3Dcloud_Basics_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Mat histogram1D = new Mat();
        public float[] histArray;
        public int classCount;
        public Mat maskInput = new Mat();
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public Hist3Dcloud_Basics_CS()
        {
            labels[2] = "dst2 = backprojection of pointcloud (8UC1 format).";
            desc = "Build a 3D histogram from the pointcloud and backproject it to segment the image.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            int bins = vbc.task.redOptions.getHistBinBar3D();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, maskInput, histogram, 3, new int[] { bins, bins, bins }, vbc.task.redOptions.rangesCloud);
            histArray = new float[vbc.task.redOptions.histBins3D];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            double threshold = src.Total() * 0.001;
            for (int i = 0; i < histArray.Length; i++)
            {
                if (histArray[i] > threshold) break;
                histArray[i] = 0;
            }
            histogram = cv.Mat.FromPixelData(histArray.Length, 1, MatType.CV_32F, histArray);
            simK.Run(histogram);
            histogram = cv.Mat.FromPixelData(histArray.Length, 1, MatType.CV_32F, simK.histArray);
            classCount = simK.classCount;
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 2 }, histogram, dst2, new Rangef[] { vbc.task.redOptions.rangesCloud[vbc.task.redOptions.rangesCloud.Count() - 1] });
            dst2 = dst2.ConvertScaleAbs();
            dst2.SetTo(0, vbc.task.noDepthMask);
            //dst2.SetTo(classCount, vbc.task.maxDepthMask);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = simK.labels[2] + " with " + vbc.task.redOptions.getHistBins3D().ToString() + " histogram bins";
            labels[3] = "LastClassCount/classCount = " + classCount.ToString() + "/" + classCount.ToString();
        }
    }




    public class Hist3Dcloud_DepthSplit_CS : VB_Parent
    {
        List<Hist_Kalman> hist;
        List<Hist2D_Cloud> hist2d;
        Mat_4Click mats1 = new Mat_4Click();
        Mat_4Click mats2 = new Mat_4Click();
        public Hist3Dcloud_DepthSplit_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            hist = new List<Hist_Kalman> { new Hist_Kalman(), new Hist_Kalman(), new Hist_Kalman() };
            hist2d = new List<Hist2D_Cloud> { new Hist2D_Cloud(), new Hist2D_Cloud(), new Hist2D_Cloud() };
            labels[2] = "Histograms (Kalman) for X (upper left), Y (upper right) and Z.  UseZeroDepth removes 0 (no depth) entries.";
            labels[3] = "X to Y histogram (upper left), X to Z (upper right), and Y to Z (bottom).";
            desc = "Plot the 3 histograms of the depth data dimensions";
        }
        public void RunAlg(Mat src)
        {
            for (int i = 0; i < 3; i++)
            {
                hist[i].Run(vbc.task.pcSplit[i]);
                mats1.mat[i] = hist[i].dst2.Clone();
                if (i == 0) vbc.task.redOptions.channels = new int[] { 0, 1 };
                if (i == 1) vbc.task.redOptions.channels = new int[] { 0, 2 };
                if (i == 2) vbc.task.redOptions.channels = new int[] { 1, 2 };
                hist2d[i].Run(vbc.task.pointCloud);
                mats2.mat[i] = hist2d[i].histogram.ConvertScaleAbs();
            }
            mats1.Run(empty);
            dst2 = mats1.dst2;
            dst3 = mats1.mat[mats1.quadrant];
            mats2.Run(empty);
            dst1 = mats2.dst2;
        }
    }




    public class Hist3Dcloud_Highlights_CPP_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Rangef[] ranges;
        int maskval;
        public Hist3Dcloud_Highlights_CPP_CS()
        {
            desc = "Plot the 3D histogram of the depth data";
        }
        public void RunAlg(Mat src)
        {
            int bins = vbc.task.redOptions.getHistBinBar3D();
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            byte[] histInput = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, histInput, 0, histInput.Length);
            Vec2f rx = new Vec2f(-vbc.task.xRangeDefault, vbc.task.xRangeDefault);
            Vec2f ry = new Vec2f(-vbc.task.yRangeDefault, vbc.task.yRangeDefault);
            Vec2f rz = new Vec2f(0, vbc.task.MaxZmeters);
            GCHandle handleInput = GCHandle.Alloc(histInput, GCHandleType.Pinned);
            IntPtr dstPtr = Hist3Dcloud_Run(handleInput.AddrOfPinnedObject(), src.Rows, src.Cols, bins,
                                             rx[0], ry[0], rz[0], rx[1], ry[1], rz[1]);
            handleInput.Free();
            histogram = cv.Mat.FromPixelData(vbc.task.redOptions.histBins3D, 1, MatType.CV_32F, dstPtr);
            ranges = new Rangef[] { new Rangef(rx[0], rx[1]), new Rangef(ry[0], ry[1]), new Rangef(rz[0], rz[1]) };
            float[] samples = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, samples, 0, samples.Length);
            SortedList<float, int> sortedHist = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
            for (int i = 0; i < samples.Length; i++)
            {
                sortedHist.Add(samples[i], i);
            }
            for (int i = 0; i < sortedHist.Count; i++)
            {
                var key = sortedHist.ElementAt(i);
                int val = key.Value;
                samples[val] = i + 1;
            }
            Marshal.Copy(samples, 0, histogram.Data, samples.Length);
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, ranges);
            if (vbc.task.heartBeat) maskval += 1;
            if (sortedHist.ElementAt(maskval).Key == 0) maskval = 0;
            int index = sortedHist.ElementAt(maskval).Value;
            dst3 = dst2.InRange(index, index);
            labels[3] = "There were " + sortedHist.ElementAt(maskval).Key + " samples in bin " + index;
        }
    }




    public class Hist3Dcloud_BP_Filter_CPP_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        Options_HistXD options = new Options_HistXD();
        public Hist3Dcloud_BP_Filter_CPP_CS()
        {
            vbc.task.redOptions.setHistBinBar3D(16);
            dst3 = new Mat(dst3.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            labels[2] = "Mask of the pointcloud image after backprojection that removes 'blowback' pixels";
            desc = "Backproject a 3D pointcloud histogram after thresholding the bins with the small samples.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int bins = vbc.task.redOptions.getHistBinBar3D();
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            float[] histInput = new float[src.Total() * 3];
            Marshal.Copy(src.Data, histInput, 0, histInput.Length);
            Vec2f rx = new Vec2f(-vbc.task.xRangeDefault, vbc.task.xRangeDefault);
            Vec2f ry = new Vec2f(-vbc.task.yRangeDefault, vbc.task.yRangeDefault);
            Vec2f rz = new Vec2f(0, vbc.task.MaxZmeters);
            GCHandle handleInput = GCHandle.Alloc(histInput, GCHandleType.Pinned);
            IntPtr imagePtr = BackProjectCloud_Run(handleInput.AddrOfPinnedObject(), src.Rows, src.Cols, bins, options.threshold3D,
                                             rx[0], ry[0], rz[0], rx[1], ry[1], rz[1]);
            handleInput.Free();
            dst2 = cv.Mat.FromPixelData(dst2.Height, dst2.Width, MatType.CV_8U, imagePtr);
            dst2.SetTo(0, vbc.task.noDepthMask);
            dst3.SetTo(0);
            vbc.task.pointCloud.CopyTo(dst3, dst2);
        }
    }




    public class Hist3Dcloud_PlotHist1D_CS : VB_Parent
    {
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        public Mat histogram;
        public float[] histArray;
        Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public Hist3Dcloud_PlotHist1D_CS()
        {
            plot.removeZeroEntry = false;
            labels[2] = "The 3D histogram of the pointcloud data stream - note the number of gaps";
            desc = "Present the 3D histogram as a typical histogram bar chart.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            hcloud.Run(src);
            histArray = new float[hcloud.histogram.Total()];
            Marshal.Copy(hcloud.histogram.Data, histArray, 0, histArray.Length);
            histogram = cv.Mat.FromPixelData(histArray.Length, 1, MatType.CV_32F, histArray);
            plot.Run(histogram);
            dst2 = plot.dst2;
            simK.Run(histogram);
            labels[3] = simK.labels[2];
        }
    }




    public class Hist3Dcolor_Basics_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Mat histogram1D = new Mat();
        public int classCount;
        public Mat inputMask = new Mat();
        public float[] histArray;
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public bool alwaysRun;
        public Hist3Dcolor_Basics_CS()
        {
            desc = "Capture a 3D color histogram, find the gaps, and backproject the clusters found.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_8UC3) src = vbc.task.color;
            if (vbc.task.heartBeat || alwaysRun)
            {
                int bins = vbc.task.redOptions.getHistBinBar3D();
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, inputMask, histogram, 3, new int[] { bins, bins, bins }, vbc.task.redOptions.rangesBGR);
                histArray = new float[histogram.Total()];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                histogram1D = cv.Mat.FromPixelData((int)histogram.Total(), 1, MatType.CV_32F, histogram.Data);
                simK.Run(histogram1D);
                histogram = simK.dst2;
                classCount = simK.classCount;
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, vbc.task.redOptions.rangesBGR);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = simK.labels[2];
            labels[3] = "Backprojection of " + classCount.ToString() + " histogram entries.";
        }
    }




    public class Hist3Dcolor_UniqueRGBPixels_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public List<cv.Point3f> pixels = new List<cv.Point3f>();
        public List<int> counts = new List<int>();
        public Hist3Dcolor_UniqueRGBPixels_CS()
        {
            desc = "Get the number of non-zero BGR elements in the 3D color histogram of the current image and their BGR values";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            pixels.Clear();
            counts.Clear();
            int bins = vbc.task.redOptions.getHistBinBar3D();
            for (int z = 0; z < bins; z++)
            {
                for (int y = 0; y < bins; y++)
                {
                    for (int x = 0; x < bins; x++)
                    {
                        float val = hColor.histArray[x * bins * bins + y * bins + z];
                        if (val > 0)
                        {
                            pixels.Add(new Point3f((float)(255 * x / bins), (float)(255 * y / bins), (float)(255 * z / bins)));
                            counts.Add((int)val);
                        }
                    }
                }
            }
            SetTrueText("There are " + pixels.Count.ToString() + " non-zero entries in the 3D histogram " + "\n" + "See uniquePixels list in Hist3Dcolor_UniquePixels", 2);
        }
    }




    public class Hist3Dcolor_TopXColors_CS : VB_Parent
    {
        Hist3Dcolor_UniqueRGBPixels unique = new Hist3Dcolor_UniqueRGBPixels();
        public List<cv.Point3i> topXPixels = new List<cv.Point3i>();
        public int mapTopX = 16;
        public Hist3Dcolor_TopXColors_CS()
        {
            desc = "Get the top 256 of non-zero BGR elements in the 3D color histogram of the current image and their BGR values";
        }
        public void RunAlg(Mat src)
        {
            unique.Run(src);
            var sortedPixels = new SortedList<int, Point3f>(new CompareAllowIdenticalIntegerInverted());
            for (int i = 0; i < unique.pixels.Count; i++)
            {
                sortedPixels.Add(unique.counts[i], unique.pixels[i]);
            }
            topXPixels.Clear();
            for (int i = 0; i < sortedPixels.Count; i++)
            {
                topXPixels.Add(sortedPixels.ElementAt(i).Value.ToPoint3i());
                if (topXPixels.Count >= mapTopX) break;
            }
            SetTrueText("There are " + sortedPixels.Count.ToString() + " non-zero entries in the 3D histogram " + "\n" + "The top " + mapTopX.ToString() + " pixels are in topXPixels", 2);
        }
    }




    public class Hist3Dcolor_Reduction_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Reduction_BGR reduction = new Reduction_BGR();
        public int classCount;
        public Hist3Dcolor_Reduction_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.redOptions.setSimpleReductionBar(45);
            desc = "Backproject the 3D histogram for RGB after reduction";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 3) src = vbc.task.color;
            reduction.Run(src);
            hColor.Run(reduction.dst2);
            dst1 = reduction.dst2;
            dst2 = hColor.dst2;
            dst3 = hColor.dst3;
            labels[2] = hColor.labels[2];
        }
    }




    public class Hist3Dcolor_ZeroGroups_CS : VB_Parent
    {
        public Mat maskInput = new Mat();
        public int classCount;
        public Mat histogram = new Mat();
        public Hist3Dcolor_ZeroGroups_CS()
        {
            desc = "Breakdown the 3D histogram using the '0' entries as boundaries between clusters.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 3) src = vbc.task.color;
            if (vbc.task.optionsChanged)
            {
                int bins = vbc.task.redOptions.getHistBinBar3D();
                int[] hBins = { bins, bins, bins };
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, maskInput, histogram, 3, hBins, vbc.task.redOptions.rangesBGR);
                float[] histArray = new float[histogram.Total()];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                List<int> boundaries = new List<int>();
                bool zeroMode = false;
                for (int i = 0; i < histArray.Length; i++)
                {
                    if (histArray[i] == 0 && !zeroMode)
                    {
                        boundaries.Add(i);
                        zeroMode = true;
                    }
                    if (histArray[i] != 0) zeroMode = false;
                }
                int lastIndex = 0;
                classCount = 1;
                foreach (int index in boundaries)
                {
                    for (int i = lastIndex; i <= index; i++)
                    {
                        histArray[i] = classCount;
                    }
                    lastIndex = index + 1;
                    classCount++;
                }
                for (int i = lastIndex; i < histArray.Length; i++)
                {
                    histArray[i] = classCount;
                }
                classCount++;
                Marshal.Copy(histArray, 0, histogram.Data, histArray.Length);
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, vbc.task.redOptions.rangesBGR);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = "Hist3Dcolor_ZeroGroups_CS classCount = " + classCount.ToString();
        }
    }




    public class Hist3Dcolor_PlotHist1D_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        public Mat histogram1D;
        public Mat histogram;
        public float[] histArray;
        public Hist3Dcolor_PlotHist1D_CS()
        {
            hColor.alwaysRun = true;
            plot.removeZeroEntry = false;
            labels[2] = "The 3D histogram of the RGB image stream - note the number of gaps";
            desc = "Present the 3D histogram as a typical histogram bar chart.";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            histogram1D = hColor.histogram1D;
            histArray = hColor.histArray;
            plot.Run(hColor.histogram1D);
            dst2 = plot.dst2;
        }
    }




    public class Hist3Dcolor_Select_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public Hist3Dcolor_Select_CS()
        {
            labels[3] = "The highlighted pixels are in the selected bin";
            desc = "Build a 3D histogram from the BGR image and backproject the 'Selected bin' (in options_HistXD sliders).";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            int selection = vbc.task.gOptions.DebugSliderValue;
            dst2 = hColor.dst2.InRange(selection, selection);
            int saveCount = dst2.CountNonZero();
            dst3 = src.Clone();
            dst3.SetTo(Scalar.White, dst2);
            labels[2] = saveCount.ToString() + " pixels were found in bin " + selection.ToString();
        }
    }




    public class Hist3Dcolor_Basics_CPP_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public bool prepareImage = true;
        public Mat histogram1D = new Mat();
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public int classCount;
        public Hist3Dcolor_Basics_CPP_CS()
        {
            desc = "Build a 3D histogram from the BGR image and sort it by histogram entry size.";
        }
        public void RunAlg(Mat src)
        {
            byte[] histInput = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, histInput, 0, histInput.Length);
            GCHandle handleInput = GCHandle.Alloc(histInput, GCHandleType.Pinned);
            int bins = vbc.task.redOptions.getHistBinBar3D();
            IntPtr imagePtr = Hist3Dcolor_Run(handleInput.AddrOfPinnedObject(), src.Rows, src.Cols, bins);
            handleInput.Free();
            histogram = cv.Mat.FromPixelData(vbc.task.redOptions.histBins3D, 1, MatType.CV_32F, imagePtr);
            if (prepareImage)
            {
                float[] histArray = new float[histogram.Total()];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                histogram1D = cv.Mat.FromPixelData(histArray.Length, 1, MatType.CV_32F, histArray);
                simK.Run(histogram);
                histogram = simK.dst2;
                classCount = simK.classCount;
                Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, vbc.task.redOptions.rangesBGR);
                mmData mm = GetMinMax(dst2);
                dst3 = ShowPalette(dst2 * 255 / mm.maxVal);
                labels[2] = simK.labels[2];
                labels[3] = mm.maxVal.ToString() + " different levels in the backprojection.";
            }
        }
    }




    public class Hist3Dcolor_Diff_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Diff_Basics diff = new Diff_Basics();
        public Hist3Dcolor_Diff_CS()
        {
            vbc.task.gOptions.pixelDiffThreshold = 0;
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Create a mask for the color pixels that are changing with every frame of the Hist3Dcolor_basics.";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            dst2 = hColor.dst3;
            labels[2] = hColor.labels[3];
            diff.Run(hColor.dst2);
            if (vbc.task.heartBeat) dst3.SetTo(0);
            dst3 = dst3 | diff.dst2;
        }
    }




    public class Hist3Dcolor_Vector_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Mat inputMask = new Mat();
        public float[] histArray;
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        int[] binArray;
        public Hist3Dcolor_Vector_CS()
        {
            int bins = vbc.task.redOptions.getHistBinBar3D();
            binArray = new int[] { bins, bins, bins };
            UpdateAdvice(traceName + ": redOptions '3D Histogram Bins'");
            desc = "Capture a 3D color histogram for input src - likely to be src(rect).";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 3) src = vbc.task.color;
            if (vbc.task.optionsChanged)
            {
                int bins = vbc.task.redOptions.getHistBinBar3D();
                binArray = new int[] { bins, bins, bins };
            }
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, inputMask, histogram, 3, binArray, vbc.task.redOptions.rangesBGR);
            histArray = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            if (standaloneTest()) SetTrueText("Vector prepared in histArray");
        }
    }




    public class History_Basics_CS : VB_Parent
    {
        public List<Mat> saveFrames = new List<Mat>();
        public History_Basics_CS()
        {
            desc = "Create a frame history to sum the last X frames";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.frameHistoryCount == 1)
            {
                dst2 = src;
                return;
            }
            if (src.Type() != MatType.CV_32F)
                src.ConvertTo(src, MatType.CV_32F);
            if (dst1.Type() != src.Type() || dst1.Channels() != src.Channels() || vbc.task.optionsChanged)
            {
                dst1 = src;
                saveFrames.Clear();
            }
            if (saveFrames.Count >= vbc.task.frameHistoryCount)
                saveFrames.RemoveAt(0);
            saveFrames.Add(src.Clone());
            foreach (var m in saveFrames)
            {
                dst1 += m;
            }
            dst1 *= 1.0 / (saveFrames.Count + 1);
            if (src.Channels() == 1)
            {
                dst1.ConvertTo(dst2, MatType.CV_8U);
            }
            else
            {
                dst1.ConvertTo(dst2, MatType.CV_8UC3);
            }
        }
    }




    public class History_MotionRect_CS : VB_Parent
    {
        public History_MotionRect_CS()
        {
            desc = "Create an image that is the motionRect applied to the previous image.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
                dst2 = src.Clone();
            if (vbc.task.motionDetected)
            {
                src[vbc.task.motionRect].CopyTo(dst2[vbc.task.motionRect]);
            }
        }
    }




    public class History_Cloud_CS : VB_Parent
    {
        public History_BasicsNoSaturation frames = new History_BasicsNoSaturation();
        List<Mat> saveFrames = new List<Mat>();
        public History_Cloud_CS()
        {
            desc = "Create a frame history and sum the last X vbc.task.pointcloud's";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3 || src.Channels() != 3)
                src = vbc.task.pointCloud;
            if (vbc.task.optionsChanged || dst3.Type() != MatType.CV_32FC3)
            {
                saveFrames.Clear();
                dst3 = new Mat(dst2.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            }
            if (saveFrames.Count >= vbc.task.frameHistoryCount)
            {
                dst3 = dst3.Subtract(saveFrames[0]);
                saveFrames.RemoveAt(0);
            }
            saveFrames.Add(src.Clone());
            dst3 = src + dst3;
            dst2 = dst3 / saveFrames.Count;
            frames.Run(vbc.task.depthMask);
            dst2.SetTo(0, ~frames.dst2);
        }
    }




    public class History_BasicsNoSaturation_CS : VB_Parent
    {
        public List<Mat> saveFrames = new List<Mat>();
        public History_BasicsNoSaturation_CS()
        {
            desc = "Create a frame history and sum the last X frames (without saturation!)";
        }
        public void RunAlg(Mat src)
        {
            var input = src.Clone();
            if (input.Channels() != 1)
                input = input.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (input.Type() != MatType.CV_32F)
                input.ConvertTo(input, MatType.CV_32F);
            if (dst3.Type() != input.Type() || dst3.Channels() != input.Channels())
                dst3 = new Mat(input.Size(), input.Type(), cv.Scalar.All(0));
            input /= 255; // input is all zeros or ones.
            if (vbc.task.optionsChanged)
            {
                saveFrames.Clear();
                dst3.SetTo(0);
            }
            if (saveFrames.Count >= vbc.task.frameHistoryCount)
            {
                dst3 = dst3.Subtract(saveFrames[0]);
                saveFrames.RemoveAt(0);
            }
            saveFrames.Add(input);
            dst3 += input;
            dst1 = 255 * dst3 / saveFrames.Count;
            dst1.ConvertTo(dst2, MatType.CV_8U);
        }
    }




    public class History_BasicsDiff_CS : VB_Parent
    {
        History_BasicsNoSaturation frames = new History_BasicsNoSaturation();
        Diff_Basics diff = new Diff_Basics();
        public History_BasicsDiff_CS()
        {
            vbc.task.gOptions.pixelDiffThreshold = 0;
            desc = "Find the floodfill trouble spots.";
        }
        public void RunAlg(Mat src)
        {
            frames.Run(src);
            dst2 = ShowPalette(frames.dst2);
            diff.Run(frames.dst2);
            dst3 = diff.dst2;
        }
    }




    public class HistPeak2D_Basics_CS : VB_Parent
    {
        public OpAuto_Peaks2DGrid auto = new OpAuto_Peaks2DGrid();
        Hist2D_BGR bgr = new Hist2D_BGR();
        Delaunay_ConsistentColor delaunay = new Delaunay_ConsistentColor();
        public Mat histogram = new Mat();
        public Rangef[] ranges;
        public HistPeak2D_Basics_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Find the top X peaks in a 2D histogram and use Delaunay to setup the backprojection";
        }
        public void RunAlg(Mat src)
        {
            // if standaloneTest(), go get a histogram for input.  Src is the 3-channel input to the histogram.
            if (standaloneTest())
            {
                bgr.Run(src);
                histogram = bgr.histogram02;
            }
            if (vbc.task.heartBeat)
            {
                auto.Run(histogram);
                delaunay.inputPoints = new List<cv.Point2f>(auto.clusterPoints);
                delaunay.Run(src);
                dst1 = auto.dst2;
                dst3 = delaunay.dst2;
            }
            var mask = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            delaunay.dst1.ConvertTo(histogram, MatType.CV_32F);
            histogram.SetTo(0, ~mask);
            if (ranges == null || vbc.task.optionsChanged)
            {
                ranges = GetHist2Dminmax(src, vbc.task.redOptions.channels[0], vbc.task.redOptions.channels[1]);
            }
            var backProjection = new Mat();
            Cv2.CalcBackProject(new Mat[] { src }, vbc.task.redOptions.channels, histogram, backProjection, ranges);
            dst2 = ShowPalette(backProjection * 255 / delaunay.inputPoints.Count);
        }
    }




    public class HistPeak2D_TopAndSide_CS : VB_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistSide histSide = new Projection_HistSide();
        Projection_HistTop histTop = new Projection_HistTop();
        public HistPeak2D_TopAndSide_CS()
        {
            desc = "Find the top X peaks in the 2D histogram of the top and side views and backproject them.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.toggleOnOff)
            {
                histSide.Run(src);
                peak.ranges = vbc.task.rangesSide;
                vbc.task.redOptions.channels = vbc.task.channelsSide;
                peak.histogram = histSide.histogram;
            }
            else
            {
                histTop.Run(src);
                vbc.task.redOptions.channels = vbc.task.channelsTop;
                peak.ranges = vbc.task.rangesTop;
                peak.histogram = histTop.histogram;
            }
            peak.Run(vbc.task.pointCloud);
            dst1 = peak.dst2;
            dst2 = ShowPalette(dst1);
        }
    }




    public class HistPeak2D_NotHotTop_CS : VB_Parent
    {
        public Projection_HistTop histTop = new Projection_HistTop();
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        public HistPeak2D_NotHotTop_CS()
        {
            desc = "Find the regions with the non-zero (low) samples in the top view";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            dst1 = histTop.histogram.InRange(0, 0).ConvertScaleAbs();
            var mm = GetMinMax(histTop.histogram);
            dst3 = new Mat(dst3.Size(), MatType.CV_32F, cv.Scalar.All(mm.maxVal));
            dst3 -= histTop.histogram;
            dst3.SetTo(0, dst1);
            peak.histogram = histTop.histogram;
            peak.Run(vbc.task.pointCloud);
            dst2 = peak.dst2;
        }
    }




    public class HistPeak2D_Edges_CS : VB_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistTop histTop = new Projection_HistTop();
        Edge_Canny edges = new Edge_Canny();
        public HistPeak2D_Edges_CS()
        {
            desc = "Display the HistPeak2D_Basics edges in the RGB image";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            dst3 = histTop.histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary);
            peak.histogram = histTop.histogram;
            peak.Run(vbc.task.pointCloud);
            dst2 = peak.dst2;
            edges.Run(dst2);
            dst3 = src;
            dst3.SetTo(Scalar.White, edges.dst2);
        }
    }




    public class HistPeak2D_HSV_CS : VB_Parent
    {
        Hist2D_HSV hsv = new Hist2D_HSV();
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        public HistPeak2D_HSV_CS()
        {
            desc = "Find the peaks in the 2D plot of the HSV image";
        }
        public void RunAlg(Mat src)
        {
            hsv.Run(src);
            peak.histogram = hsv.histogram01;
            peak.Run(hsv.dst1);
            dst2 = peak.dst2;
            dst3 = peak.auto.dst2;
            labels[3] = hsv.labels[2];
        }
    }




    public class HistPeak2D_BGR_CS : VB_Parent
    {
        Hist2D_BGR bgr = new Hist2D_BGR();
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        public HistPeak2D_BGR_CS()
        {
            desc = "Find the peaks in the 2D plot of the BGR image";
        }
        public void RunAlg(Mat src)
        {
            bgr.Run(src);
            peak.histogram = bgr.histogram02;
            peak.Run(src);
            dst2 = peak.dst2;
            dst3 = peak.auto.dst2;
            labels[3] = bgr.labels[2];
        }
    }




    public class HistPeak2D_RGB_CS : VB_Parent
    {
        HistPeak2D_BGR peak = new HistPeak2D_BGR();
        public HistPeak2D_RGB_CS()
        {
            desc = "Find the peaks in the 2D plot of the BGR image";
        }
        public void RunAlg(Mat src)
        {
            peak.Run(src);
            dst2 = peak.dst2;
            dst3 = peak.dst3;
            labels[3] = peak.labels[2];
        }
    }




    public class HistPeak2D_HotSide_CS : VB_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistSide histSide = new Projection_HistSide();
        public HistPeak2D_HotSide_CS()
        {
            labels = new string[] { "", "", "Backprojection of Side View hotspots", "Side view with highlighted hot spots" };
            desc = "Find the top X peaks in the 2D histogram of the side view and backproject it.";
        }
        public void RunAlg(Mat src)
        {
            histSide.Run(src);
            dst3 = histSide.histogram;
            for (int i = 0; i < peak.auto.clusterPoints.Count; i++)
            {
                var pt = peak.auto.clusterPoints[i];
                DrawCircle(dst3, pt, vbc.task.DotSize * 3, Scalar.White);
            }
            peak.histogram = histSide.histogram;
            peak.ranges = vbc.task.rangesSide;
            vbc.task.redOptions.channels = vbc.task.channelsSide;
            peak.Run(vbc.task.pointCloud);
            dst2 = peak.dst2;
            dst2.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class HistPeak2D_HotTop_CS : VB_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistTop histTop = new Projection_HistTop();
        public HistPeak2D_HotTop_CS()
        {
            labels = new string[] { "", "", "Backprojection of Top View hotspots", "Top view with highlighted hot spots" };
            desc = "Find the top X peaks in the 2D histogram of the top view and backproject it.";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            dst3 = histTop.histogram;
            for (int i = 0; i < peak.auto.clusterPoints.Count; i++)
            {
                var pt = peak.auto.clusterPoints[i];
                DrawCircle(dst3, pt, vbc.task.DotSize * 3, Scalar.White);
            }
            peak.histogram = histTop.histogram;
            peak.ranges = vbc.task.rangesTop;
            vbc.task.redOptions.channels = vbc.task.channelsTop;
            peak.Run(vbc.task.pointCloud);
            dst2 = peak.dst2;
            dst2.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class HistValley_Basics_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Options_Boundary options = new Options_Boundary();
        public int[] valleys = new int[4]; // grayscale values for low points in the histogram.
        List<float> scaleList = new List<float>();
        public HistValley_Basics_CS()
        {
            vbc.task.frameHistoryCount = 30;
            vbc.task.gOptions.setHistogramBins(256);
            labels[2] = "Histogram of the grayscale image.  White lines mark local minimum above threshold.  Yellow horizontal = histogram mean.";
            desc = "Find the histogram valleys for a grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int vCount = options.desiredBoundaries;
            int minDistance = options.peakDistance;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst2 = hist.dst2;
            var avg = hist.histogram.Mean();
            scaleList.Add((float)(dst2.Height - dst2.Height * avg[0] / hist.plot.mm.maxVal));
            float scale = scaleList.Average();
            SetTrueText("Mean", new cv.Point(5, scale), 3);
            dst2.Line(new cv.Point(0, scale), new cv.Point(dst2.Width, scale), Scalar.Yellow, vbc.task.lineWidth + 1);
            if (scaleList.Count > vbc.task.frameHistoryCount) scaleList.RemoveAt(0);
            var hArray = hist.histArray;
            int quartile = (int)Math.Floor(hArray.Count() / 4.0); // note we really just want quartiles 
            float threshold = (float)avg[0] / 2;
            Array.Clear(valleys, 0, valleys.Length);
            for (int i = 0; i < valleys.Length; i++)
            {
                valleys[i] = quartile * i;
                float minVal = (float)avg[0];
                for (int j = quartile * i; j < quartile * (i + 1); j++)
                {
                    float nextVal = hArray[j];
                    if (nextVal < minVal && nextVal > threshold && (j - valleys[i]) >= minDistance)
                    {
                        valleys[i] = j;
                        minVal = nextVal;
                    }
                }
            }
            float wPlot = (float)dst2.Width / vbc.task.histogramBins;
            for (int i = 0; i < valleys.Length; i++)
            {
                float col = valleys[i] * wPlot;
                dst2.Line(new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, vbc.task.lineWidth + 1);
            }
        }
    }




    public class HistValley_FromPeaks_CS : VB_Parent
    {
        public HistValley_Peaks peak = new HistValley_Peaks();
        public List<int> peaks = new List<int>();
        public List<int> valleyIndex = new List<int>();
        public float[] avgValley;
        public List<float> histList = new List<float>();
        public HistValley_FromPeaks_CS()
        {
            FindSlider("Desired boundary count").Value = 10;
            desc = "Use the peaks identified in HistValley_Peaks to find the valleys between the peaks.";
        }
        public void updatePlot(cv.Mat dst, int bins)
        {
            foreach (var valley in valleyIndex)
            {
                float col = dst.Width * valley / bins;
                dst.Line(new cv.Point(col, dst.Height), new cv.Point(col, dst.Height * 9 / 10), Scalar.White, vbc.task.lineWidth);
            }
        }
        public void RunAlg(Mat src)
        {
            peak.Run(src);
            dst2 = peak.hist.dst2;
            histList = peak.histArray.ToList();
            peaks = new List<int>(peak.peaks);
            valleyIndex.Clear();
            for (int i = 0; i < peaks.Count - 1; i++)
            {
                int start = peaks[i];
                int finish = peaks[i + 1];
                List<float> testList = new List<float>();
                for (int j = start; j <= finish; j++)
                {
                    testList.Add(histList[j]);
                }
                valleyIndex.Add(start + testList.IndexOf(testList.Min()));
            }
            if (vbc.task.optionsChanged) avgValley = new float[valleyIndex.Count];
            float depthPerBin = vbc.task.MaxZmeters / histList.Count;
            for (int i = 0; i < avgValley.Length; i++)
            {
                avgValley[i] = (avgValley[i] + valleyIndex[i] * depthPerBin) / 2;
            }
            if (standaloneTest())
            {
                updatePlot(dst2, vbc.task.histogramBins);
                SetTrueText("Input data used by default is the depth data", 3);
            }
            labels[2] = peak.labels[2] + " and " + valleyIndex.Count.ToString() + " valleys (marked at bottom)";
        }
    }




    public class HistValley_Peaks_CS : VB_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public Options_Boundary options = new Options_Boundary();
        public List<int> peaks = new List<int>();
        public float[] histArray;
        public HistValley_Peaks_CS()
        {
            vbc.task.gOptions.setHistogramBins(100);
            FindSlider("Desired boundary count").Value = 5;
            labels[2] = "Histogram - white lines are peaks";
            desc = "Find the requested number of peaks in the histogram ";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int desiredBoundaries = options.desiredBoundaries;
            if (src.Type() != MatType.CV_32FC1 || standaloneTest())
            {
                src = vbc.task.pcSplit[2];
                hist.Run(src);
                dst2 = hist.dst2;
                histArray = new float[hist.histogram.Rows];
                Marshal.Copy(hist.histogram.Data, histArray, 0, histArray.Length);
            }
            else
            {
                histArray = new float[src.Rows];
                Marshal.Copy(src.Data, histArray, 0, histArray.Length);
            }
            var histList = histArray.ToList();
            var sortPeaks = new SortedList<int, int>(new compareAllowIdenticalInteger());
            for (int i = 0; i < histList.Count; i++)
            {
                if (histList[i] != 0)
                {
                    sortPeaks.Add(i, i);
                    break;
                }
            }
            for (int i = histList.Count - 1; i >= 0; i--)
            {
                if (histList[i] != 0)
                {
                    sortPeaks.Add(i, i);
                    break;
                }
            }
            for (int i = 0; i < desiredBoundaries; i++)
            {
                int index = histList.IndexOf(histList.Max());
                float lastCount = histList[index];
                sortPeaks.Add(index, index);
                for (int j = index - 1; j >= 0; j--)
                {
                    float count = histList[j];
                    if (lastCount > count) histList[j] = 0; else break;
                    lastCount = count;
                }
                lastCount = histList[index];
                histList[index] = 0;
                for (int j = index + 1; j < histList.Count; j++)
                {
                    float count = histList[j];
                    if (lastCount > count) histList[j] = 0; else break;
                    lastCount = count;
                }
            }
            mmData mm = GetMinMax(src);
            float incr = (float)(mm.maxVal - mm.minVal) / vbc.task.histogramBins;
            peaks.Clear();
            foreach (var index in sortPeaks.Keys)
            {
                float col = (float)dst2.Width * index / vbc.task.histogramBins;
                peaks.Add(index);
                DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height / 10), Scalar.White, vbc.task.lineWidth);
            }
            labels[2] = (peaks.Count - 2).ToString() + " peaks (marked at top) were found in the histogram";
        }
    }




    public class HistValley_Depth_CS : VB_Parent
    {
        public HistValley_FromPeaks valley = new HistValley_FromPeaks();
        Mat histogram;
        public HistValley_Depth_CS()
        {
            labels[2] = "Top markers = peaks, bottom markers = valleys";
            desc = "Find the valleys in the depth histogram.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                valley.Run(src);
                dst2 = valley.dst2;
                List<int> vList = new List<int>(valley.valleyIndex);
                float[] histArray = new float[valley.histList.Count];
                for (int i = 0; i < vList.Count - 1; i++)
                {
                    int start = vList[i];
                    int finish = vList[i + 1];
                    for (int j = start; j <= finish; j++)
                    {
                        histArray[j] = i + 1;
                    }
                }
                histogram = valley.peak.hist.histogram;
                Marshal.Copy(histArray, 0, histogram.Data, histArray.Length);
                histogram += cv.Scalar.All(1); // shift away from 0
            }
            if (standaloneTest()) valley.updatePlot(dst2, vbc.task.histogramBins);
        }
    }




    public class HistValley_Depth1_CS : VB_Parent
    {
        public HistValley_OptionsAuto valley = new HistValley_OptionsAuto();
        public SortedList<int, int> valleyOrder = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public HistValley_Depth1_CS()
        {
            desc = "Find the valleys in the depth histogram.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            valley.Run(src);
            dst1 = valley.dst1;
            dst2 = valley.dst2;
            dst3 = valley.dst3;
            valleyOrder = valley.auto.valleyOrder;
        }
    }




    public class HistValley_Test_CS : VB_Parent
    {
        public SortedList<int, int> valleyOrder = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public Options_Boundary options = new Options_Boundary();
        Hist_Kalman kalmanHist = new Hist_Kalman();
        public HistValley_Test_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            desc = "Get the top X highest quality valley points in the histogram.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int desiredBoundaries = options.desiredBoundaries;
            // input should be a histogram.  If not, get one...
            if (standaloneTest())
            {
                kalmanHist.Run(src);
                dst2 = kalmanHist.dst2;
                src = kalmanHist.hist.histogram.Clone();
            }
            float[] histArray = new float[src.Total() - 1];
            Marshal.Copy(src.Data, histArray, 0, histArray.Length);
            var histList = histArray.ToList();
            List<float> valleys = new List<float>();
            float incr = histList.Count / desiredBoundaries;
            for (int i = 0; i < desiredBoundaries; i++)
            {
                List<float> nextList = new List<float>();
                for (int j = (int)(i * incr); j < (int)((i + 1) * incr); j++)
                {
                    if (i == 0 && j < 5)
                    {
                        nextList.Add(dst2.Total()); // there are typically some gaps near zero.
                    }
                    else
                    {
                        if (histList[j] == 0) nextList.Add(dst2.Total()); else nextList.Add(histList[j]);
                    }
                }
                int index = nextList.IndexOf(nextList.Min());
                valleys.Add(index + i * incr);
            }
            valleyOrder.Clear();
            int lastEntry = 0;
            for (int i = 0; i < desiredBoundaries; i++)
            {
                valleyOrder.Add(lastEntry, (int)(valleys[i] - 1));
                lastEntry = (int)valleys[i];
            }
            if (valleys[desiredBoundaries - 1] != histList.Count - 1)
            {
                valleyOrder.Add((int)valleys[desiredBoundaries - 1], 256);
            }
            if (standaloneTest())
            {
                foreach (var entry in valleyOrder)
                {
                    float col = (float)entry.Value * dst2.Width / vbc.task.histogramBins;
                    DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, vbc.task.lineWidth);
                }
                SetTrueText(valleys.Count.ToString() + " valleys in histogram", 3);
            }
        }
    }




    public class HistValley_OptionsAuto_CS : VB_Parent
    {
        Hist_Kalman kalman = new Hist_Kalman();
        public Mat histogram = new Mat();
        public OpAuto_Valley auto = new OpAuto_Valley();
        public HistValley_OptionsAuto_CS()
        {
            vbc.task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "Grayscale histogram - white lines are valleys", "" };
            desc = "Isolate the different levels of gray using the histogram valleys.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                kalman.Run(src);
                dst2 = kalman.dst2;
                histogram = kalman.hist.histogram.Clone();
                auto.Run(histogram);
                if (auto.valleyOrder.Count == 0) return;
                for (int i = 0; i < auto.valleyOrder.Count; i++)
                {
                    var entry = auto.valleyOrder.ElementAt(i);
                    float cClass = (float)(255 / (i + 1));
                    int index = (i % 2 == 0) ? (int)(255 - cClass) : (int)cClass;
                    for (int j = entry.Key; j <= entry.Value; j++)
                    {
                        histogram.Set<float>(j, 0, index);
                    }
                    int col = dst2.Width * entry.Value / vbc.task.histogramBins;
                    DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, vbc.task.lineWidth);
                }
            }
            if (src.Type() == MatType.CV_32F) histogram += cv.Scalar.All(1);
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0 }, histogram, dst1, kalman.hist.ranges);
            if (dst1.Type() != MatType.CV_8U)
            {
                dst1.SetTo(0, vbc.task.noDepthMask);
                dst1.ConvertTo(dst1, MatType.CV_8U);
            }
            dst3 = ShowPalette(dst1);
            labels[3] = (auto.valleyOrder.Count + 1).ToString() + " colors in the back projection";
        }
    }




    public class HistValley_Diff_CS : VB_Parent
    {
        Diff_Basics diff = new Diff_Basics();
        HistValley_FromPeaks valley = new HistValley_FromPeaks();
        public HistValley_Diff_CS()
        {
            desc = "Compare frame to frame what has changed";
        }
        public void RunAlg(Mat src)
        {
            valley.Run(src);
            dst2 = valley.dst2;
            diff.Run(valley.dst2);
            dst3 = diff.dst2;
        }
    }




    public class HistValley_EdgeDraw_CS : VB_Parent
    {
        HistValley_FromPeaks valley = new HistValley_FromPeaks();
        EdgeDraw_Basics edges = new EdgeDraw_Basics();
        public HistValley_EdgeDraw_CS()
        {
            desc = "Remove edge color in RGB before HistValley_FromPeaks";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(src);
            dst3 = src;
            dst3.SetTo(Scalar.Black, edges.dst2);
            valley.Run(dst3);
            dst2 = valley.dst2;
        }
    }




    public class HistValley_Simple_CS : VB_Parent
    {
        SLR_Trends trends = new SLR_Trends();
        public Kalman_Basics kalman = new Kalman_Basics();
        public List<int> depthRegions = new List<int>();
        public HistValley_Simple_CS()
        {
            desc = "Identify ranges by marking the depth histogram entries from valley to valley";
        }
        public void RunAlg(Mat src)
        {
            trends.Run(src);
            if (kalman.kInput.Length != vbc.task.histogramBins) Array.Resize(ref kalman.kInput, vbc.task.histogramBins);
            kalman.kInput = trends.resultingValues.ToArray();
            kalman.Run(src);
            dst2.SetTo(Scalar.Black);
            float barWidth = (float)dst2.Width / trends.resultingValues.Count;
            int colorIndex = 0;
            Scalar color = vbc.task.scalarColors[colorIndex % 256];
            int[] vals = { -1, -1, -1 };
            for (int i = 0; i < kalman.kOutput.Count(); i++)
            {
                int h = dst2.Height - (int)kalman.kOutput[i];
                vals[0] = vals[1];
                vals[1] = vals[2];
                vals[2] = h;
                if (vals[0] >= 0)
                {
                    if (vals[0] > vals[1] && vals[2] > vals[1])
                    {
                        colorIndex++;
                        color = vbc.task.scalarColors[colorIndex % 256];
                    }
                }
                Cv2.Rectangle(dst2, new cv.Rect(i * (int)barWidth, dst2.Height - h, (int)barWidth, h), color, -1);
                depthRegions.Add(colorIndex);
            }
            cv.Point2f lastPoint = trends.resultingPoints[0];
            for (int i = 1; i < trends.resultingPoints.Count; i++)
            {
                cv.Point2f p1 = trends.resultingPoints[i];
                DrawLine(dst2, lastPoint, p1, Scalar.Yellow, vbc.task.lineWidth);
                lastPoint = p1;
            }
            labels[2] = "Depth regions between 0 and " + ((int)(vbc.task.MaxZmeters + 1)).ToString() + " meters";
        }
    }




    public class HistValley_Tiers_CS : VB_Parent
    {
        HistValley_FromPeaks valleys = new HistValley_FromPeaks();
        public HistValley_Tiers_CS()
        {
            labels = new string[] { "", "", "CV_8U tier map with values ranging from 0 to the desired valley count", "vbPalette output of dst2." };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Display the depth as tiers defined by the depth valleys in the histogram of depth.";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            valleys.Run(src);
            dst2.SetTo(0);
            var marks = valleys.avgValley;
            marks[0] = 0;
            for (int i = 1; i < marks.Count(); i++)
            {
                dst2.SetTo(i + 1, vbc.task.pcSplit[2].InRange(marks[i - 1], marks[i]));
            }
            dst2.SetTo(marks.Count(), vbc.task.pcSplit[2].InRange(marks[marks.Count() - 1], 100));
            dst3 = ShowPalette(dst2 * 255 / (marks.Count() + 1));
        }
    }




    public class HistValley_Colors_CS : VB_Parent
    {
        Hist_Kalman hist = new Hist_Kalman();
        OpAuto_Valley auto = new OpAuto_Valley();
        int splitIndex;
        public HistValley_Colors_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            if (standaloneTest()) FindSlider("Desired boundary count").Value = 10;
            desc = "Find the histogram valleys for each of the colors.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat) splitIndex = (splitIndex + 1) % 3;
            src = src.ExtractChannel(splitIndex);
            if (splitIndex == 0)
                hist.hist.plot.backColor = Scalar.Blue;
            else if (splitIndex == 1)
                hist.hist.plot.backColor = Scalar.Green;
            else
                hist.hist.plot.backColor = Scalar.Red;
            hist.Run(src);
            dst2 = hist.dst2;
            auto.Run(hist.hist.histogram);
            for (int i = 0; i < auto.valleyOrder.Count; i++)
            {
                var entry = auto.valleyOrder.ElementAt(i);
                float cClass = (float)(255 / (i + 1));
                int index = (i % 2 == 0) ? (int)(255 - cClass) : (int)cClass;
                for (int j = entry.Key; j <= entry.Value; j++)
                {
                    hist.hist.histogram.Set<float>(j, 0, index);
                }
                int col = dst2.Width * entry.Value / vbc.task.histogramBins;
                DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, vbc.task.lineWidth);
            }
        }
    }




    public class HistValley_GrayKalman_CS : VB_Parent
    {
        Hist_Kalman hist = new Hist_Kalman();
        OpAuto_Valley auto = new OpAuto_Valley();
        Kalman_Basics kalman = new Kalman_Basics();
        public HistValley_GrayKalman_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            if (standaloneTest()) FindSlider("Desired boundary count").Value = 4;
            desc = "Find the histogram valleys for a grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst2 = hist.dst2;
            auto.Run(hist.hist.histogram);
            Array.Resize(ref kalman.kInput, auto.valleyOrder.Count);
            for (int i = 0; i < auto.valleyOrder.Count; i++)
            {
                kalman.kInput[i] = auto.valleyOrder.ElementAt(i).Value;
            }
            kalman.Run(src);
            int lastEntry = 0;
            for (int i = 0; i < kalman.kOutput.Count(); i++)
            {
                int entry = auto.valleyOrder.ElementAt(i).Value;
                for (int j = lastEntry; j <= entry; j++)
                {
                    hist.hist.histogram.Set<float>(j, 0, i);
                }
                int col = dst2.Width * entry / vbc.task.histogramBins;
                DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, vbc.task.lineWidth);
                lastEntry = entry;
            }
        }
    }




    public class HistValley_GrayScale1_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        public HistValley_GrayScale1_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            desc = "Find the histogram valleys for a grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst2 = hist.dst2;
            int wquartile = dst2.Width / 4;
            for (int i = 0; i < 3; i++)
            {
                int col = wquartile * (i + 1);
                dst2.Line(new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.Yellow, vbc.task.lineWidth + 2);
            }
            int start = 0;
            int lastentry = 0;
            int[] minEntries = new int[4];
            int quartile = (int)Math.Floor(hist.histogram.Rows / 4.0);
            for (int i = 0; i < hist.histArray.Count(); i++)
            {
                if (hist.histArray[i] != 0 && i > quartile / 4)
                {
                    lastentry = (int)hist.histArray[i];
                    minEntries[0] = i;
                    start = i;
                    break;
                }
            }
            for (int i = start; i < hist.histArray.Count(); i++)
            {
                if (hist.histArray[i] == 0) hist.histArray[i] = lastentry;
                lastentry = (int)hist.histArray[i];
            }
            for (int i = 0; i < minEntries.Length; i++)
            {
                minEntries[i] = quartile * i;
                for (int j = quartile * i; j < quartile * (i + 1); j++)
                {
                    if (hist.histArray[minEntries[i]] >= hist.histArray[j]) minEntries[i] = j;
                }
            }
            float wPlot = (float)dst2.Width / vbc.task.histogramBins;
            for (int i = 0; i < minEntries.Length; i++)
            {
                int col = minEntries[i] * (int)wPlot;
                dst2.Line(new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, vbc.task.lineWidth + 1);
            }
        }
    }




    public class HMM_Example_CPP_CS : VB_Parent
    {
        public HMM_Example_CPP_CS()
        {
            if (!vbc.task.testAllRunning) cPtr = HMM_Open();
            labels[2] = "Text output with explanation will appear in the Visual Studio output.";
            desc = "Simple test of Hidden Markov Model - text output";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.testAllRunning)
            {
                SetTrueText("When HMM_Example_CS is run repeatedly as part of a 'Test All', it can run out of OpenCL memory.");
                return;
            }
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = HMM_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels());
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero)
            {
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, src.Channels() == 3 ? MatType.CV_8UC3 : MatType.CV_8UC1, imagePtr).Clone();
            }
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = HMM_Close(cPtr);
        }
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr HMM_Open();

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr HMM_Close(IntPtr cPtr);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr HMM_Run(IntPtr HMMPtr, IntPtr bgrPtr, int rows, int cols, int channels);
    }




    public class HOG_Basics_CS : VB_Parent
    {
        Mat Image;
        bool ImageProcessed;
        Options_HOG options = new Options_HOG();
        public HOG_Basics_CS()
        {
            desc = "Find people with Histogram of Gradients (HOG) 2D feature";
            if (Image == null) Image = Cv2.ImRead(vbc.task.HomeDir + "Data/Asahiyama.jpg", ImreadModes.Color);
            dst3 = Image.Resize(dst3.Size());
        }
        void drawFoundRectangles(cv.Mat dst2, cv.Rect[] found)
        {
            foreach (cv.Rect rect in found)
            {
                // the HOG detector returns slightly larger rectangles than the real objects.
                // so we slightly shrink the rectangles to get a nicer output.
                cv.Rect r = new cv.Rect
                {
                    X = rect.X + (int)Math.Truncate(Math.Round(rect.Width * 0.1)),
                    Y = rect.Y + (int)Math.Truncate(Math.Round(rect.Height * 0.1)),
                    Width = (int)Math.Truncate(Math.Round(rect.Width * 0.8)),
                    Height = (int)Math.Truncate(Math.Round(rect.Height * 0.8))
                };
                dst2.Rectangle(r.TopLeft, r.BottomRight, Scalar.Red, 3, LineTypes.Link8, 0);
            }
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            HOGDescriptor hog = new HOGDescriptor();
            hog.SetSVMDetector(HOGDescriptor.GetDefaultPeopleDetector());
            bool b = hog.CheckDetectorSize();
            b.ToString();
            // run the detector with default parameters. to get a higher hit-rate
            // (and more false alarms, respectively), decrease the hitThreshold and
            // groupThreshold (set groupThreshold to 0 to turn off the grouping completely).
            if (src.Height == 94) src = src.Resize(new cv.Size(src.Width * 2, src.Height * 2));
            cv.Rect[] found = hog.DetectMultiScale(src, options.thresholdHOG, new cv.Size(options.strideHOG, options.strideHOG), new cv.Size(24, 16), options.scaleHOG, 2);
            labels[2] = string.Format("{0} region(s) found", found.Length);
            if (dst2.Height == 94) dst2 = src.Resize(dst2.Size()); else src.CopyTo(dst2);
            drawFoundRectangles(dst2, found);
            if (!ImageProcessed)
            {
                if (dst3.Height == 94) dst3 = dst3.Resize(new cv.Size(dst3.Width * 2, dst3.Height * 2));
                found = hog.DetectMultiScale(dst3, options.thresholdHOG, new cv.Size(options.strideHOG, options.strideHOG), new cv.Size(24, 16), options.scaleHOG, 2);
                drawFoundRectangles(dst3, found);
                if (found.Length > 0)
                {
                    ImageProcessed = true;
                    labels[3] = string.Format("{0} region(s) found", found.Length);
                }
                else
                {
                    labels[3] = "Try adjusting slider bars.";
                }
            }
        }
    }




    public class Homography_Basics_CS : VB_Parent
    {
        public List<cv.Point2d> corners1 = new List<cv.Point2d>();
        public List<cv.Point2d> corners2 = new List<cv.Point2d>();
        Random_Point2d random = new Random_Point2d();
        Options_Homography options = new Options_Homography();
        public Homography_Basics_CS()
        {
            desc = "Build the homography matrix from 2 lists of corners and use it in a WarpPerspective call.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest() && vbc.task.heartBeat && (cv.HomographyMethods)options.hMethod == HomographyMethods.None)
            {
                random.Run(empty);
                corners1 = new List<cv.Point2d>(random.PointList);
                random.Run(empty);
                corners2 = new List<cv.Point2d>(random.PointList);
            }
            // cannot find a homography when less than 4...
            if (corners1.Count() >= 4 || corners2.Count() >= 4)
            {
                Mat H = Cv2.FindHomography(corners1, corners2, (cv.HomographyMethods)options.hMethod);
                if (H.Width > 0)
                    dst2 = src.WarpPerspective(H, src.Size());
            }
        }
    }




    public class Homography_FPoly_CS : VB_Parent
    {
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        Homography_Basics hGraph = new Homography_Basics();
        public Homography_FPoly_CS()
        {
            desc = "Use the feature polygon to warp the current image to a previous image.  This is not useful but demonstrates how to use homography.";
        }
        public void RunAlg(Mat src)
        {
            fPoly.Run(src);
            dst2 = fPoly.dst1;
            if (fPoly.fPD.currPoly == null || fPoly.fPD.prevPoly == null) return;
            if (fPoly.fPD.currPoly.Count() == 0 || fPoly.fPD.prevPoly.Count() == 0) return;
            if (fPoly.fPD.currPoly.Count() != fPoly.fPD.prevPoly.Count()) return;
            hGraph.corners1.Clear();
            hGraph.corners2.Clear();
            for (int i = 0; i < fPoly.fPD.currPoly.Count(); i++)
            {
                Point2f p1 = fPoly.fPD.currPoly[i];
                Point2f p2 = fPoly.fPD.prevPoly[i];
                hGraph.corners1.Add(new Point2d(p1.X, p1.Y));
                hGraph.corners2.Add(new Point2d(p2.X, p2.Y));
            }
            hGraph.Run(src);
            dst3 = hGraph.dst2;
        }
    }




    public class Horizon_Basics_CS : VB_Parent
    {
        public List<cv.Point> points = new List<cv.Point>();
        int resizeRatio = 1;
        public PointPair vec;
        public bool vecPresent;
        public bool autoDisplay;
        public Horizon_Basics_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find all the points where depth Y-component transitions from positive to negative";
        }
        public void displayResults(Point2f p1, Point2f p2)
        {
            if (vbc.task.heartBeat)
            {
                if (p1.Y >= 1 && p1.Y <= dst2.Height - 1) strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n";
            }
            dst2.SetTo(new cv.Scalar(0));
            foreach (cv.Point pt in points)
            {
                cv.Point pX = new cv.Point(pt.X * resizeRatio, pt.Y * resizeRatio);
                DrawCircle(dst2, pX, vbc.task.DotSize, new cv.Scalar(255), -1);
            }
            DrawLine(dst2, vec.p1, vec.p2, new cv.Scalar(255), 255);
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F) dst0 = PrepareDepthInput(1); else dst0 = src;
            cv.Size resolution = vbc.task.quarterRes;
            if (dst0.Size() != resolution)
            {
                dst0 = dst0.Resize(resolution, 0, 0, cv.InterpolationFlags.Linear);
                resizeRatio = dst2.Height / (int)resolution.Height;
            }
            dst0 = dst0.Abs();
            dst1 = dst0.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst0.SetTo(vbc.task.MaxZmeters, ~dst1);
            points.Clear();
            for (int i = dst0.Width / 3; i < dst0.Width * 2 / 3; i++)
            {
                mmData mm1 = GetMinMax(dst0.Col(i));
                if (mm1.minVal > 0 && mm1.minVal < 0.005)
                {
                    dst0.Col(i).Set(mm1.minLoc.Y, mm1.minLoc.X, 10);
                    mmData mm2 = GetMinMax(dst0.Col(i));
                    if (mm2.minVal > 0 && Math.Abs(mm1.minLoc.Y - mm2.minLoc.Y) <= 1) points.Add(new cv.Point(i, mm1.minLoc.Y));
                }
            }
            labels[2] = points.Count() + " points found. ";
            cv.Point p1 = new cv.Point(), p2 = new cv.Point();
            if (points.Count() >= 2)
            {
                p1 = new cv.Point(resizeRatio * points[points.Count() - 1].X, resizeRatio * points[points.Count() - 1].Y);
                p2 = new cv.Point(resizeRatio * points[0].X, resizeRatio * points[0].Y);
            }
            double distance = p1.DistanceTo(p2);
            if (distance < 10) // enough to get a line with some credibility
            {
                points.Clear();
                vecPresent = false;
                vec = new PointPair();
                strOut = "Horizon not found \n" + "The distance of p1 to p2 is " + (int)distance + " pixels.";
            }
            else
            {
                PointPair lp = new PointPair(p1, p2);
                vec = lp.edgeToEdgeLine(dst2.Size());
                vecPresent = true;
                if (standaloneTest() || autoDisplay) displayResults(p1, p2);
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Horizon_BasicsAlt_CS : VB_Parent
    {
        public Mat cloudY;
        public Horizon_BasicsAlt_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Search for the transition from positive to negative to find the horizon.";
        }
        Point2f findTransition(int startCol, int stopCol, int stepCol)
        {
            float val = 0, lastVal = 0;
            List<float> ptX = new List<float>();
            List<float> ptY = new List<float>();
            for (int x = startCol; x <= stopCol; x += stepCol)
            {
                for (int y = 0; y < cloudY.Rows; y++)
                {
                    lastVal = val;
                    val = cloudY.At<float>(y, x);
                    if (val > 0 && lastVal < 0)
                    {
                        // change sub-pixel accuracy here 
                        Point2f pt = new Point2f(x, y + Math.Abs(val) / Math.Abs(val - lastVal));
                        ptX.Add(pt.X);
                        ptY.Add(pt.Y);
                        if (ptX.Count() >= vbc.task.frameHistoryCount)
                            return new Point2f(ptX.Average(), ptY.Average());
                    }
                }
            }
            return new Point2f();
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.useGravityPointcloud)
            {
                cloudY = vbc.task.pcSplit[1]; // already oriented to gravity
            }
            else
            {
                // rebuild the pointcloud so it is oriented to gravity.
                Mat pc = (vbc.task.pointCloud.Reshape(1, vbc.task.pointCloud.Rows * vbc.task.pointCloud.Cols) * vbc.task.gMatrix).ToMat().Reshape(3, vbc.task.pointCloud.Rows);
                Mat[] split = pc.Split();
                cloudY = split[1];
            }
            Point2f p1 = findTransition(0, cloudY.Width - 1, 1);
            Point2f p2 = findTransition(cloudY.Width - 1, cloudY.Width - 1, -1);
            PointPair lp = new PointPair(p1, p2);
            vbc.task.horizonVec = lp.edgeToEdgeLine(dst2.Size());
            if (p1.Y >= 1 && p1.Y <= dst2.Height - 1)
            {
                strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n" + "      val =  " +
                          cloudY.At<float>((int)p1.Y, (int)p1.X).ToString() + "\n" + "lastVal = " + cloudY.At<float>((int)(p1.Y - 1), (int)p1.X).ToString();
            }
            SetTrueText(strOut, 3);
            if (standaloneTest())
            {
                dst2.SetTo(0);
                DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, cv.Scalar.All(255), vbc.task.lineWidth);
                DrawLine(dst2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, cv.Scalar.All(255), vbc.task.lineWidth);
            }
        }
    }





    public class Horizon_FindNonZero_CS : VB_Parent
    {
        public Horizon_FindNonZero_CS()
        {
            vbc.task.redOptions.setYRangeSlider(3);
            if (standalone) vbc.task.gOptions.setDisplay1();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
            vbc.task.horizonVec = new PointPair(new Point2f(0, dst2.Height / 2), new Point2f(dst2.Width, dst2.Height / 2));
            labels = new string[] { "", "Horizon vector mask", "Crosshairs - gravityVec (vertical) and horizonVec (horizontal)", "Gravity vector mask" };
            desc = "Create lines for the gravity vector and horizon vector in the camera image";
        }
        public void RunAlg(Mat src)
        {
            double xRatio = dst0.Width / vbc.task.quarterRes.Width;
            double yRatio = dst0.Height / vbc.task.quarterRes.Height;

            var pc = vbc.task.pointCloud.Resize(vbc.task.quarterRes);
            var split = pc.Split();
            split[2].SetTo(vbc.task.MaxZmeters);
            Cv2.Merge(split, pc);

            pc = (pc.Reshape(1, pc.Rows * pc.Cols) * vbc.task.gMatrix).ToMat().Reshape(3, pc.Rows);

            dst1 = split[1].InRange(-0.05, 0.05);
            var noDepth = vbc.task.noDepthMask.Resize(vbc.task.quarterRes);
            dst1.SetTo(0, noDepth);
            cv.Mat pointsMat = dst1.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                dst2.SetTo(new cv.Scalar(0));
                List<int> xVals = new List<int>();
                List<cv.Point2f> points = new List<cv.Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<cv.Point>(i, 0);
                    xVals.Add(pt.X);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[xVals.IndexOf(xVals.Min())];
                Point2f p2 = points[xVals.IndexOf(xVals.Max())];
                PointPair lp = new PointPair(p1, p2);
                vbc.task.horizonVec = lp.edgeToEdgeLine(dst2.Size());
                DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, new cv.Scalar(255), vbc.task.lineWidth);
            }
            dst3 = split[0].InRange(-0.01, 0.01);
            dst3.SetTo(new cv.Scalar(0), noDepth);
            pointsMat = new Mat();
            pointsMat = dst3.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                List<int> yVals = new List<int>();
                List<cv.Point2f> points = new List<cv.Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<cv.Point>(i, 0);
                    yVals.Add(pt.Y);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[yVals.IndexOf(yVals.Min())];
                Point2f p2 = points[yVals.IndexOf(yVals.Max())];
                if (Math.Abs(p1.X - p2.X) < 2)
                {
                    vbc.task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
                }
                else
                {
                    PointPair lp = new PointPair(p1, p2);
                    vbc.task.gravityVec = lp.edgeToEdgeLine(dst2.Size());
                }
                DrawLine(dst2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, new cv.Scalar(255), vbc.task.lineWidth);
            }
        }
    }




    public class Horizon_UnstableResults_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        public Horizon_UnstableResults_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Create lines for the gravity vector and horizon vector in the camera image";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != cv.MatType.CV_32FC3) src = vbc.task.pointCloud;
            dst1 = vbc.task.pcSplit[1].InRange(-0.05, 0.05);
            dst0.SetTo(new cv.Scalar(0));
            dst0.SetTo(new cv.Scalar(255), dst1);
            dst0.SetTo(new cv.Scalar(0), vbc.task.noDepthMask);
            lines.Run(dst0);
            dst2.SetTo(new cv.Scalar(0));
            if (lines.lpList.Count() > 0)
            {
                SortedList<float, PointPair> distances = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
                foreach (PointPair lp in lines.lpList)
                {
                    distances.Add((float)lp.p1.DistanceTo(lp.p2), lp);
                }
                PointPair lpBest = distances.Values[0];
                Point2f p1 = new Point2f(0, lpBest.yIntercept);
                Point2f p2 = new Point2f(dst2.Width, lpBest.slope * dst2.Width + lpBest.yIntercept);
                vbc.task.horizonVec = new PointPair(p1, p2);
                DrawLine(dst2, p1, p2, new cv.Scalar(255), 255);
                labels[2] = "horizonVec slope/intercept = " + lpBest.slope.ToString("F4") + "/" + lpBest.yIntercept.ToString("F4");
            }
            dst1 = vbc.task.pcSplit[0].InRange(-0.01, 0.01);
            dst0.SetTo(new cv.Scalar(0));
            dst0.SetTo(new cv.Scalar(255), dst1);
            dst0.SetTo(new cv.Scalar(0), vbc.task.noDepthMask);
            lines.Run(dst0);
            if (lines.lpList.Count() > 0)
            {
                SortedList<float, PointPair> distances = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
                foreach (PointPair lp in lines.lpList)
                {
                    distances.Add((float)lp.p1.DistanceTo(lp.p2), lp);
                }
                PointPair lpBest = distances.Values[0];
                Point2f p1 = new Point2f(0, lpBest.yIntercept);
                Point2f p2 = new Point2f(dst2.Width, lpBest.slope * dst2.Width + lpBest.yIntercept);
                vbc.task.gravityVec = new PointPair(p1, p2);
                DrawLine(dst2, p1, p2, new cv.Scalar(255), 255);
                labels[3] = "gravityVec slope/intercept = " + lpBest.slope.ToString("F4") + "/" + lpBest.yIntercept.ToString("F4");
            }
        }
    }




    public class Horizon_FindNonZeroOld_CS : VB_Parent
    {
        public Horizon_FindNonZeroOld_CS()
        {
            vbc.task.gOptions.setGravityUsage(false);
            vbc.task.redOptions.setYRangeSlider(3);
            if (standalone) vbc.task.gOptions.setDisplay1();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
            vbc.task.horizonVec = new PointPair(new Point2f(0, dst2.Height / 2), new Point2f(dst2.Width, dst2.Height / 2));
            labels = new string[] { "", "Horizon vector mask", "Crosshairs - gravityVec (vertical) and horizonVec (horizontal)", "Gravity vector mask" };
            desc = "Create lines for the gravity vector and horizon vector in the camera image";
        }
        public void RunAlg(Mat src)
        {
            double xRatio = dst0.Width / (double)vbc.task.quarterRes.Width;
            double yRatio = dst0.Height / (double)vbc.task.quarterRes.Height;
            Mat splitX = vbc.task.pcSplit[0];
            Mat splitY = vbc.task.pcSplit[1];
            Mat noDepth = vbc.task.noDepthMask;
            if (splitX.Size() != vbc.task.quarterRes)
            {
                splitX = splitX.Resize(vbc.task.quarterRes, 0, 0, cv.InterpolationFlags.Linear);
                splitY = splitY.Resize(vbc.task.quarterRes, 0, 0, cv.InterpolationFlags.Linear);
                noDepth = noDepth.Resize(vbc.task.quarterRes, 0, 0, cv.InterpolationFlags.Linear);
            }
            dst1 = splitY.InRange(-0.05, 0.05);
            dst1.SetTo(new cv.Scalar(0), noDepth);
            Mat pointsMat = new Mat();
            pointsMat = dst1.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                dst2.SetTo(new cv.Scalar(0));
                List<int> xVals = new List<int>();
                List<cv.Point2f> points = new List<cv.Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<cv.Point>(i, 0);
                    xVals.Add(pt.X);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[xVals.IndexOf(xVals.Min())];
                Point2f p2 = points[xVals.IndexOf(xVals.Max())];
                PointPair lp = new PointPair(p1, p2);
                vbc.task.horizonVec = lp.edgeToEdgeLine(dst2.Size());
                DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, new cv.Scalar(255), 255);
            }
            //If vbc.task.horizonVec.originalLength < dst2.Width / 2 And vbc.task.redOptions.YRangeSlider.Value < vbc.task.redOptions.YRangeSlider.Maximum Or pointsMat.Rows = 0 Then
            //    vbc.task.redOptions.YRangeSlider.Value += 1
            //End If
            dst3 = splitX.InRange(-0.01, 0.01);
            dst3.SetTo(new cv.Scalar(0), noDepth);
            pointsMat = new Mat();
            pointsMat = dst3.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                List<int> yVals = new List<int>();
                List<cv.Point2f> points = new List<cv.Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<cv.Point>(i, 0);
                    yVals.Add(pt.Y);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[yVals.IndexOf(yVals.Min())];
                Point2f p2 = points[yVals.IndexOf(yVals.Max())];
                if (Math.Abs(p1.X - p2.X) < 2)
                {
                    vbc.task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
                }
                else
                {
                    PointPair lp = new PointPair(p1, p2);
                    vbc.task.gravityVec = lp.edgeToEdgeLine(dst2.Size());
                }
                DrawLine(dst2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, new cv.Scalar(255), 255);
            }
            //If vbc.task.gravityVec.originalLength < dst2.Height / 2 And vbc.task.redOptions.XRangeSlider.Value < vbc.task.redOptions.XRangeSlider.Maximum Or pointsMat.Rows = 0 Then
            //    vbc.task.redOptions.XRangeSlider.Value += 1
            //End If
        }
    }




    public class Horizon_Validate_CS : VB_Parent
    {
        Match_Basics match = new Match_Basics();
        Point2f ptLeft, ptRight;
        Mat leftTemplate, rightTemplate;
        public Horizon_Validate_CS()
        {
            desc = "Validate the horizon points using Match_Basics";
        }
        public void RunAlg(Mat src)
        {
            int templatePad = match.options.templatePad;
            int templateSize = match.options.templateSize;
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.heartBeat)
            {
                ptLeft = vbc.task.gravityVec.p1;
                ptRight = vbc.task.gravityVec.p2;
                cv.Rect r = ValidateRect(new cv.Rect((int)(ptLeft.X - templatePad), (int)(ptLeft.Y - templatePad), templateSize, templateSize));
                leftTemplate = new Mat(src, r);
                r = ValidateRect(new cv.Rect((int)(ptRight.X - templatePad), (int)(ptRight.Y - templatePad), templateSize, templateSize));
                rightTemplate = new Mat(src, r);
            }
            else
            {
                cv.Rect r = ValidateRect(new cv.Rect((int)(ptLeft.X - templatePad), (int)(ptLeft.Y - templatePad), templateSize, templateSize));
                match.template = leftTemplate;
                match.Run(src);
                ptLeft = match.matchCenter;
                r = ValidateRect(new cv.Rect((int)(ptRight.X - templatePad), (int)(ptRight.Y - templatePad), templateSize, templateSize));
                match.template = leftTemplate;
                match.Run(src);
                ptLeft = match.matchCenter;
            }
        }
    }




    public class Horizon_Regress_CS : VB_Parent
    {
        Horizon_Basics horizon = new Horizon_Basics();
        LinearRegression_Basics regress = new LinearRegression_Basics();
        public Horizon_Regress_CS()
        {
            desc = "Collect the horizon points and run a linear regression on all the points.";
        }
        public void RunAlg(Mat src)
        {
            horizon.Run(src);
            foreach (cv.Point point in horizon.points)
            {
                regress.x.Add(point.X);
                regress.y.Add(point.Y);
            }
            regress.Run(null);
            horizon.displayResults(regress.p1, regress.p2);
            dst2 = horizon.dst2;
        }
    }




    public class Horizon_ExternalTest_CS : VB_Parent
    {
        Horizon_Basics horizon = new Horizon_Basics();
        public Horizon_ExternalTest_CS()
        {
            desc = "Supply the point cloud input to Horizon_Basics";
        }
        public void RunAlg(Mat src)
        {
            dst0 = PrepareDepthInput(1);
            horizon.Run(dst0);
            dst2 = horizon.dst2;
        }
    }




    public class Hough_Basics_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        public LineSegmentPolar[] segments;
        public Options_Hough options = new Options_Hough();
        public Hough_Basics_CS()
        {
            desc = "Use Houghlines to find lines in the image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            edges.Run(src);
            segments = Cv2.HoughLines(edges.dst2, options.rho, options.theta, options.threshold);
            labels[2] = "Found " + segments.Length + " Lines";
            if (standaloneTest())
            {
                src.CopyTo(dst2);
                dst2.SetTo(Scalar.White, edges.dst2);
                src.CopyTo(dst3);
                houghShowLines(dst2, segments, options.lineCount);
                var probSegments = Cv2.HoughLinesP(edges.dst2, options.rho, options.theta, options.threshold);
                for (int i = 0; i < Math.Min(probSegments.Length, options.lineCount); i++)
                {
                    var line = probSegments[i];
                    dst3.Line(line.P1, line.P2, Scalar.Red, vbc.task.lineWidth + 2, vbc.task.lineType);
                }
                labels[3] = "Probablistic lines = " + probSegments.Length;
            }
        }
    }




    public class Hough_Circles_CS : VB_Parent
    {
        Draw_Circles circles = new Draw_Circles();
        int method = 3;
        public Hough_Circles_CS()
        {
            FindSlider("DrawCount").Value = 3;
            labels[2] = "Input circles to Hough";
            labels[3] = "Hough Circles found";
            desc = "Find circles using HoughCircles.";
        }
        public void RunAlg(Mat src)
        {
            circles.Run(src);
            dst2 = circles.dst2;
            Cv2.CvtColor(dst2, dst3, ColorConversionCodes.BGR2GRAY);
            var cFound = Cv2.HoughCircles(dst3, (cv.HoughModes)method, 1, dst2.Rows / 4, 100, 10, 1, 200);
            var foundColor = new Scalar(0, 0, 255);
            dst2.CopyTo(dst3);
            for (int i = 0; i < cFound.Length; i++)
            {
                cv.Point pt = new cv.Point((int)cFound[i].Center.X, (int)cFound[i].Center.Y);
                DrawCircle(dst3, pt, (int)cFound[i].Radius, foundColor, (int)vbc.task.lineType);
            }
            labels[3] = cFound.Length + " circles were identified";
        }
    }




    public class Hough_Lines_MT_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        Options_Hough options = new Options_Hough();
        public Hough_Lines_MT_CS()
        {
            labels[2] = "Output of the Canny Edge algorithm (no Hough lines)";
            labels[3] = "Hough Lines for each threaded cell or if no lines, the featureless cell depth data.";
            desc = "Multithread Houghlines to find lines in image fragments.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            edges.Run(src);
            dst2 = edges.dst2;
            var depth8uC3 = vbc.task.depthRGB;
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                var segments = Cv2.HoughLines(dst2[roi], options.rho, options.theta, options.threshold);
                if (segments.Length == 0)
                {
                    dst3[roi] = depth8uC3[roi];
                    return;
                }
                dst3[roi].SetTo(0);
                Mat tmp = dst3[roi];
                houghShowLines(tmp, segments, 1);
            });
            dst2.SetTo(Scalar.White, vbc.task.gridMask);
        }
    }




    public class Hough_Featureless_CS : VB_Parent
    {
        public Edge_Canny edges = new Edge_Canny();
        public int[] noDepthCount;
        public Options_Hough options = new Options_Hough();
        public Vec3b[] roiColor;
        public Hough_Featureless_CS()
        {
            vbc.task.gOptions.setGridSize(10);
            labels[2] = "Featureless mask";
            desc = "Multithread Houghlines to find featureless regions in an image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            edges.Run(src);
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            int regionCount = 0;
            noDepthCount = new int[vbc.task.gridRects.Count()];
            roiColor = new Vec3b[vbc.task.gridRects.Count()];
            foreach (var roi in vbc.task.gridRects)
            {
                var segments = Cv2.HoughLines(edges.dst2[roi], options.rho, options.theta, options.threshold);
                if (edges.dst2[roi].CountNonZero() == 0)
                {
                    regionCount++;
                    dst2[roi].SetTo(255);
                }
            }
            dst3.SetTo(0);
            src.CopyTo(dst3, dst2);
            labels[2] = "FeatureLess Regions = " + regionCount;
            labels[3] = "Of the " + vbc.task.gridRects.Count() + " grid elements, " + regionCount + " had no edge or hough features present";
        }
    }




    public class Hough_FeatureLessTopX_CS : VB_Parent
    {
        public Edge_Canny edges = new Edge_Canny();
        public Options_Hough options = new Options_Hough();
        public Mat maskFless;
        public Mat maskFeat;
        public Mat maskPredict;
        public Hough_FeatureLessTopX_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setGridSize(10);
            maskFless = new Mat(dst2.Size(), MatType.CV_8U);
            maskFeat = new Mat(dst2.Size(), MatType.CV_8U);
            maskPredict = new Mat(dst2.Size(), MatType.CV_8U);
            labels = new string[] { "", "", "Areas without features", "Areas with features" };
            desc = "Multithread Houghlines to find featureless regions in an image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var segSlider = FindSlider("Minimum feature pixels");
            int minSegments = segSlider.Value;
            edges.Run(src);
            src.CopyTo(dst2);
            maskFless.SetTo(0);
            maskFeat.SetTo(0);
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                var segments = Cv2.HoughLines(edges.dst2[roi], options.rho, options.theta, options.threshold);
                if (segments.Length == 0) maskFless[roi].SetTo(255);
                if (edges.dst2[roi].CountNonZero() >= minSegments) maskFeat[roi].SetTo(255);
            });
            maskPredict.SetTo(255);
            maskPredict.SetTo(0, maskFless);
            maskPredict.SetTo(0, maskFeat);
            dst1.SetTo(0);
            src.CopyTo(dst1, maskPredict);
            int pCount = maskPredict.CountNonZero();
            labels[1] = string.Format("{0:0%} are inbetween feature and featureless", (double)pCount / dst1.Total());
            dst2.SetTo(0);
            src.CopyTo(dst2, maskFless);
            dst3.SetTo(0);
            src.CopyTo(dst3, maskFeat);
        }
    }




    public class Hough_LaneFinder_CS : VB_Parent
    {
        LaneFinder_HLSColor hls = new LaneFinder_HLSColor();
        public LineSegmentPoint[] segments;
        public Mat mask;
        public int laneLineMinY;
        public Hough_LaneFinder_CS()
        {
            labels = new string[] { "Original video image", "Mask to isolate lane regions", "Combined yellow and white masks", "HoughLines output" };
            desc = "Use Hough to isolate features in the mask of the road.";
        }
        public void RunAlg(Mat src)
        {
            hls.Run(empty);
            if (vbc.task.optionsChanged)
            {
                int w = hls.input.video.dst2.Width;
                int h = hls.input.video.dst2.Height;
                var bl = new cv.Point(w * 0.1, h * 0.95);
                var tl = new cv.Point(w * 0.4, h * 0.6);
                var br = new cv.Point(w * 0.95, h * 0.95);
                var tr = new cv.Point(w * 0.6, h * 0.6);
                cv.Point[] pList = new cv.Point[] { bl, tl, tr, br };
                mask = new Mat(new cv.Size(w, h), MatType.CV_8U, cv.Scalar.All(0));
                mask.FillConvexPoly(pList, Scalar.White, vbc.task.lineType);
            }
            dst1 = mask.Clone();
            dst0 = hls.dst0;
            dst2 = new Mat(mask.Size(), MatType.CV_8U, cv.Scalar.All(0));
            hls.dst3.CopyTo(dst2, mask);
            int rho = 1;
            double theta = Cv2.PI / 180;
            int threshold = 20;
            int minLineLength = 20;
            int maxLineGap = 300;
            segments = Cv2.HoughLinesP(dst2.Clone(), rho, theta, threshold, minLineLength, maxLineGap);
            dst3 = new Mat(mask.Size(), MatType.CV_8UC3, cv.Scalar.All(0));
            laneLineMinY = dst2.Height;
            for (int i = 0; i < segments.Length; i++)
            {
                if (laneLineMinY > segments[i].P1.Y) laneLineMinY = segments[i].P1.Y;
                if (laneLineMinY > segments[i].P2.Y) laneLineMinY = segments[i].P2.Y;
                DrawLine(dst3, segments[i].P1, segments[i].P2, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
        }
    }




    public class Hough_Sudoku_CS : VB_Parent
    {
        Hough_Basics hough = new Hough_Basics();
        public Hough_Sudoku_CS()
        {
            desc = "Successful use of Hough to find lines in Sudoku grid.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = Cv2.ImRead(vbc.task.HomeDir + "opencv/Samples/Data/sudoku.png").Resize(dst2.Size());
            dst3 = dst2.Clone();
            hough.Run(dst2);
            houghShowLines(dst3, hough.segments, hough.options.lineCount);
        }
    }




    public class Hull_Basics_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();
        public List<cv.Point2f> inputPoints = new List<cv.Point2f>();
        public List<cv.Point> hull = new List<cv.Point>();
        public bool useRandomPoints;
        public Hull_Basics_CS()
        {
            labels = new string[] { "", "", "Input Points - draw a rectangle anywhere.  Enclosing rectangle in yellow.", "" };
            if (standaloneTest()) random.range = new cv.Rect(100, 100, 50, 50);
            desc = "Given a list of points, create a hull that encloses them.";
        }
        List<cv.Point> vbFloat2Int(List<cv.Point2f> ptList2f)
        {
            List<cv.Point> ptList = new List<cv.Point>();
            foreach (var pt in ptList2f)
            {
                ptList.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            return ptList;
        }
        public void RunAlg(Mat src)
        {
            if ((standaloneTest() && vbc.task.heartBeat) || (useRandomPoints && vbc.task.heartBeat))
            {
                random.Run(empty);
                dst2.SetTo(0);
                foreach (var pt in random.PointList)
                {
                    DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White);
                }
                inputPoints = new List<cv.Point2f>(random.PointList);
            }
            var hull2f = Cv2.ConvexHull(inputPoints, true);
            hull = vbFloat2Int(hull2f.ToList());
            DrawContour(dst2, hull, Scalar.Yellow);
        }
    }




    public class Hull_Contour_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Hull_Contour_CS()
        {
            desc = "Compare the hull to the contour of a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            var rc = vbc.task.rc;
            List<cv.Point> jumpList = new List<cv.Point>();
            for (int i = 1; i < rc.contour.Count(); i++)
            {
                var p1 = rc.contour[i - 1];
                var p2 = rc.contour[i];
                if (p1.DistanceTo(p2) > 1)
                {
                    if (!jumpList.Contains(p2)) jumpList.Add(p2);
                }
            }
            rc.hull = Cv2.ConvexHull(rc.contour.ToArray(), true).ToList();
            DrawContour(dst3, rc.contour, Scalar.LightBlue, vbc.task.lineWidth);
            if (rc.hull.Count() > 0) rc.hull.RemoveAt(rc.hull.Count() - 1);
            DrawContour(dst3, rc.hull, Scalar.White, vbc.task.lineWidth);
        }
    }




    public class Image_Basics_CS : VB_Parent
    {
        public string inputFileName;
        public Options_Images options = new Options_Images();
        public Image_Basics_CS()
        {
            desc = "Load an image into OpenCVB";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            src = options.fullsizeImage;
            if (src.Width != dst2.Width || src.Height != dst2.Height)
            {
                var newSize = new cv.Size(dst2.Height * src.Width / src.Height, dst2.Height);
                if (newSize.Width > dst2.Width)
                {
                    newSize = new cv.Size(dst2.Width, dst2.Width * src.Height / src.Width);
                }
                dst2.SetTo(0);
                dst2[new cv.Rect(0, 0, newSize.Width, newSize.Height)] = src.Resize(newSize);
            }
            else
            {
                dst2 = src;
            }
        }
    }




    public class Image_Series_CS : VB_Parent
    {
        public Image_Basics images = new Image_Basics();
        public Image_Series_CS()
        {
            images.options.imageSeries = true;
            desc = "Display a new image from the directory every heartbeat";
        }
        public void RunAlg(Mat src)
        {
            // to work on a specific file, specify it here.
            // options.fileInputName = new FileInfo(vbc.task.HomeDir + "Images/train/103041.jpg");
            images.Run(images.options.fullsizeImage);
            dst2 = images.dst2;
        }
    }




    public class Image_RedCloudColor_CS : VB_Parent
    {
        public Image_Series images = new Image_Series();
        public RedCloud_Cells redC = new RedCloud_Cells();
        public Image_RedCloudColor_CS()
        {
            vbc.task.gOptions.setDisplay1();
            desc = "Use RedCloud on a photo instead of the video stream.";
        }
        public void RunAlg(Mat src)
        {
            images.Run(empty);
            dst0 = images.dst2.Clone();
            dst1 = images.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            redC.Run(dst0);
            dst2 = redC.dst2;
            var mask = vbc.task.cellMap.InRange(0, 0);
            dst2.SetTo(Scalar.Black, mask);
            labels[2] = redC.labels[2];
        }
    }




    public class Image_CellStats_CS : VB_Parent
    {
        Image_RedCloudColor images = new Image_RedCloudColor();
        Cell_Basics stats = new Cell_Basics();
        public Image_CellStats_CS()
        {
            images.images.images.options.imageSeries = false;
            if (standaloneTest()) vbc.task.gOptions.setDisplay0();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Display the statistics for the selected cell";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.pointCloud.SetTo(0);
            vbc.task.pcSplit = vbc.task.pointCloud.Split();
            images.Run(empty);
            dst0 = images.dst0;
            dst1 = images.dst1;
            dst2 = images.dst2;
            stats.statsString();
            SetTrueText(stats.strOut, 3);
        }
    }




    public class Image_MSER_CS : VB_Parent
    {
        public Image_Series images = new Image_Series();
        MSER_Detect core = new MSER_Detect();
        Options_Images options = new Options_Images();
        public Image_MSER_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            FindSlider("MSER Min Area").Value = 15;
            FindSlider("MSER Max Area").Value = 200000;
            desc = "Find the MSER (Maximally Stable Extermal Regions) in the still image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            images.Run(options.fullsizeImage);
            dst1 = images.dst2;
            core.Run(dst1);
            dst2 = core.dst2;
        }
    }




    public class ImShow_Basics_CS : VB_Parent
    {
        public ImShow_Basics_CS()
        {
            desc = "This is just a reminder that all HighGUI methods are available in OpenCVB";
        }
        public void RunAlg(Mat src)
        {
            Cv2.ImShow("color", src);
        }
    }




    public class ImShow_WaitKey_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        public ImShow_WaitKey_CS()
        {
            desc = "You can use the HighGUI WaitKey call to pause an algorithm and review output one frame at a time.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            Cv2.ImShow("Hit space bar to advance to the next frame", feat.dst2);
            Cv2.WaitKey(1000); // No need for waitkey with imshow in OpenCVB - finishing a buffer is the same thing so waitkey just delays by 1 second here.
            dst2 = feat.dst2;
        }
    }




    public class ImShow_CV32FC3_CS : VB_Parent
    {
        public ImShow_CV32FC3_CS()
        {
            desc = "Experimenting with how to show an 32fc3 Mat file.";
        }
        public void RunAlg(Mat src)
        {
            Cv2.ImShow("Point cloud", vbc.task.pointCloud);
            dst2 = vbc.task.pointCloud.Clone();
        }
    }




    public class IMU_Basics_CS : VB_Parent
    {
        double lastTimeStamp;
        public IMU_Basics_CS()
        {
            desc = "Read and display the IMU coordinates";
        }
        public void RunAlg(Mat src)
        {
            Point3f gyroAngle;
            if (vbc.task.optionsChanged)
            {
                lastTimeStamp = vbc.task.IMU_TimeStamp;
            }
            else
            {
                gyroAngle = vbc.task.IMU_AngularVelocity;
                double dt_gyro = (vbc.task.IMU_TimeStamp - lastTimeStamp) / 1000;
                if (vbc.task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i") dt_gyro /= 1000; // different units in the timestamp?
                gyroAngle = gyroAngle * dt_gyro;
                vbc.task.theta += new Point3f(-gyroAngle.Z, -gyroAngle.Y, gyroAngle.X);
                lastTimeStamp = vbc.task.IMU_TimeStamp;
            }
            // NOTE: Initialize the angle around the y-axis to zero.
            cv.Point3f g = vbc.task.IMU_RawAcceleration;
            vbc.task.accRadians = new Point3f((float)Math.Atan2(g.X, Math.Sqrt(g.Y * g.Y + g.Z * g.Z)),
                                         (float)Math.Abs(Math.Atan2(g.X, g.Y)), (float)Math.Atan2(g.Y, g.Z));
            if (vbc.task.optionsChanged)
            {
                vbc.task.theta = vbc.task.accRadians;
            }
            else
            {
                // Apply the Complementary Filter:
                //  - high-pass filter = theta * alpha: allows short-duration signals to pass while filtering steady signals (trying to cancel drift)
                //  - low-pass filter = accel * (1 - alpha): lets the long-term changes through, filtering out short term fluctuations
                vbc.task.theta.X = vbc.task.theta.X * vbc.task.IMU_AlphaFilter + vbc.task.accRadians.X * (1 - vbc.task.IMU_AlphaFilter);
                vbc.task.theta.Y = vbc.task.accRadians.Y;
                vbc.task.theta.Z = vbc.task.theta.Z * vbc.task.IMU_AlphaFilter + vbc.task.accRadians.Z * (1 - vbc.task.IMU_AlphaFilter);
            }
            double x1 = -(90 + vbc.task.accRadians.X * 57.2958);
            double x2 = -(90 + vbc.task.theta.X * 57.2958);
            double y1 = vbc.task.accRadians.Y - Math.PI;
            if (vbc.task.accRadians.X < 0) y1 *= -1;
            strOut = "Angles in degree to gravity (before velocity filter)" + "\n" +
                     x1.ToString(vbc.fmt1) + "\t" + (y1 * 57.2958).ToString(vbc.fmt1) + "\t" + (vbc.task.accRadians.Z * 57.2958).ToString(vbc.fmt1) +
                     x1.ToString(vbc.fmt1) + "\t" + (y1 * 57.2958).ToString(vbc.fmt1) + "\t" + (vbc.task.accRadians.Z * 57.2958).ToString(vbc.fmt1) + "\n" +
                     "Velocity-Filtered Angles to gravity in degrees" + "\n" +
                     x2.ToString(vbc.fmt1) + "\t" + (y1 * 57.2958).ToString(vbc.fmt1) + "\t" + (vbc.task.theta.Z * 57.2958).ToString(vbc.fmt1) + "\n";
            strOut += "cx = " + vbc.task.gMat.cx.ToString(vbc.fmt3) + " sx = " + vbc.task.gMat.sx.ToString(vbc.fmt3) + "\n" +
                      "cy = " + vbc.task.gMat.cy.ToString(vbc.fmt3) + " sy = " + vbc.task.gMat.sy.ToString(vbc.fmt3) + "\n" +
                      "cz = " + vbc.task.gMat.cz.ToString(vbc.fmt3) + " sz = " + vbc.task.gMat.sz.ToString(vbc.fmt3);
            vbc.task.accRadians = vbc.task.theta;
            if (vbc.task.accRadians.Y > Math.PI / 2) vbc.task.accRadians.Y -= (float)Math.PI / 2;
            vbc.task.accRadians.Z += (float)Math.PI / 2;
            SetTrueText(strOut);
        }
    }




    public class IMU_BasicsKalman_CS : VB_Parent
    {
        double lastTimeStamp;
        Kalman_Basics kalman = new Kalman_Basics();
        public IMU_BasicsKalman_CS()
        {
            desc = "Read and display the IMU coordinates";
        }
        public void RunAlg(Mat src)
        {
            Point3f gyroAngle;
            if (vbc.task.optionsChanged)
            {
                lastTimeStamp = vbc.task.IMU_TimeStamp;
            }
            else
            {
                gyroAngle = vbc.task.IMU_AngularVelocity;
                double dt_gyro = (vbc.task.IMU_TimeStamp - lastTimeStamp) / 1000;
                if (vbc.task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i") dt_gyro /= 1000; // different units in the timestamp?
                gyroAngle = gyroAngle * dt_gyro;
                lastTimeStamp = vbc.task.IMU_TimeStamp;
            }
            // NOTE: Initialize the angle around the y-axis to zero.
            cv.Point3f g = vbc.task.IMU_RawAcceleration;
            vbc.task.accRadians = new Point3f((float)Math.Atan2(g.X, Math.Sqrt(g.Y * g.Y + g.Z * g.Z)),
                                         (float)Math.Abs(Math.Atan2(g.X, g.Y)), (float)Math.Atan2(g.Y, g.Z));
            kalman.kInput = new float[] { vbc.task.accRadians.X, vbc.task.accRadians.Y, vbc.task.accRadians.Z };
            kalman.Run(null);
            vbc.task.accRadians = new Point3f(kalman.kOutput[0], kalman.kOutput[1], kalman.kOutput[2]);
            double x1 = -(90 + vbc.task.accRadians.X * 57.2958);
            double y1 = vbc.task.accRadians.Y - Math.PI;
            if (vbc.task.accRadians.X < 0) y1 *= -1;
            strOut = "Angles in degree to gravity (before velocity filter)" + "\n" +
                     x1.ToString(vbc.fmt1) + "\t" + (y1 * 57.2958).ToString(vbc.fmt1) + "\t" + (vbc.task.accRadians.Z * 57.2958).ToString(vbc.fmt1) + "\n";
            strOut += "cx = " + vbc.task.gMat.cx.ToString(vbc.fmt3) + " sx = " + vbc.task.gMat.sx.ToString(vbc.fmt3) + "\n" +
                      "cy = " + vbc.task.gMat.cy.ToString(vbc.fmt3) + " sy = " + vbc.task.gMat.sy.ToString(vbc.fmt3) + "\n" +
                      "cz = " + vbc.task.gMat.cz.ToString(vbc.fmt3) + " sz = " + vbc.task.gMat.sz.ToString(vbc.fmt3);
            if (vbc.task.accRadians.Y > Math.PI / 2) vbc.task.accRadians.Y -= (float)Math.PI / 2;
            vbc.task.accRadians.Z += (float)Math.PI / 2;
            SetTrueText(strOut);
        }
    }




    public class IMU_BasicsWithOptions_CS : VB_Parent
    {
        double lastTimeStamp;
        Options_IMU options = new Options_IMU();
        public IMU_BasicsWithOptions_CS()
        {
            desc = "Read and display the IMU coordinates";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Point3f gyroAngle;
            if (vbc.task.optionsChanged)
            {
                lastTimeStamp = vbc.task.IMU_TimeStamp;
            }
            else
            {
                gyroAngle = vbc.task.IMU_AngularVelocity;
                double dt_gyro = (vbc.task.IMU_TimeStamp - lastTimeStamp) / 1000;
                if (vbc.task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i") dt_gyro /= 1000; // different units in the timestamp?
                gyroAngle = gyroAngle * dt_gyro;
                vbc.task.theta += new Point3f(-gyroAngle.Z, -gyroAngle.Y, gyroAngle.X);
                lastTimeStamp = vbc.task.IMU_TimeStamp;
            }
            // NOTE: Initialize the angle around the y-axis to zero.
            cv.Point3f g = vbc.task.IMU_RawAcceleration;
            vbc.task.accRadians = new Point3f((float)Math.Atan2(g.X, Math.Sqrt(g.Y * g.Y + g.Z * g.Z)),
                                          (float)Math.Abs(Math.Atan2(g.X, g.Y)), (float)Math.Atan2(g.Y, g.Z));
            if (vbc.task.optionsChanged)
            {
                vbc.task.theta = vbc.task.accRadians;
            }
            else
            {
                // Apply the Complementary Filter:
                //  - high-pass filter = theta * alpha: allows short-duration signals to pass while filtering steady signals (trying to cancel drift)
                //  - low-pass filter = accel * (1 - alpha): lets the long-term changes through, filtering out short term fluctuations
                vbc.task.theta.X = vbc.task.theta.X * vbc.task.IMU_AlphaFilter + vbc.task.accRadians.X * (1 - vbc.task.IMU_AlphaFilter);
                vbc.task.theta.Y = vbc.task.accRadians.Y;
                vbc.task.theta.Z = vbc.task.theta.Z * vbc.task.IMU_AlphaFilter + vbc.task.accRadians.Z * (1 - vbc.task.IMU_AlphaFilter);
            }
            double x1 = -(90 + vbc.task.accRadians.X * 57.2958);
            double x2 = -(90 + vbc.task.theta.X * 57.2958);
            double y1 = vbc.task.accRadians.Y - Math.PI;
            if (vbc.task.accRadians.X < 0) y1 *= -1;
            strOut = "Angles in degree to gravity (before velocity filter)" + "\n" +
                     x1.ToString(vbc.fmt1) + "\t" + (y1 * 57.2958).ToString(vbc.fmt1) + "\t" + (vbc.task.accRadians.Z * 57.2958).ToString(vbc.fmt1) + "\n" +
                     "Velocity-Filtered Angles to gravity in degrees" + "\n" +
                     x2.ToString(vbc.fmt1) + "\t" + (y1 * 57.2958).ToString(vbc.fmt1) + "\t" + (vbc.task.theta.Z * 57.2958).ToString(vbc.fmt1) + "\n";
            SetTrueText(strOut);
            vbc.task.accRadians = vbc.task.theta;
            if (vbc.task.accRadians.Y > Math.PI / 2) vbc.task.accRadians.Y -= (float)Math.PI / 2;
            vbc.task.accRadians.Z += (float)Math.PI / 2;
            SetTrueText(strOut);
        }
    }




    public class IMU_GMatrix_CS : VB_Parent
    {
        public float cx = 1, sx = 0, cy = 1, sy = 0, cz = 1, sz = 0;
        public Mat gMatrix;
        public IMU_GMatrix_CS()
        {
            desc = "Find the angle of tilt for the camera with respect to gravity.";
        }
        void buildGmatrix()
        {
            //[cx -sx    0]  [1  0   0 ] 
            //[sx  cx    0]  [0  cz -sz]
            //[0   0     1]  [0  sz  cz]
            float[,] gArray = {{cx * 1 + -sx * 0 + 0 * 0, cx * 0 + -sx * cz + 0 * sz, cx * 0 + -sx * -sz + 0 * cz},
                           {sx * 1 + cx * 0 + 0 * 0, sx * 0 + cx * cz + 0 * sz, sx * 0 + cx * -sz + 0 * cz},
                           {0 * 1 + 0 * 0 + 1 * 0, 0 * 0 + 0 * cz + 1 * sz, 0 * 0 + 0 * -sz + 1 * cz}};
            float g1 = gArray[0, 0] * cy + gArray[0, 1] * 0 + gArray[0, 2] * sy;
            float g2 = gArray[0, 0] * 0 + gArray[0, 1] * 1 + gArray[0, 2] * 0;
            float g3 = gArray[0, 0] * -sy + gArray[0, 1] * 0 + gArray[0, 2] * cy;
            float g4 = gArray[1, 0] * cy + gArray[1, 1] * 0 + gArray[1, 2] * sy;
            float g5 = gArray[1, 0] * 0 + gArray[1, 1] * 1 + gArray[1, 2] * 0;
            float g6 = gArray[1, 0] * -sy + gArray[1, 1] * 0 + gArray[1, 2] * cy;
            float g7 = gArray[2, 0] * cy + gArray[2, 1] * 0 + gArray[2, 2] * sy;
            float g8 = gArray[2, 0] * 0 + gArray[2, 1] * 1 + gArray[2, 2] * 0;
            float g9 = gArray[2, 0] * -sy + gArray[2, 1] * 0 + gArray[2, 2] * cy;
            float[] tmp = new float[] { g1, g2, g3, g4, g5, g6, g7, g8, g9 };
            gMatrix = cv.Mat.FromPixelData(3, 3, MatType.CV_32F, tmp);
        }
        public void RunAlg(Mat src)
        {
            //[cos(a) -sin(a)    0]
            //[sin(a)  cos(a)    0]
            //[0       0         1] rotate the point cloud around the x-axis.
            cz = (float)Math.Cos(vbc.task.accRadians.Z);
            sz = (float)Math.Sin(vbc.task.accRadians.Z);
            //[1       0         0      ] rotate the point cloud around the z-axis.
            //[0       cos(a)    -sin(a)]
            //[0       sin(a)    cos(a) ]
            cx = (float)Math.Cos(vbc.task.accRadians.X);
            sx = (float)Math.Sin(vbc.task.accRadians.X);
            buildGmatrix();
            cv.Point3f g = vbc.task.IMU_Acceleration;
            string fmt = vbc.fmt3;
            strOut = "IMU Acceleration in X-direction = " + "\t" + g.X.ToString(fmt) + "\n"
                     + "IMU Acceleration in Y-direction = " + "\t" + g.Y.ToString(fmt) + "\n"
                     + "IMU Acceleration in Z-direction = " + "\t" + g.Z.ToString(fmt) + "\n" + "\n"
                     + "\n" + "sqrt (" + "\t" + g.X.ToString(fmt) + "*" + g.X.ToString(fmt) + "\t" +
                     g.Y.ToString(fmt) + "*" + g.Y.ToString(fmt) + "\t" +
                     g.Z.ToString(fmt) + "*" + g.Z.ToString(fmt) + " ) = " + "\t" +
                     (Math.Sqrt(g.X * g.X + g.Y * g.Y + g.Z * g.Z)).ToString(fmt) + "\n" +
                     "Should be close to the earth's gravitational constant of 9.807 (or the camera was moving.)";
            strOut += "\n" + "Gravity-oriented gMatrix - move camera to test this:" + "\n" + gMatrixToStr(gMatrix);
            SetTrueText(strOut);
            vbc.task.gMatrix = gMatrix;
        }
    }




    public class IMU_Stabilize_CS : VB_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        public IMU_Stabilize_CS()
        {
            kalman.kInput = new float[3];
            desc = "Stabilize IMU acceleration data.";
            labels = new string[] { "", "", "IMU Stabilize (move camera around)", "Difference from Color Image" };
        }
        public void RunAlg(Mat src)
        {
            int borderCrop = 5;
            int vert_Border = borderCrop * src.Rows / src.Cols;
            double dx = vbc.task.IMU_AngularVelocity.X;
            double dy = vbc.task.IMU_AngularVelocity.Y;
            double dz = vbc.task.IMU_AngularVelocity.Z;
            double sx = 1; // assume no scaling is taking place.
            double sy = 1; // assume no scaling is taking place.
            kalman.kInput = new float[] { (float)dx, (float)dy, (float)dz };
            kalman.Run(src);
            dx = kalman.kOutput[0];
            dy = kalman.kOutput[1];
            dz = kalman.kOutput[2];
            Mat smoothedMat = cv.Mat.FromPixelData(2, 3, MatType.CV_64F, new double[] {
            sx * Math.Cos(dz), sx * -Math.Sin(dz), dx,
            sy * Math.Sin(dz), sy * Math.Cos(dz), dy });
            Mat smoothedFrame = src.WarpAffine(smoothedMat, src.Size());
            smoothedFrame = smoothedFrame.RowRange(borderCrop, smoothedFrame.Rows - borderCrop).ColRange(borderCrop, smoothedFrame.Cols - borderCrop);
            dst2 = smoothedFrame.Resize(src.Size());
            Cv2.Subtract(src, dst2, dst3);
            string Text = "dx = " + dx.ToString(vbc.fmt2) + "\n" + "dy = " + dy.ToString(vbc.fmt2) + "\n" + "dz = " + dz.ToString(vbc.fmt2);
            SetTrueText(Text, new cv.Point(10, 10), 3);
        }
    }




    public class IMU_PlotIMUFrameTime_CS : VB_Parent
    {
        Plot_OverTime plot = new Plot_OverTime();
        public double CPUInterval;
        public double IMUtoCaptureEstimate;
        Options_IMUFrameTime options = new Options_IMUFrameTime();
        double imuTotalTime;
        int allZeroCount;
        public IMU_PlotIMUFrameTime_CS()
        {
            plot.dst2 = dst3;
            plot.maxScale = 40;
            plot.minScale = -10;
            plot.plotCount = 4;
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Use the IMU timestamp to estimate the delay from IMU capture to image capture.  Just an estimate!";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int IMUanchor = (int)vbc.task.IMU_FrameTime;
            int[] histogramIMU = new int[plot.maxScale];
            // there can be some errant times at startup.
            if (vbc.task.IMU_FrameTime >= histogramIMU.Length) vbc.task.IMU_FrameTime = plot.maxScale;
            if (vbc.task.IMU_FrameTime < 0) vbc.task.IMU_FrameTime = 0;
            imuTotalTime += vbc.task.IMU_FrameTime;
            if (imuTotalTime == 0)
            {
                allZeroCount++;
                if (allZeroCount > 20)
                {
                    SetTrueText("Is IMU present?  No IMU FrameTimes");
                    allZeroCount = int.MinValue; // don't show message again.
                }
                return; // if the IMU frametime was 0, then no new IMU data was generated (or it is unsupported!)
            }
            int maxval = int.MinValue;
            for (int i = 0; i < histogramIMU.Length; i++)
            {
                if (maxval < histogramIMU[i])
                {
                    maxval = histogramIMU[i];
                    IMUanchor = i;
                }
            }
            int imuFrameTime = (int)vbc.task.IMU_FrameTime;
            if (IMUanchor != 0) imuFrameTime = imuFrameTime % IMUanchor;
            IMUtoCaptureEstimate = IMUanchor - imuFrameTime + options.minDelayIMU;
            if (IMUtoCaptureEstimate > IMUanchor) IMUtoCaptureEstimate -= IMUanchor;
            if (IMUtoCaptureEstimate < options.minDelayIMU) IMUtoCaptureEstimate = options.minDelayIMU;
            double sampledIMUFrameTime = vbc.task.IMU_FrameTime;
            if (vbc.task.heartBeat) sampledIMUFrameTime = vbc.task.IMU_FrameTime;
            histogramIMU[Math.Min((int)vbc.task.IMU_FrameTime, histogramIMU.Length - 1)]++;
            if (standaloneTest())
            {
                string output = "IMU_TimeStamp (ms) " + vbc.task.IMU_TimeStamp.ToString("00") + "\n" +
                                "CPU TimeStamp (ms) " + vbc.task.CPU_TimeStamp.ToString("00") + "\n" +
                                "IMU Frametime (ms, sampled) " + sampledIMUFrameTime.ToString("000.00") +
                                " IMUanchor = " + IMUanchor.ToString("00") +
                                " latest = " + vbc.task.IMU_FrameTime.ToString("00.00") + "\n" +
                                "IMUtoCapture (ms, sampled, in red) " + IMUtoCaptureEstimate.ToString("00") + "\n" + "\n" +
                                "IMU Frame Time = Blue" + "\n" +
                                "Host Frame Time = Green" + "\n" +
                                "IMU Total Delay = Red" + "\n" +
                                "IMU Anchor Frame Time = White (IMU Frame Time that occurs most often" + "\n" + "\n" + "\n";
                plot.plotData = new Scalar(vbc.task.IMU_FrameTime, vbc.task.CPU_FrameTime, IMUtoCaptureEstimate, IMUanchor);
                plot.Run(null);
                if (plot.maxScale - plot.minScale > histogramIMU.Length) Array.Resize(ref histogramIMU, plot.maxScale - plot.minScale);
                if (plot.lastXdelta.Count() > options.plotLastX)
                {
                    for (int i = 0; i < plot.plotCount; i++)
                    {
                        string timeLabel = " IMU FrameTime ";
                        if (i == 1) timeLabel = " Host Frame Time ";
                        if (i == 2) timeLabel = " IMUtoCapture ms ";
                        if (i == 3) timeLabel = " IMU Center time ";

                        output += "Last " + options.plotLastX + timeLabel + "\t";
                        for (int j = plot.lastXdelta.Count() - options.plotLastX - 1; j < plot.lastXdelta.Count() - 1; j++)
                        {
                            output += plot.lastXdelta[j][i].ToString("00") + ", ";
                        }
                        output += "\n";
                    }
                }
                SetTrueText(output);
            }
        }
    }




    public class IMU_PlotTotalDelay_CS : VB_Parent
    {
        IMU_PlotHostFrameTimes host = new IMU_PlotHostFrameTimes();
        IMU_PlotIMUFrameTime imu = new IMU_PlotIMUFrameTime();
        Plot_OverTime plot = new Plot_OverTime();
        Kalman_Single kalman = new Kalman_Single();
        TrackBar countSlider;
        double sampledCPUDelay = 0;
        double sampledIMUDelay = 0;
        double sampledTotalDelay = 0;
        double sampledSmooth = 0;
        public IMU_PlotTotalDelay_CS()
        {
            countSlider = FindSlider("Number of Plot Values");
            plot.dst2 = dst3;
            plot.maxScale = 50;
            plot.minScale = 0;
            plot.plotCount = 4;
            labels[2] = "Timing data - total (white) right image";
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Estimate time from IMU capture to host processing to allow predicting effect of camera motion.";
        }
        public void RunAlg(Mat src)
        {
            int plotLastX = countSlider.Value;
            host.Run(src);
            imu.Run(src);
            double totaldelay = host.HostInterruptDelayEstimate + imu.IMUtoCaptureEstimate;
            kalman.inputReal = (float)totaldelay;
            kalman.Run(src);
            if (vbc.task.FirstPass)
            {
                sampledCPUDelay = host.HostInterruptDelayEstimate;
                sampledIMUDelay = imu.IMUtoCaptureEstimate;
                sampledTotalDelay = totaldelay;
                sampledSmooth = kalman.stateResult;
            }
            if (vbc.task.heartBeat)
            {
                sampledCPUDelay = host.HostInterruptDelayEstimate;
                sampledIMUDelay = imu.IMUtoCaptureEstimate;
                sampledTotalDelay = totaldelay;
                sampledSmooth = kalman.stateResult;
            }
            string output = "Estimated host delay (ms, sampled) " + string.Format("{0:00}", sampledCPUDelay) + "\n" +
                            "Estimated IMU delay (ms, sampled) " + string.Format("{0:00}", sampledIMUDelay) + "\n" +
                            "Estimated Total delay (ms, sampled) " + string.Format("{0:00}", sampledTotalDelay) + "\n" +
                            "Estimated Total delay Smoothed (ms, sampled, in White) " + string.Format("{0:00}", sampledSmooth) + "\n" + "\n" +
                            "Blue" + "\t" + "IMU Frame Time" + "\n" +
                            "Green" + "\t" + "Host Frame Time" + "\n" +
                            "Red" + "\t" + "Host+IMU Total Delay (latency)" + "\n" +
                            "White" + "\t" + "Host+IMU Anchor Frame Time (Host Frame Time that occurs most often)" + "\n" + "\n" + "\n";
            plot.plotData = new Scalar(imu.IMUtoCaptureEstimate, host.HostInterruptDelayEstimate, totaldelay, kalman.stateResult);
            plot.Run(empty);
            if (plot.lastXdelta.Count() > plotLastX)
            {
                for (int i = 0; i < plot.plotCount; i++)
                {
                    string timeLabel = " IMU Delay ";
                    if (i == 1) timeLabel = " Host Delay ";
                    if (i == 2) timeLabel = " Total Delay ms ";
                    if (i == 3) timeLabel = " Smoothed Total ";
                    output += "Last " + plotLastX + timeLabel + "\t";
                    for (int j = plot.lastXdelta.Count() - plotLastX - 1; j < plot.lastXdelta.Count(); j++)
                    {
                        output += string.Format("{0:00}", plot.lastXdelta[j][i]) + ", ";
                    }
                    output += "\n";
                }
            }
            SetTrueText(output);
        }
    }




    public class IMU_VerticalAngles_CS : VB_Parent
    {
        Line_GCloud vert = new Line_GCloud();
        public IMU_VerticalAngles_CS()
        {
            labels = new[] { "", "", "Highlighted vertical lines", "Line details" };
            desc = "Compare the IMU changes to the angle changes in the vertical lines.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            vert.Run(src);
            string strOut = "ID" + "\t" + "len3D" + "\t" + "Depth" + "\t" + "Arc X" + "\t" + "Arc Y" + "\t" + "Arc Z" + "\t" + "IMU X" + "\t" + "IMU Y" + "\t" + "IMU Z" + "\n";
            dst3.SetTo(0);
            for (int i = 0; i < vert.sortedVerticals.Count(); i++)
            {
                var gc = vert.sortedVerticals.ElementAt(i).Value;
                strOut += i + "\t" + string.Format("{0}", gc.len3D) + "m" + "\t" + string.Format("{0}", gc.tc1.depth) + "m" + "\t" +
                          string.Format("{0}", gc.arcX) + "\t" + string.Format("{0}", gc.arcY) + "\t" + string.Format("{0}", gc.arcZ) + "\t";
                strOut += string.Format("{0}", vbc.task.accRadians.X * 57.2958) + "\t" + string.Format("{0}", vbc.task.accRadians.Y * 57.2958) + "\t" + string.Format("{0}", vbc.task.accRadians.Z * 57.2958) + "\t" + "\n";
                cv.Point pt = new cv.Point(gc.tc1.center.X, gc.tc1.center.Y);
                SetTrueText(i.ToString(), pt, 2);
                SetTrueText(i.ToString(), pt, 3);
                DrawLine(dst2, gc.tc1.center, gc.tc2.center, vbc.task.HighlightColor, vbc.task.lineWidth);
                DrawLine(dst3, gc.tc1.center, gc.tc2.center, Scalar.White, vbc.task.lineWidth);
            }
            SetTrueText(strOut, 3);
        }
    }




    public class IMU_PlotGravityAngles_CS : VB_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public IMU_PlotGravityAngles_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Plot the motion of the camera based on the IMU data in degrees";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("ts = " + string.Format("{0}", vbc.task.IMU_TimeStamp) + "\n" + "X degrees = " + string.Format("{0}", vbc.task.accRadians.X * 57.2958) + "\n" +
                        "Y degrees = " + string.Format("{0}", Math.Abs(vbc.task.accRadians.Y * 57.2958)) + "\n" + "Z degrees = " + string.Format("{0}", vbc.task.accRadians.Z * 57.2958) + "\n" + "\n" +
                        "Motion (radians/sec) " + "\n" + "pitch = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.X) + "\n" +
                        "Yaw = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.Y) + "\n" + " Roll = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.Z), 1);
            plot.plotData = new Scalar(vbc.task.accRadians.X * 57.2958, vbc.task.accRadians.Y * 57.2958, vbc.task.accRadians.Z * 57.2958);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }




    public class IMU_PlotAngularVelocity_CS : VB_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public IMU_PlotAngularVelocity_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Plot the IMU Velocity over time.";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("ts = " + string.Format("{0}", vbc.task.IMU_TimeStamp) + "\n" + "X m/sec^2 = " + string.Format("{0}", vbc.task.IMU_Acceleration.X) + "\n" +
                        "Y m/sec^2 = " + string.Format("{0}", vbc.task.IMU_Acceleration.Y) + "\n" + "Z m/sec^2 = " + string.Format("{0}", vbc.task.IMU_Acceleration.Z) + "\n" + "\n" +
                        "Motion (radians/sec) " + "\n" + "X - Pitch = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.X) + "\n" +
                        "Y - Yaw = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.Y) + "\n" + "Z - Roll = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.Z) + "\n" + "\n" +
                        "Move the camera to move values off of zero...", 1);
            plot.plotData = new Scalar(vbc.task.IMU_AngularVelocity.X, vbc.task.IMU_AngularVelocity.Y, vbc.task.IMU_AngularVelocity.Z);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }





    public class IMU_Lines_CS : VB_Parent
    {
        Line_GCloud vert = new Line_GCloud();
        Kalman_Basics kalman = new Kalman_Basics();
        gravityLine lastGcell;
        public IMU_Lines_CS()
        {
            labels[2] = "Vertical lines in Blue and horizontal lines in Yellow";
            desc = "Find the vertical and horizontal lines";
        }
        public void RunAlg(Mat src)
        {
            vert.Run(src);
            dst2 = vert.dst2;
            gravityLine gcell;
            var cells = vert.sortedVerticals;
            if (cells.Count() > 0) gcell = cells.ElementAt(0).Value; else gcell = lastGcell;
            if (gcell.len3D > 0)
            {
                string strOut = "ID" + "\t" + "len3D" + "\t" + "Depth" + "\t" + "Arc Y" + "\t" + "Image" + "\t" + "IMU Y" + "\t" + "\n";
                if (vbc.task.heartBeat) dst3.SetTo(0);
                var p1 = gcell.tc1.center;
                var p2 = gcell.tc2.center;
                var lastP1 = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
                var lastp2 = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
                kalman.kInput = new float[] { p1.X, p1.Y, p2.X, p2.Y };
                kalman.Run(empty);
                p1 = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
                p2 = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
                DrawCircle(dst2, p1, vbc.task.DotSize, vbc.task.HighlightColor);
                DrawCircle(dst2, p2, vbc.task.DotSize, vbc.task.HighlightColor);
                DrawCircle(dst3, p1, vbc.task.DotSize, Scalar.White);
                DrawCircle(dst3, p2, vbc.task.DotSize, Scalar.White);
                lastGcell = gcell;
                strOut += "0" + "\t" + string.Format("{0}", gcell.len3D) + "m" + "\t" +
                                                    string.Format("{0}", gcell.tc1.depth) + "m" + "\t" +
                                                    string.Format("{0}", gcell.arcY) + "\t" +
                                                    string.Format("{0}", gcell.imageAngle) + "\t";
                strOut += string.Format("{0}", vbc.task.accRadians.Y * 57.2958) + "\n";
                SetTrueText(strOut, 3);
                labels[2] = vert.labels[3];
            }
        }
    }




    public class IMU_PlotAcceleration_CS : VB_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public IMU_PlotAcceleration_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Plot the IMU Acceleration in m/Sec^2 over time.";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("ts = " + string.Format("{0}", vbc.task.IMU_TimeStamp) + "\n" + "X m/sec^2 = " + string.Format("{0}", vbc.task.IMU_Acceleration.X) + "\n" +
                        "Y m/sec^2 = " + string.Format("{0}", vbc.task.IMU_Acceleration.Y) + "\n" + "Z m/sec^2 = " + string.Format("{0}", vbc.task.IMU_Acceleration.Z) + "\n" + "\n" +
                        "Motion (radians/sec) " + "\n" + "pitch = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.X) + "\n" +
                        "Yaw = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.Y) + "\n" + " Roll = " + string.Format("{0}", vbc.task.IMU_AngularVelocity.Z), 1);
            plot.plotData = new Scalar(vbc.task.IMU_Acceleration.X, vbc.task.IMU_Acceleration.Y, vbc.task.IMU_Acceleration.Z);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }




    public class IMU_Average_CS : VB_Parent
    {
        List<Scalar> accList = new List<Scalar>();
        public IMU_Average_CS()
        {
            desc = "Average the IMU Acceleration values over the previous X images.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) accList.Clear();
            accList.Add(new cv.Scalar(vbc.task.IMU_RawAcceleration.X, vbc.task.IMU_RawAcceleration.Y, vbc.task.IMU_RawAcceleration.Z));
            var accMat = cv.Mat.FromPixelData(accList.Count(), 1, MatType.CV_64FC4, accList.ToArray());
            var imuMean = accMat.Mean();
            vbc.task.IMU_AverageAcceleration = new Point3f((float)imuMean[0], (float)imuMean[1], (float)imuMean[2]);
            if (accList.Count() >= vbc.task.frameHistoryCount) accList.RemoveAt(0);
            string strOut = "Average IMU acceleration: " + "\n" + string.Format("{0}", vbc.task.IMU_AverageAcceleration.X) + "\t" + string.Format("{0}", vbc.task.IMU_AverageAcceleration.Y) + "\t" +
                            string.Format("{0}", vbc.task.IMU_AverageAcceleration.Z) + "\n";
            SetTrueText(strOut);
        }
    }




    public class IMU_PlotCompareIMU_CS : VB_Parent
    {
        Plot_OverTimeScalar[] plot = new Plot_OverTimeScalar[3];
        IMU_AllMethods imuAll = new IMU_AllMethods();
        public IMU_PlotCompareIMU_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay0();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            for (int i = 0; i < plot.Length; i++)
            {
                plot[i] = new Plot_OverTimeScalar();
                plot[i].plotCount = 4;
            }
            labels = new string[] { "IMU Acceleration in X", "IMU Acceleration in Y", "IMU Acceleration in Z", "" };
            desc = "imre the results of the raw IMU data with the same values after Kalman";
        }
        public void RunAlg(Mat src)
        {
            imuAll.Run(empty);
            plot[0].plotData = new Scalar(vbc.task.IMU_RawAcceleration.X, vbc.task.IMU_Acceleration.X, vbc.task.kalmanIMUacc.X, vbc.task.IMU_AverageAcceleration.X);
            plot[0].Run(empty);
            dst0 = plot[0].dst2;
            plot[1].plotData = new Scalar(vbc.task.IMU_RawAcceleration.Y, vbc.task.IMU_Acceleration.Y, vbc.task.kalmanIMUacc.Y, vbc.task.IMU_AverageAcceleration.Y);
            plot[1].Run(empty);
            dst1 = plot[1].dst2;
            plot[2].plotData = new Scalar(vbc.task.IMU_RawAcceleration.Z, vbc.task.IMU_Acceleration.Z, vbc.task.kalmanIMUacc.Z, vbc.task.IMU_AverageAcceleration.Z);
            plot[2].Run(empty);
            dst2 = plot[2].dst2;
            SetTrueText("Blue (usually hidden) is the raw signal" + "\n" + "Green (usually hidden) is the Velocity-filtered results" + "\n" +
                        "Red is the Kalman IMU data" + "\n" + "White is the IMU Averaging output (note delay from Kalman output)" + "\n" + "\n" +
                        "Move the camera around to see the impact on the IMU data." + "\n" +
                        "Adjust the global option 'Frame History' to see the impact." + "\n" + "\n" +
                        "Remember that IMU Data filtering only impacts the X and Z values." + "\n" +
                        "Averaging seems to track closer but is not as timely.", 3);
        }
    }




    public class IMU_Kalman_CS : VB_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        public IMU_Kalman_CS()
        {
            desc = "Use Kalman Filter to stabilize the IMU acceleration and velocity";
        }
        public void RunAlg(Mat src)
        {
            kalman.kInput = new float[] { vbc.task.IMU_RawAcceleration.X, vbc.task.IMU_RawAcceleration.Y, vbc.task.IMU_RawAcceleration.Z,
                                       vbc.task.IMU_RawAngularVelocity.X, vbc.task.IMU_RawAngularVelocity.Y, vbc.task.IMU_RawAngularVelocity.Z };
            kalman.Run(empty);
            vbc.task.kalmanIMUacc = new Point3f(kalman.kOutput[0], kalman.kOutput[1], kalman.kOutput[2]);
            vbc.task.kalmanIMUvelocity = new Point3f(kalman.kOutput[3], kalman.kOutput[4], kalman.kOutput[5]);
            string strOut = "IMU Acceleration Raw" + "\t" + "IMU Velocity Raw" + "\n" +
                            string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t", vbc.task.IMU_RawAcceleration.X, vbc.task.IMU_RawAcceleration.Y, vbc.task.IMU_RawAcceleration.Z, vbc.task.IMU_RawAngularVelocity.X, vbc.task.IMU_RawAngularVelocity.Y, vbc.task.IMU_RawAngularVelocity.Z) + "\n" + "\n" +
                            "kalmanIMUacc" + "\t" + "\t" + "kalmanIMUvelocity" + "\n" +
                            string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t", vbc.task.kalmanIMUacc.X, vbc.task.kalmanIMUacc.Y, vbc.task.kalmanIMUacc.Z, vbc.task.kalmanIMUvelocity.X, vbc.task.kalmanIMUvelocity.Y, vbc.task.kalmanIMUvelocity.Z);
            SetTrueText(strOut);
        }
    }




    public class IMU_AllMethods_CS : VB_Parent
    {
        IMU_Basics basics = new IMU_Basics();
        IMU_Average imuAvg = new IMU_Average();
        IMU_Kalman kalman = new IMU_Kalman();
        public IMU_AllMethods_CS()
        {
            desc = "Compute the IMU acceleration using all available methods - raw, Kalman, averaging, and velocity-filtered.";
        }
        public void RunAlg(Mat src)
        {
            basics.Run(empty);
            kalman.Run(empty);
            imuAvg.Run(empty);
            SetTrueText(basics.strOut + "\n" + kalman.strOut + "\n" + "\n" + imuAvg.strOut, 2);
        }
    }




    public class IMU_VelocityPlot_CS : VB_Parent
    {
        IMU_Plot plot = new IMU_Plot();
        public IMU_VelocityPlot_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Plot the angular velocity";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.pitch = vbc.task.IMU_AngularVelocity.X;
            vbc.task.yaw = vbc.task.IMU_AngularVelocity.Y;
            vbc.task.roll = vbc.task.IMU_AngularVelocity.Z;
            plot.blueA = vbc.task.pitch * 1000;
            plot.greenA = vbc.task.yaw * 1000;
            plot.redA = vbc.task.roll * 1000;
            plot.labels[2] = "pitch X 1000 (blue), Yaw X 1000 (green), and roll X 1000 (red)";
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            if (vbc.task.heartBeat)
            {
                strOut = "Pitch X1000 (blue): " + "\t" + (vbc.task.pitch * 1000).ToString(vbc.fmt1) + "\n" +
                         "Yaw X1000 (green): " + "\t" + (vbc.task.yaw * 1000).ToString(vbc.fmt1) + "\n" +
                         "Roll X1000 (red): " + "\t" + (vbc.task.roll * 1000).ToString(vbc.fmt1);
            }
            SetTrueText(strOut, 1);
        }
    }




    public class IMU_IscameraStable_CS : VB_Parent
    {
        IMU_Plot plot = new IMU_Plot();
        Options_IMU options = new Options_IMU();
        public IMU_IscameraStable_CS()
        {
            desc = "Track the standard deviation of the angular velocities.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            vbc.task.pitch = vbc.task.IMU_AngularVelocity.X;
            vbc.task.yaw = vbc.task.IMU_AngularVelocity.Y;
            vbc.task.roll = vbc.task.IMU_AngularVelocity.Z;
            if (vbc.task.heartBeat)
            {
                strOut = "Pitch X1000 (blue): " + "\t" + (vbc.task.pitch * 1000).ToString(vbc.fmt1) + "\n" +
                         "Yaw X1000 (green): " + "\t" + (vbc.task.yaw * 1000).ToString(vbc.fmt1) + "\n" +
                         "Roll X1000 (red): " + "\t" + (vbc.task.roll * 1000).ToString(vbc.fmt1);
            }
            SetTrueText(strOut, 3);
        }
    }




    public class IMU_PlotHostFrameTimes_CS : VB_Parent
    {
        public Plot_OverTime plot = new Plot_OverTime();
        public double CPUInterval;
        public double HostInterruptDelayEstimate;
        Options_IMUFrameTime options = new Options_IMUFrameTime();
        int CPUanchor = 0;
        int[] hist;
        double sampledCPUFrameTime = 0;
        public IMU_PlotHostFrameTimes_CS()
        {
            plot.dst2 = dst3;
            plot.maxScale = 50;
            plot.minScale = -10;
            plot.plotCount = 4;
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Use the Host timestamp to estimate the delay from image capture to host interrupt.  Just an estimate!";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.FirstPass) CPUanchor = (int)vbc.task.CPU_FrameTime;
            if (vbc.task.FirstPass) hist = new int[plot.maxScale + 1];
            // there can be some errant times at startup.
            if (vbc.task.CPU_FrameTime > plot.maxScale) vbc.task.CPU_FrameTime = plot.maxScale;
            if (vbc.task.CPU_FrameTime < 0) vbc.task.CPU_FrameTime = 0;
            int maxval = int.MinValue;
            for (int i = 0; i < hist.Length; i++)
            {
                if (maxval < hist[i])
                {
                    maxval = hist[i];
                    CPUanchor = i;
                }
            }
            int cpuFrameTime = (int)vbc.task.CPU_FrameTime;
            if (CPUanchor != 0) cpuFrameTime = cpuFrameTime % CPUanchor;
            HostInterruptDelayEstimate = CPUanchor - cpuFrameTime + options.minDelayHost;
            if (HostInterruptDelayEstimate > CPUanchor) HostInterruptDelayEstimate -= CPUanchor;
            if (HostInterruptDelayEstimate < 0) HostInterruptDelayEstimate = options.minDelayHost;
            if (vbc.task.FirstPass) sampledCPUFrameTime = vbc.task.CPU_FrameTime;
            if (vbc.task.heartBeat) sampledCPUFrameTime = vbc.task.CPU_FrameTime;
            hist[Math.Min((int)vbc.task.CPU_FrameTime, hist.Length - 1)] += 1;
            if (standaloneTest())
            {
                string output = "IMU_TimeStamp (ms) " + vbc.task.IMU_TimeStamp.ToString("00") + "\n" +
                                "CPU TimeStamp (ms) " + vbc.task.CPU_TimeStamp.ToString("00") + "\n" +
                                "Host Frametime (ms, sampled) " + sampledCPUFrameTime.ToString("000.00") +
                                " CPUanchor = " + CPUanchor.ToString("00") +
                                " latest = " + vbc.task.CPU_FrameTime.ToString("00.00") + "\n" +
                                "Host Interrupt Delay (ms, sampled, in red) " + HostInterruptDelayEstimate.ToString("00") + "\n" + "\n" +
                                "Blue" + "\t" + "IMU Frame Time" + "\n" +
                                "Green" + "\t" + "Host Frame Time" + "\n" +
                                "Red" + "\t" + "Host Total Delay (latency)" + "\n" +
                                "White" + "\t" + "Host Anchor Frame Time (Host Frame Time that occurs most often" + "\n" + "\n" + "\n";
                plot.plotData = new Scalar(vbc.task.IMU_FrameTime, vbc.task.CPU_FrameTime, HostInterruptDelayEstimate, CPUanchor);
                plot.Run(empty);
                if (plot.maxScale - plot.minScale > hist.Length) Array.Resize(ref hist, plot.maxScale - plot.minScale + 1);
                if (plot.lastXdelta.Count() > options.plotLastX)
                {
                    for (int i = 0; i < plot.plotCount; i++)
                    {
                        string timeLabel = " IMU FrameTime ";
                        if (i == 1) timeLabel = " IMU Delay ";
                        if (i == 2) timeLabel = " Host FrameTime ";
                        if (i == 3) timeLabel = " CPUanchor FT";
                        output += "Last " + options.plotLastX.ToString() + timeLabel + "\t";
                        for (int j = plot.lastXdelta.Count() - options.plotLastX - 1; j < plot.lastXdelta.Count(); j++)
                        {
                            output += plot.lastXdelta[j][i].ToString("00") + ", ";
                        }
                        output += "\n";
                    }
                }
                SetTrueText(output);
            }
        }
    }




    public class IMU_PlotHostFrameScalar_CS : VB_Parent
    {
        public Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public double CPUInterval;
        public double HostInterruptDelayEstimate;
        Options_IMUFrameTime options = new Options_IMUFrameTime();
        double CPUanchor = 0;
        double sampledCPUFrameTime = 0;
        public IMU_PlotHostFrameScalar_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            plot.plotCount = 4;
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Use the Host timestamp to estimate the delay from image capture to host interrupt.  Just an estimate!";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.FirstPass) CPUanchor = vbc.task.CPU_FrameTime;
            int cpuFrameTime = (int)vbc.task.CPU_FrameTime;
            if (CPUanchor != 0) cpuFrameTime = (int)(cpuFrameTime % CPUanchor);
            HostInterruptDelayEstimate = CPUanchor - cpuFrameTime + options.minDelayHost;
            if (HostInterruptDelayEstimate > CPUanchor) HostInterruptDelayEstimate -= CPUanchor;
            if (HostInterruptDelayEstimate < 0) HostInterruptDelayEstimate = options.minDelayHost;
            if (vbc.task.FirstPass) sampledCPUFrameTime = vbc.task.CPU_FrameTime;
            if (vbc.task.heartBeat) sampledCPUFrameTime = vbc.task.CPU_FrameTime;
            if (standaloneTest())
            {
                string strOut = "IMU_TimeStamp (ms) " + vbc.task.IMU_TimeStamp.ToString("00") + "\n" +
                                "CPU TimeStamp (ms) " + vbc.task.CPU_TimeStamp.ToString("00") + "\n" +
                                "Host Frametime (ms, sampled) " + sampledCPUFrameTime.ToString("000.00") +
                                " CPUanchor = " + CPUanchor.ToString("00") +
                                " latest = " + vbc.task.CPU_FrameTime.ToString("00.00") + "\n" +
                                "Host Interrupt Delay (ms, sampled, in red) " + HostInterruptDelayEstimate.ToString("00") + "\n" + "\n" +
                                "Blue" + "\t" + "IMU Frame Time" + "\n" +
                                "Green" + "\t" + "Host Frame Time" + "\n" +
                                "Red" + "\t" + "Host Total Delay (latency)" + "\n" +
                                "White" + "\t" + "Host Anchor Frame Time (Host Frame Time that occurs most often" + "\n" + "\n" + "\n";
                plot.plotData = new Scalar(vbc.task.IMU_FrameTime, vbc.task.CPU_FrameTime, HostInterruptDelayEstimate, CPUanchor);
                plot.Run(empty);
                dst2 = plot.dst2;
                dst3 = plot.dst3;
                SetTrueText(strOut, 1);
            }
        }
    }




    public class IMU_GMatrixWithOptions_CS : VB_Parent
    {
        public float cx = 1, sx = 0, cy = 1, sy = 0, cz = 1, sz = 0;
        public Mat gMatrix;
        TrackBar xSlider;
        TrackBar ySlider;
        TrackBar zSlider;
        Options_IMU options = new Options_IMU();
        public IMU_GMatrixWithOptions_CS()
        {
            desc = "Find the angle of tilt for the camera with respect to gravity.";
        }
        void getSliderValues()
        {
            if (xSlider == null) xSlider = FindSlider("Rotate pointcloud around X-axis (degrees)");
            if (ySlider == null) ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            if (zSlider == null) zSlider = FindSlider("Rotate pointcloud around Z-axis (degrees)");
            cx = (float)Math.Cos(xSlider.Value * Cv2.PI / 180);
            sx = (float)Math.Sin(xSlider.Value * Cv2.PI / 180);
            cy = (float)Math.Cos(ySlider.Value * Cv2.PI / 180);
            sy = (float)Math.Sin(ySlider.Value * Cv2.PI / 180);
            cz = (float)Math.Cos(zSlider.Value * Cv2.PI / 180);
            sz = (float)Math.Sin(zSlider.Value * Cv2.PI / 180);
        }
        Mat buildGmatrix()
        {
            float[,] gArray = new float[3, 3]
            {
            { cx * 1 + -sx * 0 + 0 * 0, cx * 0 + -sx * cz + 0 * sz, cx * 0 + -sx * -sz + 0 * cz },
            { sx * 1 + cx * 0 + 0 * 0, sx * 0 + cx * cz + 0 * sz, sx * 0 + cx * -sz + 0 * cz },
            { 0 * 1 + 0 * 0 + 1 * 0, 0 * 0 + 0 * cz + 1 * sz, 0 * 0 + 0 * -sz + 1 * cz }
            };
            Mat tmpGMatrix = cv.Mat.FromPixelData(3, 3, MatType.CV_32F, new float[]
            {
            gArray[0, 0] * cy + gArray[0, 1] * 0 + gArray[0, 2] * sy,
            gArray[0, 0] * 0 + gArray[0, 1] * 1 + gArray[0, 2] * 0,
            gArray[0, 0] * -sy + gArray[0, 1] * 0 + gArray[0, 2] * cy,
            gArray[1, 0] * cy + gArray[1, 1] * 0 + gArray[1, 2] * sy,
            gArray[1, 0] * 0 + gArray[1, 1] * 1 + gArray[1, 2] * 0,
            gArray[1, 0] * -sy + gArray[1, 1] * 0 + gArray[1, 2] * cy,
            gArray[2, 0] * cy + gArray[2, 1] * 0 + gArray[2, 2] * sy,
            gArray[2, 0] * 0 + gArray[2, 1] * 1 + gArray[2, 2] * 0,
            gArray[2, 0] * -sy + gArray[2, 1] * 0 + gArray[2, 2] * cy
            });
            return tmpGMatrix;
        }
        public void RunAlg(Mat src)
        {
            if (xSlider == null) xSlider = FindSlider("Rotate pointcloud around X-axis (degrees)");
            if (ySlider == null) ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            if (zSlider == null) zSlider = FindSlider("Rotate pointcloud around Z-axis (degrees)");
            if (vbc.task.useGravityPointcloud)
            {
                cz = (float)Math.Cos(vbc.task.accRadians.Z);
                sz = (float)Math.Sin(vbc.task.accRadians.Z);
                cx = (float)Math.Cos(vbc.task.accRadians.X);
                sx = (float)Math.Sin(vbc.task.accRadians.X);
            }
            else
            {
                getSliderValues();
            }
            gMatrix = buildGmatrix();
            if (standaloneTest())
            {
                var g = vbc.task.IMU_Acceleration;
                strOut = "IMU Acceleration in X-direction = " + "\t\t" + string.Format("{0:F4}", g.X) + "\n";
                strOut += "IMU Acceleration in Y-direction = " + "\t\t" + string.Format("{0:F4}", g.Y) + "\n";
                strOut += "IMU Acceleration in Z-direction = " + "\t\t" + string.Format("{0:F4}", g.Z) + "\n\n";
                strOut += "Rotate around X-axis (in degrees) = " + "\t" + string.Format("{0:F4}", xSlider.Value) + "\n";
                strOut += "Rotate around Y-axis (in degrees) = " + "\t" + string.Format("{0:F4}", ySlider.Value) + "\n";
                strOut += "Rotate around Z-axis (in degrees) = " + "\t" + string.Format("{0:F4}", zSlider.Value) + "\n";
                strOut += "\n" + "sqrt (" + "\t" + string.Format("{0:F4}", g.X) + "*" + string.Format("{0:F4}", g.X) + "\t\t" +
                          string.Format("{0:F4}", g.Y) + "*" + string.Format("{0:F4}", g.Y) + "\t\t" +
                          string.Format("{0:F4}", g.Z) + "*" + string.Format("{0:F4}", g.Z) + " ) = " + "\t\t" +
                          string.Format("{0:F4}", Math.Sqrt(g.X * g.X + g.Y * g.Y + g.Z * g.Z)) + "\n" +
                          "Should be close to the earth's gravitational constant of 9.807 (or the camera was moving.)";
                var tmpGMat1 = buildGmatrix();
                strOut += "\nGravity-oriented gMatrix - move camera to test this:\n" + gMatrixToStr(tmpGMat1);
                getSliderValues();
                var tmpGMat2 = buildGmatrix();
                strOut += "\ngMatrix with slider input - use Options_IMU Sliders to change this:\n" + gMatrixToStr(tmpGMat2);
            }
            SetTrueText(strOut);
            vbc.task.gMatrix = gMatrix;
        }
    }




    public class IMU_VerticalVerify_CS : VB_Parent
    {
        public List<gravityLine> gCells = new List<gravityLine>();
        FeatureLine_VH linesVH = new FeatureLine_VH();
        Options_VerticalVerify options = new Options_VerticalVerify();
        public IMU_VerticalVerify_CS()
        {
            labels = new string[] { "", "", "Highlighted vertical lines", "Line details" };
            desc = "Use the Y-Arc to confirm which vertical lines are valid";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            if (standaloneTest())
            {
                linesVH.Run(src);
                gCells = linesVH.gCells;
            }
            strOut = "ID" + "\t" + "len3D" + "\t" + "Depth" + "\t" + "Arc Y" + "\t" + "Image" + "\t" + "IMU Y" + "\n";
            dst3.SetTo(0);
            int index;
            for (int i = gCells.Count() - 1; i >= 0; i--)
            {
                var gc = gCells[i];
                if (gc.arcY > options.angleThreshold)
                {
                    index = gCells.Count() - i;
                    var p1 = gc.tc1.center;
                    var p2 = gc.tc2.center;
                    float xOffset = p1.X - p2.X;
                    if (p1.Y < p2.Y) xOffset = p2.X - p1.X;
                    float hypot = (float)p1.DistanceTo(p2);
                    gc.imageAngle = -(float)Math.Asin(xOffset / hypot) * 57.2958f;
                    strOut += index.ToString() + "\t" + string.Format("{0:F1}", gc.len3D) + "m" + "\t" +
                              string.Format("{0:F1}", gc.tc1.depth) + "m" + "\t" +
                              string.Format("{0:F1}", gc.arcY) + "\t" +
                              string.Format("{0:F1}", gc.imageAngle) + "\t";
                    strOut += string.Format("{0:F1}", vbc.task.accRadians.Y * 57.2958) + "\n";
                    cv.Point pt = new cv.Point(gc.tc1.center.X, gc.tc1.center.Y);
                    SetTrueText(index.ToString(), pt, 2);
                    SetTrueText(index.ToString(), pt, 3);
                    DrawLine(dst2, gc.tc1.center, gc.tc2.center, vbc.task.HighlightColor, vbc.task.lineWidth);
                    DrawLine(dst3, gc.tc1.center, gc.tc2.center, Scalar.White, vbc.task.lineWidth);
                    gCells[i] = gc;
                }
                else
                {
                    gCells.RemoveAt(i);
                }
            }
            SetTrueText(strOut, 3);
        }
    }




    public class IMU_Plot_CS : VB_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public float blueA, greenA, redA;
        Options_IMUPlot options = new Options_IMUPlot();
        public IMU_Plot_CS()
        {
            plot.plotCount = 3;
            desc = "Plot the angular velocity of the camera based on the IMU data";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest())
            {
                blueA = vbc.task.IMU_AngularVelocity.X * 1000;
                greenA = vbc.task.IMU_AngularVelocity.Y * 1000;
                redA = vbc.task.IMU_AngularVelocity.Z * 1000;
            }
            float blueX = 0, greenX = 0, redX = 0;
            if (options.setBlue) blueX = blueA;
            if (options.setGreen) greenX = greenA;
            if (options.setRed) redX = redA;
            plot.plotData = new Scalar(blueX, greenX, redX);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            labels[2] = "When run standaloneTest(), the default is to plot the angular velocity for X, Y, and Z";
        }
    }




    public class InPaint_Basics_CS : VB_Parent
    {
        Options_InPaint options = new Options_InPaint();
        public InPaint_Basics_CS()
        {
            desc = "Create a flaw in an image and then use inPaint to mask it.";
            labels[3] = "Repaired Image";
        }
        public Mat drawRandomLine(Mat dst)
        {
            var p1 = new Point2f(msRNG.Next(dst.Cols / 4, dst.Cols * 3 / 4), msRNG.Next(dst.Rows / 4, dst.Rows * 3 / 4));
            var p2 = new Point2f(msRNG.Next(dst.Cols / 4, dst.Cols * 3 / 4), msRNG.Next(dst.Rows / 4, dst.Rows * 3 / 4));
            DrawLine(dst2, p1, p2, new Scalar(0, 0, 0), vbc.task.lineWidth);
            var mask = new Mat(dst2.Size(), MatType.CV_8UC1);
            mask.SetTo(0);
            DrawLine(mask, p1, p2, Scalar.All(255), vbc.task.lineWidth);
            return mask;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            src.CopyTo(dst2);
            Mat mask = drawRandomLine(dst2);
            Cv2.Inpaint(dst2, mask, dst3, vbc.task.lineWidth, options.telea ? InpaintMethod.Telea : InpaintMethod.NS);
        }
    }




    public class InPaint_Noise_CS : VB_Parent
    {
        Draw_Noise noise = new Draw_Noise();
        Options_InPaint options = new Options_InPaint();
        public InPaint_Noise_CS()
        {
            desc = "Create noise in an image and then use inPaint to remove it.";
            labels[3] = "Repaired Image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            noise.Run(src); // create some noise in the result1 image.
            dst2 = noise.dst2;
            Cv2.Inpaint(dst2, noise.noiseMask, dst3, noise.options.noiseWidth, options.telea ? InpaintMethod.Telea : InpaintMethod.NS);
        }
    }




    public class InPaint_Depth_CS : VB_Parent
    {
        Options_InPaint options = new Options_InPaint();
        public InPaint_Depth_CS()
        {
            labels[2] = "32-bit representation of original depth";
            labels[3] = "32-bit depth repaired with inpainting";
            desc = "Use Navier-Stokes to fill in the holes in the depth";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            dst2 = src.Clone();
            Cv2.Inpaint(src, vbc.task.noDepthMask, dst3, 20, options.telea ? InpaintMethod.Telea : InpaintMethod.NS);
        }
    }




    public class Interpolate_Basics_CS : VB_Parent
    {
        public Options_Resize options = new Options_Resize();
        public Options_Interpolate iOptions = new Options_Interpolate();
        int direction = 1;
        int saveSliderValue = 0;
        public Interpolate_Basics_CS()
        {
            UpdateAdvice(traceName + ": 'Interpolation threshold' is the primary control" + "\n" +
                         "Local option 'Resize %' has a secondary effect." + "\n" +
                         "Local option 'Line length' affects the lines found.");
            desc = "Resize image using all available interpolation methods in OpenCV";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            iOptions.RunOpt();
            if (vbc.task.FirstPass) saveSliderValue = iOptions.interpolationThreshold;
            if (standaloneTest())
            {
                bool userGrab = iOptions.interpolationThreshold != iOptions.saveDefaultThreshold;
                if (!userGrab)
                {
                    saveSliderValue += direction;
                    if (saveSliderValue > 50) direction = -1;
                    if (saveSliderValue == 1) direction = 1;
                }
                else
                {
                    userGrab = true;
                    saveSliderValue = iOptions.interpolationThreshold;
                }
            }
            else
            {
                saveSliderValue = iOptions.interpolationThreshold;
            }
            dst2 = src.Clone();
            var newSize = new cv.Size((int)(dst2.Width * saveSliderValue / 100), (int)(dst2.Height * saveSliderValue / 100));
            dst2 = src.Resize(newSize, 0, 0, options.warpFlag);
            labels[2] = "Resize % = " + string.Format("{0:0%}", saveSliderValue / 100.0);
        }
    }




    public class Interpolate_Kalman_CS : VB_Parent
    {
        Interpolate_Basics inter = new Interpolate_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        int updatedFrames;
        int myFrameCount;
        int heartCount;
        Mat lastFrame = new cv.Mat();
        public Interpolate_Kalman_CS()
        {
            desc = "Use Kalman to smooth the grayscale results of interpolation";
        }
        public void RunAlg(Mat src)
        {
            inter.Run(src);
            dst2 = inter.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.optionsChanged)
            {
                kalman.kInput = new float[dst2.Width * dst2.Height];
                myFrameCount = 1;
                updatedFrames = 0;
            }
            Mat tmp32f = new Mat();
            dst2.ConvertTo(tmp32f, MatType.CV_32F);
            Marshal.Copy(tmp32f.Data, kalman.kInput, 0, kalman.kInput.Length);
            kalman.Run(empty);
            byte[] results = new byte[kalman.kInput.Length];
            for (int i = 0; i < kalman.kOutput.Length; i++)
            {
                float val = kalman.kOutput[i];
                if (float.IsNaN(val)) val = 255;
                if (val < 0) val = 0;
                if (val > 255) val = 255;
                results[i] = (byte)val;
            }
            Marshal.Copy(results, 0, dst2.Data, kalman.kOutput.Length);
            if (vbc.task.gOptions.GetUseKalman())
            {
                labels[2] = "Kalman-smoothed output after resizing to " + dst2.Width + "x" + dst2.Height;
            }
            else
            {
                labels[2] = "Raw output after resizing to " + dst2.Width + "x" + dst2.Height;
            }
            if (vbc.task.FirstPass) lastFrame = dst2.Clone();
            if (lastFrame.Size() != dst2.Size()) lastFrame = dst2.Clone();
            Mat tmp = dst2 - lastFrame;
            int diffCount = tmp.CountNonZero();
            if (diffCount > inter.iOptions.pixelCountThreshold)
            {
                lastFrame = dst2.Clone();
                dst3 = src.Clone();
                updatedFrames++;
            }
            labels[3] = "Total frames = " + myFrameCount + " updates=" + updatedFrames +
                         " savings = " + (myFrameCount - updatedFrames) + " or " +
                         string.Format("{0:0%}", (myFrameCount - updatedFrames) / (float)myFrameCount) + " diffCount = " + diffCount;
            if (vbc.task.heartBeat)
            {
                heartCount++;
                if (heartCount % 10 == 0)
                {
                    myFrameCount = 0;
                    updatedFrames = 0;
                }
            }
            myFrameCount++;
        }
    }




    public class Interpolate_Lines_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        Interpolate_Basics inter = new Interpolate_Basics();
        public Interpolate_Lines_CS()
        {
            FindSlider("Interpolation Resize %").Value = 80;
            FindSlider("Interpolation threshold").Value = 100;
            desc = "Detect lines in interpolation results.";
        }
        public void RunAlg(Mat src)
        {
            inter.Run(src);
            dst1 = inter.dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Resize(dst3.Size());
            dst1 = dst1.Threshold(inter.iOptions.interpolationThreshold, 255, ThresholdTypes.Binary);
            lines.Run(dst1);
            dst2 = lines.dst2;
            dst3 = src;
            foreach (var lp in lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, Scalar.Yellow, vbc.task.lineWidth);
            }
            labels[3] = "There were " + lines.lpList.Count() + " lines found";
            labels[2] = inter.labels[2];
        }
    }




    public class Interpolate_Difference_CS : VB_Parent
    {
        Interpolate_Kalman inter = new Interpolate_Kalman();
        Diff_Basics diff = new Diff_Basics();
        public Interpolate_Difference_CS()
        {
            desc = "Highlight the difference between the interpolation results and the current image.";
        }
        public void RunAlg(Mat src)
        {
            inter.Run(src);
            dst2 = inter.dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            labels[2] = inter.labels[3];
            diff.lastFrame = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            diff.Run(dst2);
            dst3 = diff.dst2;
        }
    }




    public class Interpolate_QuarterBeat_CS : VB_Parent
    {
        Diff_Basics diff = new Diff_Basics();
        int updatedFrames;
        int myFrameCount;
        float cameraFPS;
        float processedFPS;
        int heartCount = 0;
        DateTime nextTime = DateTime.Now;
        public Interpolate_QuarterBeat_CS()
        {
            desc = "Highlight the image differences after every quarter second.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.quarterBeat)
            {
                diff.Run(src);
                dst3 = diff.dst2;
                if (diff.dst2.CountNonZero() > 0)
                {
                    diff.lastFrame = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                    dst2 = src;
                    updatedFrames++;
                }
            }
            if (vbc.task.heartBeat)
            {
                heartCount++;
                if (heartCount % 3 == 0)
                {
                    DateTime newTime = DateTime.Now;
                    long elapsedTicks = newTime.Ticks - nextTime.Ticks;
                    TimeSpan span = new TimeSpan(elapsedTicks);
                    cameraFPS = myFrameCount / (span.Ticks / TimeSpan.TicksPerSecond);
                    processedFPS = updatedFrames / (span.Ticks / TimeSpan.TicksPerSecond);
                    nextTime = newTime;
                    myFrameCount = 0;
                    updatedFrames = 0;
                }
            }
            myFrameCount++;
            labels[2] = "Total frames = " + myFrameCount + " updates=" + updatedFrames +
                         " savings = " + (myFrameCount - updatedFrames) + " or " +
                         string.Format("{0:0%}", (myFrameCount - updatedFrames) / (float)myFrameCount) + " cameraFPS = " + string.Format("{0:00.0}", cameraFPS) +
                         " processedFPS = " + string.Format("{0:00.0}", processedFPS);
        }
    }




    public class Kalman_Basics_CS : VB_Parent
    {
        Kalman_Simple[] kalman;
        public float[] kInput = new float[4];
        public float[] kOutput = new float[4];
        int saveDimension = -1;
        cv.Rect lastRect = new cv.Rect(0, 0, 0, 0);
        public Kalman_Basics_CS()
        {
            desc = "Use Kalman to stabilize values (such as a cv.rect.)";
        }
        public void RunAlg(Mat src)
        {
            if (saveDimension != kInput.Length)
            {
                if (kalman != null && kalman.Length > 0)
                {
                    foreach (var k in kalman)
                    {
                        k.Dispose();
                    }
                }
                saveDimension = kInput.Length;
                kalman = new Kalman_Simple[kInput.Length];
                for (int i = 0; i < kInput.Length; i++)
                {
                    kalman[i] = new Kalman_Simple();
                }
                kOutput = new float[kInput.Length];
            }
            if (vbc.task.gOptions.GetUseKalman())
            {
                for (int i = 0; i < kalman.Length; i++)
                {
                    kalman[i].inputReal = kInput[i];
                    kalman[i].RunAlg(null);
                    if (double.IsNaN(kalman[i].stateResult)) kalman[i].stateResult = kalman[i].inputReal; // kalman failure...
                    kOutput[i] = kalman[i].stateResult;
                }
            }
            else
            {
                kOutput = kInput; // do nothing to the input.
            }
            if (standaloneTest())
            {
                dst2 = src;
                cv.Rect rect = new cv.Rect((int)kOutput[0], (int)kOutput[1], (int)kOutput[2], (int)kOutput[3]);
                rect = ValidateRect(rect);
                if (vbc.task.FirstPass) lastRect = rect;
                if (rect == lastRect)
                {
                    var r = InitRandomRect(src.Height <= 240 ? 20 : 50);
                    kInput = new float[] { r.X, r.Y, r.Width, r.Height };
                }
                lastRect = rect;
                dst2.Rectangle(rect, Scalar.White, vbc.task.lineWidth + 1);
                dst2.Rectangle(rect, Scalar.Red, vbc.task.lineWidth);
            }
        }
    }




    public class Kalman_Compare_CS : VB_Parent
    {
        Kalman_Single[] kalman;
        public Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public Plot_OverTimeScalar kPlot = new Plot_OverTimeScalar();
        public Kalman_Compare_CS()
        {
            plot.plotCount = 3;
            kPlot.plotCount = 3;
            labels[2] = "Kalman input: mean values for RGB";
            labels[3] = "Kalman output: smoothed mean values for RGB";
            desc = "Use this kalman filter to predict the next value.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
            {
                if (kalman != null && kalman.Length > 0)
                {
                    foreach (var k in kalman)
                    {
                        k.Dispose();
                    }
                }
                kalman = new Kalman_Single[3];
                for (int i = 0; i < kalman.Length; i++)
                {
                    kalman[i] = new Kalman_Single();
                }
            }
            plot.plotData = src.Mean();
            plot.Run(empty);
            dst2 = plot.dst2;
            for (int i = 0; i < kalman.Length; i++)
            {
                kalman[i].inputReal = (float)plot.plotData[i];
                kalman[i].Run(src);
            }
            kPlot.plotData = new Scalar(kalman[0].stateResult, kalman[1].stateResult, kalman[2].stateResult);
            kPlot.Run(empty);
            dst3 = kPlot.dst2;
        }
    }




    public class Kalman_RotatingPoint_CS : VB_Parent
    {
        KalmanFilter kf = new KalmanFilter(2, 1, 0);
        Mat kState = new Mat(2, 1, MatType.CV_32F);
        Mat processNoise = new Mat(2, 1, MatType.CV_32F);
        Mat measurement = new Mat(1, 1, MatType.CV_32F, cv.Scalar.All(0));
        Point2f center, statePt;
        float radius;
        cv.Point calcPoint(Point2f center, double R, double angle)
        {
            return new cv.Point((int)(center.X + Math.Cos(angle)), (int)(center.Y - Math.Sin(angle)) * R);
        }
        void drawCross(Mat dst2, cv.Point center, Scalar color)
        {
            int d = 3;
            DrawLine(dst2, new cv.Point(center.X - d, center.Y - d), new cv.Point(center.X + d, center.Y + d), color, vbc.task.lineWidth);
            DrawLine(dst2, new cv.Point(center.X + d, center.Y - d), new cv.Point(center.X - d, center.Y + d), color, vbc.task.lineWidth);
        }
        public Kalman_RotatingPoint_CS()
        {
            labels[2] = "Estimate Yellow < Real Red (if working)";
            Cv2.Randn(kState, new Scalar(0), Scalar.All(0.1));
            kf.TransitionMatrix = cv.Mat.FromPixelData(2, 2, MatType.CV_32F, new float[] { 1, 1, 0, 1 });
            Cv2.SetIdentity(kf.MeasurementMatrix);
            Cv2.SetIdentity(kf.ProcessNoiseCov, Scalar.All(0.00001));
            Cv2.SetIdentity(kf.MeasurementNoiseCov, Scalar.All(0.1));
            Cv2.SetIdentity(kf.ErrorCovPost, Scalar.All(1));
            Cv2.Randn(kf.StatePost, new Scalar(0), Scalar.All(1));
            radius = dst2.Rows / 2.4f; // so we see the entire circle...
            center = new Point2f(dst2.Cols / 2, dst2.Rows / 2);
            desc = "Track a rotating point using a Kalman filter. Yellow line (estimate) should be shorter than red (real).";
        }
        public void RunAlg(Mat src)
        {
            float stateAngle = kState.Get<float>(0);
            Mat prediction = kf.Predict();
            float predictAngle = prediction.Get<float>(0);
            cv.Point predictPt = calcPoint(center, radius, predictAngle);
            statePt = calcPoint(center, radius, stateAngle);
            Cv2.Randn(measurement, new Scalar(0), Scalar.All(kf.MeasurementNoiseCov.Get<float>(0)));
            measurement += kf.MeasurementMatrix * kState;
            float measAngle = measurement.Get<float>(0);
            cv.Point measPt = calcPoint(center, radius, measAngle);
            dst2.SetTo(0);
            drawCross(dst2, new cv.Point((int)statePt.X, (int)statePt.Y), Scalar.White);
            drawCross(dst2, measPt, Scalar.White);
            drawCross(dst2, predictPt, Scalar.White);
            DrawLine(dst2, statePt, measPt, new Scalar(0, 0, 255), vbc.task.lineWidth + 2);
            DrawLine(dst2, statePt, predictPt, new Scalar(0, 255, 255), vbc.task.lineWidth + 2);
            if (msRNG.Next(0, 4) != 0) kf.Correct(measurement);
            Cv2.Randn(processNoise, Scalar.Black, Scalar.All(Math.Sqrt(kf.ProcessNoiseCov.Get<float>(0, 0))));
            kState = kf.TransitionMatrix * kState + processNoise;
        }
    }




    public class Kalman_MousePredict_CS : VB_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        cv.Point lastRealMouse = new cv.Point(0, 0);
        public Kalman_MousePredict_CS()
        {
            kalman.kInput = new float[2];
            kalman.kOutput = new float[2];
            labels[2] = "Red is real mouse, white is prediction";
            desc = "Use kalman filter to predict the next mouse location.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.frameCount % 300 == 0) dst2.SetTo(0);
            cv.Point lastStateResult = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
            if (vbc.task.FirstPass) lastRealMouse = vbc.task.mouseMovePoint;
            kalman.kInput = new float[] { vbc.task.mouseMovePoint.X, vbc.task.mouseMovePoint.Y };
            kalman.Run(src);
            DrawLine(dst2, new cv.Point(kalman.kOutput[0], kalman.kOutput[1]), lastStateResult, cv.Scalar.White, vbc.task.lineWidth);
            dst2.Line(vbc.task.mouseMovePoint, lastRealMouse, Scalar.Red);
            lastRealMouse = vbc.task.mouseMovePoint;
        }
    }




    public class Kalman_CVMat_CS : VB_Parent
    {
        Kalman_Simple[] kalman;
        public Mat output;
        Kalman_Basics basics = new Kalman_Basics();
        public Mat input;
        int saveDimension = -1;
        cv.Rect lastRect;
        public Kalman_CVMat_CS()
        {
            basics.kInput = new float[4];
            input = new Mat(4, 1, MatType.CV_32F, cv.Scalar.All(0));
            if (standaloneTest()) labels[2] = "Rectangle moves smoothly to random locations";
            desc = "Use Kalman to stabilize a set of values such as a cv.rect or cv.Mat";
        }
        public void RunAlg(Mat src)
        {
            if (saveDimension != input.Rows)
            {
                if (kalman != null && kalman.Length > 0)
                {
                    foreach (var k in kalman)
                    {
                        k.Dispose();
                    }
                }
                saveDimension = input.Rows;
                kalman = new Kalman_Simple[input.Rows];
                for (int i = 0; i < input.Rows; i++)
                {
                    kalman[i] = new Kalman_Simple();
                }
                output = new Mat(input.Rows, 1, MatType.CV_32F, cv.Scalar.All(0));
            }
            if (vbc.task.gOptions.GetUseKalman())
            {
                for (int i = 0; i < kalman.Length; i++)
                {
                    kalman[i].inputReal = input.Get<float>(i, 0);
                    kalman[i].RunAlg(src);
                    output.Set<float>(i, 0, kalman[i].stateResult);
                }
            }
            else
            {
                output = input; // do nothing to the input.
            }
            if (standaloneTest())
            {
                float[] rx = new float[input.Rows];
                for (int i = 0; i < input.Rows; i++)
                {
                    rx[i] = output.Get<float>(i, 0);
                }
                dst2 = src;
                cv.Rect rect = new cv.Rect((int)rx[0], (int)rx[1], (int)rx[2], (int)rx[3]);
                rect = ValidateRect(rect);
                if (vbc.task.FirstPass) lastRect = rect;
                if (lastRect == rect)
                {
                    var r = InitRandomRect(25);
                    float[] array = { r.X, r.Y, r.Width, r.Height };
                    input = cv.Mat.FromPixelData(4, 1, MatType.CV_32F, array);
                }
                dst2.Rectangle(rect, Scalar.Red, 2);
                lastRect = rect;
            }
        }
    }




    public class Kalman_ImageSmall_CS : VB_Parent
    {
        Kalman_CVMat kalman = new Kalman_CVMat();
        Resize_Smaller resize;
        public Kalman_ImageSmall_CS()
        {
            resize = new Resize_Smaller();
            labels[2] = "The small image is processed by the Kalman filter";
            labels[3] = "Mask of the smoothed image minus original";
            desc = "Resize the image to allow the Kalman filter to process the whole image.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            resize.Run(src);
            var saveOriginal = resize.dst2.Clone();
            Mat gray32f = new Mat();
            resize.dst2.ConvertTo(gray32f, MatType.CV_32F);
            kalman.input = gray32f.Reshape(1, gray32f.Width * gray32f.Height);
            kalman.Run(src);
            Mat tmp = new Mat();
            kalman.output.ConvertTo(tmp, MatType.CV_8U);
            tmp = tmp.Reshape(1, gray32f.Height);
            dst2 = tmp.Resize(dst2.Size());
            Cv2.Subtract(tmp, saveOriginal, dst3);
            dst3 = dst3.Threshold(1, 255, ThresholdTypes.Binary);
            dst3 = dst3.Resize(dst2.Size());
        }
    }




    public class Kalman_DepthSmall_CS : VB_Parent
    {
        Kalman_ImageSmall kalman = new Kalman_ImageSmall();
        public Kalman_DepthSmall_CS()
        {
            labels[2] = "Mask of non-zero depth after Kalman smoothing";
            labels[3] = "Mask of the smoothed image minus original";
            desc = "Use a resized depth Mat to find where depth is decreasing (something getting closer.)";
        }
        public void RunAlg(Mat src)
        {
            kalman.Run(vbc.task.depthRGB);
            dst2 = kalman.dst2;
            dst3 = kalman.dst3;
        }
    }




    public class Kalman_Depth32f_CS : VB_Parent
    {
        Kalman_CVMat kalman = new Kalman_CVMat();
        Resize_Smaller resize;
        public Kalman_Depth32f_CS()
        {
            resize = new Resize_Smaller();
            FindSlider("LowRes %").Value = 4;
            labels[2] = "Mask of non-zero depth after Kalman smoothing";
            labels[3] = "Difference from original depth";
            desc = "Use a resized depth Mat to find where depth is decreasing (getting closer.)";
        }
        public void RunAlg(Mat src)
        {
            resize.Run(vbc.task.pcSplit[2]);
            kalman.input = resize.dst2.Reshape(1, resize.dst2.Width * resize.dst2.Height);
            kalman.Run(src);
            dst2 = kalman.output.Reshape(1, resize.dst2.Height);
            dst2 = dst2.Resize(src.Size());
            Cv2.Subtract(dst2, vbc.task.pcSplit[2], dst3);
            dst3 = dst3.Normalize(255);
        }
    }




    public class Kalman_Single_CS : VB_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        KalmanFilter kf = new KalmanFilter(2, 1, 0);
        Mat processNoise = new Mat(2, 1, MatType.CV_32F);
        public Mat measurement = new Mat(1, 1, MatType.CV_32F, cv.Scalar.All(0));
        public float inputReal;
        public float stateResult;
        public float ProcessNoiseCov = 0.00001f;
        public float MeasurementNoiseCov = 0.1f;
        public float ErrorCovPost = 1f;
        public float[] transitionMatrix = { 1, 1, 0, 1 }; // Change the transition matrix externally and set newTransmissionMat_vbbacrix.
        public bool newTransmissionMatrix = true;
        public Kalman_Single_CS()
        {
            float[] tMatrix = { 1, 1, 0, 1 };
            kf.TransitionMatrix = cv.Mat.FromPixelData(2, 2, MatType.CV_32F, tMatrix);
            kf.MeasurementMatrix.SetIdentity(cv.Scalar.All(1));
            kf.ProcessNoiseCov.SetIdentity(cv.Scalar.All(0.00001));
            kf.MeasurementNoiseCov.SetIdentity(cv.Scalar.All(0.1));
            kf.ErrorCovPost.SetIdentity(cv.Scalar.All(1));
            plot.plotCount = 2;
            desc = "Estimate a single value using a Kalman Filter - in the default case, the value of the mean of the grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                inputReal = (float)dst1.Mean()[0];
            }
            var prediction = kf.Predict();
            measurement.Set<float>(0, 0, inputReal);
            stateResult = kf.Correct(measurement).Get<float>(0, 0);
            if (standaloneTest())
            {
                plot.plotData = new Scalar(inputReal, stateResult, 0, 0);
                plot.Run(empty);
                dst2 = plot.dst2;
                dst3 = plot.dst3;
                labels[2] = "Mean of the grayscale image is predicted";
                labels[3] = "Mean (blue) = " + string.Format("{0:0.0}", inputReal) + " predicted (green) = " + string.Format("{0:0.0}", stateResult);
            }
        }
    }




    public class Kalman_Simple_CS : IDisposable
    {
        KalmanFilter kf = new KalmanFilter(2, 1, 0);
        Mat processNoise = new Mat(2, 1, MatType.CV_32F);
        public Mat measurement = new Mat(1, 1, MatType.CV_32F, cv.Scalar.All(0));
        public float inputReal;
        public float stateResult;
        public float ProcessNoiseCov = 0.00001f;
        public float MeasurementNoiseCov = 0.1f;
        public float ErrorCovPost = 1f;
        public float[] transitionMatrix = { 1, 1, 0, 1 }; // Change the transition matrix externally and set newTransmissionMatrix.
        public bool newTMatrix = true;
        public void updateTMatrix()
        {
            kf.TransitionMatrix = cv.Mat.FromPixelData(2, 2, MatType.CV_32F, transitionMatrix);
            kf.MeasurementMatrix.SetIdentity(cv.Scalar.All(1));
            kf.ProcessNoiseCov.SetIdentity(cv.Scalar.All(0.00001));
            kf.MeasurementNoiseCov.SetIdentity(cv.Scalar.All(0.1));
            kf.ErrorCovPost.SetIdentity(cv.Scalar.All(1));
        }
        public Kalman_Simple_CS()
        {
            float[] tMatrix = { 1, 1, 0, 1 };
        }
        public void RunAlg(Mat src)
        {
            if (newTMatrix)
            {
                newTMatrix = false;
                updateTMatrix();
            }
            var prediction = kf.Predict();
            measurement.Set<float>(0, 0, inputReal);
            stateResult = kf.Correct(measurement).Get<float>(0, 0);
        }
        public void Dispose()
        {
            // required dispose function. It is tempting to remove this but it is needed...It does not inherit from VB_Parent...
        }
    }

    // https://towardsdatascience.com/kalman-filter-interview-bdc39f3e6cf3
    // https://towardsdatascience.com/extended-kalman-filter-43e52b16757d
    // https://towardsdatascience.com/the-unscented-kalman-filter-anything-ekf-can-do-i-can-do-it-better-ce7c773cf88d




    public class Kalman_CSharp_Basics_CS : VB_Parent
    {
        public float kInput;
        public float kOutput;
        public float kAverage;
        float[,] P = new float[,] { { 1, 0 }, { 0, 1 } }; // 2x2 This is the covariance matrix
        float q_bias;
        float outputError = 0.002f;
        float processCovar = 0.001f; // This is the process covariance matrix. It's how much we trust the accelerometer
        List<float> matrix = new List<float>();
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        int saveAvgCount = 0;
        Options_Kalman options = new Options_Kalman();
        public Kalman_CSharp_Basics_CS()
        {
            labels[2] = "Blue = grayscale mean after Kalman, green is grayscale mean value without Kalman, red is the grayscale average without Kalman";
            desc = "Build a generic kalman filter based on Kalman_CSharp";
        }
        public void State_Update(float q_m)
        {
            float unbias = q_m - q_bias; // Unbias our gyro
            float[] Pdot = new float[] { processCovar - P[0, 1] - P[1, 0], -P[1, 1], -P[1, 1], (float)options.pdotEntry };
            kOutput += (float)(unbias * options.delta);
            plot.plotCount = 3;
            // Update the covariance matrix
            P[0, 0] += (float)(Pdot[0] * options.delta);
            P[0, 1] += (float)(Pdot[1] * options.delta);
            P[1, 0] += (float)(Pdot[2] * options.delta);
            P[1, 1] += (float)(Pdot[3] * options.delta);
        }
        public void Kalman_Update()
        {
            float kError = kInput - kOutput;
            float C_0 = 1;
            float PCt_0 = C_0 * P[0, 0]; // + C_1 * P[0, 1] 'This second part is always 0, so we don't bother
            float PCt_1 = C_0 * P[1, 0]; // + C_1 * P[1, 1]
            float err = outputError + C_0 * PCt_0; // Compute the error estimate.
            float K_0 = PCt_0 / err; // Compute the Kalman filter gains
            float K_1 = PCt_1 / err;
            float t_0 = PCt_0;
            float t_1 = C_0 * P[0, 1];
            P[0, 0] -= K_0 * t_0; // Update covariance matrix
            P[0, 1] -= K_0 * t_1;
            P[1, 0] -= K_1 * t_0;
            P[1, 1] -= K_1 * t_1;
            kOutput += K_0 * kError; // Update our state estimate
            q_bias += K_1 * kError;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (standaloneTest()) kInput = (float)src.CvtColor(cv.ColorConversionCodes.BGR2GRAY).Mean()[0];
            if (options.averageInputCount != saveAvgCount)
            {
                saveAvgCount = options.averageInputCount;
                matrix.Clear();
                for (int i = 0; i < saveAvgCount; i++)
                {
                    matrix.Add(kInput);
                }
            }
            matrix[vbc.task.frameCount % saveAvgCount] = kInput;
            kAverage = (float)(cv.Mat.FromPixelData(saveAvgCount, 1, MatType.CV_32F, matrix.ToArray())).Mean()[0];
            if (vbc.task.gOptions.GetUseKalman())
            {
                // The Kalman Filter code comes from:
                // http://www.rotomotion.com/downloads/tilt.c
                State_Update(kInput);
                Kalman_Update();
            }
            else
            {
                kOutput = kInput;
            }
            if (standaloneTest())
            {
                plot.plotData = new Scalar(kOutput, kInput, kAverage);
                plot.Run(empty);
                dst2 = plot.dst2;
                dst3 = plot.dst3;
            }
            labels[3] = "Move the camera around to see the impact of the Kalman filter.";
        }
    }




    public class KLT_Basics_CS : VB_Parent
    {
        public Mat status = new Mat();
        public Mat outputMat = new Mat();
        public Scalar circleColor = Scalar.Red;
        public Options_KLT options = new Options_KLT();
        Mat lastGray;
        public KLT_Basics_CS()
        {
            desc = "Track movement with Kanada-Lucas-Tomasi algorithm";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.nightMode)
                dst2.SetTo(0);
            else
                src.CopyTo(dst2);
            if (vbc.task.FirstPass) lastGray = src.Clone();
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            TermCriteria term = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 10, 1.0);
            if (options.ptInput == null)
            {
                options.ptInput = Cv2.GoodFeaturesToTrack(src, options.maxCorners, options.qualityLevel,
                                                              options.minDistance, new Mat(), options.blockSize, false, 0);
                if (options.ptInput.Length > 0)
                {
                    options.ptInput = Cv2.CornerSubPix(src, options.ptInput, options.subPixWinSize, new cv.Size(-1, -1), term);
                }
                outputMat = cv.Mat.FromPixelData(options.ptInput.Length, 1, MatType.CV_32FC2, options.ptInput);
                status = new Mat(outputMat.Rows, outputMat.Cols, MatType.CV_8U, cv.Scalar.All(1));
            }
            else if (options.ptInput.Length > 0)
            {
                Mat err = new Mat();
                // convert the point2f vector to an inputarray (cv.Mat)
                Mat inputMat = cv.Mat.FromPixelData(options.ptInput.Length, 1, MatType.CV_32FC2, options.ptInput);
                outputMat = inputMat.Clone();
                Cv2.CalcOpticalFlowPyrLK(lastGray, src, inputMat, outputMat, status, err, options.winSize, 3, term, OpticalFlowFlags.None);
                int k = 0;
                for (int i = 0; i < options.ptInput.Length; i++)
                {
                    if (status.Get<byte>(i) != 0)
                    {
                        options.ptInput[k] = outputMat.Get<cv.Point2f>(i);
                        k++;
                    }
                }
                Array.Resize(ref options.ptInput, k);
            }
            for (int i = 0; i < outputMat.Rows; i++)
            {
                Point2f pt = outputMat.Get<cv.Point2f>(i);
                if (pt.X >= 0 && pt.X <= src.Cols && pt.Y >= 0 && pt.Y <= src.Rows)
                {
                    if (status.Get<byte>(i) != 0)
                    {
                        DrawCircle(dst2, pt, vbc.task.DotSize + 1, circleColor);
                    }
                }
                else
                {
                    status.Set<byte>(i, 0); // this point is not visible!
                }
            }
            lastGray = src.Clone();
            labels[2] = "KLT Basics - " + (options.ptInput == null ? "0" : options.ptInput.Length.ToString()) + " points";
        }
    }




    public class KLT_OpticalFlow_CS : VB_Parent
    {
        KLT_Basics klt = new KLT_Basics();
        Point2f[] lastpoints;
        public KLT_OpticalFlow_CS()
        {
            desc = "KLT optical flow - needs more work";
        }
        public void RunAlg(Mat src)
        {
            klt.Run(src);
            if (vbc.task.frameCount > 0 && lastpoints != null && klt.ptInput != null)
            {
                dst2 = klt.dst2;
                src.CopyTo(dst3);
                for (int i = 0; i < klt.ptInput.Length; i++)
                {
                    if (klt.status.Get<byte>(i) != 0 && i < lastpoints.Length && i < klt.ptInput.Length)
                    {
                        // DrawLine(dst2, lastpoints[i], klt.ptInput[i], Scalar.Yellow, vbc.task.lineWidth + 1, vbc.task.lineType);
                        // static Point2f[] lastFlowPoints = klt.ptInput;
                        // DrawLine(dst3, lastFlowPoints[i], klt.ptInput[i], Scalar.Yellow, vbc.task.lineWidth + 1, vbc.task.lineType);
                        // if (vbc.task.heartBeat) lastFlowPoints = klt.ptInput;
                    }
                }
            }
            lastpoints = klt.ptInput;
        }
    }




    public class KMeans_Basics_CS : VB_Parent
    {
        public Options_KMeans options = new Options_KMeans();
        public Mat colors = new Mat();
        public bool buildPaletteOutput = true;
        public Mat saveLabels = new Mat();
        public int classCount;
        int lastK = 0;
        public KMeans_Basics_CS()
        {
            labels = new string[] { "", "", "", "Palette output for the kMeans labels" };
            desc = "Cluster the input using kMeans.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() && src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            options.RunOpt();
            classCount = options.kMeansK;
            if (vbc.task.FirstPass) lastK = classCount;
            if (vbc.task.optionsChanged || lastK != classCount)
            {
                options.kMeansFlag = KMeansFlags.PpCenters;
                saveLabels = new Mat();
            }
            var columnVector = src.Reshape(src.Channels(), src.Height * src.Width);
            dst2 = saveLabels;
            if (columnVector.ElemSize() % 4 != 0 || columnVector.Type() == MatType.CV_32S)
                columnVector.ConvertTo(columnVector, MatType.CV_32F);
            TermCriteria term = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 10, 1.0);
            try
            {
                if (colors.Width == 0 || colors.Height == 0)
                    options.kMeansFlag = KMeansFlags.PpCenters;
                Cv2.Kmeans(columnVector, classCount, dst2, term, 1, options.kMeansFlag, colors);
            }
            catch (Exception)
            {
                columnVector.SetTo(0);
                dst2.SetTo(0);
                Cv2.Kmeans(columnVector, classCount, dst2, term, 1, options.kMeansFlag, colors);
            }
            saveLabels = dst2.Clone();
            dst2.Reshape(1, src.Height).ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            lastK = classCount;
            labels[2] = "KMeans labels 0-" + lastK.ToString() + " spread out across 255 values.";
        }
    }




    public class KMeans_MultiChannel_CS : VB_Parent
    {
        public Mat colors = new Mat();
        KMeans_Basics km = new KMeans_Basics();
        public KMeans_MultiChannel_CS()
        {
            labels = new string[] { "", "", "KMeans_Basics output with BGR input", "dst3 contains the labels spread across the palette (dst0 contains the exact labels)" };
            desc = "Cluster the input using kMeans.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
                vbc.task.color.ConvertTo(src, MatType.CV_32FC3);
            if (src.Type() == MatType.CV_8UC3)
                src.ConvertTo(src, MatType.CV_32FC3);
            if (src.Type() == MatType.CV_8U)
                src.ConvertTo(src, MatType.CV_32F);
            km.Run(src);
            dst3 = km.dst2;
            dst2 = ShowPalette(dst3 * 255 / km.classCount);
        }
    }




    public class KMeans_k2_to_k8_CS : VB_Parent
    {
        Mat_4Click Mats = new Mat_4Click();
        KMeans_Basics km = new KMeans_Basics();
        int kmIndex;
        TrackBar kSlider;
        public KMeans_k2_to_k8_CS()
        {
            kSlider = FindSlider("KMeans k");
            labels[2] = "kmeans - k=2,4,6,8";
            desc = "Show clustering with various settings for cluster count.  Draw to select region of interest.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.frameCount % 100 == 0)
            {
                kmIndex++;
                if (kmIndex >= 4) kmIndex = 0;
            }
            kSlider.Value = 2;
            if (kmIndex == 1) kSlider.Value = 4;
            if (kmIndex == 2) kSlider.Value = 6;
            if (kmIndex == 3) kSlider.Value = 8;
            km.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
            Mats.mat[kmIndex] = km.dst2 * 255 / km.classCount;
            Mats.Run(empty);
            dst2 = Mats.dst2;
            dst3 = Mats.dst3;
        }
    }




    public class KMeans_Fuzzy_CS : VB_Parent
    {
        KMeans_Image km = new KMeans_Image();
        public Fuzzy_Basics fuzzyD = new Fuzzy_Basics();
        public KMeans_Fuzzy_CS()
        {
            labels[3] = "The white marks areas that are busy while the black marks areas that are consistent in color - not fuzzy.";
            desc = "Use the KMeans output as input to the Fuzzy detector - those areas which have little info";
        }
        public void RunAlg(Mat src)
        {
            km.Run(src);
            dst2 = km.km.dst2;
            fuzzyD.Run(dst2);
            dst3 = fuzzyD.dst3;
        }
    }




    public class KMeans_MultiGaussian_CS : VB_Parent
    {
        public KMeans_MultiGaussian_CS()
        {
            cPtr = KMeans_MultiGaussian_Open();
            desc = "Use KMeans on a random multi-gaussian distribution.";
        }
        public void RunAlg(Mat src)
        {
            IntPtr imagePtr = KMeans_MultiGaussian_RunCPP(cPtr, src.Rows, src.Cols);
            if (imagePtr != IntPtr.Zero && vbc.task.heartBeat)
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = KMeans_MultiGaussian_Close(cPtr);
        }
    }




    public class KMeans_CustomData_CS : VB_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        public Mat centers = new Mat();
        Random_Basics random = new Random_Basics();
        TrackBar randslider;
        public KMeans_CustomData_CS()
        {
            randslider = FindSlider("Random Pixel Count");
            desc = "Cluster the selected input using kMeans";
        }
        public void RunAlg(Mat src)
        {
            km.options.RunOpt();
            int k = km.options.kMeansK;
            if (src.Rows < k) k = src.Rows;
            if (standaloneTest())
            {
                if (vbc.task.FirstPass) randslider.Value = 50;
                if (randslider.Value < k) randslider.Value = k;
                if (vbc.task.heartBeat) random.Run(empty);
                var input = new List<float>();
                foreach (var pt in random.PointList)
                {
                    input.Add(pt.X);
                    input.Add(pt.Y);
                }
                dst0 = cv.Mat.FromPixelData(input.Count(), 1, MatType.CV_32F, input.ToArray());
            }
            km.Run(dst0);
            dst2 = ShowPalette(km.dst2 * 255 / km.classCount);
        }
    }




    public class KMeans_Simple_CPP_CS : VB_Parent
    {
        public KMeans_Simple_CPP_CS()
        {
            cPtr = Kmeans_Simple_Open();
            desc = "Split the input into 3 levels - zero (no depth), closer to min, closer to max.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest()) src = vbc.task.pcSplit[2];
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var mm = GetMinMax(src, vbc.task.depthMask);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Kmeans_Simple_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, (float)mm.minVal, vbc.task.gOptions.getMaxDepthBar());
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr);
            SetTrueText("Use 'Max Depth' in the global options to set the boundary between blue and yellow.", 3);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Kmeans_Simple_Close(cPtr);
        }
    }




    public class KMeans_Edges_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        public KMeans_Image km = new KMeans_Image();
        public int classCount;
        RedCloud_Basics redC = new RedCloud_Basics();
        public KMeans_Edges_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            labels[3] = "KMeans with edges output";
            desc = "Use edges to isolate regions in the KMeans output - not much different from KMeans_Basics.";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(src);
            src.SetTo(Scalar.White, edges.dst2);
            km.Run(src);
            dst3 = km.dst2 + cv.Scalar.All(1);
            classCount = km.classCount;
            redC.Run(dst3);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
        }
    }




    public class KMeans_CompareMulti_CS : VB_Parent
    {
        KMeans_Image km = new KMeans_Image();
        KMeans_MultiChannel multi = new KMeans_MultiChannel();
        public KMeans_CompareMulti_CS()
        {
            labels = new string[] { "", "", "KMeans_Basics output", "KMeans on all 3 channels - recombined" };
            desc = "Compare the results of using grayscale KMeans with multi-channel KMeans";
        }
        public void RunAlg(Mat src)
        {
            km.Run(src);
            dst2 = km.dst2;
            dst2 = ShowPalette(dst2);
            multi.Run(src);
            dst3 = multi.dst2;
            labels[2] = "";
        }
    }




    public class KMeans_TierCount_CS : VB_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        Depth_TierCount kCount = new Depth_TierCount();
        public int classCount;
        TrackBar kSlider;
        public KMeans_TierCount_CS()
        {
            kSlider = FindSlider("KMeans k");
            desc = "Use the Histogram valleys to find the best 'K' value for the current depth data";
        }
        public void RunAlg(Mat src)
        {
            kCount.Run(src);
            if (kSlider.Value != kCount.classCount) kSlider.Value = Math.Max(kCount.classCount, kSlider.Minimum);
            classCount = kCount.classCount;
            km.Run(vbc.task.pcSplit[2]);
            dst2 = km.dst2 * 255 / km.classCount;
            dst2.SetTo(0, vbc.task.noDepthMask);
            dst3 = ShowPalette(dst2);
            labels[2] = "There were " + classCount.ToString() + " tiers (on average) found in the depth valleys histogram.";
        }
    }




    public class KMeans_Image_CS : VB_Parent
    {
        public KMeans_Basics km = new KMeans_Basics();
        public List<Mat> masks = new List<Mat>();
        public List<int> counts = new List<int>();
        public int classCount;
        int maskIndex;
        public KMeans_Image_CS()
        {
            labels = new string[] { "", "", "KMeans output after Palette run", "Each of the KMeans masks is displayed below in rotation." };
            desc = "Cluster the input image pixels using kMeans and allow any region to be selected for highlight in dst3.";
        }
        public void RunAlg(Mat src)
        {
            km.Run(src);
            dst2 = ShowPalette(km.dst2 * 255 / km.classCount);
            classCount = km.options.kMeansK;
            masks.Clear();
            counts.Clear();
            int k = km.options.kMeansK;
            for (int i = 0; i < k; i++)
            {
                Mat mask = km.dst2.InRange(i, i);
                masks.Add(mask);
                counts.Add(mask.CountNonZero());
            }
            if (vbc.task.heartBeat) maskIndex++;
            if (maskIndex >= masks.Count()) maskIndex = 0;
            dst3 = masks[maskIndex];
        }
    }




    public class KMeans_DepthPlusGray_CS : VB_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        Mat[] grayPlus = new Mat[2];
        public KMeans_DepthPlusGray_CS()
        {
            km.buildPaletteOutput = false;
            labels[3] = "KMeans 8-bit results";
            grayPlus[0] = new Mat(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height), MatType.CV_32F, cv.Scalar.All(0));
            desc = "Cluster the rgb+depth image pixels using kMeans";
        }
        public void RunAlg(Mat src)
        {
            src.CvtColor(cv.ColorConversionCodes.BGR2GRAY).ConvertTo(grayPlus[0], MatType.CV_32F);
            grayPlus[0].SetTo(0, vbc.task.noDepthMask);
            grayPlus[1] = vbc.task.pcSplit[2];
            Mat merge = new Mat();
            Cv2.Merge(grayPlus, merge);
            km.Run(merge);
            int k = km.options.kMeansK;
            dst3 = km.dst2;
            dst3.SetTo(0, vbc.task.noDepthMask);
            if (standaloneTest()) dst2 = ShowPalette(km.dst2 * 255 / k);
        }
    }




    public class KMeans_Dimensions_CS : VB_Parent
    {
        public KMeans_Basics km = new KMeans_Basics();
        TrackBar dimSlider;
        public KMeans_Dimensions_CS()
        {
            dimSlider = FindSlider("Dimension");
            desc = "Demonstrate how to use KMeans for a variety of dimensions";
        }
        public void RunAlg(Mat src)
        {
            Mat merge = new Mat();
            switch (dimSlider.Value)
            {
                case 1: // grayscale
                    if (src.Channels() == 1)
                    {
                        src.ConvertTo(merge, MatType.CV_32F);
                    }
                    else
                    {
                        src.CvtColor(cv.ColorConversionCodes.BGR2GRAY).ConvertTo(merge, MatType.CV_32F);
                    }
                    break;
                case 2: // pointcloud x and y
                    Cv2.Merge(new Mat[] { vbc.task.pcSplit[0], vbc.task.pcSplit[1] }, merge);
                    break;
                case 3: // pointcloud dimensions
                    merge = vbc.task.pointCloud;
                    break;
                case 4: // color + depth
                    src.ConvertTo(src, MatType.CV_32F);
                    vbc.task.pcSplit[2] = vbc.task.pcSplit[2].Normalize(0, 255, NormTypes.MinMax);
                    Cv2.Merge(new Mat[] { src, vbc.task.pcSplit[2] }, merge);
                    break;
                case 5: // color + pcSplit(0) and pcSplit(1)
                    src.ConvertTo(src, MatType.CV_32F);
                    vbc.task.pcSplit[0] = vbc.task.pcSplit[0].Normalize(0, 255, NormTypes.MinMax);
                    vbc.task.pcSplit[1] = vbc.task.pcSplit[1].Normalize(0, 255, NormTypes.MinMax);
                    Cv2.Merge(new Mat[] { src, vbc.task.pcSplit[0], vbc.task.pcSplit[1] }, merge);
                    break;
                case 6: // color + pointcloud
                    src.ConvertTo(src, MatType.CV_32F);
                    Mat tmp1 = vbc.task.pcSplit[0].Normalize(0, 255, NormTypes.MinMax);
                    Mat tmp2 = vbc.task.pcSplit[1].Normalize(0, 255, NormTypes.MinMax);
                    Mat tmp3 = vbc.task.pcSplit[2].Normalize(0, 255, NormTypes.MinMax);
                    Cv2.Merge(new Mat[] { src, tmp1, tmp2, tmp3 }, merge);
                    break;
            }
            km.Run(merge);
            labels[2] = "Dimension = " + dimSlider.Value.ToString();
            labels[3] = labels[2];
            dst2 = km.dst2 + cv.Scalar.All(1);
            dst3 = ShowPalette(dst2 * 255 / km.classCount);
        }
    }




    public class KMeans_Valleys_CS : VB_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        KMeans_TierCount tiers = new KMeans_TierCount();
        TrackBar kSlider;
        public KMeans_Valleys_CS()
        {
            kSlider = FindSlider("KMeans k");
            labels[2] = "8-Bit input to vbPalette output in dst3";
            desc = "Cluster depth using kMeans - use KMeans_TierCount to determine 'K'";
        }
        public void RunAlg(Mat src)
        {
            tiers.Run(src);
            kSlider.Value = tiers.classCount;
            int kMeansK = kSlider.Value;
            km.Run(vbc.task.pcSplit[2]);
            dst2 = km.dst2 + cv.Scalar.All(1);
            dst3 = ShowPalette(dst2 * 255 / tiers.classCount);
            dst3.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class KMeans_Depth_CS : VB_Parent
    {
        public KMeans_Basics km = new KMeans_Basics();
        public int classCount;
        public KMeans_Depth_CS()
        {
            FindSlider("KMeans k").Value = 10;
            labels[2] = "";
            desc = "Cluster depth using kMeans - useful to split foreground and background";
        }
        public void RunAlg(Mat src)
        {
            km.Run(vbc.task.pcSplit[2]);
            dst2 = km.dst2 + cv.Scalar.All(1);
            dst2.SetTo(0, vbc.task.noDepthMask);
            classCount = km.classCount;
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = "Palettized version of the " + classCount.ToString() + " 8UC1 classes";
        }
    }




    public class KMeans_SimKColor_CS : VB_Parent
    {
        Hist3Dcolor_PlotHist1D plot1D = new Hist3Dcolor_PlotHist1D();
        Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public int classCount;
        Mat histogram = new Mat();
        public KMeans_SimKColor_CS()
        {
            desc = "Use the gaps in the 3D histogram of the color image to find 'k' and backproject the results.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                plot1D.Run(src);
                dst3 = plot1D.dst2;
                labels[3] = "The 3D histogram of the RGB image stream in 1D - note the number of gaps";
                simK.Run(plot1D.histogram1D);
                histogram = simK.dst2;
                classCount = simK.classCount;
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst1, vbc.task.redOptions.rangesBGR);
            dst2 = ShowPalette(dst1 * 255 / classCount);
            labels[2] = simK.labels[2] + " with " + vbc.task.redOptions.getHistBins3D().ToString() + " histogram bins";
        }
    }




    public class KMeans_SimKDepth_CS : VB_Parent
    {
        Hist3Dcloud_PlotHist1D plot1D = new Hist3Dcloud_PlotHist1D();
        Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public int classCount;
        public KMeans_SimKDepth_CS()
        {
            desc = "Use the gaps in the 3D histogram of depth to find simK and backproject the results.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            if (vbc.task.heartBeat)
            {
                plot1D.Run(src);
                dst3 = plot1D.dst2;
                labels[3] = "The 3D histogram of the depth stream in 1D";
                simK.Run(plot1D.histogram);
                plot1D.histogram = simK.dst2;
                classCount = simK.classCount;
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 2 }, plot1D.histogram, dst1, vbc.task.redOptions.rangesCloud);
            dst1 = dst1.ConvertScaleAbs();
            dst2 = ShowPalette(dst1 * 255 / classCount);
            labels[2] = simK.labels[2] + " with " + vbc.task.redOptions.getHistBins3D().ToString() + " histogram bins";
        }
    }




    public class KNN_NoDups_CS : VB_Parent
    {
        public List<PointPair> matches = new List<PointPair>();
        public List<cv.Point2f> noMatch = new List<cv.Point2f>();
        public KNN_Basics knn = new KNN_Basics();
        public List<cv.Point2f> queries = new List<cv.Point2f>();
        public List<int> neighbors = new List<int>();
        Random_Basics random = new Random_Basics();
        public KNN_NoDups_CS()
        {
            labels[2] = "KNN_Basics output with many-to-one results";
            labels[3] = "CS_KNN_NoDups_CS output with just the closest match.  Red = training data, yellow = queries.";
            desc = "Map points 1:1 with losses. Toss any farther duplicates. Easier to follow than previous version.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    random.Run(empty);
                    knn.trainInput = new List<cv.Point2f>(random.PointList);
                }
                random.Run(empty);
                queries = new List<cv.Point2f>(random.PointList);
            }
            if (queries.Count() == 0)
            {
                SetTrueText("Place some input points in queries before starting the knn run.");
                return;
            }
            knn.queries = queries;
            knn.Run(empty);
            knn.displayResults();
            dst2 = knn.dst2;
            neighbors.Clear();
            for (int i = 0; i < knn.neighbors.Count(); i++)
            {
                neighbors.Add(knn.neighbors[i][0]);
            }
            for (int i = 0; i < neighbors.Count(); i++)
            {
                var p1 = knn.queries[i];
                if (neighbors[i] == -1) continue;
                var ptn = knn.trainInput[neighbors[i]];
                for (int j = i + 1; j < neighbors.Count(); j++)
                {
                    if (neighbors[j] == neighbors[i])
                    {
                        var p2 = knn.queries[j];
                        var d1 = p1.DistanceTo(ptn);
                        var d2 = p2.DistanceTo(ptn);
                        neighbors[d1 > d2 ? i : j] = -1;
                    }
                }
            }
            dst3.SetTo(0);
            foreach (var pt in knn.trainInput)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Red);
            }
            noMatch.Clear();
            matches.Clear();
            for (int i = 0; i < neighbors.Count(); i++)
            {
                var pt = queries[i];
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Yellow);
                if (neighbors[i] == -1)
                {
                    noMatch.Add(pt);
                }
                else
                {
                    var nn = knn.trainInput[neighbors[i]];
                    matches.Add(new PointPair(pt, nn));
                    DrawLine(dst3, nn, pt, Scalar.White);
                }
            }
            if (!standaloneTest()) knn.trainInput = new List<cv.Point2f>(queries);
        }
    }




    public class KNN_Basics_CS : VB_Parent
    {
        public KNearest knn;
        public List<cv.Point2f> trainInput = new List<cv.Point2f>(); // put training data here
        public List<cv.Point2f> queries = new List<cv.Point2f>(); // put Query data here
        public List<List<int>> neighbors = new List<List<int>>();
        public int[,] result; // Get results here...
        public int desiredMatches = -1; // -1 indicates it is to use the number of queries.
        Random_Basics random = new Random_Basics();
        public KNN_Basics_CS()
        {
            knn = KNearest.Create();
            labels[2] = "Red=TrainingData, yellow = queries";
            desc = "Train a KNN model and map each query to the nearest training neighbor.";
        }
        public void displayResults()
        {
            dst2.SetTo(0);
            int dm = Math.Min(trainInput.Count(), queries.Count());
            for (int i = 0; i < queries.Count(); i++)
            {
                var pt = queries[i];
                var test = result[i, 0];
                if (test >= trainInput.Count() || test < 0) continue;
                var nn = trainInput[result[i, 0]];
                DrawCircle(dst2, pt, vbc.task.DotSize + 4, Scalar.Yellow);
                DrawLine(dst2, pt, nn, Scalar.Yellow);
            }
            foreach (var pt in trainInput)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize + 4, Scalar.Red);
            }
        }
        public void RunAlg(Mat src)
        {
            int KNNdimension = 2;
            if (standalone)
            {
                if (vbc.task.heartBeat)
                {
                    random.Run(empty);
                    trainInput = new List<cv.Point2f>(random.PointList);
                }
                random.Run(empty);
                queries = new List<cv.Point2f>(random.PointList);
            }
            var queryMat = cv.Mat.FromPixelData(queries.Count(), KNNdimension, MatType.CV_32F, queries.ToArray());
            if (queryMat.Rows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            if (trainInput.Count() == 0) trainInput = new List<cv.Point2f>(queries); // first pass, just match the queries.
            var trainData = cv.Mat.FromPixelData(trainInput.Count(), KNNdimension, MatType.CV_32F, trainInput.ToArray());
            var response = cv.Mat.FromPixelData(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            var neighborMat = new Mat();
            int dm = desiredMatches < 0 ? trainInput.Count() : desiredMatches;
            knn.FindNearest(queryMat, dm, new Mat(), neighborMat);
            if (neighborMat.Rows != queryMat.Rows || neighborMat.Cols != dm)
            {
                Debug.WriteLine("KNN's FindNearest did not return the correct number of neighbors.  Marshal.copy will fail so exit.");
                return;
            }
            float[] nData = new float[queryMat.Rows * dm];
            if (nData.Length == 0) return;
            Marshal.Copy(neighborMat.Data, nData, 0, nData.Length);
            for (int i = 0; i < nData.Length; i++)
            {
                if (Math.Abs(nData[i]) > trainInput.Count()) nData[i] = 0; // value must be within the range of traininput
            }
            result = new int[queryMat.Rows, dm];
            neighbors = new List<List<int>>();
            for (int i = 0; i < queryMat.Rows; i++)
            {
                var pt = queries[i];
                var res = new List<int>();
                for (int j = 0; j < dm; j++)
                {
                    var test = nData[i * dm + j];
                    if (test < nData.Length && test >= 0)
                    {
                        result[i, j] = (int)nData[i * dm + j];
                        int index = (int)nData[i * dm + j];
                        res.Add(index);
                    }
                }
                neighbors.Add(res);
            }
            if (standaloneTest()) displayResults();
        }
    }




    public class KNN_Basics2DTest_CS : VB_Parent
    {
        public KNN_Basics knn = new KNN_Basics();
        Random_Basics random = new Random_Basics();
        public KNN_Basics2DTest_CS()
        {
            FindSlider("Random Pixel Count").Value = 10;
            desc = "Test knn with random 2D points in the image.  Find the nearest requested neighbors.";
        }
        public void accumulateDisplay()
        {
            int dm = Math.Min(knn.trainInput.Count(), knn.queries.Count());
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                var pt = knn.queries[i];
                var test = knn.result[i, 0];
                if (test >= knn.trainInput.Count() || test < 0) continue;
                var nn = knn.trainInput[knn.result[i, 0]];
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Yellow);
                DrawLine(dst3, pt, nn, Scalar.Yellow);
            }
            foreach (var pt in knn.trainInput)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Red);
            }
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                dst3.SetTo(0);
                random.Run(empty);
                knn.trainInput = new List<cv.Point2f>(random.PointList);
            }
            random.Run(empty);
            knn.queries = new List<cv.Point2f>(random.PointList);
            knn.Run(empty);
            knn.displayResults();
            dst2 = knn.dst2;
            accumulateDisplay();
            labels[2] = "The top " + knn.trainInput.Count() + " best matches are shown. Red=TrainingData, yellow = queries";
        }
    }




    public class KNN_Basics3D_CS : VB_Parent
    {
        public KNearest knn;
        public List<cv.Point3f> trainInput = new List<cv.Point3f>(); // put training data here
        public List<cv.Point3f> queries = new List<cv.Point3f>(); // put Query data here
        public int[,] result; // Get results here...
        public KNN_Basics3D_CS()
        {
            knn = KNearest.Create();
            desc = "Use knn with the input 3D points in the image.  Find the nearest neighbors.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().  Use the " + traceName + "Test algorithm");
                return;
            }
            int KNNdimension = 3;
            var queryMat = cv.Mat.FromPixelData(queries.Count(), KNNdimension, MatType.CV_32F, queries.ToArray());
            if (queryMat.Rows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            if (trainInput.Count() == 0) trainInput = new List<cv.Point3f>(queries); // first pass, just match the queries.
            var trainData = cv.Mat.FromPixelData(trainInput.Count(), KNNdimension, MatType.CV_32F, trainInput.ToArray());
            var response = cv.Mat.FromPixelData(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            var neighbors = new Mat();
            int dm = trainInput.Count();
            knn.FindNearest(queryMat, dm, new Mat(), neighbors);
            float[] nData = new float[queryMat.Rows * dm];
            Marshal.Copy(neighbors.Data, nData, 0, nData.Length);
            result = new int[queryMat.Rows, dm];
            for (int i = 0; i < queryMat.Rows; i++)
            {
                for (int j = 0; j < dm; j++)
                {
                    var test = nData[i * dm + j];
                    if (test < nData.Length && test >= 0) result[i, j] = (int)nData[i * dm + j];
                }
            }
        }
    }




    public class KNN_Basics4D_CS : VB_Parent
    {
        public KNearest knn;
        public List<Vec4f> trainInput = new List<Vec4f>(); // put training data here
        public List<Vec4f> queries = new List<Vec4f>(); // put Query data here
        public int[,] result; // Get results here...
        public KNN_Basics4D_CS()
        {
            knn = KNearest.Create();
            labels[2] = "Red=TrainingData, yellow = queries, text shows Z distance to that point from query point";
            desc = "Use knn with the input 4D points in the image.  Find the nearest neighbors.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().  Use the " + traceName + "Test algorithm");
                return;
            }
            int KNNdimension = 4;
            Mat queryMat = cv.Mat.FromPixelData(queries.Count(), KNNdimension, MatType.CV_32F, queries.ToArray());
            if (queryMat.Rows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            if (trainInput.Count() == 0) trainInput = new List<Vec4f>(queries); // first pass, just match the queries.
            Mat trainData = cv.Mat.FromPixelData(trainInput.Count(), KNNdimension, MatType.CV_32F, trainInput.ToArray());
            Mat response = cv.Mat.FromPixelData(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            Mat neighbors = new Mat();
            int dm = trainInput.Count();
            knn.FindNearest(queryMat, dm, new Mat(), neighbors);
            float[] nData = new float[queryMat.Rows * dm];
            Marshal.Copy(neighbors.Data, nData, 0, nData.Length);
            result = new int[queryMat.Rows, dm];
            for (int i = 0; i < queryMat.Rows; i++)
            {
                for (int j = 0; j < dm; j++)
                {
                    float test = nData[i * dm + j];
                    if (test < nData.Length && test >= 0) result[i, j] = (int)nData[i * dm + j];
                }
            }
        }
    }




    public class KNN_BasicsN_CS : VB_Parent
    {
        public KNearest knn;
        public List<float> trainInput = new List<float>(); // put training data here
        public List<float> queries = new List<float>(); // put Query data here
        public int[,] result; // Get results here...
        bool messageSent;
        public Options_KNN options = new Options_KNN();
        public KNN_BasicsN_CS()
        {
            knn = KNearest.Create();
            desc = "Generalize the use knn with X input points.  Find the nearest requested neighbors.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            IEnumerable<int> responseList = Enumerable.Range(0, 10);
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().  Use the " + traceName + "_Test algorithm");
                return;
            }
            if (options.knnDimension == 0)
            {
                if (!messageSent)
                {
                    System.Windows.Forms.MessageBox.Show("The KNN dimension needs to be set for the general purpose KNN_Basics to start");
                    messageSent = true;
                }
                return;
            }
            int qRows = (int)(queries.Count() / options.knnDimension);
            if (qRows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            Mat queryMat = cv.Mat.FromPixelData(qRows, options.knnDimension, MatType.CV_32F, queries.ToArray());
            Mat trainData = cv.Mat.FromPixelData((int)(trainInput.Count() / options.knnDimension), options.knnDimension, MatType.CV_32F, trainInput.ToArray());
            Mat response = cv.Mat.FromPixelData(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            Mat neighbors = new Mat();
            int dm = trainInput.Count();
            knn.FindNearest(queryMat, dm, new Mat(), neighbors);
            result = new int[neighbors.Rows, neighbors.Cols];
            for (int i = 0; i < neighbors.Rows; i++)
            {
                for (int j = 0; j < neighbors.Cols; j++)
                {
                    float test = neighbors.Get<float>(i, j);
                    if (test < trainInput.Count() && test >= 0) result[i, j] = neighbors.Get<int>(i, j);
                }
            }
        }
    }




    public class KNN_Basics3DTest_CS : VB_Parent
    {
        KNN_Basics3D knn = new KNN_Basics3D();
        Distance_Point3D dist = new Distance_Point3D();
        Random_Basics3D random = new Random_Basics3D();
        public KNN_Basics3DTest_CS()
        {
            labels[2] = "Red=TrainingData, yellow = queries, text shows Euclidean distance to that point from query point";
            FindSlider("Random Pixel Count").Value = 100;
            desc = "Validate that knn works with random 3D points in the image.  Find the nearest requested neighbors.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                knn.queries.Clear();
                knn.trainInput.Clear();
                random.Run(empty);
                foreach (var pt in random.PointList)
                {
                    var vec = vbc.task.pointCloud.Get<cv.Point3f>((int)pt.Y, (int)pt.X);
                    if (knn.trainInput.Count() == 10)
                    {
                        if (vec.Z != 0)
                        {
                            knn.queries.Add(pt);
                            break;
                        }
                    }
                    else
                    {
                        if (vec.Z != 0) knn.trainInput.Add(pt);
                    }
                }
            }
            knn.Run(empty);
            dst2.SetTo(0);
            dist.inPoint1 = knn.queries[0];
            for (int i = 0; i < knn.trainInput.Count(); i++)
            {
                var pt = new cv.Point(knn.trainInput[i].X, knn.trainInput[i].Y);
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Red);
                dist.inPoint2 = knn.trainInput[i];
                dist.Run(src);
                SetTrueText("depth=" + knn.trainInput[i].Z.ToString() + "\n" + "dist=" + dist.distance.ToString("F0"), pt);
            }
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                cv.Point pt = new cv.Point(knn.queries[i].X, knn.queries[i].Y);
                for (int j = 0; j <= Math.Min(2, knn.trainInput.Count()); j++)
                {
                    int index = knn.result[i, j];
                    if (index >= knn.trainInput.Count() || index < 0) continue;
                    var nn = new Point2f(knn.trainInput[index].X, knn.trainInput[index].Y);
                    DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Yellow);
                    DrawLine(dst2, pt, nn, Scalar.Yellow);
                    cv.Point midPt = new cv.Point((pt.X + nn.X) / 2, (pt.Y + nn.Y) / 2);
                    SetTrueText(j.ToString(), midPt);
                    SetTrueText("depth=" + knn.queries[i].Z.ToString(), pt);
                }
            }
        }
    }




    public class KNN_Basics4DTest_CS : VB_Parent
    {
        KNN_Basics4D knn = new KNN_Basics4D();
        Distance_Point4D dist = new Distance_Point4D();
        Random_Basics4D random = new Random_Basics4D();
        public KNN_Basics4DTest_CS()
        {
            labels[2] = "Red=TrainingData, yellow = queries, text shows Euclidean distance to that point from query point";
            FindSlider("Random Pixel Count").Value = 5;
            desc = "Validate that knn works with random 3D points in the image.  Find the nearest requested neighbors.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                random.Run(empty);
                knn.trainInput = new List<Vec4f>(random.PointList);
                knn.queries.Clear();
                knn.queries.Add(new Vec4f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height), msRNG.Next(0, dst2.Height), msRNG.Next(0, dst2.Height)));
            }
            knn.Run(empty);
            dst2.SetTo(0);
            dist.inPoint1 = knn.queries[0];
            for (int i = 0; i < knn.trainInput.Count(); i++)
            {
                cv.Point pt = new cv.Point(knn.trainInput[i][0], knn.trainInput[i][1]);
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Red);
                dist.inPoint2 = knn.trainInput[i];
                dist.Run(src);
                SetTrueText("dist=" + dist.distance.ToString(vbc.fmt0), pt);
            }
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                cv.Point pt = new cv.Point(knn.queries[i][0], knn.queries[i][1]);
                for (int j = knn.result.GetLowerBound(1); j <= knn.result.GetUpperBound(1); j++)
                {
                    int index = knn.result[i, j];
                    if (index >= knn.trainInput.Count() || index < 0) continue;
                    var nn = new Point2f(knn.trainInput[index][0], knn.trainInput[index][1]);
                    DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Yellow);
                    DrawLine(dst2, pt, nn, vbc.task.HighlightColor);
                    cv.Point midPt = new cv.Point((pt.X + nn.X) / 2, (pt.Y + nn.Y) / 2);
                    SetTrueText(j.ToString(), midPt);
                }
            }
        }
    }




    public class KNN_BasicsNTest_CS : VB_Parent
    {
        KNN_BasicsN knn = new KNN_BasicsN();
        public KNN_BasicsNTest_CS()
        {
            labels[2] = "Highlight color (Yellow) is query.  The red dots are the training set.";
            desc = "Test the use of the general form KNN_BasicsN algorithm";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                knn.trainInput.Clear();
                for (int i = 0; i < knn.options.numPoints; i++)
                {
                    for (int j = 0; j < knn.options.knnDimension; j++)
                    {
                        knn.trainInput.Add(msRNG.Next(dst2.Height));
                    }
                }
                knn.queries.Clear();
                for (int j = 0; j < knn.options.knnDimension; j++)
                {
                    knn.queries.Add(msRNG.Next(dst2.Height));
                }
            }
            knn.Run(empty);
            dst2.SetTo(0);
            for (int i = 0; i < knn.trainInput.Count(); i += knn.options.knnDimension)
            {
                var pt = new Point2f(knn.trainInput[i], knn.trainInput[i + 1]);
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Red);
            }
            for (int i = 0; i < knn.queries.Count(); i += knn.options.knnDimension)
            {
                var pt = new Point2f(knn.queries[i], knn.queries[i + 1]);
                int index = knn.result[i, 0];
                if (index * knn.options.knnDimension >= knn.trainInput.Count() || index < 0) continue;
                var nn = new Point2f(knn.trainInput[index * knn.options.knnDimension], knn.trainInput[index * knn.options.knnDimension + 1]);
                DrawCircle(dst2, pt, vbc.task.DotSize + 1, vbc.task.HighlightColor);
                DrawLine(dst2, pt, nn, vbc.task.HighlightColor);
            }
            if (standaloneTest())
            {
                SetTrueText("Results are easily verified for the 2-dimensional case.  For higher dimension, " + "\n" +
                            "the results may appear incorrect because the higher dimensions are projected into " + "\n" +
                            "a 2-dimensional presentation.", 3);
            }
        }
    }




    public class KNN_Emax_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();
        public KNN_Basics knn = new KNN_Basics();
        EMax_Basics em = new EMax_Basics();
        public KNN_Emax_CS()
        {
            labels[2] = "Output from Emax";
            labels[3] = "Red=TrainingData, yellow = queries - use EMax sigma to introduce more chaos.";
            desc = "Emax centroids move but here KNN is used to matched the old and new locations and keep the colors the same.";
        }
        public void RunAlg(Mat src)
        {
            em.Run(src);
            random.Run(empty);
            knn.queries = new List<cv.Point2f>(em.centers);
            knn.Run(src);
            dst2 = em.dst2 + knn.dst2;
            knn.displayResults();
            dst3 = knn.dst2;
            knn.trainInput = new List<cv.Point2f>(knn.queries);
        }
    }




    public class KNN_TrackMean_CS : VB_Parent
    {
        Plot_Histogram plot = new Plot_Histogram();
        KNN_NoDups knn = new KNN_NoDups();
        Feature_Stable feat = new Feature_Stable();
        const int maxDistance = 50;
        public float shiftX;
        public float shiftY;
        List<cv.Point2f> motionTrack = new List<cv.Point2f>();
        Mat lastImage;
        TrackBar dotSlider;
        Options_KNN options = new Options_KNN();
        public KNN_TrackMean_CS()
        {
            FindSlider("Feature Sample Size").Value = 200;
            dotSlider = FindSlider("Average distance multiplier");
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new[] { "", "Histogram of Y-Axis camera motion", "Yellow points are good features and the white trail in the center estimates camera motion.", "Histogram of X-Axis camera motion" };
            desc = "Track points with KNN and match the goodFeatures from frame to frame";
        }
        float plotDiff(List<int> diffList, string xyStr, int labelImage, ref string label)
        {
            int count = diffList.Max() - diffList.Min() + 1;
            float[] hist = new float[maxDistance];
            int zeroLoc = hist.Length / 2;
            int nonZero = 0;
            int zeroCount = 0;
            foreach (int diff in diffList)
            {
                if (diff != 0) nonZero++;
                else zeroCount++;
                int diffPlus = diff + zeroLoc;
                if (diffPlus >= maxDistance) diffPlus = maxDistance - 1;
                if (diffPlus < 0) diffPlus = 0;
                hist[diffPlus] += 1;
            }
            plot.Run(cv.Mat.FromPixelData(hist.Length, 1, MatType.CV_32F, hist));
            var histList = hist.ToList();
            float maxVal = histList.Max();
            int maxIndex = histList.IndexOf(maxVal);
            plot.maxRange = (float)Math.Ceiling((maxVal + 50) - (maxVal + 50) % 50);
            label = xyStr + "Max count = " + maxVal + " at " + (maxIndex - zeroLoc) + " with " + nonZero + " non-zero values or " +
                    string.Format("{0:0%}", (float)nonZero / (nonZero + zeroCount));
            float histSum = 0;
            for (int i = 0; i < histList.Count(); i++)
            {
                histSum += histList[i] * (i - zeroLoc);
            }
            return histSum / histList.Count();
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) lastImage = src.Clone();
            int multiplier = dotSlider.Value;
            feat.Run(src);
            knn.queries = new List<cv.Point2f>(vbc.task.features);
            knn.Run(src);
            List<int> diffX = new List<int>();
            List<int> diffY = new List<int>();
            Mat correlationMat = new Mat();
            dst2 = src.Clone();
            var sz = vbc.task.gridSize;
            foreach (var mps in knn.matches)
            {
                var currRect = ValidateRect(new cv.Rect((int)(mps.p1.X - sz), (int)(mps.p1.Y - sz), sz * 2, sz * 2));
                var prevRect = ValidateRect(new cv.Rect((int)(mps.p2.X - sz), (int)(mps.p2.Y - sz), currRect.Width, currRect.Height));
                Cv2.MatchTemplate(lastImage[prevRect], src[currRect], correlationMat, feat.options.matchOption);
                float corrNext = correlationMat.Get<float>(0, 0);
                DrawCircle(dst2, mps.p1, vbc.task.DotSize, vbc.task.HighlightColor);
                diffX.Add((int)(mps.p1.X - mps.p2.X));
                diffY.Add((int)(mps.p1.Y - mps.p2.Y));
            }
            if (diffX.Count() == 0 || diffY.Count() == 0) return;
            string xLabel = "", yLabel = "";
            shiftX = multiplier * plotDiff(diffX, " X ", 3, ref xLabel);
            dst3 = plot.dst2.Clone();
            dst3.Line(new cv.Point(plot.plotCenter, 0), new cv.Point(plot.plotCenter, dst2.Height), Scalar.White, 1);
            shiftY = multiplier * plotDiff(diffY, " Y ", 1, ref yLabel);
            dst1 = plot.dst2;
            dst1.Line(new cv.Point(plot.plotCenter, 0), new cv.Point(plot.plotCenter, dst2.Height), Scalar.White, 1);
            lastImage = src.Clone();
            motionTrack.Add(new Point2f(shiftX + dst2.Width / 2, shiftY + dst2.Height / 2));
            if (motionTrack.Count() > vbc.task.fpsRate) motionTrack.RemoveAt(0);
            var lastpt = motionTrack[0];
            foreach (var pt in motionTrack)
            {
                DrawLine(dst2, pt, lastpt, Scalar.White);
                lastpt = pt;
            }
            SetTrueText(yLabel, 1);
            SetTrueText(xLabel, 3);
        }
    }




    public class KNN_ClosestTracker_CS : VB_Parent
    {
        public Line_Basics lines = new Line_Basics();
        public PointPair lastPair = new PointPair();
        public List<cv.Point2f> trainInput = new List<cv.Point2f>();
        List<float> minDistances = new List<float>();
        public KNN_ClosestTracker_CS()
        {
            labels = new[] { "", "", "Highlight the tracked line (move camera to see track results)", "Candidate lines - standaloneTest() only" };
            desc = "Find the longest line and keep finding it among the list of lines using a minimized KNN test.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            cv.Point2f p1 = new cv.Point2f(), p2 = new cv.Point2f();
            if (trainInput.Count() == 0)
            {
                lines.Run(src);
                dst3 = lines.dst2;
            }
            else
            {
                p1 = lastPair.p1;
                p2 = lastPair.p2;
            }
            foreach (var lp in lines.lpList)
            {
                if (trainInput.Count() == 0)
                {
                    p1 = lp.p1;
                    p2 = lp.p2;
                }
                trainInput.Add(lp.p1);
                trainInput.Add(lp.p2);
                if (trainInput.Count() >= 10) break;
            }
            if (trainInput.Count() == 0)
            {
                SetTrueText("No lines were found in the current image.");
                return;
            }
            if (lastPair.compare(new PointPair())) lastPair = new PointPair(p1, p2);
            List<float> distances = new List<float>();
            for (int i = 0; i < trainInput.Count(); i += 2)
            {
                var pt1 = trainInput[i];
                var pt2 = trainInput[i + 1];
                distances.Add((float)(Math.Min(pt1.DistanceTo(lastPair.p1) + pt2.DistanceTo(lastPair.p2), pt1.DistanceTo(lastPair.p2) + pt2.DistanceTo(lastPair.p2))));
            }
            float minDist = distances.Min();
            int index = distances.IndexOf(minDist) * 2;
            p1 = trainInput[index];
            p2 = trainInput[index + 1];
            if (minDistances.Count() > 0)
            {
                if (minDist > minDistances.Max() * 2)
                {
                    Debug.WriteLine("Overriding KNN min Distance Rule = " + string.Format("{0:0}", minDist) + " max = " + string.Format("{0:0}", minDistances.Max()));
                    lastPair = new PointPair(trainInput[0], trainInput[1]);
                }
                else
                {
                    lastPair = new PointPair(p1, p2);
                }
            }
            else
            {
                lastPair = new PointPair(p1, p2);
            }
            if (minDist > 0) minDistances.Add(minDist);
            if (minDistances.Count() > 100) minDistances.RemoveAt(0);
            DrawLine(dst2, p1, p2, vbc.task.HighlightColor);
            trainInput.Clear();
        }
    }




    public class KNN_ClosestLine_CS : VB_Parent
    {
        public Point2f lastP1;
        public Point2f lastP2;
        public int lastIndex;
        public List<cv.Point2f> trainInput = new List<cv.Point2f>();
        List<float> minDistances;
        public KNN_ClosestLine_CS()
        {
            desc = "Try to find the closest pair of points in the traininput.  Dynamically compute distance ceiling to determine when to report fail.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            if (lastP1 == new Point2f())
            {
                SetTrueText("KNN_ClosestLine_CS is only run with other KNN algorithms" + "\n" +
                            "lastP1 and lastP2 need to be initialized by the other algorithm." + "\n" +
                            "Initialize with a pair of points to track a line. ", 3);
                return;
            }
            List<float> distances = new List<float>();
            for (int i = 0; i < trainInput.Count(); i += 2)
            {
                var pt1 = trainInput[i];
                var pt2 = trainInput[i + 1];
                distances.Add((float)(Math.Min(pt1.DistanceTo(lastP1) + pt2.DistanceTo(lastP2), pt1.DistanceTo(lastP2) + pt2.DistanceTo(lastP2))));
            }
            float minDist = distances.Min();
            lastIndex = distances.IndexOf(minDist) * 2;
            lastP1 = trainInput[lastIndex];
            lastP2 = trainInput[lastIndex + 1];
            if (vbc.task.FirstPass) minDistances = new List<float> { distances[0] };
            if (minDist > minDistances.Max() * 4)
            {
                Debug.WriteLine("Overriding KNN min Distance Rule = " + string.Format("{0:0}", minDist) + " max = " + string.Format("{0:0}", minDistances.Max()));
                lastP1 = trainInput[0];
                lastP2 = trainInput[1];
            }
            if (minDist > 0) minDistances.Add(minDist);
            if (minDistances.Count() > 100) minDistances.RemoveAt(0);
            DrawLine(dst2, lastP1, lastP2, vbc.task.HighlightColor);
            trainInput.Clear();
        }
    }




    public class KNN_ClosestVertical_CS : VB_Parent
    {
        public FeatureLine_Finder lines = new FeatureLine_Finder();
        public KNN_ClosestLine knn = new KNN_ClosestLine();
        public Point3f pt1 = new Point3f();
        public Point3f pt2 = new Point3f();
        public KNN_ClosestVertical_CS()
        {
            labels = new[] { "", "", "Highlight the tracked line", "Candidate vertical lines are in Blue" };
            desc = "Test the code find the longest line and track it using a minimized KNN test.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            lines.Run(src);
            if (lines.sortedVerticals.Count() == 0)
            {
                SetTrueText("No vertical lines were found.");
                return;
            }
            int index = lines.sortedVerticals.ElementAt(0).Value;
            float lastDistance = (float)knn.lastP1.DistanceTo(knn.lastP2);
            float bestDistance = (float)lines.lines2D[index].DistanceTo(lines.lines2D[index + 1]);
            if (knn.lastP1 == new Point2f() || lastDistance < 0.75f * bestDistance)
            {
                knn.lastP1 = lines.lines2D[index];
                knn.lastP2 = lines.lines2D[index + 1];
            }
            knn.trainInput.Clear();
            for (int i = 0; i < lines.sortedVerticals.Count(); i++)
            {
                index = lines.sortedVerticals.ElementAt(i).Value;
                knn.trainInput.Add(lines.lines2D[index]);
                knn.trainInput.Add(lines.lines2D[index + 1]);
            }
            knn.Run(src);
            pt1 = lines.lines3D[knn.lastIndex];
            pt2 = lines.lines3D[knn.lastIndex + 1];
            dst3 = lines.dst3;
            DrawLine(dst2, knn.lastP1, knn.lastP2, vbc.task.HighlightColor);
        }
    }




    public class KNN_NoDupsOld_CS : VB_Parent
    {
        public List<PointPair> matches = new List<PointPair>();
        public List<cv.Point> noMatch = new List<cv.Point>();
        public KNN_Basics knn = new KNN_Basics();
        public List<cv.Point2f> queries = new List<cv.Point2f>();
        Random_Basics random = new Random_Basics();
        public KNN_NoDupsOld_CS()
        {
            labels[2] = "KNN_Basics output with many-to-one results";
            labels[3] = "KNN_NoDupsOld_CS output with just the closest match.  Red = training data, yellow = queries.";
            desc = "Map points 1:1 with losses.  When duplicates are found, toss the farthest.  Too hard to follow.  Trying a better approach.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    random.Run(empty);
                    knn.trainInput = new List<cv.Point2f>(random.PointList);
                }
                random.Run(empty);
                queries = new List<cv.Point2f>(random.PointList);
            }
            if (queries.Count() == 0)
            {
                SetTrueText("Place some input points in queries before starting the knn run.");
                return;
            }
            knn.queries = queries;
            knn.Run(empty);
            knn.displayResults();
            dst2 = knn.dst2;
            var nearest = new List<int>();
            var sortedResults = new SortedList<int, int>(new CompareAllowIdenticalInteger());
            for (int i = 0; i < queries.Count(); i++)
            {
                nearest.Add(knn.result[i, 0]);
                sortedResults.Add(knn.result[i, 0], i);
            }
            for (int i = 0; i < sortedResults.Count() - 1; i++)
            {
                var resultA = sortedResults.ElementAt(i).Key;
                var resultB = sortedResults.ElementAt(i + 1).Key;
                if (resultA == resultB)
                {
                    var nn = knn.trainInput[resultA];
                    var queryA = sortedResults.ElementAt(i).Value;
                    for (int j = i + 1; j < sortedResults.Count(); j++)
                    {
                        resultB = sortedResults.ElementAt(j).Key;
                        if (resultA != resultB) break;
                        var queryB = sortedResults.ElementAt(j).Value;
                        var p1 = queries[queryA];
                        var p2 = queries[queryB];
                        var distance1 = Math.Sqrt((p1.X - nn.X) * (p1.X - nn.X) + (p1.Y - nn.Y) * (p1.Y - nn.Y));
                        var distance2 = Math.Sqrt((p2.X - nn.X) * (p2.X - nn.X) + (p2.Y - nn.Y) * (p2.Y - nn.Y));
                        if (distance1 < distance2)
                        {
                            nearest[queryB] = -1;
                        }
                        else
                        {
                            nearest[queryA] = -1;
                            queryA = queryB;
                        }
                    }
                }
            }
            dst3.SetTo(0);
            foreach (var pt in knn.trainInput)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Red);
            }
            noMatch.Clear();
            matches.Clear();
            for (int i = 0; i < queries.Count(); i++)
            {
                var pt = queries[i];
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Yellow);
                if (nearest[i] == -1)
                {
                    noMatch.Add(new cv.Point((int)pt.X, (int)pt.Y));
                }
                else
                {
                    if (nearest[i] < knn.trainInput.Count())
                    {
                        var nn = knn.trainInput[nearest[i]];
                        matches.Add(new PointPair(pt, nn));
                        DrawLine(dst3, nn, pt, Scalar.White);
                    }
                }
            }
            if (!standaloneTest()) knn.trainInput = new List<cv.Point2f>(queries);
        }
    }




    public class KNN_Farthest_CS : VB_Parent
    {
        KNN_Basics knn = new KNN_Basics();
        public PointPair mpFar;
        Random_Basics random = new Random_Basics();
        public KNN_Farthest_CS()
        {
            labels = new string[] { "", "", "Lines connecting pairs that are farthest.", "Training Input which is also query input and longest line" };
            desc = "Use KNN to find the farthest point from each query point.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    random.Run(empty);
                    knn.trainInput = new List<cv.Point2f>(random.PointList);
                    knn.queries = new List<cv.Point2f>(knn.trainInput);
                }
            }
            knn.Run(empty);
            dst2.SetTo(0);
            dst3.SetTo(0);
            var farthest = new List<PointPair>();
            var distances = new List<float>();
            for (int i = 0; i <= knn.result.GetUpperBound(0) - 1; i++)
            {
                int farIndex = knn.result[i, knn.result.GetUpperBound(1)];
                var mp = new PointPair(knn.queries[i], knn.trainInput[farIndex]);
                DrawCircle(dst2, mp.p1, vbc.task.DotSize + 4, Scalar.Yellow);
                DrawCircle(dst2, mp.p2, vbc.task.DotSize + 4, Scalar.Yellow);
                DrawLine(dst2, mp.p1, mp.p2, Scalar.Yellow);
                farthest.Add(mp);
                distances.Add((float)mp.p1.DistanceTo(mp.p2));
            }
            foreach (var pt in knn.queries)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize + 4, Scalar.Red);
            }
            var maxIndex = distances.IndexOf(distances.Max());
            mpFar = farthest[maxIndex];
            DrawLine(dst3, mpFar.p1, mpFar.p2, Scalar.White);
        }
    }




    public class KNN_TrackEach_CS : VB_Parent
    {
        KNN_NoDups knn = new KNN_NoDups();
        Feature_Stable feat = new Feature_Stable();
        List<List<PointPair>> trackAll = new List<List<PointPair>>();
        public KNN_TrackEach_CS()
        {
            desc = "Track each good feature with KNN and match the goodFeatures from frame to frame";
        }
        public void RunAlg(Mat src)
        {
            var minDistance = feat.options.minDistance;
            if (!vbc.task.motionFlag || vbc.task.optionsChanged) minDistance = 2;
            feat.Run(src);
            knn.queries = new List<cv.Point2f>(vbc.task.features);
            knn.Run(src);
            var tracker = new List<PointPair>();
            dst2 = src.Clone();
            foreach (var mp in knn.matches)
            {
                if (mp.p1.DistanceTo(mp.p2) < minDistance) tracker.Add(mp);
            }
            trackAll.Add(tracker);
            for (int i = 0; i < trackAll.Count(); i += 2)
            {
                var t1 = trackAll[i];
                foreach (var mp in t1)
                {
                    DrawCircle(dst2, mp.p1, vbc.task.DotSize, vbc.task.HighlightColor);
                    DrawCircle(dst2, mp.p2, vbc.task.DotSize, vbc.task.HighlightColor);
                    DrawLine(dst2, mp.p1, mp.p2, Scalar.Red);
                }
            }
            labels[2] = vbc.task.features.Count().ToString() + " good features were tracked across " + vbc.task.frameHistoryCount.ToString() + " frames.";
            SetTrueText(labels[2] + "\nThe highlighted dots are the good feature points", 3);
            if (trackAll.Count() > vbc.task.frameHistoryCount) trackAll.RemoveAt(0);
        }
    }




    public class LaneFinder_Basics_CS : VB_Parent
    {
        LaneFinder_SlopeIntercept lane = new LaneFinder_SlopeIntercept();
        public LaneFinder_Basics_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "The basics of lane-finding.  A better name than LaneFinder_SlopeIntercept";
        }
        public void RunAlg(Mat src)
        {
            lane.Run(src);
            dst0 = lane.dst0;
            dst1 = lane.dst1;
            dst2 = lane.dst2;
            dst3 = lane.dst3;
        }
    }




    public class LaneFinder_Videos_CS : VB_Parent
    {
        public Video_Basics video = new Video_Basics();
        Options_LaneFinder options = new Options_LaneFinder();
        public LaneFinder_Videos_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();

            desc = "Read in the videos showing road conditions.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                FileInfo inputFile = new FileInfo(vbc.task.HomeDir + options.inputName);
                if (inputFile.Exists) video.options.fileInfo = new FileInfo(inputFile.FullName);
            }
            video.Run(empty);
            dst2 = video.dst2;
        }
    }




    public class LaneFinder_Edges_CS : VB_Parent
    {
        LaneFinder_Videos input = new LaneFinder_Videos();
        Edge_Basics edges = new Edge_Basics();
        public LaneFinder_Edges_CS()
        {
            desc = "Using the videos provided, find the lane markers.";
        }
        public void RunAlg(Mat src)
        {
            input.Run(empty);
            dst0 = input.dst2;
            edges.Run(dst0);
            dst2 = edges.dst2;
        }
    }




    public class LaneFinder_HLSColor_CS : VB_Parent
    {
        public LaneFinder_Videos input = new LaneFinder_Videos();
        public LaneFinder_HLSColor_CS()
        {
            labels = new string[] { "HLS color conversion", "InRange White", "InRange Yellow", "Combined InRange White and InRange Yellow results" };
            desc = "Isolate the colors for the white and yellow";
        }
        public void RunAlg(Mat src)
        {
            input.Run(empty);
            dst0 = input.dst2.CvtColor(cv.ColorConversionCodes.BGR2HLS);
            dst1 = dst0.InRange(new Scalar(0, 200, 0), new Scalar(255, 255, 255));
            dst2 = dst0.InRange(new Scalar(10, 0, 100), new Scalar(40, 255, 255));
            dst3 = dst1 | dst2;
        }
    }




    public class LaneFinder_ROI_CS : VB_Parent
    {
        LaneFinder_HLSColor hls = new LaneFinder_HLSColor();
        cv.Point[][] pListList = new cv.Point[1][];
        public LaneFinder_ROI_CS()
        {
            labels = new string[] { "Original input", "Mask showing ROI", "HLS version with ROI outline", "HLS Mask with ROI outline" };
            desc = "Define the ROI for the location of the lanes";
        }
        public void RunAlg(Mat src)
        {
            hls.Run(empty);
            if (vbc.task.optionsChanged)
            {
                var w = hls.input.video.dst2.Width;
                var h = hls.input.video.dst2.Height;
                var bl = new cv.Point(w * 0.1, h * 0.95);
                var tl = new cv.Point(w * 0.4, h * 0.6);
                var br = new cv.Point(w * 0.95, h * 0.95);
                var tr = new cv.Point(w * 0.6, h * 0.6);
                var pList = new cv.Point[] { bl, tl, tr, br };
                dst1 = new Mat(new cv.Size(w, h), MatType.CV_8U, cv.Scalar.All(0));
                dst1.FillConvexPoly(pList, Scalar.White, vbc.task.lineType);
                pListList[0] = pList;
            }
            dst0 = hls.input.video.dst2;
            dst2 = hls.dst0;
            dst3 = hls.dst3;
            Cv2.Polylines(dst0, pListList, true, Scalar.White, vbc.task.lineWidth, vbc.task.lineType, 0);
            Cv2.Polylines(dst2, pListList, true, Scalar.White, vbc.task.lineWidth, vbc.task.lineType, 0);
            Cv2.Polylines(dst3, pListList, true, Scalar.White, vbc.task.lineWidth, vbc.task.lineType, 0);
        }
    }




    public class LaneFinder_SlopeIntercept_CS : VB_Parent
    {
        Hough_LaneFinder hough = new Hough_LaneFinder();
        public float leftLaneIntercept;
        public float rightLaneIntercept;
        public float leftAvgSlope;
        public float rightAvgSlope;
        public LaneFinder_SlopeIntercept_CS()
        {
            desc = "Use the Hough lines found to build a slope intercept format line.";
        }
        public void RunAlg(Mat src)
        {
            hough.Run(empty);
            dst0 = hough.dst0;
            dst1 = hough.dst2;
            dst2 = hough.dst3;
            dst3 = hough.dst0.Clone();
            if (hough.segments.Count() == 0) return;
            var leftIntercept = new List<float>();
            var leftSlope = new List<float>();
            var leftWeight = new List<float>();
            var rightIntercept = new List<float>();
            var rightSlope = new List<float>();
            var rightWeight = new List<float>();
            foreach (var line in hough.segments)
            {
                if (line.P1.X == line.P2.X) continue;
                var slope = (line.P1.Y - line.P2.Y) / (line.P1.X - line.P2.X);
                if (slope < 0)
                {
                    leftIntercept.Add(line.P1.Y - (slope * line.P1.X));
                    leftSlope.Add(slope);
                    leftWeight.Add((float)line.P1.DistanceTo(line.P2));
                }
                else
                {
                    rightIntercept.Add(line.P1.Y - (slope * line.P1.X));
                    rightSlope.Add(slope);
                    rightWeight.Add((float)line.P1.DistanceTo(line.P2));
                }
            }
            var mat1 = cv.Mat.FromPixelData(leftWeight.Count(), 1, MatType.CV_32F, leftWeight.ToArray());
            var mat2 = cv.Mat.FromPixelData(leftSlope.Count(), 1, MatType.CV_32F, leftSlope.ToArray());
            var mat3 = cv.Mat.FromPixelData(leftIntercept.Count(), 1, MatType.CV_32F, leftIntercept.ToArray());
            var weight = leftWeight.Sum();
            leftLaneIntercept = (float)(mat1.Dot(mat3) / weight);
            leftAvgSlope = (float)(mat1.Dot(mat2) / weight);
            mat1 = cv.Mat.FromPixelData(rightWeight.Count(), 1, MatType.CV_32F, rightWeight.ToArray());
            mat2 = cv.Mat.FromPixelData(rightSlope.Count(), 1, MatType.CV_32F, rightSlope.ToArray());
            mat3 = cv.Mat.FromPixelData(rightIntercept.Count(), 1, MatType.CV_32F, rightIntercept.ToArray());
            weight = rightWeight.Sum();
            rightLaneIntercept = (float)(mat1.Dot(mat3) / weight);
            rightAvgSlope = (float)(mat1.Dot(mat2) / weight);
            SetTrueText("Left lane intercept = " + string.Format(vbc.fmt1, leftLaneIntercept) +
                        " Right lane intercept = " + string.Format(vbc.fmt1, rightLaneIntercept) + "\n" +
                        "Left slope = " + string.Format(vbc.fmt3, leftAvgSlope) +
                        " Right slope = " + string.Format(vbc.fmt3, rightAvgSlope), 3);
            var tmp = dst2.EmptyClone();
            var p1 = new cv.Point(0, leftLaneIntercept);
            var p2 = new cv.Point(-leftLaneIntercept / leftAvgSlope, 0);
            tmp.Line(p1, p2, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            p1 = new cv.Point(0, rightLaneIntercept);
            p2 = new cv.Point((dst0.Height - rightLaneIntercept) / rightAvgSlope, dst2.Height);
            tmp.Line(p1, p2, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            tmp.CopyTo(dst2, hough.mask);
            dst2.CopyTo(dst3, dst2);
        }
    }




    public class Laplacian_PyramidFilter_CS : VB_Parent
    {
        Options_LaPlacianPyramid options = new Options_LaPlacianPyramid();
        public Laplacian_PyramidFilter_CS()
        {
            desc = "C# version of the Laplacian Pyramid Filter - see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.54.299.";
        }
        public void RunAlg(Mat src)
        {
            src.ConvertTo(options.img, MatType.CV_32F);
            options.RunOpt();
            options.img.ConvertTo(dst2, MatType.CV_8UC3);
        }
    }




    public class Laplacian_Basics_CS : VB_Parent
    {
        Options_Laplacian options = new Options_Laplacian();
        Erode_Basics erode = new Erode_Basics();
        Dilate_Basics dilate = new Dilate_Basics();
        public Laplacian_Basics_CS()
        {
            desc = "Laplacian filter - the second derivative.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) src = src.GaussianBlur(options.kernel, 0, 0);
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = src.Laplacian(MatType.CV_16S, options.kernel.Width, options.scale, options.delta).ConvertScaleAbs();
            erode.Run(dst3.Threshold(options.threshold, 255, ThresholdTypes.Binary));
            dilate.Run(erode.dst2);
            dst2 = dilate.dst2;
            labels[2] = "Laplacian Filter k = " + options.kernel.Width.ToString();
            labels[3] = "Laplacian after " + erode.options.iterations.ToString() + " erode iterations and " + dilate.options.iterations.ToString() + " dilate iterations";
        }
    }




    public class Laplacian_Blur_CS : VB_Parent
    {
        Options_Laplacian options = new Options_Laplacian();
        public Laplacian_Blur_CS()
        {
            desc = "Laplacian filter - the second derivative - with different bluring techniques";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            string blurText;
            if (options.gaussianBlur)
            {
                src = src.GaussianBlur(options.kernel, 0, 0);
                blurText = "Gaussian";
            }
            else if (options.boxFilterBlur)
            {
                src = src.Blur(options.kernel);
                blurText = "boxfilter";
            }
            else
            {
                src = src.MedianBlur(options.kernel.Width);
                blurText = "MedianBlur";
            }
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = src.Laplacian(MatType.CV_16S, options.kernel.Width, options.scale, options.delta).ConvertScaleAbs();
            labels[2] = "Laplacian+" + blurText + " k = " + options.kernel.Width.ToString();
        }
    }




    public class LeftRight_Basics_CS : VB_Parent
    {
        public LeftRight_Basics_CS()
        {
            if (vbc.task.cameraName == "MYNT-EYE-D1000") FindSlider("Alpha (contrast)").Value = 1100;
            labels = new string[] { "", "", "Left camera image", vbc.task.cameraName == "Azure Kinect 4K" ? "No right image" : "Right camera image" };
            desc = "Display the left and right views as they came from the camera.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.leftView;
            dst3 = vbc.task.rightView;
        }
    }




    public class LeftRight_CompareRaw_CS : VB_Parent
    {
        Options_LeftRight options = new Options_LeftRight();
        public LeftRight_CompareRaw_CS()
        {
            desc = "Show slices of the left and right view next to each other for visual comparison";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            cv.Rect r1 = new cv.Rect(0, options.sliceY, vbc.task.leftView.Width, options.sliceHeight);
            cv.Rect r2 = new cv.Rect(0, 25, vbc.task.leftView.Width, options.sliceHeight);
            dst2.SetTo(0);
            vbc.task.leftView[r1].CopyTo(dst2[r2]);
            r2.Y += options.sliceHeight;
            vbc.task.rightView[r1].CopyTo(dst2[r2]);
            dst3 = vbc.task.rightView;
        }
    }




    public class LeftRight_Palettized_CS : VB_Parent
    {
        public LeftRight_Palettized_CS()
        {
            desc = "Add color to the 8-bit infrared images.";
            labels[2] = "Left Image";
            labels[3] = "Right Image";
        }
        public void RunAlg(Mat src)
        {
            dst2 = ShowPalette(vbc.task.leftView);
            dst3 = ShowPalette(vbc.task.rightView);
        }
    }




    public class LeftRight_BRISK_CS : VB_Parent
    {
        BRISK_Basics brisk = new BRISK_Basics();
        Options_Features options = new Options_Features();
        public LeftRight_BRISK_CS()
        {
            FindSlider("Min Distance").Value = 20;
            labels = new string[] { "", "", "Left Image", "Right Image" };
            desc = "Add color to the 8-bit infrared images.";
        }
        public void RunAlg(Mat src)
        {
            brisk.Run(vbc.task.leftView);
            dst2 = brisk.dst2.Clone();
            brisk.Run(vbc.task.rightView);
            dst3 = brisk.dst2.Clone();
        }
    }




    public class LeftRight_Edges_CS : VB_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        public LeftRight_Edges_CS()
        {
            desc = "Display the edges in the left and right views";
            labels[2] = "Left Image";
            labels[3] = "Right Image";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(vbc.task.leftView);
            dst2 = edges.dst2;
            edges.Run(vbc.task.rightView);
            dst3 = edges.dst2;
        }
    }




    public class LeftRight_Reduction_CS : VB_Parent
    {
        public Reduction_Basics reduction = new Reduction_Basics();
        public LeftRight_Reduction_CS()
        {
            labels = new string[] { "", "", "Reduced Left Image", "Reduced Right Image" };
            desc = "Reduce both the left and right color images";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(vbc.task.leftView);
            dst2 = reduction.dst2.Clone();
            reduction.Run(vbc.task.rightView);
            dst3 = reduction.dst2.Clone();
        }
    }




    public class LeftRight_Markers_CS : VB_Parent
    {
        LeftRight_Reduction redView = new LeftRight_Reduction();
        public LeftRight_Markers_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Reduced Left Image", "Reduced Right Image" };
            desc = "Use the left/right reductions to find hard markers - neighboring pixels of identical values";
        }
        public void RunAlg(Mat src)
        {
            redView.Run(src);
            dst2 = redView.reduction.dst3.Clone();
            dst3 = redView.reduction.dst3.Clone();
            var left = redView.dst2;
            var right = redView.dst3;
            // find combinations in the left image - they are markers.
            var impList = new List<List<int>>();
            var lineLen = vbc.task.gOptions.DebugSliderValue;
            for (int y = 0; y < left.Height; y++)
            {
                var important = new List<int>();
                var impCounts = new List<int>();
                for (int x = 0; x < left.Width; x++)
                {
                    var m1 = left.Get<byte>(y, x);
                    if (!important.Contains(m1))
                    {
                        important.Add(m1);
                        impCounts.Add(1);
                    }
                    else
                    {
                        impCounts[important.IndexOf(m1)] += 1;
                    }
                }
                impList.Add(important);
                impList.Add(impCounts);
            }
            dst0.SetTo(0);
            dst1.SetTo(0);
            for (int i = 0; i < left.Rows; i++)
            {
                var important = impList[i * 2];
                var impcounts = impList[i * 2 + 1];
                var maxVal = important[impcounts.IndexOf(impcounts.Max())];
                var tmp = left.Row(i).InRange(maxVal, maxVal);
                dst0.Row(i).SetTo(255, tmp);
                tmp = right.Row(i).InRange(maxVal, maxVal);
                dst1.Row(i).SetTo(255, tmp);
            }
        }
    }




    public class LeftRight_Markers1_CS : VB_Parent
    {
        LeftRight_Reduction redView = new LeftRight_Reduction();
        public LeftRight_Markers1_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Reduced Left Image", "Reduced Right Image" };
            desc = "Use the left/right reductions to find markers - neighboring pixels of identical values";
        }
        public void RunAlg(Mat src)
        {
            redView.Run(src);
            dst0 = redView.dst2;
            dst1 = redView.dst3;
            // find combinations in the left image - they are markers.
            List<List<int>> impList = new List<List<int>>();
            int lineLen = vbc.task.gOptions.DebugSliderValue;
            for (int y = 0; y < dst2.Height; y++)
            {
                List<int> important = new List<int>();
                List<int> impCounts = new List<int>();
                for (int x = 0; x < dst0.Width; x++)
                {
                    byte m1 = dst0.At<byte>(y, x);
                    if (!important.Contains(m1))
                    {
                        important.Add(m1);
                        impCounts.Add(1);
                    }
                    else
                    {
                        impCounts[important.IndexOf(m1)] += 1;
                    }
                }
                impList.Add(important);
                impList.Add(impCounts);
            }
            dst2.SetTo(0);
            dst3.SetTo(0);
            for (int i = 0; i < dst2.Rows; i++)
            {
                List<int> important = impList[i * 2];
                List<int> impcounts = impList[i * 2 + 1];
                int maxVal = important[impcounts.IndexOf(impcounts.Max())];
                Mat tmp = dst0.Row(i).InRange(maxVal, maxVal);
                dst2.Row(i).SetTo(255, tmp);
                tmp = dst1.Row(i).InRange(maxVal, maxVal);
                dst3.Row(i).SetTo(255, tmp);
            }
        }
    }




    public class LeftRight_Lines_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        public LeftRight_Lines_CS()
        {
            labels = new string[] { "", "", "Left camera lines", "Right camera lines" };
            desc = "Find the lines in the Left and Right images.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(vbc.task.leftView);
            dst2 = lines.dst2.Clone();
            lines.Run(vbc.task.rightView);
            dst3 = lines.dst2;
        }
    }




    public class LeftRight_RedCloudRight_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public LeftRight_RedCloudRight_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Segment the right view image with RedCloud";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(vbc.task.rightView);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class LeftRight_RedCloudLeft_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public LeftRight_RedCloudLeft_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Segment the left view image with RedCloud";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(vbc.task.leftView);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class LeftRight_RedCloudBoth_CS : VB_Parent
    {
        LeftRight_RedCloudRight stLeft = new LeftRight_RedCloudRight();
        LeftRight_RedCloudLeft stRight = new LeftRight_RedCloudLeft();
        public LeftRight_RedCloudBoth_CS()
        {
            desc = "Match cells in the left view to the right view - something is flipped here...";
        }
        public void RunAlg(Mat src)
        {
            stRight.Run(empty);
            dst2 = stRight.dst2;
            labels[2] = "Left view - " + stRight.labels[2];
            stLeft.Run(empty);
            dst3 = stLeft.dst2;
            labels[3] = "Right view - " + stLeft.labels[2];
        }
    }




    public class LeftRight_Features_CS : VB_Parent
    {
        FeatureLeftRight_Basics feat = new FeatureLeftRight_Basics();
        public LeftRight_Features_CS()
        {
            desc = "Placeholder to make it easier to find FeatureLeftRight_Basics";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            dst3 = feat.dst3;
            labels = feat.labels;
        }
    }




    public class Line_Basics_CS : VB_Parent
    {
        cv.XImgProc.FastLineDetector ld;
        public List<PointPair> lpList = new List<PointPair>();
        public Scalar lineColor = Scalar.White;
        public Line_Basics_CS()
        {
            ld = cv.XImgProc.CvXImgProc.CreateFastLineDetector();
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use FastLineDetector (OpenCV Contrib) to find all the lines present.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3)
                dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            else
                dst2 = src.Clone();
            if (dst2.Type() != MatType.CV_8U)
                dst2.ConvertTo(dst2, MatType.CV_8U);
            var lines = ld.Detect(dst2);
            var sortByLen = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
            foreach (var v in lines)
            {
                if (v[0] >= 0 && v[0] <= dst2.Cols && v[1] >= 0 && v[1] <= dst2.Rows &&
                    v[2] >= 0 && v[2] <= dst2.Cols && v[3] >= 0 && v[3] <= dst2.Rows)
                {
                    var p1 = new cv.Point(v[0], v[1]);
                    var p2 = new cv.Point(v[2], v[3]);
                    var lp = new PointPair(p1, p2);
                    sortByLen.Add(lp.length, lp);
                }
            }
            dst2 = src;
            dst3.SetTo(0);
            lpList.Clear();
            foreach (var lp in sortByLen.Values)
            {
                lpList.Add(lp);
                DrawLine(dst2, lp.p1, lp.p2, lineColor);
                DrawLine(dst3, lp.p1, lp.p2, cv.Scalar.All(255));
            }
            labels[2] = lpList.Count().ToString() + " lines were detected in the current frame";
        }
    }




    public class Line_SubsetRect_CS : VB_Parent
    {
        cv.XImgProc.FastLineDetector ld;
        public SortedList<float, PointPair> sortByLen = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
        public List<PointPair> mpList = new List<PointPair>();
        public List<cv.Point2f> ptList = new List<cv.Point2f>();
        public cv.Rect subsetRect;
        public Scalar lineColor = Scalar.White;
        public Line_SubsetRect_CS()
        {
            subsetRect = new cv.Rect(0, 0, dst2.Width, dst2.Height);
            ld = cv.XImgProc.CvXImgProc.CreateFastLineDetector();
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use FastLineDetector (OpenCV Contrib) to find all the lines present.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3)
                dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            else
                dst2 = src.Clone();
            if (dst2.Type() != MatType.CV_8U)
                dst2.ConvertTo(dst2, MatType.CV_8U);
            var lines = ld.Detect(dst2[subsetRect]);
            sortByLen.Clear();
            mpList.Clear();
            ptList.Clear();
            foreach (var v in lines)
            {
                if (v[0] >= 0 && v[0] <= dst2.Cols && v[1] >= 0 && v[1] <= dst2.Rows &&
                    v[2] >= 0 && v[2] <= dst2.Cols && v[3] >= 0 && v[3] <= dst2.Rows)
                {
                    var p1 = new cv.Point(v[0] + subsetRect.X, v[1] + subsetRect.Y);
                    var p2 = new cv.Point(v[2] + subsetRect.X, v[3] + subsetRect.Y);
                    var lp = new PointPair(p1, p2);
                    mpList.Add(lp);
                    ptList.Add(p1);
                    ptList.Add(p2);
                    sortByLen.Add(lp.length, lp);
                }
            }
            dst2 = src;
            dst3.SetTo(0);
            foreach (var lp in sortByLen.Values)
            {
                DrawLine(dst2, lp.p1, lp.p2, lineColor);
                DrawLine(dst3, lp.p1, lp.p2, cv.Scalar.All(255));
            }
            labels[2] = mpList.Count().ToString() + " lines were detected in the current frame";
        }
    }




    public class Line_InterceptsUI_CS : VB_Parent
    {
        Line_Intercepts lines = new Line_Intercepts();
        cv.Point p2;
        System.Windows.Forms.RadioButton redRadio;
        System.Windows.Forms.RadioButton greenRadio;
        System.Windows.Forms.RadioButton yellowRadio;
        System.Windows.Forms.RadioButton blueRadio;
        public Line_InterceptsUI_CS()
        {
            redRadio = FindRadio("Show Top intercepts");
            greenRadio = FindRadio("Show Bottom intercepts");
            yellowRadio = FindRadio("Show Right intercepts");
            blueRadio = FindRadio("Show Left intercepts");
            labels[2] = "Use mouse in right image to highlight lines";
            desc = "An alternative way to highlight line segments with common slope";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst3.SetTo(0);
            var red = new Scalar(0, 0, 255);
            var green = new Scalar(1, 128, 0);
            var yellow = new Scalar(2, 255, 255);
            var blue = new Scalar(254, 0, 0);
            var center = new cv.Point(dst3.Width / 2, dst3.Height / 2);
            dst3.Line(new cv.Point(0, 0), center, blue, vbc.task.lineWidth, LineTypes.Link4);
            dst3.Line(new cv.Point(dst2.Width, 0), center, red, vbc.task.lineWidth, LineTypes.Link4);
            dst3.Line(new cv.Point(0, dst2.Height), center, blue, vbc.task.lineWidth, LineTypes.Link4);
            dst3.Line(new cv.Point(dst2.Width, dst2.Height), center, yellow, vbc.task.lineWidth, LineTypes.Link4);
            var mask = new Mat(new cv.Size(dst2.Width + 2, dst2.Height + 2), MatType.CV_8U, cv.Scalar.All(0));
            var pt = new cv.Point(center.X, center.Y - 30);
            cv.Rect r;
            Cv2.FloodFill(dst3, mask, pt, red, out r, cv.Scalar.All(1), cv.Scalar.All(1), FloodFillFlags.FixedRange | (cv.FloodFillFlags)(255 << 8));
            pt = new cv.Point(center.X, center.Y + 30);
            Cv2.FloodFill(dst3, mask, pt, green, out r, cv.Scalar.All(1), cv.Scalar.All(1), FloodFillFlags.FixedRange | (cv.FloodFillFlags)(255 << 8));
            pt = new cv.Point(center.X - 30, center.Y);
            Cv2.FloodFill(dst3, mask, pt, blue, out r, cv.Scalar.All(1), cv.Scalar.All(1), FloodFillFlags.FixedRange | (cv.FloodFillFlags)(255 << 8));
            pt = new cv.Point(center.X + 30, center.Y);
            Cv2.FloodFill(dst3, mask, pt, yellow, out r, cv.Scalar.All(1), cv.Scalar.All(1), FloodFillFlags.FixedRange | (cv.FloodFillFlags)(255 << 8));
            var color = dst3.Get<Vec3b>(vbc.task.mouseMovePoint.Y, vbc.task.mouseMovePoint.X);
            var p1 = vbc.task.mouseMovePoint;
            if (p1.X == center.X)
            {
                if (p1.Y <= center.Y)
                    p2 = new cv.Point(dst3.Width / 2, 0);
                else
                    p2 = new cv.Point(dst3.Width, dst3.Height);
            }
            else
            {
                double m = (center.Y - p1.Y) / (center.X - p1.X);
                double b = p1.Y - p1.X * m;
                if (color[0] == 0) p2 = new cv.Point(-b / m, 0); // red zone
                if (color[0] == 1) p2 = new cv.Point((dst3.Height - b) / m, dst3.Height); // green
                if (color[0] == 2) p2 = new cv.Point(dst3.Width, dst3.Width * m + b); // yellow
                if (color[0] == 254) p2 = new cv.Point(0, b); // blue
                DrawLine(dst3, center, p2, Scalar.Black);
            }
            DrawCircle(dst3, center, vbc.task.DotSize, Scalar.White);
            if (color[0] == 0) redRadio.Checked = true;
            if (color[0] == 1) greenRadio.Checked = true;
            if (color[0] == 2) yellowRadio.Checked = true;
            if (color[0] == 254) blueRadio.Checked = true;
            lines.hightLightIntercept(dst3);
            dst2 = lines.dst2;
        }
    }




    public class Line_Intercepts_CS : VB_Parent
    {
        public LongLine_Extend extended = new LongLine_Extend();
        public Line_Basics lines = new Line_Basics();
        public List<cv.Point2f> p1List = new List<cv.Point2f>();
        public List<cv.Point2f> p2List = new List<cv.Point2f>();
        LongLine_Basics longLine = new LongLine_Basics();
        public Options_Intercepts options = new Options_Intercepts();
        public SortedList<int, int> intercept = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public SortedList<int, int> topIntercepts = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public SortedList<int, int> botIntercepts = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public SortedList<int, int> leftIntercepts = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public SortedList<int, int> rightIntercepts = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public SortedList<int, int>[] interceptArray;
        public Line_Intercepts_CS()
        {
            interceptArray = new[] { topIntercepts, botIntercepts, leftIntercepts, rightIntercepts };
            labels[2] = "Highlight line x- and y-intercepts.  Move mouse over the image.";
            desc = "Show lines with similar y-intercepts";
        }
        public void hightLightIntercept(Mat dst)
        {
            foreach (var inter in intercept)
            {
                if (Math.Abs(options.mouseMovePoint - inter.Key) < options.interceptRange)
                {
                    DrawLine(dst2, p1List[inter.Value], p2List[inter.Value], Scalar.White);
                    DrawLine(dst2, p1List[inter.Value], p2List[inter.Value], Scalar.Blue);
                }
            }
            foreach (var inter in intercept)
            {
                switch (options.selectedIntercept)
                {
                    case 0:
                        dst.Line(new cv.Point(inter.Key, 0), new cv.Point(inter.Key, 10), Scalar.White, vbc.task.lineWidth);
                        break;
                    case 1:
                        dst.Line(new cv.Point(inter.Key, dst2.Height), new cv.Point(inter.Key, dst2.Height - 10), Scalar.White, vbc.task.lineWidth);
                        break;
                    case 2:
                        dst.Line(new cv.Point(0, inter.Key), new cv.Point(10, inter.Key), Scalar.White, vbc.task.lineWidth);
                        break;
                    case 3:
                        dst.Line(new cv.Point(dst2.Width, inter.Key), new cv.Point(dst2.Width - 10, inter.Key), Scalar.White, vbc.task.lineWidth);
                        break;
                }
            }
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            lines.Run(src);
            if (lines.lpList.Count() == 0) return;
            dst2 = src;
            p1List.Clear();
            p2List.Clear();
            intercept = interceptArray[options.selectedIntercept];
            topIntercepts.Clear();
            botIntercepts.Clear();
            leftIntercepts.Clear();
            rightIntercepts.Clear();
            int index = 0;
            foreach (var lp in lines.lpList)
            {
                var minXX = Math.Min(lp.p1.X, lp.p2.X);
                if (lp.p1.X != minXX) // leftmost point is always in p1
                {
                    var tmp = lp.p1;
                    lp.p1 = lp.p2;
                    lp.p2 = tmp;
                }
                p1List.Add(lp.p1);
                p2List.Add(lp.p2);
                DrawLine(dst2, lp.p1, lp.p2, Scalar.Yellow);
                var saveP1 = lp.p1;
                var saveP2 = lp.p2;
                var emps = longLine.BuildLongLine(lp);
                if (emps.p1.X == 0) leftIntercepts.Add((int)saveP1.Y, index);
                if (emps.p1.Y == 0) topIntercepts.Add((int)saveP1.X, index);
                if (emps.p1.X == dst2.Width) rightIntercepts.Add((int)saveP1.Y, index);
                if (emps.p1.Y == dst2.Height) botIntercepts.Add((int)saveP1.X, index);
                if (emps.p2.X == 0) leftIntercepts.Add((int)saveP2.Y, index);
                if (emps.p2.Y == 0) topIntercepts.Add((int)saveP2.X, index);
                if (emps.p2.X == dst2.Width) rightIntercepts.Add((int)saveP2.Y, index);
                if (emps.p2.Y == dst2.Height) botIntercepts.Add((int)saveP2.X, index);
                index++;
            }
            if (standaloneTest()) hightLightIntercept(dst2);
        }
    }




    public class Line_LeftRightImages_CS : VB_Parent
    {
        public Line_TimeView leftLines = new Line_TimeView();
        public Line_TimeView rightLines = new Line_TimeView();
        public Line_LeftRightImages_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels[2] = "Left image lines(red) with Right(blue)";
            desc = "Find lines in the infrared images and overlay them in a single image";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.cameraStable) dst2.SetTo(Scalar.White);
            leftLines.Run(vbc.task.leftView);
            dst2.SetTo(Scalar.White);
            dst2.SetTo(Scalar.Red, leftLines.dst3);
            rightLines.Run(vbc.task.rightView);
            dst2.SetTo(Scalar.Blue, rightLines.dst3);
            dst0 = vbc.task.leftView;
            dst1 = vbc.task.rightView;
        }
    }




    public class Line_InDepthAndBGR_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        public List<cv.Point2f> p1List = new List<cv.Point2f>();
        public List<cv.Point2f> p2List = new List<cv.Point2f>();
        public List<cv.Point3f> z1List = new List<cv.Point3f>(); // the point cloud values corresponding to p1 and p2
        public List<cv.Point3f> z2List = new List<cv.Point3f>();
        public Line_InDepthAndBGR_CS()
        {
            labels[2] = "Lines defined in BGR";
            labels[3] = "Lines in BGR confirmed in the point cloud";
            desc = "Find the BGR lines and confirm they are present in the cloud data.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            if (lines.lpList.Count() == 0) return;
            var lineList = new List<cv.Rect>();
            if (vbc.task.motionFlag || vbc.task.optionsChanged) dst3.SetTo(0);
            p1List.Clear();
            p2List.Clear();
            z1List.Clear();
            z2List.Clear();
            foreach (var lp in lines.lpList)
            {
                var minXX = Math.Min(lp.p1.X, lp.p2.X);
                var minYY = Math.Min(lp.p1.Y, lp.p2.Y);
                var w = Math.Abs(lp.p1.X - lp.p2.X);
                var h = Math.Abs(lp.p1.Y - lp.p2.Y);
                var r = new cv.Rect((int)minXX, (int)minYY, (int)(w > 0 ? w : 2), (int)(h > 0 ? h : 2));
                var mask = new Mat(new cv.Size(w, h), MatType.CV_8U, cv.Scalar.All(0));
                DrawLine(mask, new cv.Point((int)(lp.p1.X - r.X), (int)(lp.p1.Y - r.Y)), 
                               new cv.Point((int)(lp.p2.X - r.X), (int)(lp.p2.Y - r.Y)), cv.Scalar.All(255), vbc.task.lineWidth);
                var mean = vbc.task.pointCloud[r].Mean(mask);
                if (mean != new Scalar())
                {
                    var mmX = GetMinMax(vbc.task.pcSplit[0][r], mask);
                    var mmY = GetMinMax(vbc.task.pcSplit[1][r], mask);
                    var len1 = mmX.minLoc.DistanceTo(mmX.maxLoc);
                    var len2 = mmY.minLoc.DistanceTo(mmY.maxLoc);
                    if (len1 > len2)
                    {
                        lp.p1 = new cv.Point(mmX.minLoc.X + r.X, mmX.minLoc.Y + r.Y);
                        lp.p2 = new cv.Point(mmX.maxLoc.X + r.X, mmX.maxLoc.Y + r.Y);
                    }
                    else
                    {
                        lp.p1 = new cv.Point(mmY.minLoc.X + r.X, mmY.minLoc.Y + r.Y);
                        lp.p2 = new cv.Point(mmY.maxLoc.X + r.X, mmY.maxLoc.Y + r.Y);
                    }
                    if (lp.p1.DistanceTo(lp.p2) > 1)
                    {
                        DrawLine(dst3, lp.p1, lp.p2, Scalar.Yellow);
                        p1List.Add(lp.p1);
                        p2List.Add(lp.p2);
                        z1List.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p1.Y, (int)lp.p1.X));
                        z2List.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p2.Y, (int)lp.p2.X));
                    }
                }
            }
        }
    }




    public class Line_PointSlope_CS : VB_Parent
    {
        LongLine_Extend extend = new LongLine_Extend();
        Line_Basics lines = new Line_Basics();
        KNN_BasicsN knn = new KNN_BasicsN();
        public List<PointPair> bestLines = new List<PointPair>();
        const int lineCount = 3;
        const int searchCount = 100;
        public Line_PointSlope_CS()
        {
            knn.options.knnDimension = 5; // slope, p1.x, p1.y, p2.x, p2.y
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new[] { "", "TrainInput to KNN", "Tracking these lines", "Query inputs to KNN" };
            desc = "Find the 3 longest lines in the image and identify them from frame to frame using the point and slope.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = src;
            if (bestLines.Count() < lineCount || vbc.task.heartBeat)
            {
                dst3.SetTo(0);
                bestLines.Clear();
                knn.queries.Clear();
                foreach (var lp in lines.lpList)
                {
                    bestLines.Add(lp);
                    knn.trainInput.Add(lp.slope);
                    knn.trainInput.Add(lp.p1.X);
                    knn.trainInput.Add(lp.p1.Y);
                    knn.trainInput.Add(lp.p2.X);
                    knn.trainInput.Add(lp.p2.Y);
                    DrawLine(dst3, lp.p1, lp.p2, vbc.task.HighlightColor);
                    if (bestLines.Count() >= lineCount) break;
                }
            }
            dst1.SetTo(0);
            knn.trainInput.Clear();
            foreach (var lp in lines.lpList)
            {
                knn.trainInput.Add(lp.slope);
                knn.trainInput.Add(lp.p1.X);
                knn.trainInput.Add(lp.p1.Y);
                knn.trainInput.Add(lp.p2.X);
                knn.trainInput.Add(lp.p2.Y);
                DrawLine(dst1, lp.p1, lp.p2, vbc.task.HighlightColor);
            }
            if (knn.trainInput.Count() == 0)
            {
                SetTrueText("There were no lines detected!  Were there any unusual settings for this run?", 3);
                return;
            }
            knn.Run(empty);
            if (knn.result == null) return;
            var nextLines = new List<PointPair>();
            var usedBest = new List<int>();
            int index = 0;
            for (int i = 0; i <= knn.result.GetUpperBound(0); i++)
            {
                for (int j = 0; j <= knn.result.GetUpperBound(1); j++)
                {
                    index = knn.result[i, j];
                    if (!usedBest.Contains(index)) break;
                }
                usedBest.Add(index);
                if (index * knn.options.knnDimension + 4 < knn.trainInput.Count())
                {
                    var mps = new PointPair(new Point2f(knn.trainInput[index * knn.options.knnDimension + 0], knn.trainInput[index * knn.options.knnDimension + 1]),
                                            new Point2f(knn.trainInput[index * knn.options.knnDimension + 2], knn.trainInput[index * knn.options.knnDimension + 3]));
                    mps.slope = knn.trainInput[index * knn.options.knnDimension];
                    nextLines.Add(mps);
                }
            }
            bestLines = new List<PointPair>(nextLines);
            foreach (var ptS in bestLines)
            {
                DrawLine(dst2, ptS.p1, ptS.p2, vbc.task.HighlightColor);
                DrawLine(dst1, ptS.p1, ptS.p2, Scalar.Red);
            }
        }
    }




    public class Line_Movement_CS : VB_Parent
    {
        public cv.Point p1;
        public cv.Point p2;
        Scalar[] gradientColors = new Scalar[100];
        Kalman_Basics kalman = new Kalman_Basics();
        int frameCount;
        cv.Point k1 = new cv.Point(0, 0);
        cv.Point k2 = new cv.Point(0, 0);
        public Line_Movement_CS()
        {
            kalman.kOutput = new float[] { 0.0f, 0.0f, 0.0f, 0.0f };
            var color1 = Scalar.Yellow;
            var color2 = Scalar.Blue;
            double f = 1.0;
            for (int i = 0; i < gradientColors.Length; i++)
            {
                gradientColors[i] = new Scalar(f * color2[0] + (1 - f) * color1[0], f * color2[1] + (1 - f) * color1[1], f * color2[2] + (1 - f) * color1[2]);
                f -= 1.0 / gradientColors.Length;
            }
            labels = new[] { "", "", "Line Movement", "" };
            desc = "Show the movement of the line provided";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.FirstPass) k1 = p1;
                if (vbc.task.FirstPass) k2 = p2;
                if (k1.DistanceTo(p1) == 0 && k2.DistanceTo(p2) == 0)
                {
                    k1 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                    k2 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                    dst2.SetTo(0);
                }
                kalman.kInput = new float[] { k1.X, k1.Y, k2.X, k2.Y };
                kalman.Run(empty);
                p1 = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
                p2 = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
            }
            frameCount += 1;
            DrawLine(dst2, p1, p2, gradientColors[frameCount % gradientColors.Length]);
        }
    }




    public class Line_GCloud_CS : VB_Parent
    {
        public Line_Basics lines = new Line_Basics();
        public SortedList<float, gravityLine> sortedVerticals = new SortedList<float, gravityLine>(new compareAllowIdenticalSingleInverted());
        public SortedList<float, gravityLine> sortedHorizontals = new SortedList<float, gravityLine>(new compareAllowIdenticalSingleInverted());
        public SortedList<float, gravityLine> allLines = new SortedList<float, gravityLine>(new compareAllowIdenticalSingleInverted());
        public Options_Features options = new Options_Features();
        Match_tCell match = new Match_tCell();
        TrackBar angleSlider;
        public Line_GCloud_CS()
        {
            angleSlider = FindSlider("Angle tolerance in degrees");
            labels[2] = "Line_GCloud_CS - Blue are vertical lines using the angle thresholds.";
            desc = "Find all the vertical lines using the point cloud rectified with the IMU vector for gravity.";
        }
        public gravityLine updateGLine(Mat src, gravityLine gc, cv.Point p1, cv.Point p2)
        {
            gc.tc1.center = p1;
            gc.tc2.center = p2;
            gc.tc1 = match.createCell(src, gc.tc1.correlation, p1);
            gc.tc2 = match.createCell(src, gc.tc2.correlation, p2);
            gc.tc1.strOut = string.Format("{0}\n{1}m", gc.tc1.correlation.ToString(vbc.fmt2), gc.tc1.depth.ToString(vbc.fmt2));
            gc.tc2.strOut = string.Format("{0}\n{1}m", gc.tc2.correlation.ToString(vbc.fmt2), gc.tc2.depth.ToString(vbc.fmt2));
            var mean = vbc.task.pointCloud[gc.tc1.rect].Mean(vbc.task.depthMask[gc.tc1.rect]);
            gc.pt1 = new Point3f((float)mean[0], (float)mean[1], (float)mean[2]);
            gc.tc1.depth = gc.pt1.Z;
            mean = vbc.task.pointCloud[gc.tc2.rect].Mean(vbc.task.depthMask[gc.tc2.rect]);
            gc.pt2 = new Point3f((float)mean[0], (float)mean[1], (float)mean[2]);
            gc.tc2.depth = gc.pt2.Z;
            gc.len3D = distance3D(gc.pt1, gc.pt2);
            if (gc.pt1 == new Point3f() || gc.pt2 == new Point3f())
            {
                gc.len3D = 0;
            }
            else
            {
                gc.arcX = (float)(Math.Asin((gc.pt1.X - gc.pt2.X) / gc.len3D) * 57.2958);
                gc.arcY = (float)Math.Abs(Math.Asin((gc.pt1.Y - gc.pt2.Y) / gc.len3D) * 57.2958);
                if (gc.arcY > 90) gc.arcY -= 90;
                gc.arcZ = (float)(Math.Asin((gc.pt1.Z - gc.pt2.Z) / gc.len3D) * 57.2958);
            }
            return gc;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var maxAngle = angleSlider.Value;
            dst2 = src.Clone();
            lines.Run(src.Clone());
            sortedVerticals.Clear();
            sortedHorizontals.Clear();
            foreach (var lp in lines.lpList)
            {
                gravityLine gc = updateGLine(src, new gravityLine(), new cv.Point((int)lp.p1.X, (int)lp.p1.Y), new cv.Point((int)lp.p2.X, (int)lp.p2.Y));
                allLines.Add((int)lp.p1.DistanceTo(lp.p2), gc);
                if (Math.Abs(90 - gc.arcY) < maxAngle && gc.tc1.depth > 0 && gc.tc2.depth > 0)
                {
                    sortedVerticals.Add((int)lp.p1.DistanceTo(lp.p2), gc);
                    DrawLine(dst2, lp.p1, lp.p2, Scalar.Blue);
                }
                if (Math.Abs(gc.arcY) <= maxAngle && gc.tc1.depth > 0 && gc.tc2.depth > 0)
                {
                    sortedHorizontals.Add((int)lp.p1.DistanceTo(lp.p2), gc);
                    DrawLine(dst2, lp.p1, lp.p2, Scalar.Yellow);
                }
            }
            labels[2] = string.Format("{0:00} Horizontal lines were identified and {1:00} Vertical lines were identified.", sortedHorizontals.Count(), sortedVerticals.Count());
        }
    }




    public class Line_DisplayInfo_CS : VB_Parent
    {
        public List<tCell> tcells = new List<tCell>();
        Edge_Canny canny = new Edge_Canny();
        Blur_Basics blur = new Blur_Basics();
        public int distance;
        public int maskCount;
        int myCurrentFrame = -1;
        public Line_DisplayInfo_CS()
        {
            dst1 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[2] = "When running standaloneTest(), a pair of random points is used to test the algorithm.";
            desc = "Display the line provided in mp";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            if (standaloneTest() && vbc.task.heartBeat)
            {
                tCell tc = new tCell();
                tcells.Clear();
                for (int i = 0; i < 2; i++)
                {
                    tc.center = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                    tcells.Add(tc);
                }
            }
            if (tcells.Count() < 2) return;
            if (myCurrentFrame < vbc.task.frameCount)
            {
                canny.Run(src);
                blur.Run(canny.dst2);
                myCurrentFrame = vbc.task.frameCount;
            }
            dst1.SetTo(0);
            cv.Point2f p1 = tcells[0].center;
            cv.Point2f p2 = tcells[1].center;
            DrawLine(dst1, p1, p2, cv.Scalar.All(255));
            dst3.SetTo(0);
            blur.dst2.Threshold(1, 255, ThresholdTypes.Binary).CopyTo(dst3, dst1);
            distance = (int)p1.DistanceTo(p2);
            maskCount = dst3.CountNonZero();
            foreach (var tc in tcells)
            {
                //dst2.Rectangle(tc.rect, myHighlightColor);
                //dst2.Rectangle(tc.searchRect, Scalar.White, vbc.task.lineWidth);
                SetTrueText(tc.strOut, new cv.Point(tc.rect.X, tc.rect.Y));
            }
            strOut = "Mask count = " + maskCount + ", Expected count = " + distance + " or " + string.Format("{0:0%}", maskCount / (float)distance) + "\n";
            DrawLine(dst2, p1, p2, vbc.task.HighlightColor);
            strOut += "Color changes when correlation falls below threshold and new line is detected.\n" +
                      "Correlation coefficient is shown with the depth in meters.";
            SetTrueText(strOut, 3);
        }
    }




    public class Line_Perpendicular_CS : VB_Parent
    {
        public Point2f p1; // first input point
        public Point2f p2; // second input point
        public Point2f r1; // first output point (perpendicular to input)
        public Point2f r2; // second output point (perpendicular to input)
        bool externalUse = false;
        public Line_Perpendicular_CS()
        {
            labels = new string[] { "", "", "White is the original line, red dot is midpoint, yellow is perpendicular line", "" };
            desc = "Find the line perpendicular to the line created by the points provided.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass && p1 != new Point2f()) externalUse = true;
            if (vbc.task.heartBeat || externalUse)
            {
                if (standaloneTest())
                {
                    p1 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                    p2 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                }
                dst2.SetTo(0);
                DrawLine(dst2, p1, p2, Scalar.White);
                float slope;
                if (p1.X == p2.X) slope = 100000; else slope = (p1.Y - p2.Y) / (p1.X - p2.X);
                var midPoint = new Point2f((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);
                DrawCircle(dst2, midPoint, vbc.task.DotSize + 2, Scalar.Red);
                float m = (slope == 0) ? 100000 : -1 / slope;
                float b = midPoint.Y - m * midPoint.X;
                r1 = new Point2f(-b / m, 0);
                r2 = new Point2f((dst2.Height - b) / m, dst2.Height);
                DrawLine(dst2, r1, r2, Scalar.Yellow);
            }
        }
    }




    public class Line_CellsVertHoriz_CS : VB_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public Line_CellsVertHoriz_CS()
        {
            labels[2] = "RedCloud_Hulls output with lines highlighted";
            desc = "Identify the lines created by the RedCloud Cells and separate vertical from horizontal";
        }
        public void RunAlg(Mat src)
        {
            hulls.Run(src);
            dst2 = hulls.dst2;
            lines.Run(dst2.Clone());
            dst3 = src;
            for (int i = 0; i < lines.sortedHorizontals.Count(); i++)
            {
                var index = lines.sortedHorizontals.ElementAt(i).Value;
                var p1 = lines.lines2D[index];
                var p2 = lines.lines2D[index + 1];
                DrawLine(dst3, p1, p2, Scalar.Yellow);
            }
            for (int i = 0; i < lines.sortedVerticals.Count(); i++)
            {
                var index = lines.sortedVerticals.ElementAt(i).Value;
                var p1 = lines.lines2D[index];
                var p2 = lines.lines2D[index + 1];
                DrawLine(dst3, p1, p2, Scalar.Blue);
            }
            labels[3] = lines.sortedVerticals.Count() + " vertical and " + lines.sortedHorizontals.Count() + " horizontal lines identified in the RedCloud output";
        }
    }




    public class Line_Cells_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Line_Cells_CS()
        {
            desc = "Identify all lines in the RedCloud_Basics cell boundaries";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            lines.Run(dst2.Clone());
            dst3 = lines.dst3;
            labels[2] = (lines.lpList.Count() / 2) + " lines identified";
        }
    }




    public class Line_ViewSide_CS : VB_Parent
    {
        public OpAuto_YRange autoY = new OpAuto_YRange();
        public Line_Basics lines = new Line_Basics();
        Projection_HistSide histSide = new Projection_HistSide();
        public Line_ViewSide_CS()
        {
            labels = new string[] { "", "", "Hotspots in the Side View", "Lines found in the hotspots of the Side View." };
            desc = "Find lines in the hotspots for the side view.";
        }
        public void RunAlg(Mat src)
        {
            histSide.Run(src);
            autoY.Run(histSide.histogram);
            dst2 = histSide.histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            lines.Run(dst2.Clone());
            dst3 = lines.dst3;
        }
    }




    public class Line_ViewTop_CS : VB_Parent
    {
        public OpAuto_XRange autoX = new OpAuto_XRange();
        public Line_Basics lines = new Line_Basics();
        Projection_HistTop histTop = new Projection_HistTop();
        public Line_ViewTop_CS()
        {
            labels = new string[] { "", "", "Hotspots in the Top View", "Lines found in the hotspots of the Top View." };
            desc = "Find lines in the hotspots for the Top View.";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            autoX.Run(histTop.histogram);
            dst2 = histTop.histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            lines.Run(dst2);
            dst3 = lines.dst3;
        }
    }




    public class Line_FromContours_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Line_Basics lines = new Line_Basics();
        Contour_Gray contours = new Contour_Gray();
        public Line_FromContours_CS()
        {
            vbc.task.redOptions.setColorSource("Reduction_Basics"); // to enable sliders.
            lines.lineColor = Scalar.Red;
            UpdateAdvice("Use the reduction sliders in the redoptions to control contours and subsequent lines found.");
            desc = "Find the lines in the contours.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            contours.Run(reduction.dst2);
            dst2 = contours.dst2.Clone();
            lines.Run(dst2);
            dst3.SetTo(0);
            foreach (var lp in lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, Scalar.White);
            }
        }
    }




    public class Line_ColorClass_CS : VB_Parent
    {
        Color8U_Basics colorClass = new Color8U_Basics();
        Line_Basics lines = new Line_Basics();
        public Line_ColorClass_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Lines for the current color class", "Color Class input" };
            desc = "Review lines in all the different color classes";
        }
        public void RunAlg(Mat src)
        {
            colorClass.Run(src);
            dst1 = colorClass.dst2;
            lines.Run(dst1 * 255 / colorClass.classCount);
            dst2 = lines.dst2;
            dst3 = lines.dst3;
            labels[1] = "Input to Line_Basics";
            labels[2] = "Lines found in the " + vbc.task.redOptions.colorMethods[vbc.task.redOptions.colorInputIndex] + " output";
        }
    }




    public class Line_Canny_CS : VB_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        Line_Basics lines = new Line_Basics();
        public Line_Canny_CS()
        {
            FindSlider("Canny Aperture").Value = 7;
            labels = new string[] { "", "", "Straight lines in Canny output", "Input to Line_Basics" };
            desc = "Find lines in the Canny output";
        }
        public void RunAlg(Mat src)
        {
            canny.Run(src);
            dst3 = canny.dst2.Clone();
            lines.Run(canny.dst2);
            dst2 = lines.dst3;
        }
    }




    public class Line_TimeViewLines_CS : VB_Parent
    {
        Line_TimeView lines = new Line_TimeView();
        public List<PointPair> lpList = new List<PointPair>();
        public Line_TimeViewLines_CS()
        {
            labels[2] = "Lines from the latest Line_TimeLine";
            labels[3] = "Vertical (blue) Horizontal (Red) Other (Green)";
            desc = "Find slope and y-intercept of lines over time.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            if (lines.pixelcount == 0) return;
            lpList.Clear();
            dst2 = lines.dst3;
            dst3.SetTo(Scalar.White);
            int index = lines.frameList.Count() - 1; // the most recent.
            foreach (var lp in lines.lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, Scalar.Green);
                lpList.Add(lp);
                if (lp.slope == 0)
                {
                    DrawLine(dst3, lp.p1, lp.p2, Scalar.Red, vbc.task.lineWidth * 2 + 1);
                }
            }
        }
    }




    public class Line_TimeView_CS : VB_Parent
    {
        public List<List<PointPair>> frameList = new List<List<PointPair>>();
        public Line_Basics lines = new Line_Basics();
        public int pixelcount;
        public List<PointPair> mpList = new List<PointPair>();
        public Line_TimeView_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Collect lines over time";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            if (vbc.task.optionsChanged || vbc.task.motionFlag) frameList.Clear();
            var nextMpList = new List<PointPair>(lines.lpList);
            frameList.Add(nextMpList);
            dst2 = src;
            dst3.SetTo(0);
            mpList.Clear();
            int lineTotal = 0;
            for (int i = 0; i < frameList.Count(); i++)
            {
                lineTotal += frameList[i].Count();
                foreach (var lp in frameList[i])
                {
                    DrawLine(dst2, lp.p1, lp.p2, Scalar.Yellow);
                    DrawLine(dst3, lp.p1, lp.p2, Scalar.White);
                    mpList.Add(lp);
                }
            }
            if (frameList.Count() >= vbc.task.frameHistoryCount) frameList.RemoveAt(0);
            pixelcount = Cv2.CountNonZero(dst3);
            labels[3] = "There were " + lineTotal + " lines detected using " + (pixelcount / 1000.0).ToString("#.0") + "k pixels";
        }
    }




    public class Line_Verticals_CS : VB_Parent
    {
        public Line_Basics lines = new Line_Basics();
        public Options_Features options = new Options_Features();
        public List<gravityLine> verticals = new List<gravityLine>();
        public int maxAngleX;
        public int maxAngleZ;
        IMU_GMatrix gMat = new IMU_GMatrix();
        TrackBar cellSlider;
        TrackBar angleXSlider;
        TrackBar angleZSlider;
        public Line_Verticals_CS()
        {
            cellSlider = FindSlider("MatchTemplate Cell Size");
            angleXSlider = FindSlider("X angle tolerance in degrees");
            angleZSlider = FindSlider("Z angle tolerance in degrees");
            desc = "Capture all vertical and horizontal lines.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            maxAngleX = angleXSlider.Value;
            maxAngleZ = angleZSlider.Value;
            int radius = (int)(cellSlider.Value / 2);
            lines.Run(src.Clone());
            if (lines.lpList.Count() == 0) return; // nothing to work with...
            var lines2 = new List<cv.Point2f>();
            var lines3 = new List<cv.Point3f>();
            foreach (var lp in lines.lpList)
            {
                lines2.Add(new Point2f(lp.p1.X, lp.p1.Y));
                lines2.Add(new Point2f(lp.p2.X, lp.p2.Y));
                lines3.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p1.Y, (int)lp.p1.X));
                lines3.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)lp.p2.Y, (int)lp.p2.X));
            }
            dst2 = src.Clone();
            gMat.Run(empty);
            var points = cv.Mat.FromPixelData(lines3.Count(), 3, MatType.CV_32F, lines3.ToArray());
            var gPoints = (points * gMat.gMatrix).ToMat();
            verticals.Clear();
            for (int i = 0; i < gPoints.Rows; i += 2)
            {
                gravityLine vert = new gravityLine();
                vert.tc1.center = lines2[i];
                vert.tc2.center = lines2[i + 1];
                vert.pt1 = gPoints.Get<cv.Point3f>(i + 0, 0);
                vert.pt2 = gPoints.Get<cv.Point3f>(i + 1, 0);
                vert.len3D = distance3D(vert.pt1, vert.pt2);
                double arcX = Math.Asin((vert.pt1.X - vert.pt2.X) / vert.len3D) * 57.2958;
                double arcZ = Math.Asin((vert.pt1.Z - vert.pt2.Z) / vert.len3D) * 57.2958;
                if (Math.Abs(arcX) <= maxAngleX && Math.Abs(arcZ) <= maxAngleZ)
                {
                    cv.Point pt = new cv.Point(lines2[i].X, lines2[i].Y);
                    SetTrueText(arcX.ToString(vbc.fmt1) + " X" + "\n" + arcZ.ToString(vbc.fmt1) + " Z", pt, 2);
                    SetTrueText(arcX.ToString(vbc.fmt1) + " X" + "\n" + arcZ.ToString(vbc.fmt1) + " Z", pt, 3);
                    DrawLine(dst2, lines2[i], lines2[i + 1], vbc.task.HighlightColor);
                    verticals.Add(vert);
                }
            }
            labels[2] = verticals.Count() + " vertical lines were found.  Total lines found = " + lines.lpList.Count();
        }
    }




    public class Line_Verts_CS : VB_Parent
    {
        Line_Verticals verts = new Line_Verticals();
        Match_tCell match = new Match_tCell();
        public List<gravityLine> verticals = new List<gravityLine>();
        IMU_GMatrix gMat = new IMU_GMatrix();
        public Line_Verts_CS()
        {
            labels[3] = "Numbers below are: correlation coefficient, distance in meters, angle from vertical in the X-direction, angle from vertical in the Z-direction";
            desc = "Find the list of vertical lines and track them until most are lost, then recapture the vertical lines again.";
        }
        public void RunAlg(Mat src)
        {
            if (verticals.Count() < 2 || verticals.Count() < verts.verticals.Count() / 3 || vbc.task.optionsChanged)
            {
                verts.Run(src);
                foreach (var vert in verts.verticals)
                {
                    var vtmp = vert;
                    vtmp.tc1 = match.createCell(src, 0, vert.tc1.center);
                    vtmp.tc2 = match.createCell(src, 0, vert.tc2.center);
                    verticals.Add(vtmp);
                }
            }
            dst2 = src.Clone();
            List<cv.Point2f> lines2 = new List<cv.Point2f>();
            List<cv.Point3f> lines3 = new List<cv.Point3f>();
            List<gravityLine> newVerts = new List<gravityLine>();
            for (int i = 0; i < verticals.Count(); i++)
            {
                var vert = verticals[i];
                match.tCells.Clear();
                match.tCells.Add(vert.tc1);
                match.tCells.Add(vert.tc2);
                match.Run(src);
                vert.tc1 = match.tCells[0];
                vert.tc2 = match.tCells[1];
                double correlationMin = verts.options.correlationMin;
                if (vert.tc1.correlation >= correlationMin && vert.tc2.correlation >= correlationMin)
                {
                    lines2.Add(vert.tc1.center);
                    lines2.Add(vert.tc2.center);
                    lines3.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)vert.tc1.center.Y, (int)vert.tc1.center.X));
                    lines3.Add(vbc.task.pointCloud.Get<cv.Point3f>((int)vert.tc2.center.Y, (int)vert.tc2.center.X));
                }
                newVerts.Add(vert);
            }
            if (lines3.Count() > 0)
            {
                gMat.Run(empty);
                Mat points = cv.Mat.FromPixelData(lines3.Count(), 3, MatType.CV_32F, lines3.ToArray());
                Mat gPoints = (points * gMat.gMatrix).ToMat();
                verticals.Clear();
                for (int i = 0; i < gPoints.Rows; i += 2)
                {
                    var vert = newVerts[i / 2];
                    vert.pt1 = gPoints.Get<cv.Point3f>(i + 0, 0);
                    vert.pt2 = gPoints.Get<cv.Point3f>(i + 1, 0);
                    vert.len3D = distance3D(vert.pt1, vert.pt2);
                    float arcX = (float)(Math.Asin((vert.pt1.X - vert.pt2.X) / vert.len3D) * 57.2958);
                    float arcZ = (float)(Math.Asin((vert.pt1.Z - vert.pt2.Z) / vert.len3D) * 57.2958);
                    if (Math.Abs(arcX) <= verts.maxAngleX && Math.Abs(arcZ) <= verts.maxAngleZ)
                    {
                        SetTrueText(vert.tc1.strOut, new cv.Point(vert.tc1.rect.X, vert.tc1.rect.Y));
                        SetTrueText(vert.tc1.strOut + "\n" + string.Format(vbc.fmt1, arcX) + " X" + "\n" + string.Format(vbc.fmt1, arcZ) + " Z",
                                    new cv.Point(vert.tc1.rect.X, vert.tc1.rect.Y), 3);
                        DrawLine(dst2, vert.tc1.center, vert.tc2.center, vbc.task.HighlightColor);
                        verticals.Add(vert);
                    }
                }
            }
            labels[2] = "Starting with " + verts.verticals.Count().ToString() + " there are " + verticals.Count().ToString() + " lines remaining";
        }
    }




    public class Line_Nearest_CS : VB_Parent
    {
        public Point2f pt; // How close is this point to the input line?
        public PointPair lp = new PointPair(); // the input line.
        public Point2f nearPoint;
        public bool onTheLine;
        public float distance;
        public Line_Nearest_CS()
        {
            labels[2] = "Yellow line is input line, white dot is the input point, and the white line is the nearest path to the input line.";
            desc = "Find the nearest point on a line";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() && vbc.task.heartBeat)
            {
                lp.p1 = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                lp.p2 = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                pt = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
            }
            float minX = Math.Min(lp.p1.X, lp.p2.X);
            float minY = Math.Min(lp.p1.Y, lp.p2.Y);
            float maxX = Math.Max(lp.p1.X, lp.p2.X);
            float maxY = Math.Max(lp.p1.Y, lp.p2.Y);
            onTheLine = true;
            if (lp.p1.X == lp.p2.X)
            {
                nearPoint = new Point2f(lp.p1.X, pt.Y);
                if (pt.Y < minY || pt.Y > maxY) onTheLine = false;
            }
            else
            {
                float m = (lp.p1.Y - lp.p2.Y) / (lp.p1.X - lp.p2.X);
                if (m == 0)
                {
                    nearPoint = new Point2f(pt.X, lp.p1.Y);
                    if (pt.X < minX || pt.X > maxX) onTheLine = false;
                }
                else
                {
                    float b1 = lp.p1.Y - lp.p1.X * m;
                    float b2 = pt.Y + pt.X / m;
                    Point2f a1 = new Point2f(0, b2);
                    Point2f a2 = new Point2f(dst2.Width, b2 + dst2.Width / m);
                    float x = m * (b2 - b1) / (m * m + 1);
                    nearPoint = new Point2f(x, m * x + b1);
                    if (nearPoint.X < minX || nearPoint.X > maxX || nearPoint.Y < minY || nearPoint.Y > maxY) onTheLine = false;
                }
            }
            float distance1 = (float)Math.Sqrt(Math.Pow(pt.X - lp.p1.X, 2) + Math.Pow(pt.Y - lp.p1.Y, 2));
            float distance2 = (float)Math.Sqrt(Math.Pow(pt.X - lp.p2.X, 2) + Math.Pow(pt.Y - lp.p2.Y, 2));
            if (!onTheLine) nearPoint = distance1 < distance2 ? lp.p1 : lp.p2;
            if (standaloneTest())
            {
                dst2.SetTo(0);
                DrawLine(dst2, lp.p1, lp.p2, Scalar.Yellow);
                DrawLine(dst2, pt, nearPoint, Scalar.White);
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.White);
            }
            distance = (float)Math.Sqrt(Math.Pow(pt.X - nearPoint.X, 2) + Math.Pow(pt.Y - nearPoint.Y, 2));
        }
    }




    public class Line_Intersection_CS : VB_Parent
    {
        public Point2f p1, p2, p3, p4;
        public Point2f intersectionPoint;
        public Line_Intersection_CS()
        {
            desc = "Determine if 2 lines intersect, where the point is, and if that point is in the image.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                p1 = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                p2 = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                p3 = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                p4 = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
            }
            intersectionPoint = IntersectTest(p1, p2, p3, p4, new cv.Rect(0, 0, src.Width, src.Height));
            dst2.SetTo(0);
            DrawLine(dst2, p1, p2, Scalar.Yellow, vbc.task.lineWidth + 1);
            DrawLine(dst2, p3, p4, Scalar.Yellow, vbc.task.lineWidth + 1);
            if (intersectionPoint != new Point2f())
            {
                DrawCircle(dst2, intersectionPoint, vbc.task.DotSize + 4, Scalar.White);
                labels[2] = "Intersection point = " + (int)intersectionPoint.X + " x " + (int)intersectionPoint.Y;
            }
            else
            {
                labels[2] = "Parallel!!!";
            }
            if (intersectionPoint.X < 0 || intersectionPoint.X > dst2.Width || intersectionPoint.Y < 0 || intersectionPoint.Y > dst2.Height)
            {
                labels[2] += " (off screen)";
            }
        }
    }




    public class Line_Gravity_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        Line_Nearest nearest = new Line_Nearest();
        public Line_Gravity_CS()
        {
            vbc.task.gOptions.setLineWidth(2);
            desc = "Find all the lines in the color image that are parallel to gravity or the horizon using distance to the line instead of slope.";
        }
        public void RunAlg(Mat src)
        {
            float pixelDiff = vbc.task.gOptions.pixelDiffThreshold;
            dst2 = src.Clone();
            lines.Run(src);
            if (standaloneTest()) dst3 = lines.dst2;
            nearest.lp = vbc.task.gravityVec;
            DrawLine(dst2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, Scalar.White);
            foreach (var lp in lines.lpList)
            {
                Point2f ptInter = IntersectTest(lp.p1, lp.p2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, new cv.Rect(0, 0, src.Width, src.Height));
                if (ptInter.X >= 0 && ptInter.X < dst2.Width && ptInter.Y >= 0 && ptInter.Y < dst2.Height) continue;
                nearest.pt = lp.p1;
                nearest.Run(null);
                float d1 = nearest.distance;
                nearest.pt = lp.p2;
                nearest.Run(null);
                float d2 = nearest.distance;
                if (Math.Abs(d1 - d2) <= pixelDiff)
                {
                    DrawLine(dst2, lp.p1, lp.p2, vbc.task.HighlightColor);
                }
            }
            DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, Scalar.White);
            nearest.lp = vbc.task.horizonVec;
            foreach (var lp in lines.lpList)
            {
                Point2f ptInter = IntersectTest(lp.p1, lp.p2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, new cv.Rect(0, 0, src.Width, src.Height));
                if (ptInter.X >= 0 && ptInter.X < dst2.Width && ptInter.Y >= 0 && ptInter.Y < dst2.Height) continue;
                nearest.pt = lp.p1;
                nearest.Run(null);
                float d1 = nearest.distance;
                nearest.pt = lp.p2;
                nearest.Run(null);
                float d2 = nearest.distance;
                if (Math.Abs(d1 - d2) <= pixelDiff)
                {
                    DrawLine(dst2, lp.p1, lp.p2, Scalar.Red);
                }
            }
            labels[2] = "Slope for gravity is " + string.Format(vbc.fmt1, vbc.task.gravityVec.slope) + ".  Slope for horizon is " + string.Format(vbc.fmt1, vbc.task.horizonVec.slope);
        }
    }




    public class Line_KNN_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        Swarm_Basics swarm = new Swarm_Basics();
        public Line_KNN_CS()
        {
            FindSlider("Connect X KNN points").Value = 1;
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use KNN to find the other line end points nearest to each endpoint and connect them with a line.";
        }
        public void RunAlg(Mat src)
        {
            swarm.options.RunOpt();
            lines.Run(src);
            dst2 = lines.dst2;
            dst3.SetTo(0);
            swarm.knn.queries.Clear();
            foreach (var lp in lines.lpList)
            {
                swarm.knn.queries.Add(lp.p1);
                swarm.knn.queries.Add(lp.p2);
                DrawLine(dst3, lp.p1, lp.p2, cv.Scalar.All(255));
            }
            swarm.knn.trainInput = new List<cv.Point2f>(swarm.knn.queries);
            swarm.knn.Run(empty);
            swarm.DrawLines(dst3);
            labels[2] = lines.labels[2];
        }
    }




    public class Line3D_Draw_CS : VB_Parent
    {
        public cv.Point p1, p2;
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        bool toggleFirstSecond;
        public Line3D_Draw_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            plot.plotCount = 2;
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_32F, cv.Scalar.All(0));
            p1 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
            p2 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
            labels[2] = "Click twice in the image below to draw a line and that line's depth is correlated in X to Z and Y to Z in the plot at right";
            desc = "Determine where a 3D line is close to the real depth data";
        }
        float findCorrelation(Mat pts1, Mat pts2)
        {
            Mat correlationMat = new Mat();
            Cv2.MatchTemplate(pts1, pts2, correlationMat, TemplateMatchModes.CCoeffNormed);
            return correlationMat.At<float>(0, 0);
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.mouseClickFlag)
                {
                    if (!toggleFirstSecond)
                    {
                        p1 = vbc.task.ClickPoint;
                    }
                    else
                    {
                        p2 = vbc.task.ClickPoint;
                        toggleFirstSecond = false;
                    }
                }
            }
            if (toggleFirstSecond) return; // wait until the second point is selected...
            dst1 = src;
            DrawLine(dst1, p1, p2, vbc.task.HighlightColor);
            dst0.SetTo(0);
            DrawLine(dst0, p1, p2, cv.Scalar.All(255));
            dst1.SetTo(0);
            vbc.task.pcSplit[0].CopyTo(dst1, dst0);
            var points = dst1.FindNonZero();
            var nextList = new List<cv.Point3f>();
            for (int i = 0; i < points.Rows; i++)
            {
                var pt = points.At<cv.Point>(i, 0);
                nextList.Add(vbc.task.pointCloud.At<cv.Point3f>(pt.Y, pt.X));
            }
            if (nextList.Count() == 0) return; // line is completely in area with no depth.
            var pts = cv.Mat.FromPixelData(nextList.Count(), 1, MatType.CV_32FC3, nextList.ToArray());
            var zSplit = pts.Split();
            var c1 = findCorrelation(zSplit[0], zSplit[2]);
            var c2 = findCorrelation(zSplit[1], zSplit[2]);
            plot.plotData = new Scalar(c1, c2, 0);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            labels[3] = "using " + nextList.Count() + " points, the correlation of X to Z = " + c1.ToString(vbc.fmt3) + " (blue), correlation of Y to Z = " + c2.ToString(vbc.fmt3) + " (green)";
        }
    }




    public class Line3D_Checks_CS : VB_Parent
    {
        PointCloud_Basics pts = new PointCloud_Basics();
        public List<cv.Point3f> pcLines = new List<cv.Point3f>();
        public Line3D_Checks_CS()
        {
            desc = "Use the first and last points in the sequence to build a single line and then check it against the rest of the sequence.";
        }
        public void RunAlg(Mat src)
        {
            pts.Run(src);
            dst3 = pts.dst2;
            pcLines.Clear();
            for (int y = 0; y < vbc.task.gridRows; y++)
            {
                var vecList = new List<cv.Point3f>();
                for (int x = 0; x < vbc.task.gridCols; x++)
                {
                    var vec = pts.dst3.At<cv.Point3f>(y, x);
                    if (vec.Z > 0)
                    {
                        vecList.Add(vec);
                    }
                    else
                    {
                        if (vecList.Count() > 2)
                        {
                            pcLines.Add(new Point3f(1, 1, 1));
                            pcLines.Add(vecList[0]);
                            pcLines.Add(vecList[vecList.Count() - 1]);
                        }
                        vecList.Clear();
                    }
                }
            }
        }
    }




    public class Line3D_CandidatesFirstLast_CS : VB_Parent
    {
        PointCloud_Basics pts = new PointCloud_Basics();
        public List<cv.Point3f> pcLines = new List<cv.Point3f>();
        public Mat pcLinesMat;
        public int actualCount;
        public Line3D_CandidatesFirstLast_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Get a list of points from PointCloud_Basics.  Identify first and last as the line in the sequence";
        }
        void addLines(List<List<cv.Point3f>> nextList, List<List<cv.Point>> xyList)
        {
            var white32 = new Point3f(1, 1, 1);
            for (int i = 0; i < nextList.Count(); i++)
            {
                pcLines.Add(white32);
                pcLines.Add(nextList[i][0]);
                pcLines.Add(nextList[i][nextList[i].Count() - 1]);
            }
            foreach (var ptlist in xyList)
            {
                var p1 = ptlist[0];
                var p2 = ptlist[ptlist.Count() - 1];
                DrawLine(dst2, p1, p2, Scalar.White);
            }
        }
        public void RunAlg(Mat src)
        {
            pts.Run(src);
            dst2 = pts.dst2;
            pcLines.Clear();
            addLines(pts.hList, pts.xyHList);
            addLines(pts.vList, pts.xyVList);
            pcLinesMat = cv.Mat.FromPixelData(pcLines.Count(), 1, MatType.CV_32FC3, pcLines.ToArray());
            labels[2] = "Point series found = " + (pts.hList.Count() + pts.vList.Count());
        }
    }




    public class Line3D_CandidatesAll_CS : VB_Parent
    {
        PointCloud_Basics pts = new PointCloud_Basics();
        public List<cv.Point3f> pcLines = new List<cv.Point3f>();
        public Mat pcLinesMat;
        public int actualCount;
        Point3f white32 = new Point3f(1, 1, 1);
        public Line3D_CandidatesAll_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Get a list of points from PointCloud_Basics.  Identify all the lines in the sequence";
        }
        void addLines(List<List<cv.Point3f>> nextList, List<List<cv.Point>> xyList)
        {
            for (int i = 0; i < nextList.Count(); i++)
            {
                for (int j = 0; j < nextList[i].Count() - 1; j++)
                {
                    pcLines.Add(white32);
                    pcLines.Add(nextList[i][j]);
                    pcLines.Add(nextList[i][j + 1]);
                }
            }
            foreach (var ptlist in xyList)
            {
                for (int i = 0; i < ptlist.Count() - 1; i++)
                {
                    var p1 = ptlist[i];
                    var p2 = ptlist[i + 1];
                    DrawLine(dst2, p1, p2, Scalar.White);
                }
            }
        }
        public void RunAlg(Mat src)
        {
            pts.Run(src);
            dst2 = pts.dst2;
            pcLines.Clear();
            addLines(pts.hList, pts.xyHList);
            addLines(pts.vList, pts.xyVList);
            pcLinesMat = cv.Mat.FromPixelData(pcLines.Count(), 1, MatType.CV_32FC3, pcLines.ToArray());
            labels[2] = "Point series found = " + (pts.hList.Count() + pts.vList.Count());
        }
    }




    public class LinearRegression_Basics_CS : VB_Parent
    {
        public List<float> x = new List<float>();
        public List<float> y = new List<float>();
        public cv.Point p1, p2;
        public LinearRegression_Basics_CS()
        {
            desc = "A simple example of using OpenCV's linear regression.";
        }
        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                x = new List<float> { 1, 2, 3, 4, 5 };
                y = new List<float> { 2, 4, 5, 4, 5 };
            }
            if (x.Count() == 0) return; // nothing supplied - happens when the horizon is off the image.
            var meanX = x.Average();
            var meanY = y.Average();
            float numerator = 0, denominator = 0;
            for (int i = 0; i < x.Count(); i++)
            {
                numerator += (x[i] - meanX) * (y[i] - meanY);
                denominator += (float)Math.Pow(x[i] - meanX, 2);
            }
            var m = numerator / denominator;
            var c = meanY - m * meanX;
            p1 = new cv.Point(0, (int)c);
            p2 = new cv.Point(dst2.Width, (int)(m * dst2.Width + c));
            dst2.SetTo(0);
            DrawLine(dst2, p1, p2, Scalar.White);
            for (int i = 0; i < x.Count(); i++)
            {
                var pt = new cv.Point(x[i], y[i]);
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Red);
            }
        }
    }




    public class LinearRegression_Test_CS : VB_Parent
    {
        LinearRegression_Basics regress = new LinearRegression_Basics();
        public LinearRegression_Test_CS()
        {
            desc = "A simple example of using OpenCV's linear regression.";
        }
        public void RunAlg(Mat src)
        {
            var x = new List<float> { 1, 2, 3, 4, 5 };
            var y = new List<float> { 2, 4, 5, 4, 5 };
            regress.x.Clear();
            regress.y.Clear();
            for (int i = 0; i < x.Count(); i++)
            {
                regress.x.Add(x[i]);
                regress.y.Add(y[i]);
            }
            regress.Run(null);
            dst2 = regress.dst2;
        }
    }




    public class LinearRegression_Random_CS : VB_Parent
    {
        LinearRegression_Basics regress = new LinearRegression_Basics();
        Random_Basics random = new Random_Basics();
        public LinearRegression_Random_CS()
        {
            desc = "A simple example of using OpenCV's linear regression.";
        }
        public void RunAlg(Mat src)
        {
            random.Run(null);
            regress.x.Clear();
            regress.y.Clear();
            for (int i = 0; i < random.PointList.Count(); i++)
            {
                regress.x.Add(random.PointList[i].X);
                regress.y.Add(random.PointList[i].Y);
            }
            regress.Run(null);
            dst2 = regress.dst2;
        }
    }




    public class LineCoin_Basics_CS : VB_Parent
    {
        public LongLine_Basics longLines = new LongLine_Basics();
        public List<PointPair> lpList = new List<PointPair>();
        List<List<PointPair>> lpLists = new List<List<PointPair>>();
        public LineCoin_Basics_CS()
        {
            dst2 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find the coincident lines in the image and measure their value.";
        }
        public List<PointPair> findLines(List<List<PointPair>> lpLists)
        {
            var p1List = new List<cv.Point>();
            var p2List = new List<cv.Point>();
            var ptCounts = new List<int>();
            PointPair lp;
            foreach (var lpList in lpLists)
            {
                foreach (var mp in lpList)
                {
                    mp.slope = (int)(mp.slope * 10) / 10;
                    if (mp.slope == 0)
                    {
                        lp = new PointPair(new cv.Point(mp.p1.X, 0), new cv.Point(mp.p1.X, dst2.Height));
                    }
                    else
                    {
                        lp = longLines.BuildLongLine(mp);
                    }
                    int index = p1List.IndexOf(new cv.Point((int)lp.p1.X, (int)lp.p1.Y));
                    if (index >= 0)
                    {
                        ptCounts[index] += 1;
                    }
                    else
                    {
                        p1List.Add(new cv.Point((int)lp.p1.X, (int)lp.p1.Y));
                        p2List.Add(new cv.Point((int)lp.p2.X, (int)lp.p2.Y));
                        ptCounts.Add(1);
                    }
                }
            }
            lpList.Clear();
            dst2.SetTo(0);
            for (int i = 0; i < p1List.Count(); i++)
            {
                if (ptCounts[i] >= vbc.task.frameHistoryCount)
                {
                    DrawLine(dst2, p1List[i], p2List[i], cv.Scalar.All(255));
                    lpList.Add(new PointPair(p1List[i], p2List[i]));
                }
            }
            if (lpLists.Count() >= vbc.task.frameHistoryCount) lpLists.RemoveAt(0);
            return lpList;
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) lpLists.Clear();
            longLines.Run(src);
            lpLists.Add(longLines.lpList);
            lpList = findLines(lpLists);
            if (standaloneTest())
            {
                dst3 = src;
                foreach (var lp in lpList)
                {
                    DrawLine(dst3, lp.p1, lp.p2, Scalar.White);
                }
            }
            labels[2] = $"The {lpList.Count()} lines below were present in each of the last " + vbc.task.frameHistoryCount.ToString() + " frames";
        }
    }




    public class LineCoin_HistoryIntercept_CS : VB_Parent
    {
        LineCoin_Basics coin = new LineCoin_Basics();
        public List<PointPair> lpList = new List<PointPair>();
        List<List<PointPair>> mpLists = new List<List<PointPair>>();
        public LineCoin_HistoryIntercept_CS()
        {
            dst2 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "find lines with coincident slopes and intercepts.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) mpLists.Clear();
            coin.Run(src);
            dst2 = coin.dst2;
            labels[2] = $"The {lpList.Count()} lines below were present in each of the last " + vbc.task.frameHistoryCount.ToString() + " frames";
        }
    }




    public class LineCoin_Parallel_CS : VB_Parent
    {
        LongLine_ExtendParallel parallel = new LongLine_ExtendParallel();
        Line_Nearest near = new Line_Nearest();
        public List<coinPoints> coinList = new List<coinPoints>();
        public LineCoin_Parallel_CS()
        {
            desc = "Find the lines that are coincident in the parallel lines";
        }
        public void RunAlg(Mat src)
        {
            parallel.Run(src);
            coinList.Clear();
            foreach (var cp in parallel.parList)
            {
                near.lp = new PointPair(cp.p1, cp.p2);
                near.pt = cp.p3;
                near.Run(empty);
                double d1 = near.distance;
                near.pt = cp.p4;
                near.Run(empty);
                if (near.distance <= 1 || d1 <= 1) coinList.Add(cp);
            }
            dst2 = src.Clone();
            foreach (var cp in coinList)
            {
                dst2.Line(cp.p3, cp.p4, Scalar.Red, vbc.task.lineWidth + 2, vbc.task.lineType);
                dst2.Line(cp.p1, cp.p2, vbc.task.HighlightColor, vbc.task.lineWidth + 1, vbc.task.lineType);
            }
            labels[2] = coinList.Count().ToString() + " coincident lines were detected";
        }
    }




    public class LongLine_Basics_CS : VB_Parent
    {
        public LongLine_Core lines = new LongLine_Core();
        public List<PointPair> lpList = new List<PointPair>();
        Options_LongLine options = new Options_LongLine();
        public LongLine_Basics_CS()
        {
            lines.lineCount = 1000;
            desc = "Identify the longest lines";
        }
        public PointPair BuildLongLine(PointPair lp)
        {
            if (lp.p1.X != lp.p2.X)
            {
                double b = lp.p1.Y - lp.p1.X * lp.slope;
                if (lp.p1.Y == lp.p2.Y)
                {
                    return new PointPair(new cv.Point(0, lp.p1.Y), new cv.Point(dst2.Width, lp.p1.Y));
                }
                else
                {
                    int xint1 = (int)(-b / lp.slope);
                    int xint2 = (int)((dst2.Height - b) / lp.slope);
                    int yint1 = (int)b;
                    int yint2 = (int)(lp.slope * dst2.Width + b);
                    List<cv.Point> points = new List<cv.Point>();
                    if (xint1 >= 0 && xint1 <= dst2.Width) points.Add(new cv.Point(xint1, 0));
                    if (xint2 >= 0 && xint2 <= dst2.Width) points.Add(new cv.Point(xint2, dst2.Height));
                    if (yint1 >= 0 && yint1 <= dst2.Height) points.Add(new cv.Point(0, yint1));
                    if (yint2 >= 0 && yint2 <= dst2.Height) points.Add(new cv.Point(dst2.Width, yint2));
                    return new PointPair(points[0], points[1]);
                }
            }
            return new PointPair(new cv.Point(lp.p1.X, 0), new cv.Point(lp.p1.X, dst2.Height));
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            lines.Run(src);
            lpList.Clear();
            foreach (var lp in lines.lpList)
            {
                PointPair lpTmp = BuildLongLine(lp);
                DrawLine(dst2, lpTmp.p1, lpTmp.p2, Scalar.White);
                if (lpTmp.p1.X > lpTmp.p2.X) lpTmp = new PointPair(lpTmp.p2, lpTmp.p1);
                lpList.Add(lpTmp);
                if (lpList.Count() >= options.maxCount) break;
            }
            labels[2] = $"{lines.lpList.Count()} lines found, longest {lpList.Count()} displayed.";
        }
    }




    public class LongLine_Core_CS : VB_Parent
    {
        public Line_Basics lines = new Line_Basics();
        public int lineCount = 1; // How many of the longest lines...
        public List<PointPair> lpList = new List<PointPair>(); // this will be sorted by length - longest first
        public LongLine_Core_CS()
        {
            desc = "Isolate the longest X lines.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            if (lines.lpList.Count() == 0) return;
            dst2 = src;
            lpList.Clear();
            foreach (var lp in lines.lpList)
            {
                lpList.Add(lp);
                DrawLine(dst2, lp.p1, lp.p2, vbc.task.HighlightColor);
                if (lpList.Count() >= lineCount) break;
            }
        }
    }




    public class LongLine_Depth_CS : VB_Parent
    {
        LongLine_Consistent longLine = new LongLine_Consistent();
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        Kalman_Basics kalman = new Kalman_Basics();
        public LongLine_Depth_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, cv.Scalar.All(0));
            plot.dst2 = dst3;
            desc = "Find the longest line in BGR and use it to measure the average depth for the line";
        }
        public void RunAlg(Mat src)
        {
            longLine.Run(src.Clone());
            dst1 = src;
            DrawLine(dst1, longLine.ptLong.p1, longLine.ptLong.p2, Scalar.Yellow, vbc.task.lineWidth + 2);
            dst0.SetTo(0);
            DrawLine(dst0, longLine.ptLong.p1, longLine.ptLong.p2, cv.Scalar.All(255), 3);
            dst0.SetTo(0, vbc.task.noDepthMask);
            var mm = GetMinMax(vbc.task.pcSplit[2], dst0);
            kalman.kInput = new float[] { mm.minLoc.X, mm.minLoc.Y, mm.maxLoc.X, mm.maxLoc.Y };
            kalman.Run(empty);
            mm.minLoc = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
            mm.maxLoc = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
            DrawCircle(dst1, mm.minLoc, vbc.task.DotSize, Scalar.Red);
            DrawCircle(dst1, mm.maxLoc, vbc.task.DotSize, Scalar.Blue);
            SetTrueText($"{mm.minVal:F1}m", new cv.Point(mm.minLoc.X + 5, mm.minLoc.Y), 1);
            SetTrueText($"{mm.maxVal:F1}m", new cv.Point(mm.maxLoc.X + 5, mm.maxLoc.Y), 1);
            var depth = vbc.task.pcSplit[2].Mean(dst0)[0];
            SetTrueText($"Average Depth = {depth:F1}m", new cv.Point((longLine.ptLong.p1.X + longLine.ptLong.p2.X) / 2 + 30,
                                                                     (longLine.ptLong.p1.Y + longLine.ptLong.p2.Y) / 2), 1);
            labels[3] = $"Mean (blue)/Min (green)/Max (red) = {depth:F1}/{mm.minVal:F1}/{mm.maxVal:F1} meters ";
            plot.plotData = new Scalar(depth, mm.minVal, mm.maxVal);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }




    public class LongLine_Consistent_CS : VB_Parent
    {
        LongLine_Core longest = new LongLine_Core();
        public PointPair ptLong;
        public LongLine_Consistent_CS()
        {
            longest.lineCount = 4;
            desc = "Isolate the line that is consistently among the longest lines present in the image.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            longest.Run(src);
            if (longest.lpList.Count() == 0) return;
            if (ptLong == null) ptLong = longest.lpList[0];
            var minDistance = float.MaxValue;
            PointPair lpMin = null;
            foreach (var lp in longest.lpList)
            {
                var distance = lp.p1.DistanceTo(ptLong.p1) + lp.p2.DistanceTo(ptLong.p2);
                if (distance < minDistance)
                {
                    minDistance = (float)distance;
                    lpMin = lp;
                }
            }
            labels[2] = $"minDistance = {minDistance:F1}";
            DrawLine(dst2, ptLong.p1, ptLong.p2, vbc.task.HighlightColor);
            ptLong = lpMin;
        }
    }




    public class LongLine_Point_CS : VB_Parent
    {
        LongLine_Consistent longLine = new LongLine_Consistent();
        Kalman_Basics kalman = new Kalman_Basics();
        public cv.Point longPt;
        public LongLine_Point_CS()
        {
            desc = "Isolate the line that is consistently among the longest lines present in the image and then kalmanize the mid-point";
        }
        public void RunAlg(Mat src)
        {
            longLine.Run(src);
            dst2 = longLine.dst2;
            var lp = longLine.ptLong;
            kalman.kInput = new float[] { lp.p1.X, lp.p1.Y, lp.p2.X, lp.p2.Y };
            kalman.Run(empty);
            lp.p1 = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
            lp.p2 = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
            longPt = new cv.Point((lp.p1.X + lp.p2.X) / 2, (lp.p1.Y + lp.p2.Y) / 2);
            DrawCircle(dst2, longPt, vbc.task.DotSize, Scalar.Red);
        }
    }




    public class LongLine_Match_CS : VB_Parent
    {
        LongLine_Consistent longest = new LongLine_Consistent();
        Mat template = new cv.Mat();
        Options_LongLine options = new Options_LongLine();
        public LongLine_Match_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_32F, cv.Scalar.All(0));
            desc = "Find the longest line from last image and use matchTemplate to find the line in the latest image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            longest.Run(src);
            dst2 = longest.dst2;
            var lp = longest.ptLong;
            var x1 = Math.Min(lp.p1.X - options.pad, lp.p2.X - options.pad);
            var x2 = Math.Max(lp.p1.X + options.pad, lp.p2.X + options.pad);
            var y1 = Math.Min(lp.p1.Y - options.pad, lp.p2.Y - options.pad);
            var y2 = Math.Max(lp.p1.Y + options.pad, lp.p2.Y + options.pad);
            var rect = ValidateRect(new cv.Rect((int)Math.Min(x1, x2), (int)Math.Min(y1, y2), (int)Math.Abs(x1 - x2), (int)Math.Abs(y1 - y2)));
            dst2.Rectangle(rect, vbc.task.HighlightColor, vbc.task.lineWidth);
            if (vbc.task.FirstPass) template = src[rect].Clone();
            Cv2.MatchTemplate(template, src, dst0, TemplateMatchModes.CCoeffNormed);
            var mm = GetMinMax(dst0);
            mm.maxLoc = new cv.Point(mm.maxLoc.X + rect.Width / 2, mm.maxLoc.Y + rect.Height / 2);
            DrawCircle(dst2, mm.maxLoc, vbc.task.DotSize, Scalar.Red);
            dst3.SetTo(0);
            dst0 = dst0.Normalize(0, 255, NormTypes.MinMax);
            dst0.CopyTo(dst3[new cv.Rect((dst3.Width - dst0.Width) / 2, (dst3.Height - dst0.Height) / 2, dst0.Width, dst0.Height)]);
            DrawCircle(dst3, mm.maxLoc, vbc.task.DotSize, cv.Scalar.All(255));
            template = src[rect].Clone();
        }
    }




    public class LongLine_ExtendTest_CS : VB_Parent
    {
        LongLine_Basics longLine = new LongLine_Basics();
        public LongLine_ExtendTest_CS()
        {
            labels = new string[] { "", "", "Random Line drawn", "" };
            desc = "Test PointPair constructor with random values to make sure lines are extended properly";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                var p1 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                var p2 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                var mps = new PointPair(p1, p2);
                var emps = longLine.BuildLongLine(mps);
                dst2 = src;
                DrawLine(dst2, emps.p1, emps.p2, vbc.task.HighlightColor);
                DrawCircle(dst2, p1, vbc.task.DotSize + 2, Scalar.Red);
                DrawCircle(dst2, p2, vbc.task.DotSize + 2, Scalar.Red);
            }
        }
    }




    public class LongLine_ExtendAll_CS : VB_Parent
    {
        public Line_Basics lines = new Line_Basics();
        public List<PointPair> lpList = new List<PointPair>();
        public LongLine_ExtendAll_CS()
        {
            labels = new string[] { "", "", "Image output from Line_Basics", "The extended line for each line found in Line_Basics" };
            desc = "Create a list of all the extended lines in an image";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            dst3 = src.Clone();
            lpList.Clear();
            foreach (var lp in lines.lpList)
            {
                lpList.Add(lp);
                DrawLine(dst3, lp.p1, lp.p2, vbc.task.HighlightColor);
            }
        }
    }




    public class LongLine_ExtendParallel_CS : VB_Parent
    {
        LongLine_ExtendAll extendAll = new LongLine_ExtendAll();
        KNN_Basics knn = new KNN_Basics();
        Line_Nearest near = new Line_Nearest();
        public List<coinPoints> parList = new List<coinPoints>();
        public LongLine_ExtendParallel_CS()
        {
            labels = new string[] { "", "", "Image output from Line_Basics", "Parallel extended lines" };
            desc = "Use KNN to find which lines are near each other and parallel";
        }
        public void RunAlg(Mat src)
        {
            extendAll.Run(src);
            dst3 = extendAll.dst2;
            knn.queries.Clear();
            foreach (var lp in extendAll.lpList)
            {
                knn.queries.Add(new Point2f((lp.p1.X + lp.p2.X) / 2, (lp.p1.Y + lp.p2.Y) / 2));
            }
            knn.trainInput = new List<cv.Point2f>(knn.queries);
            if (knn.queries.Count() == 0) return; // no input...possible in a dark room...
            knn.Run(empty);
            dst2 = src.Clone();
            parList.Clear();
            var checkList = new List<cv.Point>();
            for (int i = 0; i <= knn.result.GetUpperBound(0) - 1; i++)
            {
                for (int j = 0; j < knn.queries.Count(); j++)
                {
                    var index = knn.result[i, j];
                    if (index >= extendAll.lpList.Count() || index < 0) continue;
                    var lp = extendAll.lpList[index];
                    var elp = extendAll.lpList[i];
                    var mid = knn.queries[i];
                    var near = knn.trainInput[index];
                    var distanceMid = mid.DistanceTo(near);
                    var distance1 = lp.p1.DistanceTo(elp.p1);
                    var distance2 = lp.p2.DistanceTo(elp.p2);
                    if (distance1 > distanceMid * 2)
                    {
                        distance1 = lp.p1.DistanceTo(elp.p2);
                        distance2 = lp.p2.DistanceTo(elp.p1);
                    }
                    if (distance1 < distanceMid * 2 && distance2 < distanceMid * 2)
                    {
                        var cp = new coinPoints();
                        var mps = extendAll.lines.lpList[index];
                        cp.p1 = new cv.Point((int)mps.p1.X, (int)mps.p1.Y);
                        cp.p2 = new cv.Point((int)mps.p2.X, (int)mps.p2.Y);
                        mps = extendAll.lines.lpList[i];
                        cp.p3 = new cv.Point((int)mps.p1.X, (int)mps.p1.Y);
                        cp.p4 = new cv.Point((int)mps.p2.X, (int)mps.p2.Y);
                        if (!checkList.Contains(cp.p1) && !checkList.Contains(cp.p2) && !checkList.Contains(cp.p3) && !checkList.Contains(cp.p4))
                        {
                            if ((cp.p1 == cp.p3 || cp.p1 == cp.p4) && (cp.p2 == cp.p3 || cp.p2 == cp.p4))
                            {
                                // duplicate points...
                            }
                            else
                            {
                                DrawLine(dst2, cp.p1, cp.p2, vbc.task.HighlightColor);
                                DrawLine(dst2, cp.p3, cp.p4, Scalar.Red);
                                parList.Add(cp);
                                checkList.Add(cp.p1);
                                checkList.Add(cp.p2);
                                checkList.Add(cp.p3);
                                checkList.Add(cp.p4);
                            }
                        }
                    }
                }
            }
            labels[2] = $"{parList.Count()} parallel lines were found in the image";
            labels[3] = $"{extendAll.lpList.Count()} lines were found in the image before finding the parallel lines";
        }
    }




    public class LongLine_Extend_CS : VB_Parent
    {
        LongLine_Basics lines = new LongLine_Basics();
        cv.Point saveP1, saveP2, p1, p2;
        public LongLine_Extend_CS()
        {
            labels = new string[] { "", "", "Original Line", "Original line Extended" };
            desc = "Given 2 points, extend the line to the edges of the image.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() && vbc.task.heartBeat)
            {
                p1 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                p2 = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                saveP1 = p1;
                saveP2 = p2;
            }
            var mps = new PointPair(p1, p2);
            var emps = lines.BuildLongLine(mps);
            if (standaloneTest())
            {
                labels[2] = $"{emps.p1} and {emps.p2} started with {saveP1} and {saveP2}";
                dst2 = src;
                DrawLine(dst2, emps.p1, emps.p2, vbc.task.HighlightColor);
                DrawCircle(dst2, saveP1, vbc.task.DotSize, Scalar.Red);
                DrawCircle(dst2, saveP2, vbc.task.DotSize, Scalar.Red);
            }
        }
    }




    public class LongLine_NoDepth_CS : VB_Parent
    {
        LineCoin_Basics lineHist = new LineCoin_Basics();
        public LongLine_NoDepth_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find any lines in regions without depth.";
        }
        public void RunAlg(Mat src)
        {
            lineHist.Run(src);
            dst2 = lineHist.dst2;
            dst2.SetTo(0, vbc.task.depthMask);
        }
    }




    public class LongLine_History_CS : VB_Parent
    {
        LongLine_Basics lines = new LongLine_Basics();
        public List<PointPair> lpList = new List<PointPair>();
        List<List<PointPair>> mpList = new List<List<PointPair>>();
        public LongLine_History_CS()
        {
            desc = "Find the longest lines and toss any that are intermittant.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            mpList.Add(lines.lpList);
            var tmplist = new List<PointPair>();
            var lpCount = new List<int>();
            foreach (var list in mpList)
            {
                foreach (var lp in list)
                {
                    var index = tmplist.IndexOf(lp);
                    if (index < 0)
                    {
                        tmplist.Add(lp);
                        lpCount.Add(1);
                    }
                    else
                    {
                        lpCount[index] += 1;
                    }
                }
            }
            lpList.Clear();
            for (int i = 0; i < lpCount.Count(); i++)
            {
                var count = lpCount[i];
                if (count >= vbc.task.frameHistoryCount) lpList.Add(tmplist[i]);
            }
            foreach (var lp in lpList)
            {
                DrawLine(dst2, lp.p1, lp.p2, Scalar.White);
            }
            if (mpList.Count() > vbc.task.frameHistoryCount) mpList.RemoveAt(0);
            labels[2] = $"{lpList.Count()} were found that were present for every one of the last {vbc.task.frameHistoryCount} frames.";
        }
    }




    public class LUT_Basics_CS : VB_Parent
    {
        public int classCount;
        Options_LUT options = new Options_LUT();
        byte[] segment = new byte[256];
        Mat myLut;
        public LUT_Basics_CS()
        {
            labels[3] = "Palettized version of dst2";
            desc = "Divide the image into n-segments controlled with a slider.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (classCount != options.lutSegments)
            {
                classCount = options.lutSegments;
                int incr = (int)Math.Truncate(255.0 / classCount);
                for (int i = 0; i < classCount; i++)
                {
                    int val = i * incr;
                    for (int j = 0; j < incr; j++)
                    {
                        segment[val + j] = (byte)val;
                    }
                }
                for (int i = incr * classCount; i <= 255; i++)
                {
                    segment[i] = 255;
                }
                myLut = cv.Mat.FromPixelData(1, 256, MatType.CV_8U, segment);
            }
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = src.LUT(myLut) * classCount / 255;
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = "Image segmented into " + (classCount + 1) + " divisions (0-" + classCount + ")";
        }
    }




    public class LUT_Sliders_CS : VB_Parent
    {
        Options_LUT options = new Options_LUT();
        public LUT_Sliders_CS()
        {
            desc = "Use an OpenCV Lookup Table to define 5 regions in a grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat gray = (src.Channels() == 1) ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat myLut = new Mat(1, 256, MatType.CV_8U);
            int splitIndex = 0;
            for (int i = 0; i <= 255; i++)
            {
                myLut.Set<byte>(0, i, (byte)options.vals[splitIndex]);
                if (i >= options.splits[splitIndex]) splitIndex++;
            }
            dst2 = gray.LUT(myLut);
        }
    }




    public class LUT_Reduction_CS : VB_Parent
    {
        public Reduction_Basics reduction = new Reduction_Basics();
        Mat vector = new Mat(256, 1, MatType.CV_8UC3, new Scalar(0));
        public LUT_Reduction_CS()
        {
            for (int i = 0; i <= 255; i++)
            {
                vector.Set<Vec3b>(i, 0, randomCellColor());
            }
            labels[3] = "Custom Color Lookup Table";
            desc = "Build and use a custom color palette";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2.CvtColor(ColorConversionCodes.GRAY2BGR).LUT(vector);
        }
    }




    public class LUT_RGBDepth_CS : VB_Parent
    {
        LUT_Basics lut = new LUT_Basics();
        public LUT_RGBDepth_CS()
        {
            desc = "Use a LUT on the RGBDepth to segregate depth data.";
        }
        public void RunAlg(Mat src)
        {
            lut.Run(vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = lut.dst2 * 255 / lut.classCount;
            labels[2] = lut.labels[2];
        }
    }




    public class LUT_Depth32f_CS : VB_Parent
    {
        LUT_Basics lut = new LUT_Basics();
        public LUT_Depth32f_CS()
        {
            desc = "Use a LUT on the 32-bit depth to segregate depth data.";
        }
        public void RunAlg(Mat src)
        {
            lut.Run(vbc.task.pcSplit[2].Normalize(255).ConvertScaleAbs(255));
            dst2 = lut.dst2 * 255 / lut.classCount;
            dst2.SetTo(0, vbc.task.noDepthMask);
            labels[2] = lut.labels[2];
        }
    }




    public class LUT_Equalized_CS : VB_Parent
    {
        Hist_EqualizeGray eq = new Hist_EqualizeGray();
        LUT_Basics lut = new LUT_Basics();
        public LUT_Equalized_CS()
        {
            labels[2] = "Without Histogram Equalized";
            labels[3] = "With Histogram Equalized";
            desc = "Use LUT_Basics but with an equalized histogram image.";
        }
        public void RunAlg(Mat src)
        {
            lut.Run(src);
            dst3 = lut.dst2 * 255 / lut.classCount;
            eq.dst3.SetTo(0);
            eq.Run(src);
            lut.Run(eq.dst2);
            dst2 = lut.dst2 * 255 / lut.classCount;
        }
    }




    public class LUT_Watershed_CS : VB_Parent
    {
        public Watershed_Basics wShed = new Watershed_Basics();
        public LUT_Equalized lut = new LUT_Equalized();
        Edge_Canny edges = new Edge_Canny();
        public LUT_Watershed_CS()
        {
            labels[3] = "LUT output with edges highlighted.";
            labels[2] = "Watershed Results - draw a rectangle to create a region";
            wShed.UseCorners = true;
            desc = "Use watershed algorithm with LUT input to identify regions in the image";
        }
        public void RunAlg(Mat src)
        {
            lut.Run(src);
            dst3 = lut.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            edges.Run(src);
            dst3.SetTo(Scalar.White, edges.dst2);
            wShed.Run(dst3);
            dst2 = wShed.dst3;
        }
    }




    public class LUT_Custom_CS : VB_Parent
    {
        Palette_RandomColorMap gradMap = new Palette_RandomColorMap();
        public Mat colorMap;
        int saveColorCount = -1;
        TrackBar colorSlider;
        public LUT_Custom_CS()
        {
            colorSlider = FindSlider("Color transitions");
            colorSlider.Value = 5;
            labels[3] = "Custom Color Lookup Table";
            desc = "Use a palette to provide the lookup table for LUT";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged || vbc.task.heartBeat)
            {
                if (saveColorCount == 20) colorSlider.Value = 5; else colorSlider.Value++;
                saveColorCount = colorSlider.Value;
                gradMap.Run(src);
                colorMap = gradMap.gradientColorMap.Flip(FlipMode.X);
            }
            dst2 = src.LUT(colorMap);
            dst3 = colorMap.Resize(src.Size());
        }
    }




    public class LUT_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Sort_3Channel sort3 = new Sort_3Channel();
        public LUT_RedCloud_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Use LUT on the grayscale image after masking with rc.mask";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            var rc = vbc.task.rc;
            src[rc.rect].CopyTo(dst3[rc.rect], rc.mask);
            sort3.Run(dst3);
            dst1 = sort3.dst2;
        }
    }




    public class LUT_Create_CS : VB_Parent
    {
        byte[][] pixels = new byte[3][];
        Options_LUT_Create options = new Options_LUT_Create();
        public LUT_Create_CS()
        {
            desc = "Create a LUT table that can map similar pixels to the same exact pixel.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var split = src.Split();
            for (int i = 0; i <= 2; i++)
            {
                if (vbc.task.FirstPass) Array.Resize(ref pixels[i], (int)src.Total());
                Marshal.Copy(split[i].Data, pixels[i], 0, pixels[i].Length);
            }
            float[] totals = new float[256];
            Vec3i[] lutI = new Vec3i[256];
            for (int i = 0; i < src.Total(); i++)
            {
                int index = (int)(0.299 * pixels[2][i] + 0.587 * pixels[1][i] + 0.114 * pixels[0][i]);
                totals[index] += 1;
                Vec3i v1 = lutI[index];
                Vec3i v2 = new Vec3i(pixels[0][i], pixels[1][i], pixels[2][i]);
                lutI[index] = new Vec3i((v1.Item0 + v2.Item0) / 2, (v1.Item1 + v2.Item1) / 2, (v1.Item2 + v2.Item2) / 2);
            }
            Vec3i lastVec = lutI[0];
            for (int i = 1; i < lutI.Length; i++)
            {
                Vec3i vec = lutI[i];
                int diff = Math.Abs(vec.Item0 - lastVec.Item0) + Math.Abs(vec.Item1 - lastVec.Item1) + Math.Abs(vec.Item2 - lastVec.Item2);
                if (diff < options.lutThreshold)
                {
                    lutI[i] = lastVec;
                }
                else
                {
                    lastVec = vec;
                }
            }
            Vec3b[] lut = new Vec3b[256];
            for (int i = 0; i < lutI.Length; i++)
            {
                lut[i] = new Vec3b((byte)lutI[i].Item0, (byte)lutI[i].Item1, (byte)lutI[i].Item2);
            }
            dst2 = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            Mat myLut = cv.Mat.FromPixelData(1, 256, MatType.CV_8UC3, lut);
            // dst3 = dst2.LUT(myLut); // Not clear why this is failing!
        }
    }




    public class Magnify_Basics_CS : VB_Parent
    {
        public Magnify_Basics_CS()
        {
            vbc.task.drawRect = new cv.Rect(10, 10, 50, 50);
            desc = "Magnify the drawn rectangle on dst2 and put it in dst3.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            if (vbc.task.drawRect.Width > 0 && vbc.task.drawRect.Height > 0)
            {
                dst3 = dst2[vbc.task.drawRect].Resize(dst3.Size(), 0, 0, InterpolationFlags.Nearest);
            }
        }
    }




    public class Magnify_Example_CS : VB_Parent
    {
        Neighbors_Intersects prep = new Neighbors_Intersects();
        Magnify_Basics zoom = new Magnify_Basics();
        public Magnify_Example_CS()
        {
            desc = "Magnify the output of the algorithm above.";
        }
        public void RunAlg(Mat src)
        {
            prep.Run(src);
            dst2 = prep.dst2;
            zoom.Run(dst2);
            dst3 = zoom.dst3;
        }
    }




    public class Mat_Repeat_CS : VB_Parent
    {
        public Mat_Repeat_CS()
        {
            desc = "Use the repeat method to replicate data.";
        }
        public void RunAlg(Mat src)
        {
            var small = src.Resize(new cv.Size(src.Cols / 10, src.Rows / 10));
            dst2 = small.Repeat(10, 10);
            small = vbc.task.depthRGB.Resize(new cv.Size(src.Cols / 10, src.Rows / 10));
            dst3 = small.Repeat(10, 10);
        }
    }




    public class Mat_PointToMat_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();
        public Mat_PointToMat_CS()
        {
            labels[2] = "Random_Basics points (original)";
            labels[3] = "Random_Basics points after format change with indexer";
            desc = "Convert point2f into a mat of points";
        }
        public void RunAlg(Mat src)
        {
            random.Run(empty);
            dst2.SetTo(0);
            foreach (var pt in random.PointList)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Yellow);
            }
            var rows = random.PointList.Count();
            var pMat = cv.Mat.FromPixelData(rows, 1, MatType.CV_32FC2, random.PointList.ToArray());
            var indexer = pMat.GetGenericIndexer<Vec2f>();
            dst3.SetTo(0);
            var white = new Vec3b(255, 255, 255);
            for (int i = 0; i < rows; i++)
            {
                dst3.Set<Vec3b>((int)indexer[i][1], (int)indexer[i][0], white);
            }
        }
    }




    public class Mat_MatToPoint_CS : VB_Parent
    {
        public Mat_MatToPoint_CS()
        {
            desc = "Convert a mat into a vector of points.";
            labels[2] = "Reconstructed BGR Image";
        }
        public void RunAlg(Mat src)
        {
            var points = new Vec3b[src.Total()];
            Vec3b vec = new Vec3b();
            int index = 0;
            var indexer = src.GetGenericIndexer<Vec3b>();
            for (int y = 0; y < src.Rows; y++)
            {
                for (int x = 0; x < src.Cols; x++)
                {
                    vec = indexer[y, x];
                    points[index] = new Vec3b(vec[0], vec[1], vec[2]);
                    index++;
                }
            }
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, points);
        }
    }




    public class Mat_Tricks_CS : VB_Parent
    {
        public Mat_Tricks_CS()
        {
            labels[2] = "Image squeezed into square Mat";
            labels[3] = "Mat transposed around the diagonal";
            desc = "Show some Mat tricks.";
        }
        public void RunAlg(Mat src)
        {
            var mat = src.Resize(new cv.Size(src.Height, src.Height));
            var roi = new cv.Rect(0, 0, mat.Width, mat.Height);
            dst2[roi] = mat;
            dst3[roi] = mat.Transpose();
        }
    }




    public class Mat_RowColRange_CS : VB_Parent
    {
        public Mat_RowColRange_CS()
        {
            labels[2] = "BitwiseNot of RowRange and ColRange";
            desc = "Perform operation on a range of cols and/or Rows.";
        }
        public void RunAlg(Mat src)
        {
            var midX = src.Width / 2;
            var midY = src.Height / 2;
            dst2 = src;
            Cv2.BitwiseNot(dst2.RowRange(midY - 25, midY + 25), dst2.RowRange(midY - 25, midY + 25));
            Cv2.BitwiseNot(dst2.ColRange(midX - 25, midX + 25), dst2.ColRange(midX - 25, midX + 25));
        }
    }





    public class Mat_MultiplyReview_CS : VB_Parent
    {
        public Mat_MultiplyReview_CS()
        {
            desc = "Review matrix multiplication";
        }
        public void RunAlg(Mat src)
        {
            int[,] a = { { 1, 4, 2 }, { 2, 5, 1 } };
            int[,] b = { { 3, 4, 2 }, { 3, 5, 7 }, { 1, 2, 1 } };
            string strOut = "Matrix a" + "\n";
            for (int i = 0; i < a.GetLength(0); i++)
            {
                for (int j = 0; j < a.GetLength(1); j++)
                {
                    strOut += a[i, j].ToString() + "\t";
                }
                strOut += "\n";
            }
            strOut += "Matrix b" + "\n";
            for (int i = 0; i < b.GetLength(0); i++)
            {
                for (int j = 0; j < b.GetLength(1); j++)
                {
                    strOut += b[i, j].ToString() + "\t";
                }
                strOut += "\n";
            }
            int[,] c = new int[a.GetLength(0), b.GetLength(1)];
            string[,] input = new string[a.GetLength(0), b.GetLength(1)];
            for (int i = 0; i < c.GetLength(0); i++)
            {
                for (int j = 0; j < c.GetLength(1); j++)
                {
                    input[i, j] = "";
                    for (int k = 0; k < a.GetLength(1); k++)
                    {
                        c[i, j] += a[i, k] * b[k, j];
                        input[i, j] += a[i, k].ToString() + "*" + b[k, j].ToString() + (k < a.GetLength(1) - 1 ? " + " : "\t");
                    }
                }
            }
            strOut += "Matrix c = a X b" + "\n";
            for (int i = 0; i < a.GetLength(0); i++)
            {
                for (int j = 0; j < b.GetLength(1); j++)
                {
                    strOut += c[i, j].ToString() + " = " + input[i, j];
                }
                strOut += "\n";
            }
            SetTrueText(strOut, 2);
        }
    }





    public class Mat_2to1_CS : VB_Parent
    {
        Mat mat1;
        Mat mat2;
        public Mat[] mat;
        public bool lineSeparators = true; // if they want lines or not...
        public Mat_2to1_CS()
        {
            mat1 = new Mat(new cv.Size(dst2.Rows, dst2.Cols), MatType.CV_8UC3, cv.Scalar.All(0));
            mat2 = mat1.Clone();
            mat = new Mat[] { mat1, mat2 };
            labels[2] = "";
            desc = "Fill a Mat with 2 images";
        }
        public void RunAlg(Mat src)
        {
            var nSize = new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height / 2);
            var roiTop = new cv.Rect(0, 0, nSize.Width, nSize.Height);
            var roibot = new cv.Rect(0, nSize.Height, nSize.Width, nSize.Height);
            if (standaloneTest())
            {
                mat1 = src;
                mat2 = vbc.task.depthRGB;
                mat = new Mat[] { mat1, mat2 };
            }
            dst2.SetTo(0);
            if (mat[0] != null)
            {
                if (dst2.Type() != mat[0].Type())
                    dst2 = new Mat(dst2.Size(), mat[0].Type());
                for (int i = 0; i <= 1; i++)
                {
                    var roi = (i == 0) ? roiTop : roibot;
                    if (!mat[i].Empty())
                        dst2[roi] = mat[i].Resize(nSize);
                }
                if (lineSeparators)
                {
                    dst2.Line(new cv.Point(0, dst2.Height / 2), new cv.Point(dst2.Width, dst2.Height / 2), Scalar.White, vbc.task.lineWidth + 1);
                }
            }
        }
    }




    public class Mat_ToList_CS : VB_Parent
    {
        OpAuto_XRange autoX = new OpAuto_XRange();
        Projection_HistTop histTop = new Projection_HistTop();
        public Mat_ToList_CS()
        {
            desc = "Convert a Mat to List of points in 2 ways to measure which is better";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            autoX.Run(histTop.histogram);
            dst2 = histTop.histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            var ptList = new List<cv.Point>();
            if (vbc.task.gOptions.getDebugCheckBox())
            {
                for (int y = 0; y < dst2.Height; y++)
                {
                    for (int x = 0; x < dst2.Width; x++)
                    {
                        if (dst2.At<byte>(y, x) != 0) ptList.Add(new cv.Point(x, y));
                    }
                }
            }
            else
            {
                var points = dst2.FindNonZero();
                for (int i = 0; i < points.Rows; i++)
                {
                    ptList.Add(points.At<cv.Point>(i, 0));
                }
            }
            labels[2] = "There were " + ptList.Count().ToString() + " points identified";
        }
    }




    public class Mat_Inverse_CS : VB_Parent
    {
        public float[,] matrix = new float[,] { { 1.1688f, 0.23f, 62.2f }, { -0.013f, 1.225f, -6.29f }, { 0, 0, 1 } };
        public bool validateInverse;
        public Mat inverse = new Mat();
        Options_Mat options = new Options_Mat();
        public Mat_Inverse_CS()
        {
            desc = "Given a 3x3 matrix, invert it and present results.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest() || validateInverse)
            {
                strOut = "Matrix Input " + "\n";
                for (int i = 0; i < matrix.GetLength(0); i++)
                {
                    for (int j = 0; j < matrix.GetLength(1); j++)
                    {
                        strOut += matrix[i, j].ToString() + "\t";
                    }
                    strOut += "\n";
                }
                strOut += "\n";
            }
            var input = cv.Mat.FromPixelData(3, 3, MatType.CV_32F, matrix);
            Cv2.Invert(input, inverse, options.decompType);
            if (standaloneTest() || validateInverse)
            {
                strOut += "Matrix Inverse " + "\n";
                for (int i = 0; i < matrix.GetLength(0); i++)
                {
                    for (int j = 0; j < matrix.GetLength(1); j++)
                    {
                        strOut += inverse.At<float>(j, i).ToString() + "\t";
                    }
                    strOut += "\n";
                }
                strOut += "\n";
                var identity = (input * inverse).ToMat();
                strOut += "Verify Inverse is correct " + "\n";
                for (int i = 0; i < matrix.GetLength(0); i++)
                {
                    for (int j = 0; j < matrix.GetLength(1); j++)
                    {
                        strOut += identity.At<float>(j, i).ToString() + "\t";
                    }
                    strOut += "\n";
                }
                strOut += "\n";
            }
            SetTrueText(strOut, 2);
        }
    }





    public class Mat_Transpose_CS : VB_Parent
    {
        public Mat_Transpose_CS()
        {
            desc = "Transpose a Mat and show results.";
            labels[2] = "Color Image Transposed";
            labels[3] = "Color Image Transposed back (artifacts)";
        }
        public void RunAlg(Mat src)
        {
            var trColor = src.T();
            dst2 = trColor.ToMat().Resize(new cv.Size(src.Cols, src.Rows));
            var trBack = dst2.T();
            dst3 = trBack.ToMat().Resize(src.Size());
        }
    }




    public class Mat_Managed_CS : VB_Parent
    {
        Random autoRand = new Random();
        Vec3b[] img;
        Vec3b nextColor = new Vec3b();
        public Mat_Managed_CS()
        {
            img = new Vec3b[dst2.Total()];
            labels[2] = "Color change is in the managed cv.vec3b array";
            desc = "There is a limited ability to use Mat data in Managed code directly.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, img);
            if (vbc.task.heartBeat)
            {
                nextColor = nextColor == new Vec3b(0, 0, 255) ? new Vec3b(0, 255, 0) : new Vec3b(0, 0, 255);
            }
            for (int i = 0; i < img.Length; i++)
            {
                img[i] = nextColor;
            }
            var rect = new cv.Rect(autoRand.Next(0, src.Width - 50), autoRand.Next(0, src.Height - 50), 50, 50);
            dst2[rect].SetTo(0);
        }
    }




    public class Mat_Inverse_4D_CS : VB_Parent
    {
        double[,] defaultInput = new double[,] { { 3, 7, 2, 5 }, { 4, 0, 1, 1 }, { 1, 6, 3, 0 }, { 2, 8, 4, 3 } };
        public Mat input;
        public Mat_Inverse_4D_CS()
        {
            input = cv.Mat.FromPixelData(4, 4, MatType.CV_64F, defaultInput);
            desc = "Use OpenCV to invert a matrix";
        }
        string printMatrixResults(Mat src, Mat dst2)
        {
            string outstr = "Original Matrix " + "\n";
            for (int y = 0; y < src.Rows; y++)
            {
                for (int x = 0; x < src.Cols; x++)
                {
                    outstr += string.Format("{0}\t", src.At<double>(y, x).ToString("F4"));
                }
                outstr += "\n";
            }
            outstr += "\nMatrix Inverse" + "\n";
            for (int y = 0; y < src.Rows; y++)
            {
                for (int x = 0; x < src.Cols; x++)
                {
                    outstr += string.Format("{0}\t", dst2.At<double>(y, x).ToString("F4"));
                }
                outstr += "\n";
            }
            return outstr;
        }
        public void RunAlg(Mat src)
        {
            if (input.Width != input.Height)
            {
                SetTrueText("The input matrix must be square!");
                return;
            }
            Mat result = new Mat();
            Cv2.Invert(input, result, DecompTypes.LU);
            string outstr = printMatrixResults(input, result);
            SetTrueText(outstr);
        }
    }




    public class Mat_4Click_CS : VB_Parent
    {
        public Mat_4to1_CS mats;
        public Mat[] mat;
        public int quadrant = 3;

        public Mat_4Click_CS()
        {
            mats = new Mat_4to1_CS();
            mat = mats.mat;
            labels[3] = "Click a quadrant in dst2 to view it in dst3";
            desc = "Split an image into 4 segments and allow clicking on a quadrant to open it in dst3";
        }

        public void RunAlg(Mat src)
        {
            mat = mats.mat;
            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC3));
            dst2 = mats.dst2.Clone();
            if (standalone) mats.defaultMats(src);
            if (vbc.task.FirstPass)
            {
                vbc.task.ClickPoint = new cv.Point(0, 0);
                vbc.task.mousePicTag = 2;
            }

            if (vbc.task.mouseClickFlag && vbc.task.mousePicTag == 2)
            {
                if (vbc.task.ClickPoint.Y < dst2.Rows / 2)
                {
                    quadrant = (vbc.task.ClickPoint.X < vbc.task.dst2.Width / 2) ? 0 : 1;
                }
                else
                {
                    quadrant = (vbc.task.ClickPoint.X < vbc.task.dst2.Width / 2) ? 2 : 3;
                }
            }
            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC3));
            dst2 = mats.dst2.Clone();
            dst3 = mats.mat[quadrant].Clone();
        }
    }






    public class Mat_4to1_CS : VB_Parent
    {
        public Mat[] mat = new Mat[4];
        public bool lineSeparators = true; // if they want lines or not...
        public int quadrant = 0;

        public Mat_4to1_CS()
        {
            for (int i = 0; i < mat.Length; i++)
            {
                mat[i] = dst2.Clone();
            }
            labels[2] = "Combining 4 images into one";
            labels[3] = "Click any quadrant at left to view it below";
            desc = "Use one Mat for up to 4 images";
        }

        public void defaultMats(Mat src)
        {
            Mat tmpLeft = (vbc.task.leftView.Channels() == 1) ? vbc.task.leftView.CvtColor(ColorConversionCodes.GRAY2BGR) : vbc.task.leftView;
            Mat tmpRight = (vbc.task.rightView.Channels() == 1) ? vbc.task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : vbc.task.rightView;
            mat = new Mat[] { vbc.task.color.Clone(), vbc.task.depthRGB.Clone(), tmpLeft, tmpRight };
        }

        public void RunAlg(Mat src)
        {
            cv.Size nSize = new cv.Size(dst2.Width / 2, dst2.Height / 2);
            cv.Rect roiTopLeft = new cv.Rect(0, 0, nSize.Width, nSize.Height);
            cv.Rect roiTopRight = new cv.Rect(nSize.Width, 0, nSize.Width, nSize.Height);
            cv.Rect roibotLeft = new cv.Rect(0, nSize.Height, nSize.Width, nSize.Height);
            cv.Rect roibotRight = new cv.Rect(nSize.Width, nSize.Height, nSize.Width, nSize.Height);
            if (standalone) defaultMats(src);

            dst2 = new Mat(dst2.Size(), MatType.CV_8UC3);
            cv.Rect roi = new cv.Rect(0, 0, 0, 0);
            for (int i = 0; i < 4; i++)
            {
                Mat tmp = mat[i].Clone();
                if (tmp.Channels() == 1) tmp = mat[i].CvtColor(ColorConversionCodes.GRAY2BGR);
                if (i == 0) roi = roiTopLeft;
                if (i == 1) roi = roiTopRight;
                if (i == 2) roi = roibotLeft;
                if (i == 3) roi = roibotRight;
                dst2[roi] = tmp.Resize(nSize);
            }
            if (lineSeparators)
            {
                dst2.Line(new cv.Point(0, dst2.Height / 2), new cv.Point(dst2.Width, dst2.Height / 2), Scalar.White, vbc.task.lineWidth + 1);
                dst2.Line(new cv.Point(dst2.Width / 2, 0), new cv.Point(dst2.Width / 2, dst2.Height), Scalar.White, vbc.task.lineWidth + 1);
            }
        }
    }




    public class Match_Basics_CS : VB_Parent
    {
        public Mat template;
        public mmData mmData;
        public float correlation;
        public Options_Features options = new Options_Features();
        public cv.Point matchCenter;
        public cv.Rect matchRect = new cv.Rect();
        public cv.Rect searchRect = new cv.Rect();
        public Match_Basics_CS()
        {
            if (standalone) vbc.task.gOptions.setDebugCheckBox(true);
            labels[2] = standaloneTest() ? "Draw anywhere to define a new target" : "Both drawRect must be provided by the caller.";
            dst3 = new Mat(dst3.Size(), MatType.CV_32F, cv.Scalar.All(0));
            desc = "Find the requested template in an image.  Managing template is responsibility of caller (allows multiple targets per image.)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standalone)
            {
                if (vbc.task.gOptions.getDebugCheckBox())
                {
                    vbc.task.gOptions.setDebugCheckBox(false);
                    var inputRect = vbc.task.FirstPass ? new cv.Rect(25, 25, 25, 25) : ValidateRect(vbc.task.drawRect);
                    template = src[inputRect];
                }
            }
            if (searchRect.Width == 0)
            {
                Cv2.MatchTemplate(template, src, dst0, options.matchOption);
            }
            else
            {
                Cv2.MatchTemplate(template, src[searchRect], dst0, options.matchOption);
            }
            mmData = GetMinMax(dst0);
            correlation = (float)mmData.maxVal;
            labels[2] = "Correlation = " + correlation.ToString("#,##0.000");
            var w = template.Width;
            var h = template.Height;
            if (searchRect.Width == 0)
            {
                matchCenter = new cv.Point(mmData.maxLoc.X + w / 2, mmData.maxLoc.Y + h / 2);
                matchRect = new cv.Rect(mmData.maxLoc.X, mmData.maxLoc.Y, w, h);
            }
            else
            {
                matchCenter = new cv.Point(searchRect.X + mmData.maxLoc.X + w / 2, searchRect.Y + mmData.maxLoc.Y + h / 2);
                matchRect = new cv.Rect(searchRect.X + mmData.maxLoc.X, searchRect.Y + mmData.maxLoc.Y, w, h);
            }
            if (standalone)
            {
                dst2 = src;
                DrawCircle(dst2, matchCenter, vbc.task.DotSize, Scalar.White);
                dst3 = dst0.Normalize(0, 255, NormTypes.MinMax);
            }
        }
    }




    public class Match_BasicsTest_CS : VB_Parent
    {
        public Match_Basics match = new Match_Basics();
        public Match_BasicsTest_CS()
        {
            labels = new string[] { "", "", "Draw a rectangle to be tracked", "Highest probability of a match at the brightest point below" };
            desc = "Test the Match_Basics algorithm";
        }
        public void RunAlg(Mat src)
        {
            if ((vbc.task.FirstPass || (vbc.task.mouseClickFlag && vbc.task.drawRect.Width != 0)) && standaloneTest())
            {
                var r = vbc.task.FirstPass ? new cv.Rect(25, 25, 25, 25) : ValidateRect(vbc.task.drawRect);
                match.template = src[r];
                vbc.task.drawRectClear = true;
            }
            match.Run(src);
            if (standaloneTest())
            {
                dst2 = src;
                DrawCircle(dst2, match.matchCenter, vbc.task.DotSize, Scalar.White);
                dst3 = match.dst0.Normalize(0, 255, NormTypes.MinMax);
                SetTrueText(match.correlation.ToString(vbc.fmt3), match.matchCenter);
            }
        }
    }




    public class Match_RandomTest_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        public Mat template;
        public Mat correlationMat = new Mat();
        public float correlation;
        public mmData mm;
        public float minCorrelation = float.MaxValue;
        public float maxCorrelation = float.MinValue;
        public Options_Features options = new Options_Features();
        int saveSampleCount = -1;
        public Match_RandomTest_CS()
        {
            flow.parentData = this;
            desc = "Find correlation coefficient for 2 random series.  Should be near zero except for small sample size.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest())
            {
                if (saveSampleCount != options.featurePoints)
                {
                    saveSampleCount = options.featurePoints;
                    maxCorrelation = float.MinValue;
                    minCorrelation = float.MaxValue;
                }
                template = new Mat(new cv.Size(options.featurePoints, 1), MatType.CV_32FC1);
                src = new Mat(new cv.Size(options.featurePoints, 1), MatType.CV_32FC1);
                Cv2.Randn(template, 100, 25);
                Cv2.Randn(src, 0, 25);
            }
            Cv2.MatchTemplate(template, src, correlationMat, options.matchOption);
            mm = GetMinMax(correlationMat);
            mm.maxLoc = new cv.Point(mm.maxLoc.X + template.Width / 2, mm.maxLoc.Y + template.Height / 2);
            correlation = (float)mm.maxVal;
            if (correlation < minCorrelation) minCorrelation = correlation;
            if (correlation > maxCorrelation) maxCorrelation = correlation;
            labels[2] = "Correlation = " + correlation.ToString("#,##0.000");
            if (standaloneTest())
            {
                dst2.SetTo(0);
                labels[2] = options.matchText + " for " + template.Cols + " random test samples = " + correlation.ToString("#,##0.00");
                flow.nextMsg = options.matchText + " = " + correlation.ToString("#,##0.00");
                flow.Run(empty);
                SetTrueText("The expectation is that the " + template.Cols + " random test samples should produce" + "\r\n" +
                            " a correlation coefficient near zero" + "\r\n" +
                            "The larger the sample size, the closer to zero the correlation will be - See 'Sample Size' slider nearby." + "\r\n" +
                            "There should also be symmetry in the min and max around zero." + "\r\n" + "\r\n" +
                            "Min Correlation = " + minCorrelation.ToString(vbc.fmt3) + "\r\n" +
                            "Max Correlation = " + maxCorrelation.ToString(vbc.fmt3), 3);
            }
        }
    }




    public class Match_BestEntropy_CS : VB_Parent
    {
        Entropy_Highest entropy = new Entropy_Highest();
        Match_DrawRect match = new Match_DrawRect();
        public Match_BestEntropy_CS()
        {
            match.showOutput = true;
            labels[2] = "Probabilities that the template matches image";
            labels[3] = "Red is the best template to match (highest entropy)";
            desc = "Track an object - one with the highest entropy - using OpenCV's matchtemplate.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                entropy.Run(src);
                vbc.task.drawRect = entropy.eMaxRect;
            }
            match.Run(src);
            dst2 = match.dst2;
            dst3 = match.dst3;
            dst2.SetTo(Scalar.White, vbc.task.gridMask);
        }
    }





    public class Match_Lines_CS : VB_Parent
    {
        KNN_Basics4D knn = new KNN_Basics4D();
        Line_Basics lines = new Line_Basics();
        List<PointPair> lastPt = new List<PointPair>();
        public Match_Lines_CS()
        {
            labels[2] = "This is not matching lines from the previous frame because lines often disappear and nearby lines are selected.";
            desc = "Use the 2 points from a line as input to a 4-dimension KNN";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            if (vbc.task.FirstPass) lastPt = new List<PointPair>(lines.lpList);
            knn.queries.Clear();
            foreach (var lp in lines.lpList)
            {
                knn.queries.Add(new Vec4f(lp.p1.X, lp.p1.Y, lp.p2.X, lp.p2.Y));
            }
            if (vbc.task.optionsChanged) knn.trainInput = new List<Vec4f>(knn.queries);
            knn.Run(empty);
            if (knn.queries.Count() == 0) return;
            foreach (var i in knn.result)
            {
                if (i >= lines.lpList.Count()) continue;
                var lp = lines.lpList[i];
                var index = knn.result[i, 0];
                if (index >= 0 && index < lastPt.Count())
                {
                    var lastMP = lastPt[index];
                    DrawLine(dst2, lp.p1, lastMP.p2, Scalar.Red);
                }
            }
            knn.trainInput = new List<Vec4f>(knn.queries);
            lastPt = new List<PointPair>(lines.lpList);
        }
    }




    public class Match_PointSlope_CS : VB_Parent
    {
        Line_PointSlope lines = new Line_PointSlope();
        bool updateLines = true;
        public List<matchRect> matches = new List<matchRect>();
        List<Mat> templates = new List<Mat>();
        Mat_4to1 mats = new Mat_4to1();
        string strOut1;
        string strOut2;
        public Match_PointSlope_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new[] { "", "Output of Lines_PointSlope", "Matched lines", "correlationMats" };
            desc = "Initialize with the best lines in the image and track them using matchTemplate.  Reinitialize when correlations drop.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            var w = vbc.task.gridSize;
            var h = w;
            if (updateLines)
            {
                updateLines = false;
                templates.Clear();
                lines.Run(src);
                dst1 = src.Clone();
                foreach (var pts in lines.bestLines)
                {
                    var rect = ValidateRect(new cv.Rect((int)(pts.p1.X - w), (int)(pts.p1.Y - h), w * 2, h * 2));
                    templates.Add(src[rect]);
                    dst1.Rectangle(rect, Scalar.White, vbc.task.lineWidth);
                    rect = ValidateRect(new cv.Rect((int)(pts.p2.X - w), (int)(pts.p2.Y - h), w * 2, h * 2));
                    templates.Add(src[rect]);
                    dst1.Rectangle(rect, Scalar.White, vbc.task.lineWidth);
                    DrawLine(dst1, pts.p1, pts.p2, vbc.task.HighlightColor);
                }
            }
            var correlationMat = new Mat();
            mmData mm;
            matches.Clear();
            var newTemplates = new List<Mat>();
            for (int i = 0; i < lines.bestLines.Count(); i++)
            {
                var ptS = lines.bestLines[i];
                matchRect mr = new matchRect();
                for (int j = 0; j <= 1; j++)
                {
                    var pt = (j == 0) ? ptS.p1 : ptS.p2;
                    Cv2.MatchTemplate(templates[i * 2 + j], src, correlationMat, TemplateMatchModes.CCoeffNormed);
                    mm = GetMinMax(correlationMat);
                    if (i < 4) // only 4 mats can be displayed in the Mat_4to1 algorithm...
                    {
                        mats.mat[i].SetTo(0);
                        correlationMat = Convert32f_To_8UC3(correlationMat);
                        var r = new cv.Rect((dst2.Width - correlationMat.Width) / 2, (dst2.Height - correlationMat.Height) / 2, correlationMat.Width, correlationMat.Height);
                        correlationMat.CopyTo(mats.mat[i][r]);
                    }
                    if (j == 0)
                    {
                        mr.p1 = new cv.Point(mm.maxLoc.X + w, mm.maxLoc.Y + h);
                        mr.correlation1 = (float)mm.maxVal;
                        var rect = ValidateRect(new cv.Rect(mr.p1.X - w, mr.p1.Y - h, w * 2, h * 2));
                        newTemplates.Add(src[rect]);
                    }
                    else
                    {
                        mr.p2 = new cv.Point(mm.maxLoc.X + w, mm.maxLoc.Y + h);
                        mr.correlation2 = (float)mm.maxVal;
                        var rect = ValidateRect(new cv.Rect(mr.p2.X - w, mr.p2.Y - h, w * 2, h * 2));
                        newTemplates.Add(src[rect]);
                    }
                }
                matches.Add(mr);
            }
            mats.Run(empty);
            dst3 = mats.dst2;
            int incorrectCount = 0;
            foreach (var mr in matches)
            {
                if (mr.correlation1 < 0.5 || mr.correlation2 < 0.5) incorrectCount++;
                DrawLine(dst2, mr.p1, mr.p2, vbc.task.HighlightColor);
                DrawCircle(dst2, mr.p1, vbc.task.DotSize, vbc.task.HighlightColor);
                DrawCircle(dst2, mr.p2, vbc.task.DotSize, vbc.task.HighlightColor);
                if (vbc.task.heartBeat)
                {
                    strOut1 = string.Format("{0:F3}", mr.correlation1);
                    strOut2 = string.Format("{0:F3}", mr.correlation2);
                }
                SetTrueText(strOut1, mr.p1, 2);
                SetTrueText(strOut2, mr.p2, 2);
            }
            labels[2] = (matches.Count() - incorrectCount).ToString() + " lines were confirmed with correlations";
            if (incorrectCount > 0) updateLines = true;
        }
    }




    public class Match_TraceRedC_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        List<Mat> frameList = new List<Mat>();
        public Match_TraceRedC_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32S, cv.Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_32S, cv.Scalar.All(0));
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Track each RedCloud cell center to highlight zones of RedCloud cell instability.  Look for clusters of points in dst2.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat || !vbc.task.cameraStable) dst2.SetTo(0);
            redC.Run(src);
            if (vbc.task.optionsChanged) frameList.Clear();
            dst0.SetTo(0);
            var points = new List<cv.Point>();
            foreach (var rc in vbc.task.redCells)
            {
                dst0.Set<Byte>(rc.maxDist.Y, rc.maxDist.X, 1);
            }
            labels[2] = vbc.task.redCells.Count().ToString() + " cells added";
            frameList.Add(dst0.Clone());
            if (frameList.Count() >= vbc.task.frameHistoryCount)
            {
                dst1 = dst1.Subtract(frameList[0]);
                frameList.RemoveAt(0);
            }
            dst1 = dst1.Add(dst0);
            dst1.ConvertTo(dst2, MatType.CV_8U);
            dst2 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
            dst3 = redC.dst2;
        }
    }




    public class Match_DrawRect_CS : VB_Parent
    {
        Match_Basics match = new Match_Basics();
        public cv.Rect inputRect;
        public bool showOutput;
        Mat lastImage = new cv.Mat();
        public Match_DrawRect_CS()
        {
            inputRect = new cv.Rect(dst2.Width / 2 - 20, dst2.Height / 2 - 20, 40, 40); // arbitrary template to match
            dst3 = new Mat(dst3.Size(), MatType.CV_32F, cv.Scalar.All(0));
            if (standaloneTest()) labels[3] = "Probabilities (draw rectangle to test again)";
            labels[2] = "Red dot marks best match for the selected region.  Draw a rectangle anywhere to test again.";
            desc = "Find the requested template in vbc.task.drawrect in an image";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) lastImage = src.Clone();
            if (vbc.task.mouseClickFlag && vbc.task.drawRect.Width != 0)
            {
                inputRect = ValidateRect(vbc.task.drawRect);
                match.template = src[inputRect].Clone();
            }
            else
            {
                if (vbc.task.FirstPass) match.template = lastImage[inputRect].Clone();
            }
            match.Run(src);
            if (standaloneTest() || showOutput)
            {
                dst0 = match.dst0.Normalize(0, 255, NormTypes.MinMax);
                dst3.SetTo(0);
                dst0.CopyTo(dst3[new cv.Rect(inputRect.Width / 2, inputRect.Height / 2, dst0.Width, dst0.Height)]);
                dst3.Rectangle(inputRect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
                dst2 = src;
            }
            SetTrueText("maxLoc = " + match.matchCenter.X + ", " + match.matchCenter.Y, new cv.Point(1, 1), 3);
            if (standaloneTest())
            {
                DrawCircle(dst2, match.matchCenter, vbc.task.DotSize, Scalar.Red);
                SetTrueText(string.Format("{0:F3}", match.correlation), match.matchCenter, 2);
            }
            lastImage = src;
        }
    }




    public class Match_tCell_CS : VB_Parent
    {
        public List<tCell> tCells = new List<tCell>();
        TrackBar cellSlider;
        Options_Features options = new Options_Features();
        Line_DisplayInfo lineDisp = new Line_DisplayInfo();
        public Match_tCell_CS()
        {
            tCell tc = new tCell();
            tCells.Add(tc);
            cellSlider = FindSlider("MatchTemplate Cell Size");
            desc = "Use MatchTemplate to find the new location of the template and update the tc that was provided.";
        }
        public tCell createCell(Mat src, float correlation, Point2f pt)
        {
            var rSize = cellSlider.Value;
            tCell tc = new tCell();
            tc.rect = ValidateRect(new cv.Rect((int)(pt.X - rSize), (int)(pt.Y - rSize), rSize * 2, rSize * 2));
            tc.correlation = correlation;
            tc.depth = (float)vbc.task.pcSplit[2][tc.rect].Mean(vbc.task.depthMask[tc.rect])[0] / 1000;
            tc.center = pt;
            tc.searchRect = ValidateRect(new cv.Rect((int)(tc.center.X - rSize * 3), (int)(tc.center.Y - rSize * 3),
                                         rSize * 6, rSize * 6));
            if (tc.template == null) tc.template = src[tc.rect].Clone();
            return tc;
        }
        public void RunAlg(Mat src)
        {
            var rSize = cellSlider.Value;
            if (standaloneTest() && vbc.task.heartBeat)
            {
                options.RunOpt();
                tCells.Clear();
                tCells.Add(createCell(src, 0, new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height))));
                tCells.Add(createCell(src, 0, new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height))));
            }
            for (int i = 0; i < tCells.Count(); i++)
            {
                var tc = tCells[i];
                var input = src[tc.searchRect];
                Cv2.MatchTemplate(tc.template, input, dst0, TemplateMatchModes.CCoeffNormed);
                mmData mm = GetMinMax(dst0);
                tc.center = new Point2f(tc.searchRect.X + mm.maxLoc.X + rSize, tc.searchRect.Y + mm.maxLoc.Y + rSize);
                tc.searchRect = ValidateRect(new cv.Rect((int)(tc.center.X - rSize * 3), (int)(tc.center.Y - rSize * 3),
                                             rSize * 6, rSize * 6));
                tc.rect = ValidateRect(new cv.Rect((int)(tc.center.X - rSize), (int)(tc.center.Y - rSize), rSize * 2,
                                       rSize * 2));
                tc.correlation = (float)mm.maxVal;
                tc.depth = (float)vbc.task.pcSplit[2][tc.rect].Mean(vbc.task.depthMask[tc.rect])[0] / 1000;
                tc.strOut = string.Format("{0:F2}\n{1:F2}m", tc.correlation, tc.depth);
                tCells[i] = tc;
            }
            if (standaloneTest())
            {
                lineDisp.tcells = tCells;
                lineDisp.Run(src);
                dst2 = lineDisp.dst2;
            }
        }
    }




    public class Match_LinePairTest_CS : VB_Parent
    {
        public Point2f[] ptx = new Point2f[2];
        public Mat[] target = new Mat[2];
        public float[] correlation = new float[2];
        Options_Features options = new Options_Features();
        TrackBar cellSlider;
        TrackBar corrSlider;
        public Match_LinePairTest_CS()
        {
            cellSlider = FindSlider("MatchTemplate Cell Size");
            corrSlider = FindSlider("Feature Correlation Threshold");
            desc = "Use MatchTemplate to find the new location of the template and update the tc that was provided.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            float minCorrelation = corrSlider.Value / 100f;
            int rSize = cellSlider.Value;
            int radius = rSize / 2;
            cv.Rect rect;
            if (target[0] != null && correlation[0] < minCorrelation) target[0] = null;
            if (vbc.task.mouseClickFlag)
            {
                ptx[0] = vbc.task.ClickPoint;
                ptx[1] = new Point2f(msRNG.Next(rSize, dst2.Width - 2 * rSize), msRNG.Next(rSize, dst2.Height - 2 * rSize));
                rect = ValidateRect(new cv.Rect((int)(ptx[0].X - radius), (int)(ptx[0].Y - radius), rSize, rSize));
                target[0] = src[rect];
                rect = ValidateRect(new cv.Rect((int)(ptx[1].X - radius), (int)(ptx[1].Y - radius), rSize, rSize));
                target[1] = src[rect];
            }
            if (target[0] == null || target[1] == null)
            {
                dst3 = src;
                SetTrueText("Click anywhere in the image to start the algorithm.");
                return;
            }
            dst3 = src.Clone();
            dst2 = new Mat(dst2.Size(), MatType.CV_32FC1, cv.Scalar.All(0));
            for (int i = 0; i < ptx.Length; i++)
            {
                rect = ValidateRect(new cv.Rect((int)(ptx[i].X - radius), (int)(ptx[i].Y - radius), rSize, rSize));
                cv.Rect searchRect = ValidateRect(new cv.Rect(rect.X - rSize, rect.Y - rSize, rSize * 3, rSize * 3));
                Cv2.MatchTemplate(target[i], src[searchRect], dst0, TemplateMatchModes.CCoeffNormed);
                var mmData = GetMinMax(dst0);
                correlation[i] = (float)mmData.maxVal;
                if (i == 0)
                {
                    dst0.CopyTo(dst2[new cv.Rect(0, 0, dst0.Width, dst0.Height)]);
                    dst2 = dst2.Threshold(minCorrelation, 255, ThresholdTypes.Binary);
                }
                ptx[i] = new Point2f(mmData.maxLoc.X + searchRect.X + radius, mmData.maxLoc.Y + searchRect.Y + radius);
                DrawCircle(dst3, ptx[i], vbc.task.DotSize, vbc.task.HighlightColor);
                dst3.Rectangle(searchRect, Scalar.Yellow, 1);
                rect = ValidateRect(new cv.Rect((int)(ptx[i].X - radius), (int)(ptx[i].Y - radius), rSize, rSize));
                target[i] = vbc.task.color[rect];
            }
            labels[3] = "p1 = " + ptx[0].X + "," + ptx[0].Y + " p2 = " + ptx[1].X + "," + ptx[1].Y;
            labels[2] = "Correlation = " + correlation[0].ToString(vbc.fmt3) + " Search result is " + dst0.Width + "X" + dst0.Height;
        }
    }




    public class Match_GoodFeatureKNN_CS : VB_Parent
    {
        public KNN_NoDups knn = new KNN_NoDups();
        public Feature_Stable feat = new Feature_Stable();
        List<Mat> frameList = new List<Mat>();
        Options_Match options = new Options_Match();
        public Match_GoodFeatureKNN_CS()
        {
            dst0 = new Mat(dst2.Size(), MatType.CV_8UC1, cv.Scalar.All(0));
            dst1 = new Mat(dst2.Size(), MatType.CV_8UC1, cv.Scalar.All(0));
            labels[3] = "Shake camera to see tracking of the highlighted features";
            desc = "Track the GoodFeatures with KNN";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            feat.Run(src);
            knn.queries = new List<cv.Point2f>(vbc.task.features);
            knn.Run(empty);
            if (vbc.task.optionsChanged)
            {
                frameList.Clear();
                dst1.SetTo(0);
            }
            dst0.SetTo(0);
            foreach (var mp in knn.matches)
            {
                if (mp.p1.DistanceTo(mp.p2) <= options.maxDistance)
                    DrawLine(dst0, mp.p1, mp.p2, cv.Scalar.All(255), vbc.task.lineWidth + 2);
            }
            frameList.Add(dst0.Clone());
            if (frameList.Count() >= vbc.task.frameHistoryCount)
            {
                dst1 = dst1.Subtract(frameList[0]);
                frameList.RemoveAt(0);
            }
            dst1 += dst0;
            dst2 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst3 = src;
            dst3.SetTo(vbc.task.HighlightColor, dst2);
        }
    }




    public class Match_Point_CS : VB_Parent
    {
        public Point2f pt;
        public Mat target;
        public float correlation;
        public int radius;
        public cv.Rect searchRect;
        Options_Features options = new Options_Features();
        TrackBar cellSlider;
        public Match_Point_CS()
        {
            cellSlider = FindSlider("MatchTemplate Cell Size");
            labels[2] = "Rectangle shown is the search rectangle.";
            desc = "Track the selected point";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("Set the target mat and the pt then run to track an individual point." +
                            "\nAfter running, the pt is updated with the new location and correlation with the updated correlation." +
                            "\nThere is no output when run standaloneTest()");
                return;
            }
            int rSize = cellSlider.Value;
            int radius = rSize / 2;
            cv.Rect rect = ValidateRect(new cv.Rect((int)(pt.X - radius), (int)(pt.Y - radius), rSize, rSize));
            searchRect = ValidateRect(new cv.Rect(rect.X - rSize, rect.Y - rSize, rSize * 3, rSize * 3));
            Cv2.MatchTemplate(target[rect], src[searchRect], dst0, TemplateMatchModes.CCoeffNormed);
            var mmData = GetMinMax(dst0);
            correlation = (float)mmData.maxVal;
            pt = new Point2f(mmData.maxLoc.X + searchRect.X + radius, mmData.maxLoc.Y + searchRect.Y + radius);
            DrawCircle(src, pt, vbc.task.DotSize, Scalar.White);
            src.Rectangle(searchRect, Scalar.Yellow, 1);
        }
    }




    public class Match_Points_CS : VB_Parent
    {
        public List<cv.Point2f> ptx = new List<cv.Point2f>();
        public List<float> correlation = new List<float>();
        public Match_Point mPoint = new Match_Point();
        Feature_Stable feat = new Feature_Stable();
        public Match_Points_CS()
        {
            labels[2] = "Rectangle shown is the search rectangle.";
            desc = "Track the selected points";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) mPoint.target = src.Clone();
            if (standaloneTest())
            {
                feat.Run(src);
                ptx = new List<cv.Point2f>(vbc.task.features);
                SetTrueText("Move camera around to watch the point being tracked", 3);
            }
            dst2 = src.Clone();
            correlation.Clear();
            for (int i = 0; i < ptx.Count(); i++)
            {
                mPoint.pt = ptx[i];
                mPoint.Run(src);
                correlation.Add(mPoint.correlation);
                ptx[i] = mPoint.pt;
                DrawPolkaDot(ptx[i], dst2);
            }
            mPoint.target = src.Clone();
        }
    }




    public class Match_Motion_CS : VB_Parent
    {
        Options_Features options = new Options_Features();
        public Mat mask;
        Options_Match optionsMatch = new Options_Match();
        TrackBar correlationSlider;
        Mat lastFrame = new cv.Mat();
        public Match_Motion_CS()
        {
            correlationSlider = FindSlider("Feature Correlation Threshold");
            mask = new Mat(dst2.Size(), MatType.CV_8U);
            dst3 = mask.Clone();
            desc = "Assign each segment a correlation coefficient and stdev to the previous frame";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsMatch.RunOpt();
            float CCthreshold = (float)correlationSlider.Value / correlationSlider.Maximum;
            dst2 = src.Clone();
            if (dst2.Channels() == 3) dst2 = dst2.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) lastFrame = dst2.Clone();
            Mat saveFrame = dst2.Clone();
            int updateCount = 0;
            mask.SetTo(0);
            // Parallel.ForEach(vbc.task.gridRects,
            // roi =>
            foreach (var roi in vbc.task.gridRects)
            {
                Mat correlation = new Mat();
                cv.Scalar mean, stdev;
                Cv2.MeanStdDev(dst2[roi], out mean, out stdev);
                if (stdev[0] > optionsMatch.stdevThreshold)
                {
                    Cv2.MatchTemplate(dst2[roi], lastFrame[roi], correlation, options.matchOption);
                    cv.Point pt = new cv.Point(roi.X + 2, roi.Y + 10);
                    if (correlation.Get<float>(0, 0) < CCthreshold)
                    {
                        Interlocked.Increment(ref updateCount);
                    }
                    else
                    {
                        mask[roi].SetTo(255);
                        dst2[roi].SetTo(0);
                    }
                    SetTrueText(correlation.Get<float>(0, 0).ToString(vbc.fmt2), pt, 2);
                }
                else
                {
                    Interlocked.Increment(ref updateCount);
                }
            }
            // End Sub)
            dst2.SetTo(255, vbc.task.gridMask);
            dst3.SetTo(0);
            saveFrame.CopyTo(dst3, mask);
            lastFrame = saveFrame;
            string corrPercent = string.Format("{0:0.0%} correlation", (float)correlationSlider.Value / 100);
            labels[2] = "Correlation value for each cell is shown. " + updateCount + " of " + vbc.task.gridRects.Count() + " with < " + corrPercent +
                        " or stdev < " + optionsMatch.stdevThreshold.ToString(vbc.fmt0);
            labels[3] = (vbc.task.gridRects.Count() - updateCount) + " segments out of " + vbc.task.gridRects.Count() + " had > " + corrPercent;
        }
    }




    public class MatchLine_Basics_CS : VB_Parent
    {
        public Match_Basics match = new Match_Basics();
        public PointPair lpInput = new PointPair();
        public PointPair lpOutput;
        public int corner1, corner2;
        PointPair lpSave = new PointPair();
        KNN_ClosestTracker knn = new KNN_ClosestTracker();
        public MatchLine_Basics_CS()
        {
            desc = "Find and track a line in the BGR image.";
        }
        Point2f cornerToPoint(int whichCorner, cv.Rect r)
        {
            switch (whichCorner)
            {
                case 0:
                    return r.TopLeft;
                case 1:
                    return new Point2f(r.BottomRight.X, r.TopLeft.Y);
                case 2:
                    return r.BottomRight;
            }
            return new Point2f(r.TopLeft.X, r.BottomRight.Y);
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            var correlationMin = match.options.correlationMin;
            if (vbc.task.quarterBeat || match.correlation < correlationMin || lpSave.p1 != lpInput.p1 || lpSave.p2 != lpInput.p2)
            {
                lpSave = lpInput;
                if (standalone)
                {
                    knn.Run(src.Clone());
                    lpInput = new PointPair(knn.lastPair.p1, knn.lastPair.p2);
                }
                var r = ValidateRect(new cv.Rect(
                    (int)Math.Min(lpInput.p1.X, lpInput.p2.X),
                    (int)Math.Min(lpInput.p1.Y, lpInput.p2.Y),
                    (int)Math.Abs(lpInput.p1.X - lpInput.p2.X),
                    (int)Math.Abs(lpInput.p1.Y - lpInput.p2.Y)));
                match.template = src[r].Clone();
                var p1 = new cv.Point((int)lpInput.p1.X, (int)lpInput.p1.Y);
                // Determine which corner - numbering topleft = 0 clockwise, 1, 2, 3
                if (r.TopLeft.DistanceTo(p1) <= 2)
                {
                    corner1 = 0;
                    corner2 = 2;
                }
                else if (r.BottomRight.DistanceTo(p1) <= 2)
                {
                    corner1 = 2;
                    corner2 = 0;
                }
                else if (r.Y == p1.Y)
                {
                    corner1 = 1;
                    corner2 = 3;
                }
                else
                {
                    corner1 = 3;
                    corner2 = 1;
                }
            }
            match.Run(src);
            correlationMin = match.options.correlationMin;
            if (match.correlation >= correlationMin)
            {
                if (standaloneTest()) dst3 = match.dst0.Resize(dst3.Size());
                var p1 = cornerToPoint(corner1, match.matchRect);
                var p2 = cornerToPoint(corner2, match.matchRect);
                DrawLine(dst2, p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth + 2);
                lpOutput = new PointPair(p1, p2);
            }
            labels[2] = "Longest line end points had correlation of " + match.correlation.ToString(vbc.fmt3) + " with the original longest line.";
        }
    }




    public class MatchLine_Longest_CS : VB_Parent
    {
        public KNN_ClosestTracker knn = new KNN_ClosestTracker();
        public MatchLine_Basics matchLine = new MatchLine_Basics();
        public MatchLine_Longest_CS()
        {
            desc = "Find and track the longest line in the BGR image with a lightweight KNN.";
        }
        public void RunAlg(Mat src)
        {
            knn.Run(src.Clone());
            matchLine.lpInput = new PointPair(knn.lastPair.p1, knn.lastPair.p2);
            matchLine.Run(src);
            dst2 = matchLine.dst2;
            DrawLine(dst2, matchLine.lpOutput.p1, matchLine.lpOutput.p2, Scalar.Red);
            labels[2] = "Longest line end points had correlation of " + matchLine.match.correlation.ToString(vbc.fmt3) +
                        " with the original longest line.";
        }
    }




    public class MatchLine_Horizon_CS : VB_Parent
    {
        MatchLine_Basics matchLine = new MatchLine_Basics();
        public MatchLine_Horizon_CS()
        {
            desc = "Verify the horizon using MatchTemplate.";
        }
        public void RunAlg(Mat src)
        {
            //if (matchLine.match.correlation < matchLine.match.options.correlationThreshold) matchLine.lpInput = vbc.task.horizonVec;
            if (vbc.task.quarterBeat) matchLine.lpInput = vbc.task.horizonVec;
            matchLine.Run(src);
            dst2 = matchLine.dst2;
            DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, Scalar.Red);
            labels[2] = "MatchLine correlation = " + matchLine.match.correlation.ToString(vbc.fmt3) + " - Red = current horizon, yellow is matchLine output";
        }
    }




    public class MatchLine_Gravity_CS : VB_Parent
    {
        MatchLine_Basics matchLine = new MatchLine_Basics();
        public MatchLine_Gravity_CS()
        {
            desc = "Verify the gravity vector using MatchTemplate.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.quarterBeat) matchLine.lpInput = vbc.task.gravityVec;
            matchLine.Run(src);
            dst2 = matchLine.dst2;
            DrawLine(dst2, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, Scalar.Red);
            labels[2] = "MatchLine correlation = " + matchLine.match.correlation.ToString(vbc.fmt3) +
                        " - Red = current gravity vector, yellow is matchLine output";
        }
    }




    public class MatchRect_Basics_CS : VB_Parent
    {
        public Match_Basics match = new Match_Basics();
        public cv.Rect rectInput = new cv.Rect();
        public cv.Rect rectOutput = new cv.Rect();
        cv.Rect rectSave = new cv.Rect();
        RedCloud_Basics redC = new RedCloud_Basics();
        public MatchRect_Basics_CS()
        {
            desc = "Track a RedCloud rectangle using MatchTemplate.  Click on a cell.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) match.correlation = 0;
            if (match.correlation < match.options.correlationMin || rectSave != rectInput || vbc.task.mouseClickFlag)
            {
                if (standalone)
                {
                    redC.Run(src);
                    dst2 = redC.dst2;
                    labels[2] = redC.labels[2];
                    rectInput = vbc.task.rc.rect;
                }
                rectSave = rectInput;
                match.template = src[rectInput].Clone();
            }
            match.Run(src);
            rectOutput = match.matchRect;
            if (standalone)
            {
                if (vbc.task.heartBeat) dst3.SetTo(0);
                dst3.Rectangle(rectOutput, vbc.task.HighlightColor, vbc.task.lineWidth, vbc.task.lineType);
            }
        }
    }




    public class MatchRect_RedCloud_CS : VB_Parent
    {
        MatchRect_Basics matchRect = new MatchRect_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public MatchRect_RedCloud_CS()
        {
            desc = "Track a RedCloud cell using MatchTemplate.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            vbc.task.ClickPoint = vbc.task.rc.maxDist;
            if (vbc.task.heartBeat) matchRect.rectInput = vbc.task.rc.rect;
            matchRect.Run(src);
            if (standalone)
            {
                if (vbc.task.heartBeat) dst3.SetTo(0);
                dst3.Rectangle(matchRect.rectOutput, vbc.task.HighlightColor, vbc.task.lineWidth, vbc.task.lineType);
            }
            labels[2] = "MatchLine correlation = " + string.Format(vbc.fmt3, matchRect.match.correlation) +
                        " - Red = current gravity vector, yellow is matchLine output";
        }
    }




    public class MatchShapes_Basics_CS : VB_Parent
    {
        public cv.Point[][] hull1;
        public cv.Point[][] hull2;
        Options_MatchShapes match = new Options_MatchShapes();
        Options_Contours options = new Options_Contours();
        public MatchShapes_Basics_CS()
        {
            FindRadio("CComp").Checked = true;
            FindRadio("FloodFill").Enabled = false;
            FindRadio("ApproxNone").Checked = true;
            dst0 = Cv2.ImRead(vbc.task.HomeDir + "Data/star1.png", ImreadModes.Color).CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            dst1 = Cv2.ImRead(vbc.task.HomeDir + "Data/star2.png", ImreadModes.Color).CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            desc = "MatchShapes compares single hull to single hull - pretty tricky";
        }
        public int findBiggestHull(cv.Point[][] hull, int maxLen, int maxIndex, Mat dst)
        {
            for (int i = 0; i < hull.Length; i++)
            {
                if (hull[i].Length > maxLen)
                {
                    maxLen = hull[i].Length;
                    maxIndex = i;
                }
            }
            foreach (var p in hull[maxIndex])
            {
                DrawCircle(dst, p, vbc.task.DotSize, Scalar.Yellow);
            }
            return maxIndex;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            match.RunOpt();
            if (standaloneTest())
            {
                if (dst0.Channels() != 1)
                    dst2 = dst0.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                else
                    dst2 = dst0;
                if (dst1.Channels() != 1)
                    dst3 = dst1.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                else
                    dst3 = dst1;
            }
            dst0 = dst0.Threshold(50, 255, ThresholdTypes.Binary);
            hull1 = Cv2.FindContoursAsArray(dst0, options.retrievalMode, options.ApproximationMode);
            dst1 = dst1.Threshold(127, 255, ThresholdTypes.Binary);
            hull2 = Cv2.FindContoursAsArray(dst1, options.retrievalMode, options.ApproximationMode);
            int maxLen1 = 0, maxIndex1 = 0, maxLen2 = 0, maxIndex2 = 0;
            maxIndex1 = findBiggestHull(hull1, maxLen1, maxIndex1, dst2);
            maxIndex2 = findBiggestHull(hull2, maxLen2, maxIndex2, dst3);
            var matchVal = Cv2.MatchShapes(hull1[maxIndex1], hull2[maxIndex2], match.matchOption);
            labels[2] = "MatchShapes returned " + matchVal.ToString(vbc.fmt2);
        }
    }




    public class MatchShapes_NearbyHull_CS : VB_Parent
    {
        public List<rcData> similarCells = new List<rcData>();
        public int bestCell;
        rcData rc = new rcData();
        Options_MatchShapes options = new Options_MatchShapes();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public MatchShapes_NearbyHull_CS()
        {
            labels = new string[] { "", "", "Output of RedCloud_Hulls", "Cells similar to selected cell" };
            desc = "MatchShapes: Find all the reasonable matches (< 1.0 for matchVal)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest())
            {
                hulls.Run(vbc.task.color);
                if (vbc.task.redCells.Count() == 0) return;
                dst2 = hulls.dst2;
                rc = vbc.task.rc;
            }
            dst3.SetTo(0);
            similarCells.Clear();
            float minMatch = float.MaxValue;
            foreach (var rc2 in vbc.task.redCells)
            {
                if (rc2.hull == null || rc.hull == null) continue;
                if (Math.Abs(rc2.maxDist.Y - rc.maxDist.Y) > options.maxYdelta) continue;
                var matchVal = Cv2.MatchShapes(rc.hull, rc2.hull, options.matchOption);
                if (matchVal < options.matchThreshold)
                {
                    if (matchVal < minMatch && matchVal > 0)
                    {
                        minMatch = (float)matchVal;
                        bestCell = similarCells.Count();
                    }
                    DrawContour(dst3[rc2.rect], rc2.hull, Scalar.White, -1);
                    similarCells.Add(rc2);
                }
            }
            if (similarCells.Count() == 0)
                SetTrueText("No matches with match value < " + options.matchThreshold.ToString(vbc.fmt2), new cv.Point(5, 5), 3);
        }
    }




    public class MatchShapes_Nearby_CS : VB_Parent
    {
        public List<rcData> redCells = new List<rcData>();
        public List<rcData> similarCells = new List<rcData>();
        public int bestCell;
        public rcData rc = new rcData();
        Options_MatchShapes options = new Options_MatchShapes();
        public bool runStandalone = false;
        RedCloud_Basics redC = new RedCloud_Basics();
        RedCloud_ContourUpdate addTour = new RedCloud_ContourUpdate();
        public MatchShapes_Nearby_CS()
        {
            labels = new string[] { "Left floodfill image", "Right floodfill image", "Left image of identified cells", "Right image with identified cells" };
            desc = "MatchShapes: Find matches at similar latitude (controlled with slider)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            bool myStandalone = standaloneTest() || runStandalone;
            if (myStandalone)
            {
                redC.Run(vbc.task.color);
                if (vbc.task.redCells.Count() == 0) return;
                dst2 = redC.dst2;
                addTour.redCells = new List<rcData>(vbc.task.redCells);
                addTour.Run(src);
                rc = vbc.task.rc;
            }
            if (vbc.task.heartBeat && myStandalone) dst3.SetTo(0);
            similarCells.Clear();
            if (vbc.task.gOptions.getDisplay0())
            {
                dst0 = vbc.task.color.Clone();
                DrawContour(dst0[rc.rect], rc.contour, vbc.task.HighlightColor);
            }
            float minMatch = float.MaxValue;
            bestCell = -1;
            for (int i = 0; i < addTour.redCells.Count(); i++)
            {
                var rc2 = addTour.redCells[i];
                if (rc2.contour == null) continue;
                var matchVal = Cv2.MatchShapes(rc.contour, rc2.contour, options.matchOption);
                if (matchVal < options.matchThreshold)
                {
                    if (matchVal < minMatch && matchVal > 0)
                    {
                        minMatch = (float)matchVal;
                        bestCell = similarCells.Count();
                    }
                    DrawContour(dst3[rc2.rect], rc2.contour, vecToScalar(rc2.color), -1);
                    similarCells.Add(rc2);
                }
            }
            if (bestCell >= 0)
            {
                var rc = similarCells[bestCell];
                DrawCircle(dst3, rc.maxDist, vbc.task.DotSize, Scalar.White);
                SetTrueText("Best match", rc.maxDist, 3);
            }
            if (similarCells.Count() == 0)
                SetTrueText("No matches with match value < " + options.matchThreshold.ToString(vbc.fmt2), new cv.Point(5, 5), 3);
        }
    }





    public class MatchShapes_Hulls_CS : VB_Parent
    {
        Options_MatchShapes options = new Options_MatchShapes();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public MatchShapes_Hulls_CS()
        {
            FindSlider("Match Threshold %").Value = 3;
            labels = new string[] { "", "", "Output of RedCloud_Hulls", "All RedCloud cells that matched the selected cell with the current settings are below." };
            desc = "Find all RedCloud hull shapes similar to the one selected.  Use sliders and radio buttons to see impact.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            hulls.Run(src);
            dst2 = hulls.dst2;
            if (vbc.task.heartBeat) dst3.SetTo(0);
            var rcX = vbc.task.rc;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.hull == null || rcX.hull == null) continue;
                var matchVal = Cv2.MatchShapes(rcX.hull, rc.hull, options.matchOption);
                if (matchVal < options.matchThreshold) DrawContour(dst3[rc.rect], rc.hull, Scalar.White, -1);
            }
        }
    }




    public class MatchShapes_Contours_CS : VB_Parent
    {
        Options_MatchShapes options = new Options_MatchShapes();
        RedCloud_Basics redC = new RedCloud_Basics();
        public MatchShapes_Contours_CS()
        {
            FindSlider("Match Threshold %").Value = 3;
            labels = new string[] { "", "", "Output of RedCloud_Basics", "All RedCloud cells that matched the selected cell with the current settings are below." };
            desc = "Find all RedCloud contours similar to the one selected.  Use sliders and radio buttons to see impact.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            redC.Run(src);
            dst2 = redC.dst2;
            if (vbc.task.heartBeat) dst3.SetTo(0);
            var rcX = vbc.task.rc;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.contour == null) continue;
                var matchVal = Cv2.MatchShapes(rcX.contour, rc.contour, options.matchOption);
                if (matchVal < options.matchThreshold) DrawContour(dst3[rc.rect], rc.contour, Scalar.White, -1);
            }
        }
    }




    public class Math_Subtract_CS : VB_Parent
    {
        Options_Colors options = new Options_Colors();
        public Math_Subtract_CS()
        {
            desc = "Subtract a Mat using a scalar.  Set scalar to zero to see pixels saturate to zero.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var bgr = new Scalar(options.blueS, options.greenS, options.redS);
            Cv2.Subtract(bgr, src, dst2); // or dst2 = bgr - src
            dst3 = src - bgr;
            var scalar = $"({bgr[0]},{bgr[1]},{bgr[2]})";
            labels[2] = "Subtract Mat from scalar " + scalar;
            labels[3] = "Subtract scalar " + scalar + " from Mat ";
        }
    }
    public static class Math_Functions
    {
        public static double computeMedian(Mat src, Mat mask, int totalPixels, int bins, float rangeMin, float rangeMax)
        {
            var hist = new Mat();
            Cv2.CalcHist(new[] { src }, new[] { 0 }, mask, hist, 1, new[] { bins }, new[] { new Rangef(rangeMin, rangeMax) });
            var halfPixels = totalPixels / 2;
            double median = 0;
            double cdfVal = hist.Get<float>(0);
            for (int i = 1; i < bins - 1; i++)
            {
                cdfVal += hist.Get<float>(i);
                if (cdfVal >= halfPixels)
                {
                    median = (rangeMax - rangeMin) * i / bins;
                    break;
                }
            }
            return median;
        }
    }




    public class Math_Median_CDF_CS : VB_Parent
    {
        public double medianVal;
        public int rangeMin = 0;
        public int rangeMax = 255;
        public Math_Median_CDF_CS()
        {
            desc = "Compute the src image median";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            medianVal = Math_Functions.computeMedian(src, new Mat(), (int)src.Total(), vbc.task.histogramBins, rangeMin, rangeMax);
            if (standaloneTest())
            {
                var mask = new Mat();
                mask = src.GreaterThan(medianVal);
                dst2.SetTo(0);
                src.CopyTo(dst2, mask);
                labels[2] = "Grayscale pixels > " + medianVal.ToString(vbc.fmt1);
                dst3.SetTo(0);
                src.CopyTo(dst3, ~mask); // show the other half.
                labels[3] = "Grayscale pixels < " + medianVal.ToString(vbc.fmt1);
            }
        }
    }




    public class Math_DepthMeanStdev_CS : VB_Parent
    {
        Depth_NotMissing minMax = new Depth_NotMissing();
        public Math_DepthMeanStdev_CS()
        {
            desc = "This algorithm shows that just using the max depth at each pixel does not improve quality of measurement";
        }
        public void RunAlg(Mat src)
        {
            minMax.Run(src);
            cv.Scalar mean = cv.Scalar.All(0), stdev = cv.Scalar.All(0);
            var mask = minMax.dst3; // the mask for stable depth.
            dst3.SetTo(0);
            vbc.task.depthRGB.CopyTo(dst3, mask);
            if (mask.Type() != MatType.CV_8U) mask = mask.CvtColor(ColorConversionCodes.BGR2GRAY);
            Cv2.MeanStdDev(vbc.task.pcSplit[2], out mean, out stdev, mask);
            labels[3] = "stablized depth mean=" + mean[0].ToString(vbc.fmt1) + " stdev=" + stdev[0].ToString(vbc.fmt1);
            dst2 = vbc.task.depthRGB;
            Cv2.MeanStdDev(vbc.task.pcSplit[2], out mean, out stdev);
            labels[2] = "raw depth mean=" + mean[0].ToString(vbc.fmt1) + " stdev=" + stdev[0].ToString(vbc.fmt1);
        }
    }




    public class Math_RGBCorrelation_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        Match_Basics match = new Match_Basics();
        public Math_RGBCorrelation_CS()
        {
            flow.parentData = this;
            desc = "Compute the correlation coefficient of Red-Green and Red-Blue and Green-Blue";
        }
        public void RunAlg(Mat src)
        {
            var split = src.Split();
            match.template = split[0];
            match.Run(split[1]);
            var blueGreenCorrelation = "Blue-Green " + match.labels[2];
            match.template = split[2];
            match.Run(split[1]);
            var redGreenCorrelation = "Red-Green " + match.labels[2];
            match.template = split[2];
            match.Run(split[0]);
            var redBlueCorrelation = "Red-Blue " + match.labels[2];
            flow.nextMsg = blueGreenCorrelation + " " + redGreenCorrelation + " " + redBlueCorrelation;
            flow.Run(empty);
            labels[2] = "Log of " + match.options.matchText;
        }
    }




    public class Math_StdevBoundary_CS : VB_Parent
    {
        Math_Stdev stdev = new Math_Stdev();
        TrackBar stdevSlider;
        public Math_StdevBoundary_CS()
        {
            stdevSlider = FindSlider("Stdev Threshold");
            labels[2] = "Low stdev regions.  Gaps filled with OTSU results";
            labels[3] = "High stdev segments after the first pass";
            desc = "Explore how to get a better boundary on the low stdev mask";
        }
        public void RunAlg(Mat src)
        {
            stdev.Run(src);
            dst2 = stdev.dst2;
            stdev.saveFrame.CopyTo(dst3);
            float stdevThreshold = (float)stdevSlider.Value;
            foreach (var roi in vbc.task.gridRects)
            {
                if (roi.X + roi.Width < dst3.Width)
                {
                    var m1 = dst2.Get<byte>(roi.Y, roi.X);
                    var m2 = dst2.Get<byte>(roi.Y, roi.X + roi.Width);
                    if (m1 == 0 && m2 != 0)
                    {
                        var meanScalar = Cv2.Mean(dst3[roi]);
                        dst3[roi].CopyTo(dst2[roi], dst3[roi].Threshold(meanScalar[0], 255, ThresholdTypes.Otsu));
                    }
                    if (m1 > 0 && m2 == 0)
                    {
                        var newROI = new cv.Rect(roi.X + roi.Width, roi.Y, roi.Width, roi.Height);
                        if (newROI.X + newROI.Width >= dst2.Width) newROI.Width = dst2.Width - newROI.X - 1;
                        if (newROI.Y + newROI.Height >= dst2.Height) newROI.Height = dst2.Height - newROI.Y - 1;
                        var meanScalar = Cv2.Mean(dst3[newROI]);
                        dst3[newROI].CopyTo(dst2[newROI], dst3[newROI].Threshold(meanScalar[0], 255, ThresholdTypes.Otsu));
                    }
                }
                if (roi.Y + roi.Height < dst3.Height)
                {
                    var m1 = dst2.Get<byte>(roi.Y, roi.X);
                    var m2 = dst2.Get<byte>(roi.Y + roi.Height, roi.X);
                    if (m1 == 0 && m2 != 0)
                    {
                        var meanScalar = Cv2.Mean(dst3[roi]);
                        dst3[roi].CopyTo(dst2[roi], dst3[roi].Threshold(meanScalar[0], 255, ThresholdTypes.Otsu));
                    }
                    if (m1 > 0 && m2 == 0)
                    {
                        var newROI = new cv.Rect(roi.X, roi.Y + roi.Height, roi.Width, roi.Height);
                        if (newROI.Y + newROI.Height >= dst3.Height) newROI.Height = dst3.Height - newROI.Y;
                        var meanScalar = Cv2.Mean(dst3[newROI]);
                        dst3[newROI].CopyTo(dst2[newROI], dst3[newROI].Threshold(meanScalar[0], 255, ThresholdTypes.Otsu));
                    }
                }
            }
            dst3.SetTo(0, stdev.lowStdevMask);
        }
    }




    public class Math_Template_CS : VB_Parent
    {
        public Math_Template_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_32F, cv.Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_32F, cv.Scalar.All(0));
            labels = new[] { "", "", "Input Template showing columns", "Input Template showing rows" };
            desc = "Build a template for use with computing the point cloud";
        }
        public void RunAlg(Mat src)
        {
            for (int i = 0; i < dst2.Width; i++)
            {
                dst2.Set<float>(0, i, i);
            }
            for (int i = 1; i < dst2.Height; i++)
            {
                dst2.Row(0).CopyTo(dst2.Row(i));
            }
            for (int i = 0; i < dst2.Height; i++)
            {
                dst3.Set<float>(i, 0, i);
            }
            for (int i = 1; i < dst2.Width; i++)
            {
                dst3.Col(0).CopyTo(dst3.Col(i));
            }
            dst2 -= cv.Scalar.All(vbc.task.calibData.ppx);
            dst3 -= cv.Scalar.All(vbc.task.calibData.ppy);
        }
    }




    public class Math_ImageAverage_CS : VB_Parent
    {
        List<Mat> images = new List<Mat>();
        public Math_ImageAverage_CS()
        {
            desc = "Create an image that is the mean of x number of previous images.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) images.Clear();
            dst3 = src.Clone();
            if (dst3.Type() != MatType.CV_32F)
            {
                if (dst3.Channels() != 1) dst3.ConvertTo(dst3, MatType.CV_32FC3);
                else dst3.ConvertTo(dst3, MatType.CV_32F);
            }
            Cv2.Multiply(dst3, cv.Scalar.All(1.0 / (images.Count() + 1)), dst3);
            images.Add(dst3.Clone());
            if (images.Count() > vbc.task.frameHistoryCount) images.RemoveAt(0);
            dst3.SetTo(0);
            foreach (Mat img in images)
            {
                dst3 += img;
            }
            if (dst3.Type() != src.Type()) dst3.ConvertTo(dst2, src.Type()); else dst2 = dst3.Clone();
            dst3 = Convert32f_To_8UC3(dst3);
            labels[2] = "Average image over previous " + vbc.task.frameHistoryCount.ToString() + " images";
        }
    }




    public class Math_ImageMaskedAverage_CS : VB_Parent
    {
        List<Mat> images = new List<Mat>();
        public Math_ImageMaskedAverage_CS()
        {
            desc = "Mask off pixels where the difference is great and create an image that is the mean of x number of previous images.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) images.Clear();
            Mat nextImage = new Mat();
            if (src.Type() != MatType.CV_32F) src.ConvertTo(nextImage, MatType.CV_32F); else nextImage = src;
            Cv2.Multiply(nextImage, cv.Scalar.All(1.0 / vbc.task.frameHistoryCount), nextImage);
            images.Add(nextImage.Clone());
            if (images.Count() > vbc.task.frameHistoryCount) images.RemoveAt(0);
            nextImage.SetTo(0);
            foreach (var img in images)
            {
                nextImage += img;
            }
            if (nextImage.Type() != src.Type()) nextImage.ConvertTo(dst2, src.Type());
            else dst2 = nextImage;
            labels[2] = "Average image over previous " + vbc.task.frameHistoryCount.ToString() + " images";
        }
    }




    public class Math_ParallelTest_CS : VB_Parent
    {
        public Point3f v1 = new Point3f(1, 0, 0);
        public Point3f v2 = new Point3f(5, 0, 0);
        public bool showWork = true;
        public Math_ParallelTest_CS()
        {
            labels = new string[] { "", "", "Parallel Test Output", "" };
            desc = "Test if 2 vectors are parallel";
        }
        public void RunAlg(Mat src)
        {
            v1 *= 1 / Math.Sqrt(v1.X * v1.X + v1.Y * v1.Y + v1.Z * v1.Z); // normalize the input
            v2 *= 1 / Math.Sqrt(v2.X * v2.X + v2.Y * v2.Y + v2.Z * v2.Z);
            float n1 = dotProduct3D(v1, v2);
            if (showWork)
            {
                strOut = "Input: " + "\n";
                strOut += "normalized v1" + " = " + v1.X.ToString(vbc.fmt3) + ", " + v1.Y.ToString(vbc.fmt3) + ", " + v1.Z.ToString(vbc.fmt3) + "\n";
                strOut += "normalized v2" + " = " + v2.X.ToString(vbc.fmt3) + ", " + v2.Y.ToString(vbc.fmt3) + ", " + v2.Z.ToString(vbc.fmt3) + "\n";
                strOut += "Dot Product = " + n1.ToString(vbc.fmt3) + " - if close to 1, the vectors are parallel" + "\n";
                SetTrueText(strOut, 2);
            }
        }
    }




    public class Math_Stdev_CS : VB_Parent
    {
        public Mat highStdevMask;
        public Mat lowStdevMask;
        public Mat saveFrame;
        Options_Math options = new Options_Math();
        Options_Match optionsMatch = new Options_Match();
        TrackBar stdevSlider = new TrackBar();
        Mat lastFrame = new cv.Mat();
        public Math_Stdev_CS()
        {
            stdevSlider = FindSlider("Stdev Threshold");
            vbc.task.gOptions.setGridSize(16);
            highStdevMask = new Mat(dst2.Size(), MatType.CV_8U);
            lowStdevMask = new Mat(dst2.Size(), MatType.CV_8U);
            desc = "Compute the standard deviation in each segment";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int updateCount = 0;
            lowStdevMask.SetTo(0);
            highStdevMask.SetTo(0);
            dst2 = src.Clone();
            if (dst2.Channels() == 3) dst2 = dst2.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) lastFrame = dst2.Clone();
            saveFrame = dst2.Clone();
            Parallel.ForEach(vbc.task.gridRects,
            (roi) =>
            {
                cv.Scalar mean, stdev;
                Cv2.MeanStdDev(dst2[roi], out mean, out stdev);
                if (stdev[0] < optionsMatch.stdevThreshold)
                {
                    Interlocked.Increment(ref updateCount);
                    var pt = new cv.Point(roi.X + 2, roi.Y + 10);
                    if (options.showMean) SetTrueText(mean[0].ToString(vbc.fmt0), pt, 2);
                    if (options.showStdev) SetTrueText(stdev[0].ToString(vbc.fmt2), pt, 2);
                    lowStdevMask[roi].SetTo(255);
                }
                else
                {
                    highStdevMask[roi].SetTo(255);
                    dst2[roi].SetTo(0);
                }
            });
            if (vbc.task.gOptions.getShowGrid()) dst2.SetTo(255, vbc.task.gridMask);
            dst3.SetTo(0);
            saveFrame.CopyTo(dst3, highStdevMask);
            lastFrame = saveFrame;
            string stdevPercent = " stdev " + stdevSlider.Value.ToString("0.0");
            labels[2] = updateCount.ToString() + " of " + vbc.task.gridRects.Count().ToString() + " segments with < " + stdevPercent;
            labels[3] = (vbc.task.gridRects.Count() - updateCount).ToString() + " out of " + vbc.task.gridRects.Count().ToString() + " had stdev > " + stdevSlider.Value.ToString("0.0");
        }
    }




    public class MeanShift_Basics_CS : VB_Parent
    {
        public int rectangleEdgeWidth = 2;
        public cv.Rect trackbox = new cv.Rect();
        Mat histogram = new Mat();
        public MeanShift_Basics_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            labels[2] = "Draw anywhere to start mean shift tracking.";
            desc = "Demonstrate the use of mean shift algorithm.  Draw on the images to define an object to track.";
        }
        public void RunAlg(Mat src)
        {
            var roi = vbc.task.drawRect.Width > 0 ? vbc.task.drawRect : new cv.Rect(0, 0, dst2.Width, dst2.Height);
            var hsv = src.CvtColor(cv.ColorConversionCodes.BGR2HSV);
            int[] ch = { 0, 1, 2 };
            int[] hsize = { 16, 16, 16 };
            Rangef[] ranges = { new Rangef(0, 180) };
            if (vbc.task.optionsChanged)
            {
                trackbox = vbc.task.drawRect;
                var maskROI = hsv[roi].InRange(new Scalar(0, 60, 32), new Scalar(180, 255, 255));
                Cv2.CalcHist(new Mat[] { hsv[roi] }, ch, maskROI, histogram, 1, hsize, ranges);
                histogram = histogram.Normalize(0, 255, NormTypes.MinMax);
            }
            Cv2.CalcBackProject(new Mat[] { hsv }, ch, histogram, dst1, ranges);
            dst2 = src;
            if (trackbox.Width != 0)
            {
                Cv2.MeanShift(dst1, ref trackbox, new TermCriteria(CriteriaTypes.Count | CriteriaTypes.Eps, 10, 1));
                dst2.Rectangle(trackbox, Scalar.Red, rectangleEdgeWidth, vbc.task.lineType);
                dst3 = Show_HSV_Hist(histogram);
                dst3 = dst3.CvtColor(cv.ColorConversionCodes.HSV2BGR);
            }
        }
    }




    public class MeanShift_Depth_CS : VB_Parent
    {
        MeanShift_Basics meanShift = new MeanShift_Basics();
        public MeanShift_Depth_CS()
        {
            labels[2] = "Draw anywhere to start mean shift tracking.";
            desc = "Use depth to start mean shift algorithm.";
        }
        public void RunAlg(Mat src)
        {
            meanShift.Run(vbc.task.depthRGB);
            dst2 = meanShift.dst2;
            dst3 = meanShift.dst1;
        }
    }




    public class Mesh_Basics_CS : VB_Parent
    {
        KNN_Basics knn = new KNN_Basics();
        public List<Point2f> ptList = new List<Point2f>();
        Options_Mesh options = new Options_Mesh();
        public Mesh_Basics_CS()
        {
            desc = "Build triangles from the ptList input of points.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src;
            if (vbc.task.heartBeat && standaloneTest())
            {
                var feat = new Feature_Stable();
                feat.Run(src);
                ptList = vbc.task.features;
            }
            if (ptList.Count() <= 3) return;
            knn.queries = ptList;
            knn.trainInput = knn.queries;
            knn.Run(empty);
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                var ptLast = knn.queries[i];
                for (int j = 1; j < options.nabeCount; j++)
                {
                    var pt = knn.queries[knn.result[i, j]];
                    DrawLine(dst2, ptLast, pt, cv.Scalar.White);
                    ptLast = pt;
                }
            }
            dst3.SetTo(0);
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                DrawCircle(dst2, knn.queries[i], vbc.task.DotSize, Scalar.Red);
                DrawCircle(dst3, knn.queries[i], vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = "Triangles built each input point and its " + options.nabeCount.ToString() + " nearest neighbors.";
        }
    }




    public class Mesh_Features_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        Mesh_Basics mesh = new Mesh_Basics();
        public Mesh_Features_CS()
        {
            FindSlider("Min Distance to next").Value = 10;
            labels[2] = "Triangles built with each feature point and the specified number of nearest neighbors.";
            UpdateAdvice(traceName + ": Use 'Options_Features' to update results.");
            desc = "Build triangles from feature points";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            if (vbc.task.features.Count() < 3) return;
            mesh.ptList = vbc.task.features;
            mesh.Run(src);
            dst2 = mesh.dst2;
            dst3 = mesh.dst3;
            var pad = feat.options.templatePad;
            var size = feat.options.templateSize;
            int depthMiss = 0;
            foreach (var pt in vbc.task.features)
            {
                var depth = vbc.task.pcSplit[2].Get<float>((int)pt.Y, (int)pt.X);
                if (depth == 0)
                {
                    var r = ValidateRect(new cv.Rect((int)(pt.X - pad), (int)(pt.Y - pad), size, size));
                    depth = (float)vbc.task.pcSplit[2][r].Mean(vbc.task.depthMask[r])[0];
                    depthMiss++;
                }
                // SetTrueText(string.Format("{0}m ", depth), pt);
            }
            labels[2] = mesh.labels[2];
            labels[3] = depthMiss.ToString() + " of " + mesh.ptList.Count().ToString() + " features had no depth at that location.  Depth is an average around it for those missing depth.";
        }
    }




    public class MiniCloud_Basics_CS : VB_Parent
    {
        readonly Resize_Smaller resize;
        public cv.Rect rect;
        public Options_IMU options = new Options_IMU();
        public MiniCloud_Basics_CS()
        {
            resize = new Resize_Smaller();
            FindSlider("LowRes %").Value = 25;
            desc = "Create a mini point cloud for use with histograms";
        }
        public void RunAlg(Mat src)
        {
            resize.Run(vbc.task.pointCloud);
            var split = resize.dst2.Split();
            split[2].SetTo(0, vbc.task.noDepthMask.Resize(split[2].Size()));
            rect = new cv.Rect(0, 0, resize.dst2.Width, resize.dst2.Height);
            if (rect.Height < dst2.Height / 2) rect.Y = dst2.Height / 4; // move it below the dst2 caption
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst2[rect] = split[2].ConvertScaleAbs(255);
            dst2.Rectangle(rect, Scalar.White, 1);
            Cv2.Merge(split, dst3);
            labels[2] = "MiniPC is " + rect.Width + "x" + rect.Height + " total pixels = " + (rect.Width * rect.Height);
        }
    }




    public class MiniCloud_Rotate_CS : VB_Parent
    {
        TrackBar ySlider;
        public MiniCloud_Basics mini = new MiniCloud_Basics();
        public Mat histogram = new Mat();
        public MiniCloud_Rotate_CS()
        {
            ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[3] = "Side view after resize percentage - use Y-Axis slider to rotate image.";
            desc = "Create a histogram for the mini point cloud";
        }
        public void RunAlg(Mat src)
        {
            var input = src;
            mini.Run(input);
            input = mini.dst3;
            vbc.task.accRadians.Y = ySlider.Value;
            double cx = 1, sx = 0, cy = 1, sy = 0, cz = 1, sz = 0;
            float[,] gM = {
            { (float)(cx * 1 + -sx * 0 + 0 * 0), (float)(cx * 0 + -sx * cz + 0 * sz), (float)(cx * 0 + -sx * -sz + 0 * cz) },
            { (float)(sx * 1 + cx * 0 + 0 * 0), (float)(sx * 0 + cx * cz + 0 * sz), (float)(sx * 0 + cx * -sz + 0 * cz) },
            { (float)(0 * 1 + 0 * 0 + 1 * 0), (float)(0 * 0 + 0 * cz + 1 * sz), (float)(0 * 0 + 0 * -sz + 1 * cz) }};
            // [cos(a) 0 -sin(a)]
            // [0      1       0]
            // [sin(a) 0   cos(a] rotate the point cloud around the y-axis.
            cy = Math.Cos(vbc.task.accRadians.Y * Cv2.PI / 180);
            sy = Math.Sin(vbc.task.accRadians.Y * Cv2.PI / 180);
            gM = new float[3, 3] {
                {(float)(gM[0, 0] * cy + gM[0, 1] * 0 + gM[0, 2] * sy),
                 (float)(gM[0, 0] * 0 + gM[0, 1] * 1 + gM[0, 2] * 0),
                 (float)(gM[0, 0] * -sy + gM[0, 1] * 0 + gM[0, 2] * cy)},
                {(float)(gM[1, 0] * cy + gM[1, 1] * 0 + gM[1, 2] * sy),
                 (float)(gM[1, 0] * 0 + gM[1, 1] * 1 + gM[1, 2] * 0),
                 (float)(gM[1, 0] * -sy + gM[1, 1] * 0 + gM[1, 2] * cy)},
                {(float)(gM[2, 0] * cy + gM[2, 1] * 0 + gM[2, 2] * sy),
                 (float)(gM[2, 0] * 0 + gM[2, 1] * 1 + gM[2, 2] * 0),
                 (float)(gM[2, 0] * -sy + gM[2, 1] * 0 + gM[2, 2] * cy)}};

            var gMat = cv.Mat.FromPixelData(3, 3, MatType.CV_32F, gM);
            var gInput = input.Reshape(1, input.Rows * input.Cols);
            var gOutput = (gInput * gMat).ToMat();
            input = gOutput.Reshape(3, input.Rows);
            var split = input.Split();
            var mask = split[2].Threshold(1, 255, ThresholdTypes.BinaryInv);
            input.SetTo(0, mask.ConvertScaleAbs(255)); // remove zero depth pixels with non-zero x and y.
            var ranges = new Rangef[] { new Rangef(-vbc.task.yRange, vbc.task.yRange), new Rangef(0, vbc.task.MaxZmeters) };
            Cv2.CalcHist(new Mat[] { input }, new int[] { 1, 2 }, new Mat(), histogram, 2, new int[] { input.Height, input.Width }, ranges);
            dst2[mini.rect] = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs(255);
            dst3[mini.rect] = input.ConvertScaleAbs(255);
        }
    }




    public class MiniCloud_RotateAngle_CS : VB_Parent
    {
        TrackBar ySlider;
        readonly MiniCloud_Rotate peak = new MiniCloud_Rotate();
        Mat_4to1 mats = new Mat_4to1();
        public Plot_OverTimeSingle plot = new Plot_OverTimeSingle();
        public MiniCloud_RotateAngle_CS()
        {
            ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            vbc.task.accRadians.Y = (float)-Cv2.PI / 2;
            labels[2] = "peak dst2, peak dst3, changed mask, maxvalues history";
            labels[3] = "Blue is maxVal, green is mean * 100";
            desc = "Find a peak value in the side view histograms";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3)
            {
                peak.mini.Run(src);
                src = peak.mini.dst3;
            }
            if (ySlider.Value + 1 >= ySlider.Maximum) ySlider.Value = ySlider.Minimum; else ySlider.Value += 1;
            peak.Run(src);
            var mm = GetMinMax(peak.histogram);
            var mean = peak.histogram.Mean()[0] * 100;
            var mask = peak.histogram.Threshold(mean, 255, ThresholdTypes.Binary).ConvertScaleAbs(255);
            mats.mat[2] = mask;
            plot.plotData = (float)mm.maxVal;
            plot.Run(empty);
            dst3 = plot.dst2;
            labels[3] = "Histogram maxVal = " + mm.maxVal.ToString(vbc.fmt1) + " histogram mean = " + mean.ToString(vbc.fmt1);
            mats.mat[3] = peak.histogram.ConvertScaleAbs(255);
            mats.mat[0] = peak.dst2[peak.mini.rect];
            mats.mat[1] = peak.dst3[peak.mini.rect];
            mats.Run(empty);
            dst2 = mats.dst2;
        }
    }




    public class MiniCloud_RotateSinglePass_CS : VB_Parent
    {
        MiniCloud_Rotate peak = new MiniCloud_Rotate();
        TrackBar ySlider;
        public MiniCloud_RotateSinglePass_CS()
        {
            ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            vbc.task.accRadians.Y = (float)-Cv2.PI;
            desc = "Same operation as New MiniCloud_RotateAngle but in a single pass.";
        }
        public void RunAlg(Mat src)
        {
            peak.mini.Run(src);
            float maxHist = Single.MinValue;
            int bestAngle = 0;
            cv.Point bestLoc = new cv.Point();
            mmData mm;
            for (int i = ySlider.Minimum; i < ySlider.Maximum - 1; i++)
            {
                peak.Run(peak.mini.dst3);
                ySlider.Value = i;
                mm = GetMinMax(peak.histogram);
                if (mm.maxVal > maxHist)
                {
                    maxHist = (float)mm.maxVal;
                    bestAngle = i;
                    bestLoc = mm.maxLoc;
                }
            }
            peak.Run(peak.mini.dst3);
            vbc.task.accRadians.Y = bestAngle;
            dst2 = peak.dst2;
            dst3 = peak.dst3;
            SetTrueText("Peak concentration in the histogram is at angle " + bestAngle + " degrees", 3);
        }
    }




    public class ML_BasicsOld_CS : VB_Parent
    {
        public ML_BasicsOld_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "depth32f - 32fc3 format with missing depth filled with predicted depth based on color (brighter is farther)", "", "Color used for roi prediction" };
            desc = "Predict depth from color to fill in the depth shadow areas";
        }
        public void RunAlg(Mat src)
        {
            int[] noDepthCount = new int[vbc.task.gridRects.Count()];
            Vec3b[] roiColor = new Vec3b[vbc.task.gridRects.Count()];
            dst2.SetTo(0);
            Parallel.For(0, vbc.task.gridRects.Count(), i =>
            {
                var roi = vbc.task.gridRects[i];
                roiColor[i] = src[roi].Get<Vec3b>(roi.Height / 2, roi.Width / 2);
                dst2[roi].SetTo(roiColor[i], vbc.task.depthMask[roi]);
                noDepthCount[i] = vbc.task.noDepthMask[roi].CountNonZero();
            });
            var rtree = RTrees.Create();
            var mlInput = new List<mlData>();
            var mResponse = new List<float>();
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                if (noDepthCount[i] == 0) continue;
                mlData ml = new mlData();
                var roi = vbc.task.gridRects[i];
                ml.row = roi.Y + roi.Height / 2;
                ml.col = roi.X + roi.Width / 2;
                var c = roiColor[i];
                ml.blue = c.Item0;
                ml.green = c.Item1;
                ml.red = c.Item2;
                mlInput.Add(ml);
                mResponse.Add((float)vbc.task.pcSplit[2][roi].Mean());
            }
            if (mlInput.Count() == 0)
            {
                strOut = "No learning data was found or provided.  Exit...";
                dst3.SetTo(0);
                SetTrueText(strOut, 3);
                return;
            }
            Mat mLearn = cv.Mat.FromPixelData(mlInput.Count(), 5, MatType.CV_32F, mlInput.ToArray());
            Mat response = cv.Mat.FromPixelData(mResponse.Count(), 1, MatType.CV_32F, mResponse.ToArray());
            rtree.Train(mLearn, SampleTypes.RowSample, response);
            var predictList = new List<mlData>();
            var colors = new List<Vec3b>();
            var saveRoi = new List<cv.Rect>();
            var depthMask = new List<Mat>();
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                if (noDepthCount[i] == 0) continue;
                var roi = vbc.task.gridRects[i];
                depthMask.Add(vbc.task.noDepthMask[roi]);
                mlData ml = new mlData();
                ml.row = roi.Y + roi.Height / 2;
                ml.col = roi.X + roi.Width / 2;
                var c = roiColor[i];
                ml.blue = c.Item0;
                ml.green = c.Item1;
                ml.red = c.Item2;
                predictList.Add(ml);
                colors.Add(c);
                saveRoi.Add(roi);
            }
            Mat predMat = cv.Mat.FromPixelData(predictList.Count(), 5, MatType.CV_32F, predictList.ToArray());
            Mat output = new Mat(predictList.Count(), 1, MatType.CV_32FC1, cv.Scalar.All(0));
            rtree.Predict(predMat, output);
            dst1 = vbc.task.pcSplit[2];
            dst3.SetTo(0);
            for (int i = 0; i < predictList.Count(); i++)
            {
                var roi = saveRoi[i];
                float depth = output.Get<float>(i, 0);
                dst1[roi].SetTo(depth, depthMask[i]);
                dst3[roi].SetTo(colors[i], depthMask[i]);
            }
            labels[2] = vbc.task.gridRects.Count().ToString() + " regions with " + mlInput.Count().ToString() + " used for learning and " + predictList.Count().ToString() + " were predicted";
        }
    }
    public static class ML__Exports
    {
        class CompareVec3f : IComparer<Vec3f>
        {
            public int Compare(Vec3f a, Vec3f b)
            {
                if (a.Item0 == b.Item0 && a.Item1 == b.Item1 && a.Item2 == b.Item2) return 0;
                return a.Item0 < b.Item0 ? -1 : 1;
            }
        }
        public static Mat detectAndFillShadow(Mat holeMask, Mat borderMask, Mat depth32f, Mat color, int minLearnCount)
        {
            var learnData = new SortedList<Vec3f, float>(new CompareVec3f());
            var rng = new Random();
            int holeCount = Cv2.CountNonZero(holeMask);
            if (borderMask.Channels() != 1) borderMask = borderMask.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            int borderCount = Cv2.CountNonZero(borderMask);
            if (holeCount > 0 && borderCount > minLearnCount)
            {
                Mat color32f = new Mat();
                color.ConvertTo(color32f, MatType.CV_32FC3);
                var learnInputList = new List<Vec3f>();
                var responseInputList = new List<float>();
                for (int y = 0; y < holeMask.Rows; y++)
                {
                    for (int x = 0; x < holeMask.Cols; x++)
                    {
                        if (borderMask.Get<byte>(y, x) != 0)
                        {
                            Vec3f vec = color32f.Get<Vec3f>(y, x);
                            if (!learnData.ContainsKey(vec))
                            {
                                learnData.Add(vec, depth32f.Get<float>(y, x)); // keep out duplicates.
                                learnInputList.Add(vec);
                                responseInputList.Add(depth32f.Get<float>(y, x));
                            }
                        }
                    }
                }
                Mat learnInput = cv.Mat.FromPixelData(learnData.Count(), 3, MatType.CV_32F, learnInputList.ToArray());
                Mat depthResponse = cv.Mat.FromPixelData(learnData.Count(), 1, MatType.CV_32F, responseInputList.ToArray());
                // now learn what depths are associated with which colors.
                var rtree = RTrees.Create();
                rtree.Train(learnInput, SampleTypes.RowSample, depthResponse);
                // now predict what the depth is based just on the color (and proximity to the region)
                using (Mat predictMat = new Mat(1, 3, MatType.CV_32F))
                {
                    for (int y = 0; y < holeMask.Rows; y++)
                    {
                        for (int x = 0; x < holeMask.Cols; x++)
                        {
                            if (holeMask.Get<byte>(y, x) != 0)
                            {
                                predictMat.Set<Vec3f>(0, 0, color32f.Get<Vec3f>(y, x));
                                depth32f.Set<float>(y, x, rtree.Predict(predictMat));
                            }
                        }
                    }
                }
            }
            return depth32f;
        }
    }




    public class ML_FillRGBDepth_MT_CS : VB_Parent
    {
        Depth_Holes shadow = new Depth_Holes();
        Depth_Colorizer_CPP_VB colorizer = new Depth_Colorizer_CPP_VB();
        public ML_FillRGBDepth_MT_CS()
        {
            vbc.task.gOptions.setGridMaximum(dst2.Cols / 2);
            vbc.task.gOptions.setGridSize(dst2.Cols / 2);
            labels = new string[] { "", "", "ML filled shadow", "" };
            desc = "Predict depth based on color and colorize depth to confirm correctness of model.  NOTE: memory leak occurs if more multi-threading is used!";
        }
        public void RunAlg(Mat src)
        {
            int minLearnCount = 5;
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                vbc.task.pcSplit[2][roi] = ML__Exports.detectAndFillShadow(vbc.task.noDepthMask[roi], shadow.dst3[roi], vbc.task.pcSplit[2][roi], src[roi], minLearnCount);
            });
            colorizer.Run(vbc.task.pcSplit[2]);
            dst2 = colorizer.dst2.Clone();
            dst2.SetTo(Scalar.White, vbc.task.gridMask);
        }
    }




    public class ML_DepthFromColor_CS : VB_Parent
    {
        Depth_Colorizer_CPP_VB colorizer = new Depth_Colorizer_CPP_VB();
        Mat_4Click mats = new Mat_4Click();
        Resize_Smaller resizer = new Resize_Smaller();
        public ML_DepthFromColor_CS()
        {
            FindSlider("LowRes %").Value = 2; // 2% of the image.
            labels[3] = "Click any quadrant at left to view it below";
            desc = "Use BGR to predict depth across the entire image, maxDepth = slider value, resize % as well.";
        }
        public void RunAlg(Mat src)
        {
            mats.mat[1] = vbc.task.noDepthMask.Clone();
            Mat color32f = new Mat();
            resizer.Run(src);
            cv.Rect colorROI = new cv.Rect(0, 0, resizer.newSize.Width, resizer.newSize.Height);
            resizer.dst2.ConvertTo(color32f, MatType.CV_32FC3);
            Mat shadowSmall = mats.mat[1].Resize(color32f.Size()).Clone();
            color32f.SetTo(Scalar.Black, shadowSmall); // where depth is unknown, set to black (so we don't learn anything invalid, i.e. good color but missing depth.
            Mat depth = vbc.task.pcSplit[2].Resize(color32f.Size());
            Mat mask = depth.Threshold(vbc.task.gOptions.maxDepth, vbc.task.gOptions.maxDepth, ThresholdTypes.Binary);
            mask.ConvertTo(mask, MatType.CV_8U);
            mats.mat[2] = mask;
            mask = ~mask;
            depth.SetTo(vbc.task.gOptions.maxDepth, mask);
            colorizer.Run(depth);
            mats.mat[3] = colorizer.dst2.Clone();
            mask = depth.Threshold(1, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            int maskCount = mask.CountNonZero();
            dst2 = mask;
            Mat learnInput = color32f.Reshape(1, (int)color32f.Total());
            Mat depthResponse = depth.Reshape(1, (int)depth.Total());
            // now learn what depths are associated with which colors.
            var rtree = RTrees.Create();
            rtree.Train(learnInput, SampleTypes.RowSample, depthResponse);
            src.ConvertTo(color32f, MatType.CV_32FC3);
            Mat input = color32f.Reshape(1, (int)color32f.Total()); // test the entire original image.
            Mat output = new Mat();
            rtree.Predict(input, output);
            Mat predictedDepth = output.Reshape(1, src.Height);
            colorizer.Run(predictedDepth);
            mats.mat[0] = colorizer.dst2.Clone();
            mats.Run(empty);
            dst2 = mats.dst2;
            labels[2] = "prediction, shadow, Depth Mask < " + vbc.task.gOptions.maxDepth + ", Learn Input";
            dst3 = mats.dst3;
        }
    }




    public class ML_DepthFromXYColor_CS : VB_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        Depth_Holes shadow = new Depth_Holes();
        Resize_Smaller resizer = new Resize_Smaller();
        Depth_Colorizer_CPP_VB colorizer = new Depth_Colorizer_CPP_VB();
        public ML_DepthFromXYColor_CS()
        {
            FindSlider("LowRes %").Value = 2; // 2% of the image.
            labels[2] = "Predicted Depth";
            desc = "Use BGR to predict depth across the entire image, maxDepth = slider value, resize % as well.";
        }
        public void RunAlg(Mat src)
        {
            int maxDepth = vbc.task.gOptions.maxDepth;
            shadow.Run(src);
            mats.mat[0] = shadow.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            Mat color32f = new Mat();
            resizer.Run(src);
            cv.Rect colorROI = new cv.Rect(0, 0, resizer.newSize.Width, resizer.newSize.Height);
            resizer.dst2.ConvertTo(color32f, MatType.CV_32FC3);
            Mat shadowSmall = shadow.dst2.Resize(color32f.Size()).Clone();
            color32f.SetTo(Scalar.Black, shadowSmall); // where depth is unknown, set to black
            Mat depth32f = vbc.task.pcSplit[2].Resize(color32f.Size());
            Mat mask = depth32f.Threshold(maxDepth, maxDepth, ThresholdTypes.BinaryInv);
            mask.SetTo(0, shadowSmall); // remove the unknown depth...
            mask.ConvertTo(mask, MatType.CV_8U);
            mats.mat[2] = mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            mask = ~mask;
            depth32f.SetTo(maxDepth, mask);
            colorizer.Run(depth32f);
            mats.mat[3] = colorizer.dst2.Clone();
            mask = depth32f.Threshold(1, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            int maskCount = mask.CountNonZero();
            dst2 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            Mat c = color32f.Reshape(1, (int)color32f.Total());
            Mat depthResponse = depth32f.Reshape(1, (int)depth32f.Total());
            Mat learnInput = new Mat(c.Rows, 6, MatType.CV_32F, cv.Scalar.All(0));
            for (int y = 0; y < c.Rows; y++)
            {
                for (int x = 0; x < c.Cols; x++)
                {
                    Vec6f v6 = new Vec6f(c.Get<float>(y, x), c.Get<float>(y, x + 1), c.Get<float>(y, x + 2), x, y, 0);
                    learnInput.Set<Vec6f>(y, x, v6);
                }
            }
            // Now learn what depths are associated with which colors.
            var rtree = cv.ML.RTrees.Create();
            rtree.Train(learnInput, SampleTypes.RowSample, depthResponse);
            src.ConvertTo(color32f, MatType.CV_32FC3);
            Mat allC = color32f.Reshape(1, (int)color32f.Total()); // test the entire original image.
            Mat input = new Mat(allC.Rows, 6, MatType.CV_32F, cv.Scalar.All(0));
            for (int y = 0; y < allC.Rows; y++)
            {
                for (int x = 0; x < allC.Cols; x++)
                {
                    Vec6f v6 = new Vec6f(allC.Get<float>(y, x), allC.Get<float>(y, x + 1), allC.Get<float>(y, x + 2), x, y, 0);
                    input.Set<Vec6f>(y, x, v6);
                }
            }
            Mat output = new Mat();
            rtree.Predict(input, output);
            Mat predictedDepth = output.Reshape(1, src.Height);
            colorizer.Run(predictedDepth);
            dst2 = colorizer.dst2.Clone();
            mats.Run(empty);
            dst3 = mats.dst2;
            labels[3] = "shadow, empty, Depth Mask < " + maxDepth.ToString() + ", Learn Input";
        }
    }
    public struct mlColor
    {
        public float colorIndex;
        public float x;
        public float y;
    }




    public class ML_Color2Depth_CS : VB_Parent
    {
        Grid_MinMaxDepth minMax = new Grid_MinMaxDepth();
        Color8U_Basics colorClass = new Color8U_Basics();
        public ML_Color2Depth_CS()
        {
            vbc.task.redOptions.setColorSource("Bin4Way_Regions");
            desc = "Prepare a grid of color and depth data.";
        }
        public void RunAlg(Mat src)
        {
            colorClass.Run(src);
            dst2 = colorClass.dst3;
            labels[2] = "Output of Color8U_Basics running " + vbc.task.redOptions.colorInputName;
            var rtree = cv.ML.RTrees.Create();
            List<mlColor> mlInput = new List<mlColor>();
            List<float> mResponse = new List<float>();
            List<mlColor> predictList = new List<mlColor>();
            List<cv.Rect> roiPredict = new List<cv.Rect>();
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                mlColor mls = new mlColor
                {
                    colorIndex = colorClass.dst2.Get<byte>(roi.Y, roi.X),
                    x = roi.X,
                    y = roi.Y
                };
                if (vbc.task.noDepthMask[roi].CountNonZero() > 0)
                {
                    roiPredict.Add(roi);
                    predictList.Add(mls);
                }
                else
                {
                    mlInput.Add(mls);
                    mResponse.Add((float)vbc.task.pcSplit[2][roi].Mean());
                }
            }
            if (mlInput.Count() == 0)
            {
                SetTrueText("No learning data was found or provided.  Exit...", 3);
                return;
            }
            Mat mLearn = cv.Mat.FromPixelData(mlInput.Count(), 3, MatType.CV_32F, mlInput.ToArray());
            Mat response = cv.Mat.FromPixelData(mResponse.Count(), 1, MatType.CV_32F, mResponse.ToArray());
            rtree.Train(mLearn, SampleTypes.RowSample, response);
            Mat predMat = cv.Mat.FromPixelData(predictList.Count(), 3, MatType.CV_32F, predictList.ToArray());
            Mat output = new cv.Mat(predictList.Count(), 1, MatType.CV_32FC1, cv.Scalar.All(0));
            rtree.Predict(predMat, output);
            dst3 = vbc.task.pcSplit[2].Clone();
            for (int i = 0; i < predictList.Count(); i++)
            {
                mlColor mls = predictList[i];
                cv.Rect roi = roiPredict[i];
                float depth = output.Get<float>(i, 0);
                dst3[roi].SetTo(depth, vbc.task.noDepthMask[roi]);
            }
        }
    }
    public struct mlColorInTier
    {
        public float colorIndex;
        public float x;
        public float y;
    }




    public class ML_ColorInTier2Depth_CS : VB_Parent
    {
        Grid_MinMaxDepth minMax = new Grid_MinMaxDepth();
        Color8U_Basics colorClass = new Color8U_Basics();
        Contour_DepthTiers tiers = new Contour_DepthTiers();
        public ML_ColorInTier2Depth_CS()
        {
            vbc.task.redOptions.setColorSource("Bin4Way_Regions");
            desc = "Prepare a grid of color and depth data.";
        }
        public void RunAlg(Mat src)
        {
            colorClass.Run(src);
            dst2 = colorClass.dst3;
            labels[2] = "Output of Color8U_Basics running " + vbc.task.redOptions.colorInputName;
            var rtree = cv.ML.RTrees.Create();
            List<mlColorInTier> mlInput = new List<mlColorInTier>();
            List<float> mResponse = new List<float>();
            List<mlColorInTier> predictList = new List<mlColorInTier>();
            List<cv.Rect> roiPredict = new List<cv.Rect>();
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                cv.Rect roi = vbc.task.gridRects[i];
                mlColorInTier mls = new mlColorInTier
                {
                    colorIndex = colorClass.dst2.Get<byte>(roi.Y, roi.X),
                    x = roi.X,
                    y = roi.Y
                };
                if (vbc.task.noDepthMask[roi].CountNonZero() > 0)
                {
                    roiPredict.Add(roi);
                    predictList.Add(mls);
                }
                else
                {
                    mlInput.Add(mls);
                    mResponse.Add((float)vbc.task.pcSplit[2][roi].Mean());
                }
            }
            if (mlInput.Count() == 0)
            {
                SetTrueText("No learning data was found or provided.  Exit...", 3);
                return;
            }
            Mat mLearn = cv.Mat.FromPixelData(mlInput.Count(), 3, MatType.CV_32F, mlInput.ToArray());
            Mat response = cv.Mat.FromPixelData(mResponse.Count(), 1, MatType.CV_32F, mResponse.ToArray());
            rtree.Train(mLearn, SampleTypes.RowSample, response);
            Mat predMat = cv.Mat.FromPixelData(predictList.Count(), 3, MatType.CV_32F, predictList.ToArray());
            Mat output = new Mat(predictList.Count(), 1, MatType.CV_32FC1, cv.Scalar.All(0));
            rtree.Predict(predMat, output);
            dst3 = vbc.task.pcSplit[2].Clone();
            for (int i = 0; i < predictList.Count(); i++)
            {
                mlColorInTier mls = predictList[i];
                cv.Rect roi = roiPredict[i];
                float depth = output.Get<float>(i, 0);
                dst3[roi].SetTo(depth, vbc.task.noDepthMask[roi]);
            }
        }
    }




    public class ML_RemoveDups_CPP_CS : VB_Parent
    {
        public ML_RemoveDups_CPP_CS()
        {
            cPtr = ML_RemoveDups_Open();
            labels = new string[] { "", "", "BGR input below is converted to BGRA and sorted as integers", "" };
            desc = "The input is BGR, convert to BGRA, and sorted as an integer.  The output is a sorted BGR Mat file with duplicates removed.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() == MatType.CV_8UC3)
            {
                dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_32S, src.CvtColor(ColorConversionCodes.BGR2BGRA).Data);
            }
            else
            {
                dst2 = src.Clone();
            }
            byte[] dataSrc = new byte[dst2.Total() * dst2.ElemSize()];
            Marshal.Copy(dst2.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = ML_RemoveDups_Run(cPtr, handleSrc.AddrOfPinnedObject(), dst2.Rows, dst2.Cols, (int)dst2.Type());
            handleSrc.Free();
            int compressedCount = ML_RemoveDups_GetCount(cPtr);
            if (src.Type() == MatType.CV_32S)
            {
                dst3 = cv.Mat.FromPixelData(dst2.Rows, dst2.Cols, dst2.Type(), imagePtr).Clone();
                Mat tmp = cv.Mat.FromPixelData(dst2.Rows, dst2.Cols, MatType.CV_8UC4, dst3.Data);
                dst3 = tmp.CvtColor(ColorConversionCodes.BGRA2BGR);
            }
            else
            {
                dst3 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
            }
            labels[3] = "The BGR data in dst2 after removing duplicate BGR entries.  Input count = " + dst2.Total() + " output = " + compressedCount;
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = ML_RemoveDups_Close(cPtr);
        }
    }




    public class Model_Basics_CS : VB_Parent
    {
        OpenGL_BasicsMouse oglM = new OpenGL_BasicsMouse();
        public Model_Basics_CS()
        {
            labels = new string[] { "", "", "Captured OpenGL output", "" };
            desc = "Capture the output of the OpenGL window";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest()) oglM.Run(src);
            dst2 = oglM.dst2;
            dst3 = oglM.dst3;
        }
    }




    public class Model_OpenGL_Sliders_CS : VB_Parent
    {
        Model_Basics model = new Model_Basics();
        public Model_OpenGL_Sliders_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Basics";
            labels = new string[] { "", "", "Captured OpenGL output", "" };
            desc = "Capture the output of the OpenGL window";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            if (standaloneTest()) vbc.task.ogl.Run(src);
            model.Run(src);
            dst2 = model.dst2;
        }
    }




    public class Model_FlatSurfaces_CS : VB_Parent
    {
        public int totalPixels;
        List<float> floorList = new List<float>();
        List<float> ceilingList = new List<float>();
        public Model_FlatSurfaces_CS()
        {
            desc = "Minimalist approach to find a flat surface that is oriented to gravity (floor or ceiling)";
        }
        public void RunAlg(Mat src)
        {
            Rangef[] ranges = new Rangef[] { new Rangef(-vbc.task.yRange, vbc.task.yRange), new Rangef(0, vbc.task.MaxZmeters) };
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, new int[] { 1, 2 }, new Mat(), dst0, 2,
                          new int[] { dst2.Height, dst2.Width }, ranges);
            double thicknessCMs = 0.1, nextY = 0;
            totalPixels = 0;
            cv.Rect rect = new cv.Rect(0, 0, 0, 0);
            for (int y = dst0.Height - 2; y >= 0; y--)
            {
                rect = new cv.Rect(0, y, dst0.Width - 1, 1);
                int count = dst0[rect].CountNonZero();
                double pixelCount = dst0[rect].Sum()[0];
                totalPixels += (int)pixelCount;
                if (count > 10)
                {
                    nextY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - y) / vbc.task.sideCameraPoint.Y - thicknessCMs;
                    break;
                }
            }
            int floorY = rect.Y;
            floorList.Add((float)nextY);
            vbc.task.pcFloor = floorList.Average();
            if (floorList.Count() > vbc.task.frameHistoryCount) floorList.RemoveAt(0);
            labels[2] = "Y = " + vbc.task.pcFloor.ToString("F3") + " separates the floor.  Total pixels below floor level = " + totalPixels;
            for (int y = 0; y < dst2.Height; y++)
            {
                rect = new cv.Rect(0, y, dst0.Width - 1, 1);
                int count = dst0[rect].CountNonZero();
                double pixelCount = dst0[rect].Sum()[0];
                totalPixels += (int)pixelCount;
                if (count > 10)
                {
                    nextY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - y) / vbc.task.sideCameraPoint.Y - thicknessCMs;
                    break;
                }
            }
            int ceilingY = rect.Y;
            ceilingList.Add((float)nextY);
            vbc.task.pcCeiling = ceilingList.Average();
            if (ceilingList.Count() > vbc.task.frameHistoryCount) ceilingList.RemoveAt(0);
            labels[3] = "Y = " + vbc.task.pcCeiling.ToString("F3") + " separates the ceiling.  Total pixels above ceiling level = " + totalPixels;
            if (standaloneTest())
            {
                dst2 = dst0.Threshold(0, 255, ThresholdTypes.Binary);
                dst2.ConvertTo(dst2, MatType.CV_8U);
                dst2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
                dst2.Line(new cv.Point(0, floorY), new cv.Point(dst2.Width, floorY), Scalar.Red, vbc.task.lineWidth + 2, vbc.task.lineType);
                dst2.Line(new cv.Point(0, ceilingY), new cv.Point(dst2.Width, ceilingY), Scalar.Red, vbc.task.lineWidth + 2, vbc.task.lineType);
            }
        }
    }




    public class Model_RedCloud_CS : VB_Parent
    {
        public OpenGL_DrawHulls oglD = new OpenGL_DrawHulls();
        public Model_RedCloud_CS()
        {
            labels = new string[] { "", "", "OpenGL output", "RedCloud Output" };
            desc = "Capture the OpenGL output of the drawn cells";
        }
        public void RunAlg(Mat src)
        {
            oglD.Run(src);
            dst2 = oglD.dst2;
        }
    }




    public class Model_CellZoom_CS : VB_Parent
    {
        Model_RedCloud oglData = new Model_RedCloud();
        public Model_CellZoom_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "RedCloud_Hull output", "Selected cell in 3D" };
            desc = "Zoom in on the selected RedCloud cell in the OpenGL output";
        }
        public void RunAlg(Mat src)
        {
            oglData.Run(src);
            dst2 = oglData.dst2;
            dst3 = oglData.oglD.dst3;
            var rcX = vbc.task.rc;
            dst1.SetTo(0);
            Mat mask = dst3.InRange(Scalar.White, Scalar.White);
            dst3.CopyTo(dst1, mask);
            Mat points = mask.FindNonZero();
            if (points.Rows > 0)
            {
                Mat[] split = points.Split();
                var mmX = GetMinMax(split[0]);
                var mmY = GetMinMax(split[1]);
                cv.Rect r = new cv.Rect((int)mmX.minVal, (int)mmY.minVal, (int)(mmX.maxVal - mmX.minVal), (int)(mmY.maxVal - mmY.minVal));
                dst1.Rectangle(r, Scalar.White, 1, vbc.task.lineType);
            }
        }
    }




    public class Projection_Basics_CS : VB_Parent
    {
        public List<rcData> redCellInput = new List<rcData>();
        public List<rcData> redCells = new List<rcData>();
        public string viewType = "Top";
        public List<Vec4f> objectList = new List<Vec4f>();
        public bool showRectangles = true;
        Projection_HistTop histTop = new Projection_HistTop();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Projection_Basics_CS()
        {
            desc = "Find all the masks, rects, and counts in the input";
        }
        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                histTop.Run(src);
                src = histTop.dst2;
                redC.inputMask = ~histTop.dst3;
                redC.Run(histTop.dst3);
                redCellInput = vbc.task.redCells;
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
            }
            var sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            int check2 = 0;
            for (int i = 0; i < redCellInput.Count(); i++)
            {
                var rc = redCellInput[i];
                var tmp = new Mat(rc.rect.Size, MatType.CV_32F, cv.Scalar.All(0));
                src[rc.rect].CopyTo(tmp, rc.mask);
                rc.pixels = (int)tmp.Sum()[0];
                sortedCells.Add(rc.pixels, rc);
                check2 += rc.pixels;
            }
            redCells.Clear();
            redCells.Add(new rcData());
            foreach (var rc in sortedCells.Values)
            {
                rc.index = redCells.Count();
                redCells.Add(rc);
            }
            int otherCount = 0;
            string meterDesc = "tall";
            var ranges = vbc.task.rangesSide;
            if (viewType == "Top")
            {
                meterDesc = "wide";
                ranges = vbc.task.rangesTop;
            }
            objectList.Clear();
            float xy1, xy2, z1, z2;
            if (vbc.task.heartBeat) strOut = "";
            foreach (var rc in redCells)
            {
                if (rc.index == 0) continue;
                if (rc.index <= vbc.task.redOptions.identifyCount)
                {
                    if (viewType == "Side")
                    {
                        xy1 = (ranges[0].End - ranges[0].Start) * rc.rect.Y / dst2.Height + ranges[0].Start;
                        xy2 = (ranges[0].End - ranges[0].Start) * (rc.rect.Y + rc.rect.Height) / dst2.Height + ranges[0].Start;
                        z1 = (ranges[1].End - ranges[1].Start) * rc.rect.X / dst2.Width;
                        z2 = (ranges[1].End - ranges[1].Start) * (rc.rect.X + rc.rect.Width) / dst2.Width;
                    }
                    else
                    {
                        xy1 = (ranges[1].End - ranges[1].Start) * rc.rect.X / dst2.Width + ranges[1].Start;
                        xy2 = (ranges[1].End - ranges[1].Start) * (rc.rect.X + rc.rect.Width) / dst2.Width + ranges[1].Start;
                        z1 = (ranges[0].End - ranges[0].Start) * rc.rect.Y / dst2.Height;
                        z2 = (ranges[0].End - ranges[0].Start) * (rc.rect.Y + rc.rect.Height) / dst2.Height;
                    }
                    objectList.Add(new Vec4f(xy1, xy2, z1, z2));
                    if (vbc.task.heartBeat)
                    {
                        strOut += "Object " + "\t" + rc.index.ToString() + "\t" + (xy2 - xy1).ToString(vbc.fmt3) + " m " + meterDesc + "\t" +
                                   z1.ToString(vbc.fmt1) + "m " + " to " + z2.ToString(vbc.fmt1) + "m from camera" + "\t" + rc.pixels.ToString() + " pixels" + "\n";
                    }
                }
                else
                {
                    otherCount += rc.pixels;
                }
            }
            if (vbc.task.heartBeat)
            {
                var check1 = src.Sum()[0];
                var depthCount = vbc.task.pcSplit[2].CountNonZero();
                strOut += (redCells.Count() - vbc.task.redOptions.identifyCount - 1).ToString() + " other objects " + "\t" + otherCount.ToString() + " pixels" + "\n";
                strOut += "Sum above   " + "\t" + check2.ToString() + " pixels" + " (losses from histogram ranges?)" + "\n";
                strOut += "Sum of src  " + "\t" + check1.ToString() + " pixels" + " (losses from RedCloud.)" + "\n";
                strOut += "Actual count" + "\t" + depthCount.ToString() + " pixels" + "\n";
            }
            SetTrueText(strOut, 3);
            if (showRectangles)
            {
                for (int i = 0; i < Math.Min(redCells.Count(), vbc.task.redOptions.identifyCount); i++)
                {
                    dst2.Rectangle(redCells[i].rect, vbc.task.HighlightColor, vbc.task.lineWidth);
                }
            }
            labels[2] = redCells.Count().ToString() + " objects were found in the " + viewType + " view.";
        }
    }




    public class Projection_HistSide_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Projection_HistSide_CS()
        {
            labels = new string[] { "", "", "Top view with histogram counts", "ZY (Side View) - mask" };
            UpdateAdvice(traceName + ": redOptions 'Project threshold' affects how many regions are isolated.");
            desc = "Create a 2D side view for ZY histogram of depth";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsSide, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesSide);
            histogram.Col(0).SetTo(0);
            dst2 = histogram.ConvertScaleAbs();
            dst3 = histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class Projection_HistTop_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public Projection_HistTop_CS()
        {
            labels = new string[] { "", "", "Top view with histogram counts", "XZ (Top View) - mask" };
            UpdateAdvice(traceName + ": redOptions 'Project threshold' affects how many regions are isolated.");
            desc = "Create a 2D top view for XZ histogram of depth";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsTop, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesTop);
            histogram.Row(0).SetTo(0);
            dst2 = histogram.ConvertScaleAbs();
            dst3 = histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }




    public class Projection_Lines_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        Line_Basics lines = new Line_Basics();
        Options_Projection options = new Options_Projection();
        public Projection_Lines_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = false;
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "Lines found in the threshold output", "FeatureLess cells found", "Projections of each of the FeatureLess cells" };
            desc = "Search for surfaces among the FeatureLess regions";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                dst1.SetTo(0);
                dst3.SetTo(0);
            }
            heat.Run(src);
            dst2 = options.topCheck ? heat.dst2 : heat.dst3;
            dst1 = dst2.Threshold(options.projectionThreshold, 255, ThresholdTypes.Binary);
            lines.Run(dst1);
            dst3 += lines.dst3;
        }
    }




    public class Projection_Cell_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        HeatMap_Basics heatCell = new HeatMap_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Projection_Cell_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setUnfiltered(true);
            labels = new string[] { "", "Top View projection of the selected cell", "RedCloud_Basics output - select a cell to project at right and above", "Side projection of the selected cell" };
            desc = "Create a top and side projection of the selected cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            heat.Run(src);
            dst1 = heat.dst2.Clone();
            dst3 = heat.dst3.Clone();
            var rc = vbc.task.rc;
            dst0.SetTo(0);
            vbc.task.pointCloud[rc.rect].CopyTo(dst0[rc.rect], rc.mask);
            heatCell.Run(dst0);
            var maskTop = heatCell.dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(0, 255, ThresholdTypes.Binary);
            var maskSide = heatCell.dst3.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(0, 255, ThresholdTypes.Binary);
            if (maskTop.CountNonZero() == 0 && maskSide.CountNonZero() == 0) SetTrueText("The selected cell has no depth data.", 3);
            dst1.SetTo(Scalar.White, maskTop);
            dst3.SetTo(Scalar.White, maskSide);
        }
    }




    public class Projection_Top_CS : VB_Parent
    {
        public Projection_HistTop histTop = new Projection_HistTop();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Projection_Basics objects = new Projection_Basics();
        public Projection_Top_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            desc = "Find all the masks, rects, and counts in the top down view.";
        }
        public void RunAlg(Mat src)
        {
            histTop.Run(src);
            redC.inputMask = ~histTop.dst3;
            redC.Run(histTop.dst3);
            objects.redCellInput = vbc.task.redCells;
            objects.dst2 = redC.dst2;
            objects.labels[2] = redC.labels[2];
            objects.Run(histTop.dst2);
            dst2 = objects.dst2;
            labels[2] = redC.labels[2];
            SetTrueText(objects.strOut, 3);
        }
    }




    public class Projection_Side_CS : VB_Parent
    {
        public Projection_HistSide histSide = new Projection_HistSide();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Projection_Basics objects = new Projection_Basics();
        public Projection_Side_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            objects.viewType = "Side";
            desc = "Find all the masks, rects, and counts in the side view.";
        }
        public void RunAlg(Mat src)
        {
            histSide.Run(src);
            redC.inputMask = ~histSide.dst3;
            redC.Run(histSide.dst3);
            objects.redCellInput = vbc.task.redCells;
            objects.dst2 = redC.dst2;
            objects.labels[2] = redC.labels[2];
            objects.Run(histSide.dst2);
            dst2 = objects.dst2;
            labels[2] = redC.labels[2];
            SetTrueText(objects.strOut, 3);
        }
    }




    public class Projection_ObjectIsolate_CS : VB_Parent
    {
        public Projection_Top top = new Projection_Top();
        public Projection_Side side = new Projection_Side();
        Options_Projection options = new Options_Projection();
        public Projection_ObjectIsolate_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            side.objects.showRectangles = false;
            desc = "Using the top down view, create a histogram for Y-values of the largest object.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            top.Run(src);
            dst3 = top.dst2;
            labels[3] = top.labels[2];
            if (options.index < top.objects.objectList.Count())
            {
                var lower = new Scalar(top.objects.objectList[options.index][0], -100, top.objects.objectList[options.index][2]);
                var upper = new Scalar(top.objects.objectList[options.index][1], +100, top.objects.objectList[options.index][3]);
                dst0 = vbc.task.pointCloud.InRange(lower, upper);
                dst1.SetTo(0);
                vbc.task.pointCloud.CopyTo(dst1, dst0);
                side.Run(dst1);
                dst2 = side.histSide.dst3;
                labels[2] = side.labels[2];
            }
        }
    }




    public class Projection_Object_CS : VB_Parent
    {
        Projection_Top top = new Projection_Top();
        Projection_Side side = new Projection_Side();
        public Projection_Object_CS()
        {
            vbc.task.gOptions.setDebugSlider(0); // pick the biggest object...
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            top.objects.showRectangles = false;
            desc = "Using the top down view, create a histogram for Y-values of the largest object.";
        }
        public void RunAlg(Mat src)
        {
            top.Run(src);
            dst3 = top.dst2;
            labels[3] = top.labels[2];
            int index = vbc.task.gOptions.getDebugSlider();
            if (index < top.objects.objectList.Count())
            {
                var lower = new Scalar(top.objects.objectList[index][0], -100, top.objects.objectList[index][2]);
                var upper = new Scalar(top.objects.objectList[index][1], +100, top.objects.objectList[index][3]);
                var mask = vbc.task.pointCloud.InRange(lower, upper);
                var rc = top.objects.redCells[vbc.task.gOptions.getDebugSlider() + 1]; // the biggest by default...
                dst0.SetTo(0);
                dst0[rc.rect] = top.histTop.dst2[rc.rect].Threshold(0, 255, ThresholdTypes.Binary);
                dst0.SetTo(0, dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
                dst1.SetTo(0);
                vbc.task.pointCloud.CopyTo(dst1, mask);
                side.Run(dst1);
                dst2 = side.dst2;
                labels[2] = side.labels[2];
            }
        }
    }




    public class Projection_Floor_CS : VB_Parent
    {
        Projection_ObjectIsolate isolate = new Projection_ObjectIsolate();
        TrackBar objSlider;
        public Projection_Floor_CS()
        {
            objSlider = FindSlider("Index of object");
            desc = "Isolate just the floor.";
        }
        public void RunAlg(Mat src)
        {
            isolate.Run(src);
            dst2 = isolate.dst2;
            dst3 = isolate.dst3;
            labels[2] = isolate.labels[2];
            labels[3] = isolate.labels[3];
            if (objSlider.Value + 1 >= isolate.side.objects.redCells.Count()) return;
            var rc = isolate.top.objects.redCells[objSlider.Value + 1]; // the biggest by default...
            var rowList = new List<int>();
            for (int y = 0; y < rc.rect.Height; y++)
            {
                rowList.Add(dst2[rc.rect].Row(y).CountNonZero() + rc.rect.Y);
            }
            var maxRow = rowList.Max();
            var ranges = vbc.task.rangesSide;
            var floor = (ranges[0].End - ranges[0].Start) * maxRow / dst2.Height + ranges[0].Start;
        }
    }
    public class Moments_Basics_CS : VB_Parent
    {
        public Point2f centroid;
        Foreground_KMeans foreground = new Foreground_KMeans();
        public int scaleFactor = 1;
        public cv.Point offsetPt;
        public Kalman_Basics kalman = new Kalman_Basics();
        public Moments_Basics_CS()
        {
            kalman.kInput = new float[2]; // 2 elements - cv.point
            labels[2] = "Red dot = Kalman smoothed centroid";
            desc = "Compute the centroid of the provided mask file.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                foreground.Run(src);
                dst2 = foreground.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            }
            var m = Cv2.Moments(foreground.dst2, true);
            Point2f center;
            if (vbc.task.gOptions.GetUseKalman())
            {
                kalman.kInput[0] = (float)(m.M10 / m.M00);
                kalman.kInput[1] = (float)(m.M01 / m.M00);
                kalman.Run(src);
                center = new Point2f(kalman.kOutput[0], kalman.kOutput[1]);
            }
            else
            {
                center = new Point2f((float)(m.M10 / m.M00), (float)(m.M01 / m.M00));
            }
            if (standaloneTest()) DrawCircle(dst2, center, vbc.task.DotSize + 5, Scalar.Red);
            centroid = new Point2f(scaleFactor * (offsetPt.X + center.X), scaleFactor * (offsetPt.Y + center.Y));
        }
    }




    public class Moments_CentroidKalman_CS : VB_Parent
    {
        Foreground_KMeans foreground = new Foreground_KMeans();
        Kalman_Basics kalman = new Kalman_Basics();
        public Moments_CentroidKalman_CS()
        {
            kalman.kInput = new float[2]; // 2 elements - cv.point
            labels[2] = "Red dot = Kalman smoothed centroid";
            desc = "Compute the centroid of the foreground depth and smooth with Kalman filter.";
        }
        public void RunAlg(Mat src)
        {
            foreground.Run(src);
            dst2 = foreground.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            var m = Cv2.Moments(foreground.dst2, true);
            if (m.M00 > 5000) // if more than x pixels are present (avoiding a zero area!)
            {
                kalman.kInput[0] = (float)(m.M10 / m.M00);
                kalman.kInput[1] = (float)(m.M01 / m.M00);
                kalman.Run(src);
                DrawCircle(dst2, new cv.Point((int)kalman.kOutput[0], (int)kalman.kOutput[1]), vbc.task.DotSize + 5, Scalar.Red);
            }
        }
    }




    public class Motion_BGSub_CS : VB_Parent
    {
        public BGSubtract_MOG2 bgSub = new BGSubtract_MOG2();
        Motion_Basics_QT_CS motion;
        public Motion_BGSub_CS()
        {
            motion = new Motion_Basics_QT_CS();
            UpdateAdvice(traceName + ": redOptions are used as well as BGSubtract options.");
            desc = "Use floodfill to find all the real motion in an image.";
        }
        public void RunAlg(Mat src)
        {
            bgSub.Run(src);
            motion.RunAlg(bgSub.dst2);
            dst2 = motion.dst2;
            labels[2] = motion.labels[2];
        }
    }





    public class Motion_ThruCorrelation_CS : VB_Parent
    {
        Options_MotionDetect options = new Options_MotionDetect();
        Mat lastFrame = new cv.Mat();
        public Motion_ThruCorrelation_CS()
        {
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Detect motion through the correlation coefficient";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            var input = src.Clone();
            if (input.Channels() != 1) input = input.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) lastFrame = input.Clone();
            dst3.SetTo(0);
            Parallel.For(0, vbc.task.gridRects.Count(), i =>
            {
                cv.Rect roi = vbc.task.gridRects[i];
                Mat correlation = new Mat();
                cv.Scalar mean, stdev;
                Cv2.MeanStdDev(input[roi], out mean, out stdev);
                if (stdev[0] > options.stdevThreshold)
                {
                    Cv2.MatchTemplate(lastFrame[roi], input[roi], correlation, TemplateMatchModes.CCoeffNormed);
                    var mm = GetMinMax(correlation);
                    if (mm.maxVal < options.CCthreshold)
                    {
                        if ((i % vbc.task.gridRows) != 0) dst3[vbc.task.gridRects[i - 1]].SetTo(255);
                        if ((i % vbc.task.gridRows) < vbc.task.gridRows && i < vbc.task.gridRects.Count() - 1) dst3[vbc.task.gridRects[i + 1]].SetTo(255);
                        if (i > vbc.task.gridRows)
                        {
                            dst3[vbc.task.gridRects[i - vbc.task.gridRows]].SetTo(255);
                            dst3[vbc.task.gridRects[i - vbc.task.gridRows + 1]].SetTo(255);
                        }
                        if (i < (vbc.task.gridRects.Count() - vbc.task.gridRows - 1))
                        {
                            dst3[vbc.task.gridRects[i + vbc.task.gridRows]].SetTo(255);
                            dst3[vbc.task.gridRects[i + vbc.task.gridRows + 1]].SetTo(255);
                        }
                        dst3[roi].SetTo(255);
                    }
                }
            });
            lastFrame = input.Clone();
            if (vbc.task.heartBeat) dst2 = src.Clone();
            else src.CopyTo(dst2, dst3);
        }
    }




    public class Motion_CCmerge_CS : VB_Parent
    {
        Mat lastFrame = new cv.Mat();
        Motion_ThruCorrelation motionCC = new Motion_ThruCorrelation();
        public Motion_CCmerge_CS()
        {
            desc = "Use the correlation coefficient to maintain an up-to-date image";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.frameCount < 10) dst2 = src.Clone();
            motionCC.Run(src);
            if (vbc.task.FirstPass) lastFrame = src.Clone();
            if (motionCC.dst3.CountNonZero() > src.Total() / 2)
            {
                dst2 = src.Clone();
                lastFrame = src.Clone();
            }
            src.CopyTo(dst2, motionCC.dst3);
            dst3 = motionCC.dst3;
        }
    }




    public class Motion_PixelDiff_CS : VB_Parent
    {
        public int changedPixels;
        int changeCount, frames;
        Mat lastFrame = new cv.Mat();
        public Motion_PixelDiff_CS()
        {
            desc = "Count the number of changed pixels in the current frame and accumulate them.  If either exceeds thresholds, then set flag = true.  " +
                    "To get the Options Slider, use " + traceName + "QT";
        }
        public void RunAlg(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) lastFrame = src.Clone();
            Cv2.Absdiff(src, lastFrame, dst2);
            dst2 = dst2.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            changedPixels = dst2.CountNonZero();
            vbc.task.motionFlag = changedPixels > 0;
            if (vbc.task.motionFlag) changeCount++;
            frames++;
            if (vbc.task.heartBeat)
            {
                strOut = "Pixels changed = " + changedPixels.ToString() + " at last heartbeat.  Since last heartbeat: " +
                            (changeCount / (float)frames).ToString("0%") + " of frames were different";
                changeCount = 0;
                frames = 0;
            }
            SetTrueText(strOut, 3);
            if (vbc.task.motionFlag) lastFrame = src.Clone();
        }
    }





    public class Motion_Contours_CS : VB_Parent
    {
        public Motion_MinRect motion = new Motion_MinRect();
        Contour_Largest contours = new Contour_Largest();
        public int cumulativePixels;
        public Motion_Contours_CS()
        {
            labels[2] = "Enclosing rectangles are yellow in dst2 and dst3";
            desc = "Detect contours in the motion data and the resulting rectangles";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            motion.Run(src);
            dst3 = motion.dst3;
            var changedPixels = Cv2.CountNonZero(dst3);
            if (vbc.task.heartBeat) cumulativePixels = changedPixels;
            else cumulativePixels += changedPixels;
            if (changedPixels > 0)
            {
                contours.Run(dst3);
                DrawContour(dst2, contours.bestContour, Scalar.Yellow);
            }
        }
    }




    public class Motion_Grid_MP_CS : VB_Parent
    {
        Options_MotionDetect options = new Options_MotionDetect();
        public Motion_Grid_MP_CS()
        {
            UpdateAdvice(traceName + ": local options 'Correlation Threshold' controls how well the image matches.");
            desc = "Detect Motion in the color image using multi-threading.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.heartBeat) dst3 = src.Clone();
            dst2 = src;
            int updateCount = 0;
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                Mat correlation = new Mat();
                Cv2.MatchTemplate(src[roi], dst3[roi], correlation, TemplateMatchModes.CCoeffNormed);
                if (correlation.At<float>(0, 0) < options.CCthreshold)
                {
                    Interlocked.Increment(ref updateCount);
                    src[roi].CopyTo(dst3[roi]);
                    dst2.Rectangle(roi, Scalar.White, vbc.task.lineWidth);
                }
            });
            labels[2] = "Motion added to dst3 for " + updateCount + " segments out of " + vbc.task.gridRects.Count();
            labels[3] = (vbc.task.gridRects.Count() - updateCount) + " segments out of " + vbc.task.gridRects.Count() + " had > " +
                            (options.CCthreshold).ToString("0.0%") + " correlation.";
        }
    }




    public class Motion_Grid_CS : VB_Parent
    {
        Options_MotionDetect options = new Options_MotionDetect();
        public Motion_Grid_CS()
        {
            UpdateAdvice(traceName + ": local options 'Correlation Threshold' controls how well the image matches.");
            desc = "Detect Motion in the color image";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            float CCthreshold = (float)(options.CCthreshold);
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.heartBeat) dst3 = src.Clone();
            List<cv.Rect> roiMotion = new List<cv.Rect>();
            foreach (var roi in vbc.task.gridRects)
            {
                Mat correlation = new Mat();
                Cv2.MatchTemplate(src[roi], dst3[roi], correlation, TemplateMatchModes.CCoeffNormed);
                if (correlation.At<float>(0, 0) < CCthreshold)
                {
                    src[roi].CopyTo(dst3[roi]);
                    roiMotion.Add(roi);
                }
            }
            dst2 = src;
            foreach (var roi in roiMotion)
            {
                dst2.Rectangle(roi, Scalar.White, vbc.task.lineWidth);
            }
            labels[2] = "Motion added to dst3 for " + roiMotion.Count() + " segments out of " + vbc.task.gridRects.Count();
            labels[3] = (vbc.task.gridRects.Count() - roiMotion.Count()) + " segments out of " + vbc.task.gridRects.Count() + " had > " +
                            (options.CCthreshold).ToString("0.0%") + " correlation.";
        }
    }




    public class Motion_Intersect_CS : VB_Parent
    {
        BGSubtract_Basics bgSub = new BGSubtract_Basics();
        int minCount = 4;
        int reconstructedRGB = 0;
        Mat color = new Mat();
        cv.Rect lastMotionRect = new cv.Rect();
        public Motion_Intersect_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            if (dst2.Width == 1280 || dst2.Width == 640) minCount = 16;
            desc = "Track the max rectangle that covers all the motion until there is no motion in it.";
        }
        cv.Rect buildEnclosingRect(Mat tmp)
        {
            List<cv.Rect> rectList = new List<cv.Rect>();
            int[] dots = new int[tmp.Total() * 2];
            Marshal.Copy(tmp.Data, dots, 0, dots.Length);
            List<cv.Point> pointList = new List<cv.Point>();
            for (int i = 0; i < dots.Length; i += 2)
            {
                if (dots[i] >= 1 && dots[i] < dst2.Width - 2 && dots[i + 1] >= 1 && dots[i + 1] < dst2.Height - 2)
                {
                    pointList.Add(new cv.Point(dots[i], dots[i + 1]));
                }
            }
            FloodFillFlags flags = (FloodFillFlags)4 | FloodFillFlags.MaskOnly | FloodFillFlags.FixedRange;
            cv.Rect rect = new cv.Rect();
            Mat motionMat = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            Mat matPoints = dst1[new cv.Rect(1, 1, motionMat.Width - 2, motionMat.Height - 2)];
            foreach (var pt in pointList)
            {
                if (motionMat.At<byte>(pt.Y, pt.X) == 0 && matPoints.At<byte>(pt.Y, pt.X) != 0)
                {
                    int count = matPoints.FloodFill(motionMat, pt, cv.Scalar.All(255), out rect, cv.Scalar.All(0), 
                                                    cv.Scalar.All(0), flags | (FloodFillFlags)(255 << 8));
                    if (count <= minCount) continue;
                    rectList.Add(new cv.Rect(rect.X, rect.Y, rect.Width + 1, rect.Height + 1));
                }
            }
            labels[3] = "There were " + (dots.Length / 2) + " points collected";
            if (rectList.Count() == 0) return new cv.Rect();
            cv.Rect motionRect = rectList[0];
            foreach (var r in rectList)
            {
                motionRect = motionRect.Union(r);
            }
            return motionRect;
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) color = src.Clone();
            if (vbc.task.FirstPass) lastMotionRect = vbc.task.motionRect;
            vbc.task.motionFlag = false;
            if (vbc.task.heartBeat || vbc.task.motionRect.Width * vbc.task.motionRect.Height > src.Total() / 2 || vbc.task.optionsChanged)
            {
                vbc.task.motionFlag = true;
            }
            else
            {
                bgSub.Run(src);
                dst1 = bgSub.dst2;
                Mat tmp = new Mat();
                Cv2.FindNonZero(dst1, tmp);
                if (tmp.Total() > src.Total() / 2)
                {
                    vbc.task.motionFlag = true;
                }
                else if (tmp.Total() > 0)
                {
                    reconstructedRGB += 1;
                    vbc.task.motionRect = buildEnclosingRect(tmp);
                    if (vbc.task.motionRect.IntersectsWith(lastMotionRect)) vbc.task.motionRect = vbc.task.motionRect.Union(lastMotionRect);
                    if (vbc.task.motionRect.Width * vbc.task.motionRect.Height > src.Total() / 2) vbc.task.motionFlag = true;
                }
            }
            dst3.SetTo(0);
            if (vbc.task.motionFlag)
            {
                labels[2] = reconstructedRGB + " frames since last full image";
                reconstructedRGB = 0;
                vbc.task.motionRect = new cv.Rect();
                dst2 = src.Clone();
            }
            if (standaloneTest())
            {
                dst2 = dst1;
                if (vbc.task.motionRect.Width > 0 && vbc.task.motionRect.Height > 0)
                {
                    dst3[vbc.task.motionRect].SetTo(255);
                    src[vbc.task.motionRect].CopyTo(dst2[vbc.task.motionRect]);
                }
            }
            if (standaloneTest())
            {
                if (vbc.task.motionRect.Width > 0 && vbc.task.motionRect.Height > 0)
                {
                    src[vbc.task.motionRect].CopyTo(dst0[vbc.task.motionRect]);
                    color.Rectangle(vbc.task.motionRect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
                }
            }
            lastMotionRect = vbc.task.motionRect;
        }
    }




    public class Motion_RectTest_CS : VB_Parent
    {
        Motion_Enclosing motion = new Motion_Enclosing();
        Diff_Basics diff = new Diff_Basics();
        List<cv.Rect> lastRects = new List<cv.Rect>();
        public Motion_RectTest_CS()
        {
            UpdateAdvice(traceName + ": gOptions frame history slider will impact results.");
            labels[3] = "The white spots show the difference of the constructed image from the current image.";
            desc = "Track the RGB image using Motion_Enclosing to isolate the motion";
        }
        public void RunAlg(Mat src)
        {
            motion.Run(src);
            cv.Rect r = motion.motionRect;
            if (vbc.task.heartBeat || r.Width * r.Height > src.Total() / 2 || vbc.task.frameCount < 50)
            {
                dst2 = src.Clone();
                lastRects.Clear();
            }
            else
            {
                if (r.Width > 0 && r.Height > 0)
                {
                    foreach (var rect in lastRects)
                    {
                        r = r.Union(rect);
                    }
                    src[r].CopyTo(dst2[r]);
                    lastRects.Add(r);
                    if (lastRects.Count() > vbc.task.frameHistoryCount) lastRects.RemoveAt(0);
                }
                else
                {
                    lastRects.Clear();
                }
            }
            if (standaloneTest())
            {
                diff.lastFrame = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                diff.Run(dst2);
                dst3 = diff.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
                dst3.Rectangle(r, vbc.task.HighlightColor, vbc.task.lineWidth, vbc.task.lineType);
            }
        }
    }




    public class Motion_HistoryTest_CS : VB_Parent
    {
        Diff_Basics diff = new Diff_Basics();
        History_Basics frames = new History_Basics();
        public Motion_HistoryTest_CS()
        {
            vbc.task.gOptions.pixelDiffThreshold = 10;
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Detect motion using the last X images";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            diff.Run(src);
            dst1 = diff.dst2.Threshold(0, 1, ThresholdTypes.Binary);
            frames.Run(dst1);
            dst2 = frames.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "Cumulative diff for the last " + vbc.task.frameHistoryCount + " frames";
        }
    }





    public class Motion_Enclosing_CPP_CS : VB_Parent
    {
        RedCloud_Basics redMasks = new RedCloud_Basics();
        double learnRate;
        public cv.Rect motionRect = new cv.Rect();
        public Motion_Enclosing_CPP_CS()
        {
            if (dst2.Width >= 1280) learnRate = 0.5; else learnRate = 0.1; // learn faster with large images (slower frame rate)
            cPtr = BGSubtract_BGFG_Open(4);
            labels[2] = "MOG2 is the best option.  See BGSubtract_Basics to see more options.";
            desc = "Build an enclosing rectangle for the motion";
        }
        public void RunAlg(Mat src)
        {
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = BGSubtract_BGFG_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels(), learnRate);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Threshold(0, 255, ThresholdTypes.Binary);
            redMasks.inputMask = ~dst2;
            redMasks.Run(dst2);
            motionRect = new cv.Rect();
            if (vbc.task.redCells.Count() < 2) return;
            motionRect = vbc.task.redCells[1].rect;
            for (int i = 2; i < vbc.task.redCells.Count(); i++)
            {
                var cell = vbc.task.redCells[i];
                motionRect = motionRect.Union(cell.rect);
            }
            if (motionRect.Width > dst2.Width / 2 && motionRect.Height > dst2.Height / 2)
            {
                motionRect = new cv.Rect(0, 0, dst2.Width, dst2.Height);
            }
            dst2.Rectangle(motionRect, cv.Scalar.All(255), vbc.task.lineWidth, vbc.task.lineType);
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = BGSubtract_BGFG_Close(cPtr);
        }
    }





    public class Motion_Basics_QT_CS : VB_Parent
    {
        RedCloud_Basics redMasks = new RedCloud_Basics();
        public BGSubtract_MOG2 bgSub = new BGSubtract_MOG2();
        List<cv.Rect> rectList = new List<cv.Rect>();
        public Motion_Basics_QT_CS()
        {
            vbc.task.redOptions.setIdentifyCells(false);
            desc = "The option-free version of Motion_BGSub";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.motionDetected = true;
            if (vbc.task.heartBeat)
            {
                vbc.task.motionRect = new cv.Rect(0, 0, dst2.Width, dst2.Height);
                return;
            }
            vbc.task.motionRect = new cv.Rect();
            if (src.Channels() != 1)
            {
                bgSub.Run(src);
                src = bgSub.dst2;
            }
            dst2 = src;
            redMasks.Run(src.Threshold(0, 255, ThresholdTypes.Binary));
            if (vbc.task.redCells.Count() < 2)
            {
                vbc.task.motionDetected = false;
                rectList.Clear();
            }
            else
            {
                var nextRect = vbc.task.redCells[1].rect;
                for (int i = 2; i < vbc.task.redCells.Count(); i++)
                {
                    var rc = vbc.task.redCells[i];
                    nextRect = nextRect.Union(rc.rect);
                }
                rectList.Add(nextRect);
                foreach (var r in rectList)
                {
                    if (vbc.task.motionRect.Width == 0) vbc.task.motionRect = r; else vbc.task.motionRect = vbc.task.motionRect.Union(r);
                }
                if (rectList.Count() > vbc.task.frameHistoryCount) rectList.RemoveAt(0);
                if (vbc.task.motionRect.Width > dst2.Width / 2 && vbc.task.motionRect.Height > dst2.Height / 2)
                {
                    vbc.task.motionRect = new cv.Rect(0, 0, dst2.Width, dst2.Height);
                }
                else
                {
                    if (vbc.task.motionRect.Width == 0 || vbc.task.motionRect.Height == 0) vbc.task.motionDetected = false;
                }
            }
            if (standaloneTest())
            {
                dst2.Rectangle(vbc.task.motionRect, cv.Scalar.All(255), vbc.task.lineWidth);
                if (vbc.task.redCells.Count() > 1)
                {
                    labels[2] = vbc.task.redCells.Count().ToString() + " RedMask cells had motion";
                }
                else
                {
                    labels[2] = "No motion detected";
                }
                labels[3] = "";
                if (vbc.task.motionRect.Width > 0)
                {
                    labels[3] = "Rect width = " + vbc.task.motionRect.Width + ", height = " + vbc.task.motionRect.Height;
                }
            }
        }
    }




    public class Motion_PointCloud_CS : VB_Parent
    {
        Diff_Depth32f diff = new Diff_Depth32f();
        public Motion_PointCloud_CS()
        {
            labels = new string[] { "", "Output of MotionRect_Basics showing motion and enclosing rectangle.", "MotionRect point cloud", "Diff of MotionRect Pointcloud and latest pointcloud" };
            desc = "Display the pointcloud after updating only the motion rectangle.  Resync every heartbeat.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.motionDetected) vbc.task.pointCloud[vbc.task.motionRect].CopyTo(dst2[vbc.task.motionRect]);
            if (standaloneTest())
            {
                if (diff.lastDepth32f.Width == 0) diff.lastDepth32f = vbc.task.pcSplit[2].Clone();
                diff.Run(vbc.task.pcSplit[2]);
                dst3 = diff.dst2;
                dst3.Rectangle(vbc.task.motionRect, cv.Scalar.All(255), vbc.task.lineWidth);
                diff.lastDepth32f = vbc.task.pcSplit[2];
            }
        }
    }




    public class Motion_Color_CS : VB_Parent
    {
        public Motion_Color_CS()
        {
            labels = new string[] { "", "MotionRect_Basics output showing motion and enclosing rectangle.", "MotionRect accumulated color image", "Diff of input and latest accumulated color image" };
            desc = "Display the color image after updating only the motion rectangle.  Resync every heartbeat.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.motionDetected) src[vbc.task.motionRect].CopyTo(dst2[vbc.task.motionRect]);
            if (standaloneTest() && vbc.task.motionDetected) dst2.Rectangle(vbc.task.motionRect, Scalar.White, vbc.task.lineWidth);
        }
    }




    public class Motion_Diff_CS : VB_Parent
    {
        public Motion_Diff_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Unstable mask", "Pixel difference" };
            desc = "Capture an image and use absDiff/threshold to compare it to the last snapshot";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.heartBeat)
            {
                dst1 = src.Clone();
                dst2.SetTo(0);
            }
            Cv2.Absdiff(src, dst1, dst3);
            dst2 = dst3.Threshold(vbc.task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
        }
    }




    public class Motion_MinRect_CS : VB_Parent
    {
        public Motion_Diff motion = new Motion_Diff();
        Area_MinRect mRect = new Area_MinRect();
        public Motion_MinRect_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find the nonzero points of motion and fit an rotated rectangle to them.";
        }
        public void RunAlg(Mat src)
        {
            motion.Run(src);
            dst2 = motion.dst2;
            var nonzeros = dst2.FindNonZero();
            if (vbc.task.heartBeat) dst3.SetTo(0);
            if (nonzeros.Rows > 5)
            {
                List<int> ptx = new List<int>();
                List<int> pty = new List<int>();
                List<cv.Point> inputPoints = new List<cv.Point>();
                for (int i = 0; i < nonzeros.Rows; i++)
                {
                    cv.Point pt = nonzeros.Get<cv.Point>(i, 0);
                    inputPoints.Add(pt);
                    ptx.Add(pt.X);
                    pty.Add(pt.Y);
                }
                cv.Point p1 = inputPoints[ptx.IndexOf(ptx.Max())];
                cv.Point p2 = inputPoints[ptx.IndexOf(ptx.Min())];
                cv.Point p3 = inputPoints[pty.IndexOf(pty.Max())];
                cv.Point p4 = inputPoints[pty.IndexOf(pty.Min())];
                mRect.inputPoints = new List<Point2f> { p1, p2, p3, p4 };
                mRect.Run(empty);
                DrawRotatedRect(mRect.minRect, dst3, Scalar.White);
            }
        }
    }




    public class Motion_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Motion_RedCloud_CS()
        {
            labels[3] = "Motion detected in the cells below";
            desc = "Use RedCloud to define where there is motion";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.motionPixels > 0) dst3[rc.rect].SetTo(rc.naturalColor, rc.mask);
            }
        }
    }




    public class Mouse_Basics_CS : VB_Parent
    {
        cv.Point lastPoint = new cv.Point();
        int colorIndex;
        public Mouse_Basics_CS()
        {
            labels[2] = "Move the mouse below to show mouse tracking.";
            desc = "Test the mousePoint interface";
        }
        public void RunAlg(Mat src)
        {
            // only display mouse movement in the lower left image (pic.tag = 2)
            if (lastPoint == vbc.task.mouseMovePoint || vbc.task.mousePicTag != 2) return;
            lastPoint = vbc.task.mouseMovePoint;
            Scalar nextColor = vbc.task.scalarColors[colorIndex];
            cv.Point nextPt = vbc.task.mouseMovePoint;
            DrawCircle(dst2, nextPt, vbc.task.DotSize + 3, nextColor);
            colorIndex++;
            if (colorIndex >= vbc.task.scalarColors.Count()) colorIndex = 0;
        }
    }




    public class Mouse_LeftClickZoom_CS : VB_Parent
    {
        public Mouse_LeftClickZoom_CS()
        {
            labels[2] = "Left click and drag to draw a rectangle";
            desc = "Demonstrate what the left-click enables";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("Left-click and drag to select a region in any of the images." + "\n" +
                        "The selected area is a rectangle that is saved in vbc.task.drawRect." + "\n" +
                        "In this example, the selected region from the BGR image will be resized to fit in the Result2 image to the right." + "\n" +
                        "Double-click an image to remove the selected region.");
            if (vbc.task.drawRect.Width != 0 && vbc.task.drawRect.Height != 0)
                dst3 = src[vbc.task.drawRect].Resize(dst3.Size());
        }
    }




    public class Mouse_ClickPointUsage_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        public Mouse_ClickPointUsage_CS()
        {
            desc = "This algorithm shows how to use vbc.task.ClickPoint to dynamically identify what to break on.";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("Click on one of the feature points (carefully) to hit the breakpoint below.");
            feat.Run(src);
            dst2 = feat.dst2;
            foreach (var pt in vbc.task.features)
            {
                if (pt == vbc.task.ClickPoint)
                {
                    Debug.WriteLine("Hit the point you selected.");
                }
            }
        }
    }




    public class MSER_Basics_CS : VB_Parent
    {
        MSER_CPP_VB detect = new MSER_CPP_VB();
        public List<rcData> mserCells = new List<rcData>();
        public List<cv.Point> floodPoints = new List<cv.Point>();
        public MSER_Basics_CS()
        {
            desc = "Create cells for each region in MSER output";
        }
        public void RunAlg(Mat src)
        {
            detect.Run(src);
            var boxInput = new List<cv.Rect>(detect.boxes);
            var boxes = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < boxInput.Count(); i++)
            {
                var r = boxInput[i];
                boxes.Add(r.Width * r.Height, i);
            }
            floodPoints = new List<cv.Point>(detect.floodPoints);
            var sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            var matched = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
            dst0 = detect.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            for (int i = 0; i < boxes.Count(); i++)
            {
                var index = boxes.ElementAt(i).Value;
                var rc = new rcData();
                rc.rect = boxInput[index];
                var val = dst0.Get<byte>(floodPoints[index].Y, floodPoints[index].X);
                rc.mask = dst0[rc.rect].InRange(val, val);
                rc.pixels = detect.maskCounts[index];
                rc.contour = ContourBuild(rc.mask, ContourApproximationModes.ApproxNone);
                DrawContour(rc.mask, rc.contour, cv.Scalar.All(255), -1);
                rc.floodPoint = floodPoints[index];
                rc.maxDist = GetMaxDist(ref rc);
                rc.indexLast = vbc.task.cellMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                if (rc.indexLast != 0 && rc.indexLast < vbc.task.redCells.Count())
                {
                    var lrc = vbc.task.redCells[rc.indexLast];
                    rc.maxDStable = lrc.maxDStable;
                    rc.color = lrc.color;
                    matched.Add(rc.indexLast, rc.indexLast);
                }
                else
                {
                    rc.maxDStable = rc.maxDist;
                }
                cv.Scalar mean, stdev;
                Cv2.MeanStdDev(vbc.task.color[rc.rect], out mean, out stdev, rc.mask);
                rc.colorMean = mean;
                rc.colorStdev = stdev;
                rc.naturalColor = new Vec3b((byte)rc.colorMean[0], (byte)rc.colorMean[1], (byte)rc.colorMean[2]);
                if (rc.pixels > 0) sortedCells.Add(rc.pixels, rc);
            }
            dst2 = RebuildCells(sortedCells);
            labels[2] = vbc.task.redCells.Count().ToString() + " cells were identified and " + matched.Count().ToString() + " were matched.";
        }
    }




    public class MSER_Detect_CS : VB_Parent
    {
        public cv.Rect[] boxes;
        public cv.Point[][] regions;
        public MSER mser = MSER.Create();
        public Options_MSER options = new Options_MSER();
        public int classCount;
        public MSER_Detect_CS()
        {
            desc = "Run the core MSER (Maximally Stable Extremal Region) algorithm";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            if (vbc.task.optionsChanged)
            {
                mser = MSER.Create(options.delta, options.minArea, options.maxArea, options.maxVariation, options.minDiversity,
                                    options.maxEvolution, options.areaThreshold, options.minMargin, options.edgeBlurSize);
                mser.Pass2Only = options.pass2Setting != 0 ? true : false;
            }
            if (options.graySetting && src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            mser.DetectRegions(src, out regions, out boxes);
            classCount = boxes.Length;
            foreach (var z in boxes)
            {
                dst2.Rectangle(z, Scalar.Yellow, 1);
            }
        }
    }




    public class MSER_SyntheticInput_CS : VB_Parent
    {
        void addNestedRectangles(Mat img, cv.Point p0, int[] width, int[] color, int n)
        {
            for (int i = 0; i < n; i++)
            {
                img.Rectangle(new cv.Rect(p0.X, p0.Y, width[i], width[i]), cv.Scalar.All(color[i]), 1);
                p0 += new cv.Point((width[i] - width[i + 1]) / 2, (width[i] - width[i + 1]) / 2);
                img.FloodFill(p0, cv.Scalar.All(color[i]));
            }
        }
        void addNestedCircles(Mat img, cv.Point p0, int[] width, int[] color, int n)
        {
            for (int i = 0; i < n; i++)
            {
                DrawCircle(img, p0, width[i] / 2, cv.Scalar.All(color[i]));
                img.FloodFill(p0, cv.Scalar.All(color[i]));
            }
        }
        public MSER_SyntheticInput_CS()
        {
            desc = "Build a synthetic image for MSER (Maximal Stable Extremal Regions) testing";
        }
        public void RunAlg(Mat src)
        {
            var img = new Mat(800, 800, MatType.CV_8U, cv.Scalar.All(0));
            int[] width = { 390, 380, 300, 290, 280, 270, 260, 250, 210, 190, 150, 100, 80, 70 };
            int[] color1 = { 80, 180, 160, 140, 120, 100, 90, 110, 170, 150, 140, 100, 220 };
            int[] color2 = { 81, 181, 161, 141, 121, 101, 91, 111, 171, 151, 141, 101, 221 };
            int[] color3 = { 175, 75, 95, 115, 135, 155, 165, 145, 85, 105, 115, 155, 35 };
            int[] color4 = { 173, 73, 93, 113, 133, 153, 163, 143, 83, 103, 113, 153, 33 };
            addNestedRectangles(img, new cv.Point(10, 10), width, color1, 13);
            addNestedCircles(img, new cv.Point(200, 600), width, color2, 13);
            addNestedRectangles(img, new cv.Point(410, 10), width, color3, 13);
            addNestedCircles(img, new cv.Point(600, 600), width, color4, 13);
            img = img.Resize(new cv.Size(src.Rows, src.Rows));
            dst2[new cv.Rect(0, 0, src.Rows, src.Rows)] = img.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }




    public class MSER_LeftRight_CS : VB_Parent
    {
        MSER_Left left = new MSER_Left();
        MSER_Right right = new MSER_Right();
        public MSER_LeftRight_CS()
        {
            labels = new string[] { "", "", "MSER_Basics output for left camera", "MSER_Basics output for right camera" };
            desc = "Test MSER (Maximally Stable Extremal Region) algorithm on the left and right views.";
        }
        public void RunAlg(Mat src)
        {
            left.Run(vbc.task.leftView);
            dst2 = left.dst2;
            labels[2] = left.labels[2];
            right.Run(vbc.task.rightView);
            dst3 = right.dst2;
            labels[3] = right.labels[2];
        }
    }




    public class MSER_Left_CS : VB_Parent
    {
        MSER_Basics mBase = new MSER_Basics();
        public MSER_Left_CS()
        {
            labels = new string[] { "", "", "MSER_Basics output for left camera", "MSER_Basics rectangles found" };
            desc = "Test MSER (Maximally Stable Extremal Region) algorithm on the left and right views.";
        }
        public void RunAlg(Mat src)
        {
            mBase.Run(vbc.task.leftView);
            dst2 = mBase.dst2;
            dst3 = mBase.dst3;
            labels[2] = mBase.labels[2];
        }
    }




    public class MSER_Right_CS : VB_Parent
    {
        MSER_Basics mBase = new MSER_Basics();
        public MSER_Right_CS()
        {
            labels = new string[] { "", "", "MSER_Basics output for right camera", "MSER_Basics rectangles found" };
            desc = "Test MSER (Maximally Stable Extremal Region) algorithm on the left and right views.";
        }
        public void RunAlg(Mat src)
        {
            mBase.Run(vbc.task.rightView);
            dst2 = mBase.dst2;
            dst3 = mBase.dst3;
            labels[2] = mBase.labels[2];
        }
    }




    public class MSER_Hulls_CS : VB_Parent
    {
        Options_MSER options = new Options_MSER();
        MSER_Basics mBase = new MSER_Basics();
        public MSER_Hulls_CS()
        {
            desc = "Use MSER (Maximally Stable Extremal Region) but show the contours of each region.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            mBase.Run(src);
            dst2 = mBase.dst2;
            int pixels = 0;
            dst3.SetTo(0);
            foreach (var rc in mBase.mserCells)
            {
                rc.hull = Cv2.ConvexHull(rc.contour.ToArray(), true).ToList();
                pixels += rc.pixels;
                DrawContour(dst3[rc.rect], rc.hull, vecToScalar(rc.color), -1);
            }
            if (vbc.task.heartBeat) labels[2] = mBase.mserCells.Count() + " Regions with average size " + (mBase.mserCells.Count() > 0 ?
                (pixels / mBase.mserCells.Count()).ToString() : "0");
        }
    }




    public class MSER_TestSynthetic_CS : VB_Parent
    {
        Options_MSER options = new Options_MSER();
        MSER_SyntheticInput synth = new MSER_SyntheticInput();
        MSER_Basics mBase = new MSER_Basics();
        public MSER_TestSynthetic_CS()
        {
            FindCheckBox("Use grayscale input").Checked = true;
            labels = new string[] { "", "", "Synthetic input", "Output from MSER (Maximally Stable Extremal Region)" };
            desc = "Test MSER (Maximally Stable Extremal Region) with the synthetic image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            synth.Run(src);
            dst2 = synth.dst2.Clone();
            mBase.Run(dst2);
            dst3 = mBase.dst3;
        }
    }




    public class MSER_Grayscale_CS : VB_Parent
    {
        MSER_Basics mBase = new MSER_Basics();
        Reduction_Basics reduction = new Reduction_Basics();
        public MSER_Grayscale_CS()
        {
            FindCheckBox("Use grayscale input").Checked = true;
            desc = "Run MSER (Maximally Stable Extremal Region) with grayscale input";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            mBase.Run(reduction.dst2);
            dst2 = mBase.dst3;
            labels[2] = mBase.labels[2];
        }
    }




    public class MSER_ReducedRGB_CS : VB_Parent
    {
        MSER_Basics mBase = new MSER_Basics();
        Reduction_BGR reduction = new Reduction_BGR();
        public MSER_ReducedRGB_CS()
        {
            FindCheckBox("Use grayscale input").Checked = false;
            desc = "Run MSER (Maximally Stable Extremal Region) with a reduced RGB input";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            mBase.Run(reduction.dst2);
            dst2 = mBase.dst3;
            labels[2] = mBase.labels[2];
        }
    }




    public class MSER_ROI_CS : VB_Parent
    {
        public List<cv.Rect> containers = new List<cv.Rect>();
        Options_MSER options = new Options_MSER();
        MSER_Detect core = new MSER_Detect();
        public MSER_ROI_CS()
        {
            desc = "Identify the main regions of interest with MSER (Maximally Stable Extremal Region)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            dst3 = src.Clone();
            core.Run(src);
            var sortedBoxes = new SortedList<int, cv.Rect>(new CompareAllowIdenticalIntegerInverted());
            foreach (var box in core.boxes)
            {
                sortedBoxes.Add(box.Width * box.Height, box);
            }
            var boxList = new List<cv.Rect>();
            for (int i = 0; i < sortedBoxes.Count(); i++)
            {
                boxList.Add(sortedBoxes.ElementAt(i).Value);
            }
            containers.Clear();
            while (boxList.Count() > 0)
            {
                var box = boxList[0];
                containers.Add(box);
                var removeBoxes = new List<int>();
                for (int i = 0; i < boxList.Count(); i++)
                {
                    var b = boxList[i];
                    var center = new cv.Point((int)(b.X + b.Width / 2), (int)(b.Y + b.Height / 2));
                    if (center.X >= box.X && center.X <= (box.X + box.Width) && center.Y >= box.Y && center.Y <= (box.Y + box.Height))
                    {
                        removeBoxes.Add(i);
                        dst3.Rectangle(b, vbc.task.HighlightColor, vbc.task.lineWidth);
                    }
                }
                for (int i = removeBoxes.Count() - 1; i >= 0; i--)
                {
                    boxList.RemoveAt(removeBoxes[i]);
                }
            }
            foreach (var rect in containers)
            {
                dst2.Rectangle(rect, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
            labels[2] = containers.Count().ToString() + " consolidated regions of interest located";
            labels[3] = sortedBoxes.Count().ToString() + " total rectangles found with MSER";
        }
    }




    public class MSER_TestExample_CS : VB_Parent
    {
        Mat image;
        MSER mser;
        Options_MSER options = new Options_MSER();
        public MSER_TestExample_CS()
        {
            labels[2] = "Contour regions from MSER";
            labels[3] = "Box regions from MSER";
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Maximally Stable Extremal Regions example - still image";
            image = Cv2.ImRead(vbc.task.HomeDir + "Data/MSERtestfile.jpg", ImreadModes.Color);
            mser = MSER.Create();
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            cv.Point[][] regions;
            cv.Rect[] boxes;
            dst0 = image.Clone();
            dst2 = image.Clone();
            dst3 = image.Clone();
            if (vbc.task.optionsChanged)
            {
                mser = MSER.Create(options.delta, options.minArea, options.maxArea, options.maxVariation, options.minDiversity,
                                    options.maxEvolution, options.areaThreshold, options.minMargin, options.edgeBlurSize);
                mser.Pass2Only = options.pass2Setting != 0 ? true : false;
            }
            mser.DetectRegions(dst2, out regions, out boxes);
            int index = 0;
            foreach (var pts in regions)
            {
                var color = vbc.task.vecColors[index % 256];
                foreach (var pt in pts)
                {
                    dst2.Set<Vec3b>(pt.Y, pt.X, color);
                }
                index++;
            }
            foreach (var box in boxes)
            {
                dst3.Rectangle(box, vbc.task.HighlightColor, vbc.task.lineWidth + 1, vbc.task.lineType);
            }
            labels[2] = boxes.Length.ToString() + " regions were found using MSER";
        }
    }




    public class MSER_RedCloud_CS : VB_Parent
    {
        MSER_Basics mBase = new MSER_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public MSER_RedCloud_CS()
        {
            desc = "Use the MSER_Basics output as input to RedCloud_Basics";
        }
        public void RunAlg(Mat src)
        {
            mBase.Run(src);
            redC.Run(mBase.dst2.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class MSER_Mask_CPP_CS : VB_Parent
    {
        Options_MSER options = new Options_MSER();
        RedCloud_Cells redC = new RedCloud_Cells();
        public int classCount;
        public MSER_Mask_CPP_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            FindCheckBox("Use grayscale input").Checked = false;
            options.RunOpt();
            cPtr = MSER_Open(options.delta, options.minArea, options.maxArea, (float)options.maxVariation,
                             (float)options.minDiversity, options.maxEvolution, (float)options.areaThreshold,
                              (float)options.minMargin, options.edgeBlurSize, options.pass2Setting);
            desc = "MSER in a nutshell: intensity threshold, stability, maximize region, adaptive threshold.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.optionsChanged)
            {
                MSER_Close(cPtr);
                cPtr = MSER_Open(options.delta, options.minArea, options.maxArea, (float)options.maxVariation,
                                 (float)options.minDiversity, options.maxEvolution, (float)options.areaThreshold,
                                 (float)options.minMargin, options.edgeBlurSize, options.pass2Setting);
            }
            if (options.graySetting && src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.heartBeat)
            {
                byte[] cppData = new byte[src.Total() * src.ElemSize()];
                Marshal.Copy(src.Data, cppData, 0, cppData.Length);
                var handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
                IntPtr imagePtr = MSER_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels());
                handleSrc.Free();
                classCount = MSER_Count(cPtr);
                if (classCount == 0) return;
                dst3 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).InRange(255, 255);
            }
            labels[3] = classCount.ToString() + " regions identified";
            src.SetTo(Scalar.White, dst3);
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
        public void Close()
        {
            MSER_Close(cPtr);
        }
    }




    public class MSER_Binarize_CS : VB_Parent
    {
        MSER_Basics mser = new MSER_Basics();
        Bin4Way_Regions bin4 = new Bin4Way_Regions();
        public MSER_Binarize_CS()
        {
            desc = "Instead of a BGR src, try using the color output of Bin4Way_Regions";
        }
        public void RunAlg(Mat src)
        {
            bin4.Run(src);
            dst2 = ShowPalette(bin4.dst2 * 255 / 4);
            mser.Run(dst2);
            dst3 = mser.dst2;
            labels[3] = mser.labels[2];
        }
    }




    public class MSER_Basics1_CS : VB_Parent
    {
        MSER_CPP_VB detect = new MSER_CPP_VB();
        RedCloud_Basics flood = new RedCloud_Basics();
        public MSER_Basics1_CS()
        {
            desc = "Create cells for each region in MSER output";
        }
        public void RunAlg(Mat src)
        {
            detect.Run(src);
            dst3 = detect.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            flood.Run(dst3);
            dst2 = flood.dst2;
            labels[2] = flood.labels[2];
        }
    }




    public class MSER_BasicsNew_CS : VB_Parent
    {
        MSER_CPP_VB detect = new MSER_CPP_VB();
        int displaycount;
        public MSER_BasicsNew_CS()
        {
            desc = "Create cells for each region in MSER output";
        }
        public void RunAlg(Mat src)
        {
            detect.Run(src);
            var boxInput = new List<cv.Rect>(detect.boxes);
            var boxes = new SortedList<int, cv.Rect>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < boxInput.Count(); i++)
            {
                var r = boxInput[i];
                boxes.Add(r.Width * r.Height, r);
            }
            dst3 = src;
            for (int i = 0; i < boxes.Count(); i++)
            {
                var r = boxes.ElementAt(i).Value;
                dst3.Rectangle(r, vbc.task.HighlightColor, vbc.task.lineWidth);
                if (i >= displaycount) break;
            }
            if (vbc.task.heartBeat)
            {
                labels[2] = "Displaying the largest " + displaycount + " rectangles out of " + boxes.Count() + " found";
                if (displaycount >= boxes.Count()) displaycount = 0;
            }
        }
    }




    public class MSER_Basics2_CS : VB_Parent
    {
        MSER_CPP_VB detect = new MSER_CPP_VB();
        Mat cellMap;
        public MSER_Basics2_CS()
        {
            cellMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Create cells for each region in MSER output";
        }
        public void RunAlg(Mat src)
        {
            detect.Run(src);
            dst3 = detect.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            var floodPoints = new List<cv.Point>(detect.floodPoints);
            var boxInput = new List<cv.Rect>(detect.boxes);
            var boxes = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < boxInput.Count(); i++)
            {
                var r = boxInput[i];
                boxes.Add(r.Width * r.Height, i);
            }
            var redCells = new List<rcData> { new rcData() };
            dst1.SetTo(0);
            dst2.SetTo(0);
            var lastMap = cellMap.Clone();
            cellMap.SetTo(0);
            int matchCount = 0;
            for (int i = 0; i < floodPoints.Count(); i++)
            {
                var rc = new rcData
                {
                    index = redCells.Count(),
                    floodPoint = floodPoints[i]
                };
                var val = dst3.Get<byte>(rc.floodPoint.Y, rc.floodPoint.X);
                rc.rect = boxInput[boxes.ElementAt(i).Value];
                rc.mask = dst3[rc.rect].InRange(val, val);
                dst1[rc.rect].SetTo(rc.index, rc.mask);
                rc.pixels = detect.maskCounts[i];
                rc.maxDist = GetMaxDist(ref rc);
                rc.indexLast = lastMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                cv.Scalar mean, stdev;
                Cv2.MeanStdDev(vbc.task.color[rc.rect], out mean, out stdev, rc.mask);
                rc.colorMean = mean;
                rc.colorStdev = stdev;
                rc.color = new Vec3b((byte)rc.colorMean[0], (byte)rc.colorMean[1], (byte)rc.colorMean[2]);
                if (rc.indexLast != 0) matchCount++;
                redCells.Add(rc);
                cellMap[rc.rect].SetTo(rc.index, rc.mask);
                dst2[rc.rect].SetTo(rc.color, rc.mask);
            }
            if (vbc.task.heartBeat) labels[2] = detect.labels[2] + " and " + matchCount + " were matched to the previous frame";
        }
    }




    public class MSER_CPP_CS : VB_Parent
    {
        Options_MSER options = new Options_MSER();
        public List<cv.Rect> boxes = new List<cv.Rect>();
        public List<cv.Point> floodPoints = new List<cv.Point>();
        public List<int> maskCounts = new List<int>();
        public int classcount;
        public MSER_CPP_CS()
        {
            FindCheckBox("Use grayscale input").Checked = false;
            options.RunOpt();
            cPtr = MSER_Open(options.delta, options.minArea, options.maxArea, (float)options.maxVariation,
                             (float)options.minDiversity, options.maxEvolution, (float)options.areaThreshold,
                              (float)options.minMargin, options.edgeBlurSize, (int)options.pass2Setting);
            desc = "C++ version of MSER basics.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.optionsChanged)
            {
                MSER_Close(cPtr);
                cPtr = MSER_Open(options.delta, options.minArea, options.maxArea, (float)options.maxVariation,
                                 (float)options.minDiversity, options.maxEvolution, (float)options.areaThreshold,
                                  (float)options.minMargin, options.edgeBlurSize, options.pass2Setting);
            }
            if (options.graySetting && src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            var handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            var imagePtr = MSER_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels());
            handleSrc.Free();
            dst0 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();
            classcount = MSER_Count(cPtr);
            if (classcount == 0) return;
            var ptData = cv.Mat.FromPixelData(classcount, 1, MatType.CV_32SC2, MSER_FloodPoints(cPtr));
            var maskData = cv.Mat.FromPixelData(classcount, 1, MatType.CV_32S, MSER_MaskCounts(cPtr));
            var rectData = cv.Mat.FromPixelData(classcount, 1, MatType.CV_32SC4, MSER_Rects(cPtr));
            var sortedBoxes = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
            var rects = new List<cv.Rect>();
            for (int i = 0; i < classcount; i++)
            {
                var r = rectData.Get<cv.Rect>(i, 0);
                if (rects.Contains(r)) continue;
                rects.Add(r);
                sortedBoxes.Add(r.Width * r.Height, i);
            }
            boxes.Clear();
            floodPoints.Clear();
            maskCounts.Clear();
            for (int i = 0; i < sortedBoxes.Count(); i++)
            {
                var index = sortedBoxes.ElementAt(i).Value;
                boxes.Add(rectData.Get<cv.Rect>(index, 0));
                floodPoints.Add(ptData.Get<cv.Point>(index, 0));
                maskCounts.Add(maskData.Get<int>(index, 0));
            }
            dst2 = ShowPalette(dst0 * 255 / classcount);
            if (standaloneTest())
            {
                dst3 = src;
                for (int i = 0; i < boxes.Count(); i++)
                {
                    dst3.Rectangle(boxes[i], vbc.task.HighlightColor, vbc.task.lineWidth);
                    if (i < vbc.task.redOptions.identifyCount) SetTrueText((i + 1).ToString(), boxes[i].TopLeft, 3);
                }
            }
            labels[2] = classcount + " regions identified";
        }
        public void Close()
        {
            MSER_Close(cPtr);
        }
    }




    public class MultiDimensionScaling_Cities_CS : VB_Parent
    {
        double[] CityDistance = { // 10x10 array of distances for 10 cities
    0, 587, 1212, 701, 1936, 604, 748, 2139, 2182, 543,       // Atlanta
    587, 0, 920, 940, 1745, 1188, 713, 1858, 1737, 597,       // Chicago
    1212, 920, 0, 879, 831, 1726, 1631, 949, 1021, 1494,      // Denver
    701, 940, 879, 0, 1734, 968, 1420, 1645, 1891, 1220,      // Houston
    1936, 1745, 831, 1734, 0, 2339, 2451, 347, 959, 2300,     // Los Angeles
    604, 1188, 1726, 968, 2339, 0, 1092, 2594, 2734, 923,     // Miami
    748, 713, 1631, 1420, 2451, 1092, 0, 2571, 2408, 205,     // New York
    2139, 1858, 949, 1645, 347, 2594, 2571, 0, 678, 2442,     // San Francisco
    2182, 1737, 1021, 1891, 959, 2734, 2408, 678, 0, 2329,    // Seattle
    543, 597, 1494, 1220, 2300, 923, 205, 2442, 2329, 0};      // Washington D.C.
        public MultiDimensionScaling_Cities_CS()
        {
            labels[2] = "Resulting solution using cv.Eigen";
            desc = "Use OpenCV's Eigen function to solve a system of equations";
        }
        double Torgerson(Mat src)
        {
            int rows = src.Rows;
            mmData mm = GetMinMax(src);
            double c1 = 0;
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < rows; j++)
                {
                    for (int k = 0; k < rows; k++)
                    {
                        double v = src.At<double>(i, k) - src.At<double>(i, j) - src.At<double>(j, k);
                        if (v > c1) c1 = v;
                    }
                }
            }
            return Math.Max(Math.Max(c1, mm.maxVal), 0);
        }
        Mat CenteringMatrix(int n)
        {
            return Mat.Eye(n, n, MatType.CV_64F) - cv.Scalar.All(1.0 / n);
        }
        public void RunAlg(Mat src)
        {
            int size = 10; // we are working with 10 cities.
            Mat cityMat = cv.Mat.FromPixelData(size, size, MatType.CV_64FC1, CityDistance);
            cityMat += cv.Scalar.All(Torgerson(cityMat));
            cityMat = cityMat.Mul(cityMat);
            Mat g = CenteringMatrix(size);
            // calculates the inner product matrix b
            Mat b = g * cityMat * g.Transpose() * -0.5;
            Mat vectors = new Mat(size, size, MatType.CV_64F);
            Mat values = new Mat(size, 1, MatType.CV_64F);
            Cv2.Eigen(b, values, vectors);
            values.Threshold(0, 0, ThresholdTypes.Tozero);
            Mat result = vectors.RowRange(0, 2);
            var at = result.GetGenericIndexer<double>();
            for (int r = 0; r < result.Rows; r++)
            {
                for (int c = 0; c < result.Cols; c++)
                {
                    at[r, c] *= Math.Sqrt(values.At<double>(r));
                }
            }
            result.Normalize(0, 800, NormTypes.MinMax);
            at = result.GetGenericIndexer<double>();
            double maxX = 0, maxY = 0, minX = double.MaxValue, minY = double.MaxValue;
            for (int c = 0; c < size; c++)
            {
                double x = -at[0, c];
                double y = at[1, c];
                if (maxX < x) maxX = x;
                if (maxY < y) maxY = y;
                if (minX > x) minX = x;
                if (minY > y) minY = y;
            }
            int w = dst2.Width;
            int h = dst2.Height;
            dst2.SetTo(0);
            string cityName = "Atlanta";
            for (int c = 0; c < size; c++)
            {
                double x = -at[0, c];
                double y = at[1, c];
                x = w * 0.1 + 0.7 * w * (x - minX) / (maxX - minX);
                y = h * 0.1 + 0.7 * h * (y - minY) / (maxY - minY);
                DrawCircle(dst2, new cv.Point(x, y), vbc.task.DotSize + 3, Scalar.Red);
                cv.Point textPos = new cv.Point(x + 5, y + 10);
                if (c == 1) cityName = "Chicago";
                if (c == 2) cityName = "Denver";
                if (c == 3) cityName = "Houston";
                if (c == 4) cityName = "Los Angeles";
                if (c == 5) cityName = "Miami";
                if (c == 6) cityName = "New York";
                if (c == 7) cityName = "San Francisco";
                if (c == 8) cityName = "Seattle";
                if (c == 9) cityName = "Washington D.C.";
                SetTrueText(cityName, textPos, 2);
            }
        }
    }




    public class Neighbors_Basics_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        KNN_Basics knn = new KNN_Basics();
        public bool runRedCloud = false;
        public Options_XNeighbors options = new Options_XNeighbors();
        public Neighbors_Basics_CS()
        {
            desc = "Find all the neighbors with KNN";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standalone || runRedCloud)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels = redC.labels;
            }
            knn.queries.Clear();
            foreach (var rc in vbc.task.redCells)
            {
                knn.queries.Add(rc.maxDStable);
            }
            knn.trainInput = new List<Point2f>(knn.queries);
            knn.Run(src);
            for (int i = 0; i < vbc.task.redCells.Count(); i++)
            {
                var rc = vbc.task.redCells[i];
                rc.nabs = knn.neighbors[i];
            }
            if (standalone)
            {
                vbc.task.setSelectedContour();
                dst3.SetTo(0);
                int ptCount = 0;
                foreach (var index in vbc.task.rc.nabs)
                {
                    var pt = vbc.task.redCells[index].maxDStable;
                    if (pt == vbc.task.rc.maxDStable)
                    {
                        DrawCircle(dst2, pt, vbc.task.DotSize, cv.Scalar.Black);
                    }
                    else
                    {
                        DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                        ptCount++;
                        if (ptCount > options.xNeighbors) break;
                    }
                }
            }
        }
    }




    public class Neighbors_Intersects_CS : VB_Parent
    {
        public List<cv.Point> nPoints = new List<cv.Point>();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Neighbors_Intersects_CS()
        {
            desc = "Find the corner points where multiple cells intersect.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || src.Type() != MatType.CV_8U)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                src = vbc.task.cellMap;
                labels[2] = redC.labels[2];
            }
            byte[] samples = new byte[src.Total()];
            Marshal.Copy(src.Data, samples, 0, samples.Length);
            int w = dst2.Width;
            nPoints.Clear();
            int kSize = 2;
            for (int y = 0; y <= dst1.Height - kSize; y++)
            {
                for (int x = 0; x <= dst1.Width - kSize; x++)
                {
                    var nabs = new SortedList<byte, byte>();
                    for (int yy = y; yy < y + kSize; yy++)
                    {
                        for (int xx = x; xx < x + kSize; xx++)
                        {
                            byte val = samples[yy * w + xx];
                            if (val == 0 && removeZeroNeighbors) continue;
                            if (!nabs.ContainsKey(val)) nabs.Add(val, 0);
                        }
                    }
                    if (nabs.Count() > 2)
                    {
                        nPoints.Add(new cv.Point(x, y));
                    }
                }
            }
            if (standaloneTest())
            {
                dst3 = vbc.task.color.Clone();
                foreach (var pt in nPoints)
                {
                    DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                    DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.Yellow);
                }
            }
            labels[3] = nPoints.Count().ToString() + " intersections with 3 or more cells were found";
        }
    }




    public class Neighbors_ColorOnly_CS : VB_Parent
    {
        Neighbors_Intersects corners = new Neighbors_Intersects();
        RedCloud_Cells redC = new RedCloud_Cells();
        public Neighbors_ColorOnly_CS()
        {
            desc = "Find neighbors in a color only RedCloud cellMap";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            corners.Run(vbc.task.cellMap.Clone());
            foreach (var pt in corners.nPoints)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = redC.labels[2] + " and " + corners.nPoints.Count().ToString() + " cell intersections";
        }
    }




    public class Neighbors_Precise_CPP_CS : VB_Parent
    {
        public List<List<int>> nabList = new List<List<int>>();
        Cell_Basics stats = new Cell_Basics();
        public List<rcData> redCells;
        public bool runRedCloud = false;
        RedCloud_Basics redC = new RedCloud_Basics();
        public Neighbors_Precise_CPP_CS()
        {
            cPtr = Neighbors_Open();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Find the neighbors in a selected RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || runRedCloud)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels = redC.labels;
                src = vbc.task.cellMap;
                redCells = vbc.task.redCells;
            }
            byte[] mapData = new byte[src.Total()];
            Marshal.Copy(src.Data, mapData, 0, mapData.Length);
            GCHandle handleSrc = GCHandle.Alloc(mapData, GCHandleType.Pinned);
            int nabCount = Neighbors_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();
            SetTrueText("Review the neighbors_Precise algorithm");
            //if (nabCount > 0)
            //{
            //    var nabData = new Mat(nabCount, 1, MatType.CV_32SC2, Neighbors_NabList(cPtr));
            //    nabList.Clear();
            //    for (int i = 0; i < redCells.Count(); i++)
            //    {
            //        nabList.Add(new List<int>());
            //    }
            //    redCells[i].nab = nabList.Min();
            //    for (int i = 0; i < nabCount; i++)
            //    {
            //        var pt = nabData.Get<Point>(i, 0);
            //        if (!nabList[pt.X].Contains(pt.Y) && pt.Y != 0)
            //        {
            //            nabList[pt.X].Add(pt.Y);
            //            redCells[pt.X].nabs.Add(pt.Y);
            //        }
            //        if (!nabList[pt.Y].Contains(pt.X) && pt.X != 0)
            //        {
            //            nabList[pt.Y].Add(pt.X);
            //            redCells[pt.Y].nabs.Add(pt.X);
            //        }
            //    }
            //    nabList[0].Clear(); // neighbors to zero are not interesting (yet?)
            //    redCells[0].nabs.Clear(); // not interesting.
            //    if (vbc.task.heartBeat && standaloneTest())
            //    {
            //        stats.Run(vbc.task.color);
            //        strOut = stats.strOut;
            //        if (nabList[vbc.task.rc.index].Count() > 0)
            //        {
            //            strOut += "Neighbors: ";
            //            dst1.SetTo(0);
            //            dst1[vbc.task.rc.rect].SetTo(vbc.task.rc.color, vbc.task.rc.mask);
            //            foreach (var index in nabList[vbc.task.rc.index])
            //            {
            //                var rc = redCells[index];
            //                dst1[rc.rect].SetTo(rc.color, rc.mask);
            //                strOut += index.ToString() + ",";
            //            }
            //            strOut += "\n";
            //        }
            //    }
            //    SetTrueText(strOut, 3);
            //}
            labels[3] = nabCount.ToString() + " neighbor pairs were found.";
        }
        public void Close()
        {
            Neighbors_Close(cPtr);
        }
    }




    public class OEX_CalcBackProject_Demo1_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public int classCount;
        public OEX_CalcBackProject_Demo1_CS()
        {
            labels = new string[] { "", "", "BackProjection of Hue channel", "Plot of Hue histogram" };
            UpdateAdvice(traceName + ": <place advice here on any options that are useful>");
            desc = "OpenCV Sample CalcBackProject_Demo1";
        }
        public void RunAlg(Mat src)
        {
            Rangef[] ranges = new Rangef[] { new Rangef(0, 180) };
            Mat hsv = vbc.task.color.CvtColor(ColorConversionCodes.BGR2HSV);
            Cv2.CalcHist(new Mat[] { hsv }, new int[] { 0 }, new Mat(), histogram, 1, new int[] { vbc.task.histogramBins }, ranges);
            classCount = Cv2.CountNonZero(histogram);
            dst0 = histogram.Normalize(0, classCount, NormTypes.MinMax); // for the backprojection.
            float[] histArray = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            float peakValue = histArray.ToList().Max();
            histogram = histogram.Normalize(0, 1, NormTypes.MinMax);
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            Cv2.CalcBackProject(new Mat[] { hsv }, new int[] { 0 }, dst0, dst2, ranges);
            dst3.SetTo(Scalar.Red);
            int binW = dst2.Width / vbc.task.histogramBins;
            int bins = dst2.Width / binW;
            for (int i = 0; i < bins; i++)
            {
                int h = (int)(dst2.Height * histArray[i]);
                cv.Rect r = new cv.Rect(i * binW, dst2.Height - h, binW, h);
                dst3.Rectangle(r, Scalar.Black, -1);
            }
            if (vbc.task.heartBeat) labels[3] = $"The max value below is {peakValue}";
        }
    }




    public class OEX_CalcBackProject_Demo2_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public int classCount = 10; // initial value is just a guess.  It is refined after the first pass.
        public OEX_CalcBackProject_Demo2_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setHistogramBins(6);
            labels = new string[] { "", "Mask for isolated region", "Backprojection of the hsv 2D histogram", "Mask in image context" };
            desc = "OpenCV Sample CalcBackProject_Demo2";
        }
        public void RunAlg(Mat src)
        {
            int count = 0;
            if (vbc.task.ClickPoint != new cv.Point())
            {
                int connectivity = 8;
                int flags = connectivity | (255 << 8) | (int)FloodFillFlags.FixedRange | (int)FloodFillFlags.MaskOnly;
                Mat mask2 = new Mat(src.Rows + 2, src.Cols + 2, MatType.CV_8U, cv.Scalar.All(0));
                // the delta between each regions value is 255 / classcount. no low or high bound needed.
                int delta = (int)(255 / classCount) - 1;
                Scalar bounds = new Scalar(delta, delta, delta);
                count = Cv2.FloodFill(dst2, mask2, vbc.task.ClickPoint, cv.Scalar.All(255), out _, bounds, bounds, (cv.FloodFillFlags)flags);
                if (count != src.Total()) dst1 = mask2[new cv.Range(1, mask2.Rows - 1), new cv.Range(1, mask2.Cols - 1)];
            }
            Rangef[] ranges = new Rangef[] { new Rangef(0, 180), new Rangef(0, 256) };
            Mat hsv = vbc.task.color.CvtColor(ColorConversionCodes.BGR2HSV);
            Cv2.CalcHist(new Mat[] { hsv }, new int[] { 0, 1 }, new Mat(), histogram, 2, new int[] { vbc.task.histogramBins, vbc.task.histogramBins }, ranges);
            classCount = Cv2.CountNonZero(histogram);
            histogram = histogram.Normalize(0, 255, NormTypes.MinMax);
            Cv2.CalcBackProject(new Mat[] { hsv }, new int[] { 0, 1 }, histogram, dst2, ranges);
            dst3 = src;
            dst3.SetTo(Scalar.White, dst1);
            SetTrueText("Click anywhere to isolate that region.", 1);
        }
    }




    public class OEX_bgfg_segm_CS : VB_Parent
    {
        BGSubtract_Basics bgSub = new BGSubtract_Basics();
        public OEX_bgfg_segm_CS()
        {
            desc = "OpenCV example bgfg_segm - existing BGSubtract_Basics is the same.";
        }
        public void RunAlg(Mat src)
        {
            bgSub.Run(src);
            dst2 = bgSub.dst2;
            labels[2] = bgSub.labels[2];
        }
    }




    public class OEX_bgSub_CS : VB_Parent
    {
        BackgroundSubtractor pBackSub;
        Options_BGSubtract options = new Options_BGSubtract();
        public OEX_bgSub_CS()
        {
            desc = "OpenCV example bgSub";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.optionsChanged)
            {
                switch (options.methodDesc)
                {
                    case "GMG":
                        pBackSub = BackgroundSubtractorGMG.Create();
                        break;
                    case "KNN":
                        pBackSub = BackgroundSubtractorKNN.Create();
                        break;
                    case "MOG":
                        pBackSub = BackgroundSubtractorMOG.Create();
                        break;
                    default: // MOG2 is the default.  Other choices map to MOG2 because OpenCVSharp doesn't support them.
                        pBackSub = BackgroundSubtractorMOG2.Create();
                        break;
                }
            }
            pBackSub.Apply(src, dst2, options.learnRate);
        }
    }




    public class OEX_BasicLinearTransforms_CS : VB_Parent
    {
        Options_BrightnessContrast options = new Options_BrightnessContrast();
        public OEX_BasicLinearTransforms_CS()
        {
            desc = "OpenCV Example BasicLinearTransforms - NOTE: much faster than BasicLinearTransformTrackBar";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            src.ConvertTo(dst2, -1, options.brightness, options.contrast);
        }
    }




    public class OEX_BasicLinearTransformsTrackBar_CS : VB_Parent
    {
        Options_BrightnessContrast options = new Options_BrightnessContrast();
        public OEX_BasicLinearTransformsTrackBar_CS()
        {
            desc = "OpenCV Example BasicLinearTransformTrackBar - much slower than OEX_BasicLinearTransforms";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Cols >= 640)
            {
                src = src.Resize(vbc.task.lowRes);
                dst2 = dst2.Resize(vbc.task.lowRes);
            }
            for (int y = 0; y < src.Rows; y++)
            {
                for (int x = 0; x < src.Cols; x++)
                {
                    Vec3b vec = src.Get<Vec3b>(y, x);
                    vec[0] = (byte)Math.Max(Math.Min(vec[0] * options.brightness + options.contrast, 255), 0);
                    vec[1] = (byte)Math.Max(Math.Min(vec[1] * options.brightness + options.contrast, 255), 0);
                    vec[2] = (byte)Math.Max(Math.Min(vec[2] * options.brightness + options.contrast, 255), 0);
                    dst2.Set<Vec3b>(y, x, vec);
                }
            }
        }
    }




    public class OEX_delaunay2_CS : VB_Parent
    {
        Scalar active_facet_color = new Scalar(0, 0, 255);
        Scalar delaunay_color = new Scalar(255, 255, 255);
        List<Point2f> points = new List<Point2f>();
        Subdiv2D subdiv;
        public OEX_delaunay2_CS()
        {
            subdiv = new Subdiv2D(new cv.Rect(0, 0, dst2.Width, dst2.Height));
            if (standalone) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Next triangle list being built.  Latest entry is in red.", "The completed voronoi facets" };
            desc = "OpenCV Example delaunay2";
        }
        public void locatePoint(Mat img, Subdiv2D subdiv, cv.Point pt, Scalar activeColor)
        {
            int e0 = 0;
            int vertex = 0;
            subdiv.Locate(pt, out e0, out vertex);
            if (e0 > 0)
            {
                int e = e0;
                do
                {
                    cv.Point2f org, dst;
                    if (subdiv.EdgeOrg(e, out org) > 0 && subdiv.EdgeDst(e, out dst) > 0)
                    {
                        DrawLine(img, org, dst, activeColor, vbc.task.lineWidth + 3);
                    }
                    e = subdiv.GetEdge(e, (cv.NextEdgeType)Subdiv2D.NEXT_AROUND_LEFT);
                } while (e != e0);
            }
            DrawCircle(img, pt, vbc.task.DotSize, activeColor);
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.quarterBeat)
            {
                if (points.Count() < 10)
                {
                    dst2.SetTo(0);
                    Point2f pt = new Point2f(msRNG.Next(0, dst2.Width - 10) + 5, msRNG.Next(0, dst2.Height - 10) + 5);
                    points.Add(pt);
                    locatePoint(dst2, subdiv, new cv.Point((int)pt.X, (int)pt.Y), active_facet_color);
                    subdiv.Insert(pt);
                    var triangleList = subdiv.GetTriangleList();
                    cv.Point[] pts = new cv.Point[3];
                    foreach (var tri in triangleList)
                    {
                        pts[0] = new cv.Point(Math.Round(tri[0]), Math.Round(tri[1]));
                        pts[1] = new cv.Point(Math.Round(tri[2]), Math.Round(tri[3]));
                        pts[2] = new cv.Point(Math.Round(tri[4]), Math.Round(tri[5]));
                        DrawLine(dst2, pts[0], pts[1], delaunay_color);
                        DrawLine(dst2, pts[1], pts[2], delaunay_color);
                        DrawLine(dst2, pts[2], pts[0], delaunay_color);
                    }
                }
                else
                {
                    dst1 = dst2.Clone();
                    Point2f[][] facets = new Point2f[1][];
                    Point2f[] centers;
                    subdiv.GetVoronoiFacetList(new List<int>(), out facets, out centers);
                    List<cv.Point> ifacet = new List<cv.Point>();
                    List<List<cv.Point>> ifacets = new List<List<cv.Point>> { ifacet };
                    for (int i = 0; i < facets.Length; i++)
                    {
                        ifacet.Clear();
                        ifacet.AddRange(facets[i].Select(p => new cv.Point(p.X, p.Y)));
                        Scalar color = vecToScalar(vbc.task.vecColors[i % 256]);
                        dst3.FillConvexPoly(ifacet, color, cv.LineTypes.Link8, 0);
                        ifacets[0] = ifacet;
                        Cv2.Polylines(dst3, ifacets, true, new cv.Scalar(), vbc.task.lineWidth, vbc.task.lineType);
                        DrawCircle(dst3, centers[i], 3, new cv.Scalar());
                    }
                    points.Clear();
                    subdiv = new Subdiv2D(new cv.Rect(0, 0, dst2.Width, dst2.Height));
                }
            }
        }
    }




    public class OEX_MeanShift_CS : VB_Parent
    {
        TermCriteria term_crit = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 10, 1.0);
        Rangef[] ranges = new Rangef[] { new Rangef(0, 180) };
        public Mat histogram = new Mat();
        cv.Rect trackWindow;
        public OEX_MeanShift_CS()
        {
            labels[3] = "Draw a rectangle around the region of interest";
            desc = "OpenCV Example MeanShift";
        }
        public void RunAlg(Mat src)
        {
            cv.Rect roi = vbc.task.drawRect.Width > 0 ? vbc.task.drawRect : new cv.Rect(0, 0, dst2.Width, dst2.Height);
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            dst2 = src;
            if (vbc.task.optionsChanged)
            {
                trackWindow = roi;
                Mat mask = new Mat();
                Cv2.InRange(hsv, new Scalar(0, 60, 32), new Scalar(180, 255, 255), mask);
                Cv2.CalcHist(new Mat[] { hsv[roi] }, new int[] { 0 }, new Mat(), histogram, 1, new int[] { vbc.task.histogramBins }, ranges);
                histogram = histogram.Normalize(0, 255, NormTypes.MinMax);
            }
            Cv2.CalcBackProject(new Mat[] { hsv }, new int[] { 0 }, histogram, dst3, ranges);
            if (trackWindow.Width != 0)
            {
                Cv2.MeanShift(dst3, ref trackWindow, TermCriteria.Both(10, 1));
                src.Rectangle(trackWindow, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            }
        }
    }




    public class OEX_PointPolygon_CS : VB_Parent
    {
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        public OEX_PointPolygon_CS()
        {
            desc = "PointPolygonTest will decide what is inside and what is outside.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                rotatedRect.Run(src);
                src = rotatedRect.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            dst2 = src.Clone();
            cv.Point[][] contours;
            Cv2.FindContours(src, out contours, out _, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);
            dst1 = new Mat(dst1.Size(), MatType.CV_32F, cv.Scalar.All(0));
            for (int i = 0; i < dst1.Rows; i++)
            {
                for (int j = 0; j < dst1.Cols; j++)
                {
                    double distance = Cv2.PointPolygonTest(contours[0], new cv.Point(j, i), true);
                    dst1.Set(i, j, distance);
                }
            }
            var mm = GetMinMax(dst1);
            mm.minVal = Math.Abs(mm.minVal);
            mm.maxVal = Math.Abs(mm.maxVal);
            Vec3b blue = new Vec3b(0, 0, 0);
            Vec3b red = new Vec3b(0, 0, 0);
            for (int i = 0; i < src.Rows; i++)
            {
                for (int j = 0; j < src.Cols; j++)
                {
                    float val = dst1.Get<float>(i, j);
                    if (val < 0)
                    {
                        blue[0] = (byte)(255 - Math.Abs(val) * 255 / mm.minVal);
                        dst3.Set(i, j, blue);
                    }
                    else if (val > 0)
                    {
                        red[2] = (byte)(255 - val * 255 / mm.maxVal);
                        dst3.Set(i, j, red);
                    }
                    else
                    {
                        dst3.Set(i, j, white);
                    }
                }
            }
        }
    }




    public class OEX_PointPolygon_demo_CS : VB_Parent
    {
        OEX_PointPolygon pointPoly = new OEX_PointPolygon();
        public OEX_PointPolygon_demo_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "OpenCV Example PointPolygonTest_demo - it became PointPolygonTest_Basics.";
        }
        public void RunAlg(Mat src)
        {
            int r = dst2.Height / 4;
            List<cv.Point> vert = new List<cv.Point>
    {
        new cv.Point(3 * r / 2 + dst2.Width / 4, (int)(1.34 * r)),
        new cv.Point(r + dst2.Width / 4, 2 * r),
        new cv.Point(3 * r / 2 + dst2.Width / 4, (int)(2.866 * r)),
        new cv.Point(5 * r / 2 + dst2.Width / 4, (int)(2.866 * r)),
        new cv.Point(3 * r + dst2.Width / 4, 2 * r),
        new cv.Point(5 * r / 2 + dst2.Width / 4, (int)(1.34 * r))
    };
            dst2.SetTo(0);
            for (int i = 0; i < vert.Count(); i++)
            {
                DrawLine(dst2, vert[i], vert[(i + 1) % 6], Scalar.White);
            }
            pointPoly.Run(dst2);
            dst3 = pointPoly.dst3;
        }
    }




    public class OEX_Remap_CS : VB_Parent
    {
        Remap_Basics remap = new Remap_Basics();
        public OEX_Remap_CS()
        {
            desc = "The OpenCV Remap example became the Remap_Basics algorithm.";
        }
        public void RunAlg(Mat src)
        {
            remap.Run(src);
            dst2 = remap.dst2;
            labels[2] = remap.labels[2];
        }
    }




    public class OEX_Threshold_CS : VB_Parent
    {
        Threshold_Basics threshold = new Threshold_Basics();
        public OEX_Threshold_CS()
        {
            desc = "OpenCV Example Threshold became Threshold_Basics";
        }
        public void RunAlg(Mat src)
        {
            threshold.Run(src);
            dst2 = threshold.dst2;
            dst3 = threshold.dst3;
            labels = threshold.labels;
        }
    }




    public class OEX_Threshold_Inrange_CS : VB_Parent
    {
        Options_OEX options = new Options_OEX();
        public OEX_Threshold_Inrange_CS()
        {
            desc = "OpenCV Example Threshold_Inrange";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            dst2 = hsv.InRange(options.lows, options.highs);
        }
    }




    public class OEX_Points_Classifier_CS : VB_Parent
    {
        Classifier_Basics_CS basics;
        public OEX_Points_Classifier_CS()
        {
            basics = new Classifier_Basics_CS();
            desc = "OpenCV Example Points_Classifier became Classifier_Basics";
        }
        public void RunAlg(Mat src)
        {
            basics.Run(src);
            dst2 = basics.dst2;
            dst3 = basics.dst3;
            labels = basics.labels;
            SetTrueText("Click the global DebugCheckBox to get another set of points.", 2);
        }
    }




    public class OEX_GoodFeaturesToTrackDemo_CS : VB_Parent
    {
        Feature_Stable feat = new Feature_Stable();
        public OEX_GoodFeaturesToTrackDemo_CS()
        {
            desc = "OpenCV Example GoodFeaturesToTrackDemo - now Feature_Stable";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
        }
    }




    public class OEX_Core_Reduce_CS : VB_Parent
    {
        public OEX_Core_Reduce_CS()
        {
            desc = "Use OpenCV's reduce API to create row/col sums, averages, and min/max.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                Mat m = cv.Mat.FromPixelData(3, 2, MatType.CV_32F, new float[] { 1, 2, 3, 4, 5, 6 });
                Mat col_sum = new Mat(), row_sum = new Mat();
                Cv2.Reduce(m, col_sum, 0, ReduceTypes.Sum, MatType.CV_32F);
                Cv2.Reduce(m, row_sum, (cv.ReduceDimension)1, ReduceTypes.Sum, MatType.CV_32F);
                strOut = "Original Mat" + "\n";
                for (int y = 0; y < m.Rows; y++)
                {
                    for (int x = 0; x < m.Cols; x++)
                    {
                        strOut += m.Get<float>(y, x) + ", ";
                    }
                    strOut += "\n";
                }
                strOut += "\n" + "col_sum" + "\n";
                for (int i = 0; i < m.Cols; i++)
                {
                    strOut += col_sum.Get<float>(0, i) + ", ";
                }
                strOut += "\n" + "row_sum" + "\n";
                for (int i = 0; i < m.Rows; i++)
                {
                    strOut += row_sum.Get<float>(0, i) + ", ";
                }
                Mat col_average = new Mat(), row_average = new Mat(), col_min = new Mat();
                Mat col_max = new Mat(), row_min = new Mat(), row_max = new Mat();
                Cv2.Reduce(m, col_average, 0, ReduceTypes.Avg, MatType.CV_32F);
                Cv2.Reduce(m, row_average, (cv.ReduceDimension)1, ReduceTypes.Avg, MatType.CV_32F);
                Cv2.Reduce(m, col_min, 0, ReduceTypes.Min, MatType.CV_32F);
                Cv2.Reduce(m, row_min, (cv.ReduceDimension)1, ReduceTypes.Min, MatType.CV_32F);
                Cv2.Reduce(m, col_max, 0, ReduceTypes.Max, MatType.CV_32F);
                Cv2.Reduce(m, row_max, (cv.ReduceDimension)1, ReduceTypes.Max, MatType.CV_32F);
            }
            SetTrueText(strOut, 2);
        }
    }




    public class OEX_Core_Split_CS : VB_Parent
    {
        public OEX_Core_Split_CS()
        {
            desc = "OpenCV Example Core_Split";
        }
        public void RunAlg(Mat src)
        {
            var d = cv.Mat.FromPixelData(2, 2, MatType.CV_8UC3, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
            var channels = d.Split();
            var samples = new byte[d.Total() * d.ElemSize()];
            Marshal.Copy(d.Data, samples, 0, samples.Length);
            strOut = "Original 2x2 Mat";
            for (int i = 0; i < samples.Length; i++)
            {
                strOut += samples[i].ToString() + ", ";
            }
            strOut += "\n";
            for (int i = 0; i < 3; i++)
            {
                strOut += "Channels " + i.ToString() + "\n";
                for (int y = 0; y < channels[i].Rows; y++)
                {
                    for (int x = 0; x < channels[i].Cols; x++)
                    {
                        strOut += channels[i].Get<byte>(y, x).ToString() + ", ";
                    }
                    strOut += "\n";
                }
            }
            SetTrueText(strOut, 2);
        }
    }




    public class OEX_Filter2D_CS : VB_Parent
    {
        MatType ddepth = MatType.CV_8UC3;
        cv.Point anchor = new cv.Point(-1, -1);
        int kernelSize = 3, ind = 0;
        public OEX_Filter2D_CS()
        {
            desc = "OpenCV Example Filter2D demo - Use a varying kernel to show the impact.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat) ind++;
            kernelSize = 3 + 2 * (ind % 5);
            var kernel = new Mat(kernelSize, kernelSize, MatType.CV_32F, cv.Scalar.All(1.0 / (kernelSize * kernelSize)));
            dst2 = src.Filter2D(ddepth, kernel, anchor, 0, BorderTypes.Default);
            SetTrueText("Kernel size = " + kernelSize.ToString(), 3);
        }
    }




    public class OEX_FitEllipse_CPP_CS : VB_Parent
    {
        Mat img;
        Options_FitEllipse options = new Options_FitEllipse();
        public OEX_FitEllipse_CPP_CS()
        {
            var fileInputName = new FileInfo(vbc.task.HomeDir + "opencv/samples/data/ellipses.jpg");
            img = Cv2.ImRead(fileInputName.FullName).CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            cPtr = OEX_FitEllipse_Open();
            desc = "OEX Example fitellipse";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var cppData = new byte[img.Total() * img.ElemSize()];
            Marshal.Copy(img.Data, cppData, 0, cppData.Length);
            var handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            var imagePtr = OEX_FitEllipse_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), img.Rows, img.Cols,
                                                    options.threshold, options.fitType);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(img.Rows + 4, img.Cols + 4, MatType.CV_8UC3, imagePtr).Clone();
        }
        public void Close()
        {
            OEX_FitEllipse_Close(cPtr);
        }
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr OEX_FitEllipse_Open();
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void OEX_FitEllipse_Close(IntPtr cPtr);
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr OEX_FitEllipse_RunCPP(IntPtr cPtr, IntPtr dataPtr, int rows, int cols,
                                                            int threshold, int fitType);
    }




    public class OilPaint_Pointilism_CS : VB_Parent
    {
        Mat randomMask;
        RNG myRNG = new RNG();
        Options_Pointilism options = new Options_Pointilism();
        cv.Rect saveDrawRect = new cv.Rect();
        public OilPaint_Pointilism_CS()
        {
            vbc.task.drawRect = new cv.Rect(dst2.Cols * 3 / 8, dst2.Rows * 3 / 8, dst2.Cols * 2 / 8, dst2.Rows * 2 / 8);
            desc = "Alter the image to effect the pointilism style";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src;
            var img = src[vbc.task.drawRect];
            if (saveDrawRect != vbc.task.drawRect)
            {
                saveDrawRect = vbc.task.drawRect;
                randomMask = new Mat(img.Size(), MatType.CV_32SC2);
                cv.Point nPt = new cv.Point();
                for (int y = 0; y < randomMask.Height; y++)
                {
                    for (int x = 0; x < randomMask.Width; x++)
                    {
                        nPt.X = (msRNG.Next(-1, 1) + x) % (randomMask.Width - 1);
                        nPt.Y = (msRNG.Next(-1, 1) + y) % (randomMask.Height - 1);
                        if (nPt.X < 0) nPt.X = 0;
                        if (nPt.Y < 0) nPt.Y = 0;
                        randomMask.Set<cv.Point>(y, x, nPt);
                    }
                }
                Cv2.RandShuffle(randomMask, 1.0, ref myRNG);
            }
            var rand = randomMask.Resize(img.Size());
            var gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat fieldx = new Mat(), fieldy = new Mat();
            Cv2.Scharr(gray, fieldx, MatType.CV_32FC1, 1, 0, 1 / 15.36);
            Cv2.Scharr(gray, fieldy, MatType.CV_32FC1, 0, 1, 1 / 15.36);
            Cv2.GaussianBlur(fieldx, fieldx, new cv.Size(options.smoothingRadius, options.smoothingRadius), 0, 0);
            Cv2.GaussianBlur(fieldy, fieldy, new cv.Size(options.smoothingRadius, options.smoothingRadius), 0, 0);
            for (int y = 0; y < img.Height; y++)
            {
                for (int x = 0; x < img.Width; x++)
                {
                    var nPt = rand.Get<cv.Point>(y, x);
                    var nextColor = src.Get<Vec3b>(saveDrawRect.Y + nPt.Y, saveDrawRect.X + nPt.X);
                    var fx = fieldx[saveDrawRect].Get<float>(nPt.Y, nPt.X);
                    var fy = fieldy[saveDrawRect].Get<float>(nPt.Y, nPt.X);
                    var nPoint = new Point2f(nPt.X, nPt.Y);
                    var gradient_magnitude = Math.Sqrt(fx * fx + fy * fy);
                    var slen = Math.Round(options.strokeSize + options.strokeSize * Math.Sqrt(gradient_magnitude));
                    var eSize = new Size2f(slen, options.strokeSize);
                    var direction = Math.Atan2(fx, fy);
                    var angle = direction * 180.0 / Math.PI + 90;
                    var rotatedRect = new RotatedRect(nPoint, eSize, (float)angle);
                    if (options.useElliptical)
                    {
                        dst2[saveDrawRect].Ellipse(rotatedRect, vecToScalar(nextColor));
                    }
                    else
                    {
                        DrawCircle(dst2[saveDrawRect], nPoint, (int)(slen / 4), vecToScalar(nextColor));
                    }
                }
            }
        }
    }




    public class OilPaint_ManualVB_CS : VB_Parent
    {
        public Options_OilPaint options = new Options_OilPaint();
        public OilPaint_ManualVB_CS()
        {
            vbc.task.drawRect = new cv.Rect(dst2.Cols * 3 / 8, dst2.Rows * 3 / 8, dst2.Cols * 2 / 8, dst2.Rows * 2 / 8);
            desc = "Alter an image so it appears more like an oil painting.  Select a region of interest.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int filterKern = options.filterSize | 1;
            var roi = vbc.task.drawRect;
            src.CopyTo(dst2);
            var color = src[roi];
            var result1 = color.Clone();
            for (int y = filterKern; y < roi.Height - filterKern - 1; y++)
            {
                for (int x = filterKern; x < roi.Width - filterKern - 1; x++)
                {
                    int[] intensitybins = new int[options.intensity + 1];
                    int[] bluebin = new int[options.intensity + 1];
                    int[] greenbin = new int[options.intensity + 1];
                    int[] redbin = new int[options.intensity + 1];
                    int maxIntensity = 0;
                    int maxIndex = 0;
                    Vec3b vec = new Vec3b();
                    for (int yy = y - filterKern; yy <= y + filterKern - 1; yy++)
                    {
                        for (int xx = x - filterKern; xx <= x + filterKern - 1; xx++)
                        {
                            vec = color.Get<Vec3b>(yy, xx);
                            int currentIntensity = (int)(Math.Round((double)(vec[0] + vec[1] + vec[2]) * options.intensity / (255 * 3)));
                            intensitybins[currentIntensity] += 1;
                            bluebin[currentIntensity] += vec[0];
                            greenbin[currentIntensity] += vec[1];
                            redbin[currentIntensity] += vec[2];
                            if (intensitybins[currentIntensity] > maxIntensity)
                            {
                                maxIndex = currentIntensity;
                                maxIntensity = intensitybins[currentIntensity];
                            }
                        }
                    }
                    vec[0] = (byte)((bluebin[maxIndex] / maxIntensity) > 255 ? 255 : bluebin[maxIndex] / maxIntensity);
                    vec[1] = (byte)((greenbin[maxIndex] / maxIntensity) > 255 ? 255 : greenbin[maxIndex] / maxIntensity);
                    vec[2] = (byte)((redbin[maxIndex] / maxIntensity) > 255 ? 255 : redbin[maxIndex] / maxIntensity);
                    result1.Set<Vec3b>(y, x, vec);
                }
            }
            result1.CopyTo(dst2[roi]);
        }
    }




    public class OpAuto_XRange_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        int adjustedCount = 0;
        public OpAuto_XRange_CS()
        {
            labels[2] = "Optimized top view to show as many samples as possible.";
            desc = "Automatically adjust the X-Range option of the pointcloud to maximize visible pixels";
        }
        public void RunAlg(Mat src)
        {
            int expectedCount = vbc.task.depthMask.CountNonZero();
            int diff = Math.Abs(expectedCount - adjustedCount);
            // the input is a histogram.  If standaloneTest(), go get one...
            if (standaloneTest())
            {
                Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesTop);
                histogram.Row(0).SetTo(0);
                dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
                dst3 = histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
                src = histogram;
            }
            histogram = src;
            adjustedCount = (int)histogram.Sum()[0];
            strOut = "Adjusted = " + "\t" + adjustedCount + "k" + "\n" +
                        "Expected = " + "\t" + expectedCount + "k" + "\n" +
                        "Diff = " + "\t\t" + diff + "\n" +
                        "xRange = " + "\t" + string.Format("{0:F3}", vbc.task.xRange);
            if (vbc.task.useXYRange)
            {
                bool saveOptionState = vbc.task.optionsChanged; // the xRange and yRange change frequently.  It is safe to ignore it.
                int leftGap = histogram.Col(0).CountNonZero();
                int rightGap = histogram.Col(histogram.Width - 1).CountNonZero();
                if (leftGap == 0 && rightGap == 0 && vbc.task.redOptions.getXRangeSlider() > 3)
                {
                    vbc.task.redOptions.setXRangeSlider(vbc.task.redOptions.getXRangeSlider() - 1);
                }
                else
                {
                    vbc.task.redOptions.setXRangeSlider(vbc.task.redOptions.getXRangeSlider() + (adjustedCount < expectedCount ? 1 : -1));
                }
                vbc.task.optionsChanged = saveOptionState;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class OpAuto_YRange_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        int adjustedCount = 0;
        public OpAuto_YRange_CS()
        {
            labels[2] = "Optimized side view to show as much as possible.";
            desc = "Automatically adjust the Y-Range option of the pointcloud to maximize visible pixels";
        }
        public void RunAlg(Mat src)
        {
            int expectedCount = vbc.task.depthMask.CountNonZero();
            int diff = Math.Abs(expectedCount - adjustedCount);
            // the input is a histogram.  If standaloneTest(), go get one...
            if (standaloneTest())
            {
                Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, new Mat(), histogram, 2, vbc.task.bins2D, vbc.task.rangesSide);
                histogram.Col(0).SetTo(0);
                dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
                dst3 = histogram.Threshold(vbc.task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
                src = histogram;
            }
            histogram = src;
            adjustedCount = (int)histogram.Sum()[0];
            strOut = "Adjusted = " + "\t" + adjustedCount + "k" + "\n" +
                        "Expected = " + "\t" + expectedCount + "k" + "\n" +
                        "Diff = " + "\t\t" + diff + "\n" +
                        "yRange = " + "\t" + string.Format("{0:F3}", vbc.task.yRange);
            if (vbc.task.useXYRange)
            {
                bool saveOptionState = vbc.task.optionsChanged; // the xRange and yRange change frequently.  It is safe to ignore it.
                int topGap = histogram.Row(0).CountNonZero();
                int botGap = histogram.Row(histogram.Height - 1).CountNonZero();
                if (topGap == 0 && botGap == 0 && vbc.task.redOptions.getYRangeSlider() > 3)
                {
                    vbc.task.redOptions.setYRangeSlider(vbc.task.redOptions.getYRangeSlider() - 1);
                }
                else
                {
                    vbc.task.redOptions.setYRangeSlider(vbc.task.redOptions.getYRangeSlider() + ((adjustedCount < expectedCount) ? 1 : -1));
                }
                vbc.task.optionsChanged = saveOptionState;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class OpAuto_FloorCeiling_CS : VB_Parent
    {
        public BackProject_LineSide bpLine = new BackProject_LineSide();
        public List<float> yList = new List<float>();
        public float floorY;
        public float ceilingY;
        public OpAuto_FloorCeiling_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Automatically find the Y values that best describes the floor and ceiling (if present)";
        }
        void rebuildMask(string maskLabel, float min, float max)
        {
            Mat mask = vbc.task.pcSplit[1].InRange(min, max).ConvertScaleAbs();
            Scalar mean, stdev;
            Cv2.MeanStdDev(vbc.task.pointCloud, out mean, out stdev, mask);
            strOut += "The " + maskLabel + " mask has Y mean and stdev are:" + "\n";
            strOut += maskLabel + " Y Mean = " + string.Format("{0:F3}", mean[1]) + "\n";
            strOut += maskLabel + " Y Stdev = " + string.Format("{0:F3}", stdev[1]) + "\n" + "\n";
            if (Math.Abs(mean[1]) > vbc.task.yRange / 4) dst1 = mask | dst1;
        }
        public void RunAlg(Mat src)
        {
            float pad = 0.05f; // pad the estimate by X cm's
            dst2 = src.Clone();
            bpLine.Run(src);
            if (bpLine.lpList.Count() > 0)
            {
                strOut = "Y range = " + string.Format("{0:F3}", vbc.task.yRange) + "\n" + "\n";
                if (vbc.task.heartBeat) yList.Clear();
                if (vbc.task.heartBeat) dst1.SetTo(0);
                int h = dst2.Height / 2;
                foreach (var mp in bpLine.lpList)
                {
                    float nextY = vbc.task.yRange * (mp.p1.Y - h) / h;
                    if (Math.Abs(nextY) > vbc.task.yRange / 4) yList.Add(nextY);
                }
                if (yList.Count() > 0)
                {
                    if (yList.Max() > 0) rebuildMask("floor", yList.Max() - pad, vbc.task.yRange);
                    if (yList.Min() < 0) rebuildMask("ceiling", -vbc.task.yRange, yList.Min() + pad);
                }
                dst2.SetTo(Scalar.White, dst1);
            }
            SetTrueText(strOut, 3);
        }
    }




    public class OpAuto_Valley_CS : VB_Parent
    {
        public SortedList<int, int> valleyOrder = new SortedList<int, int>(new CompareAllowIdenticalInteger());
        public Options_Boundary options = new Options_Boundary();
        Hist_Kalman kalmanHist = new Hist_Kalman();
        public OpAuto_Valley_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            desc = "Get the top X highest quality valley points in the histogram.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int desiredBoundaries = options.desiredBoundaries;
            // input should be a histogram.  If not, get one...
            if (standaloneTest())
            {
                kalmanHist.Run(src);
                dst2 = kalmanHist.dst2;
                src = kalmanHist.hist.histogram.Clone();
            }
            float[] histArray = new float[src.Total()];
            Marshal.Copy(src.Data, histArray, 0, histArray.Length);
            List<float> histList = new List<float>(histArray);
            List<float> valleys = new List<float>();
            int incr = histList.Count() / desiredBoundaries;
            for (int i = 0; i < desiredBoundaries; i++)
            {
                List<float> nextList = new List<float>();
                for (int j = i * incr; j < (i + 1) * incr; j++)
                {
                    if (i == 0 && j < 5)
                    {
                        nextList.Add(dst2.Total()); // there are typically some gaps near zero.
                    }
                    else
                    {
                        nextList.Add(histList[j] == 0 ? dst2.Total() : histList[j]);
                    }
                }
                int index = nextList.IndexOf(nextList.Min());
                valleys.Add(index + i * incr);
            }
            valleyOrder.Clear();
            int lastEntry = 0;
            for (int i = 0; i < desiredBoundaries; i++)
            {
                valleyOrder.Add(lastEntry, (int)(valleys[i] - 1));
                lastEntry = (int)valleys[i];
            }
            if (valleys[desiredBoundaries - 1] != histList.Count() - 1)
            {
                valleyOrder.Add((int)valleys[desiredBoundaries - 1], 256);
            }
            if (standaloneTest())
            {
                foreach (var entry in valleyOrder)
                {
                    int col = entry.Value * dst2.Width / vbc.task.histogramBins;
                    DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White);
                }
                SetTrueText(valleys.Count() + " valleys in histogram", 3);
            }
        }
    }




    public class OpAuto_Peaks2D_CS : VB_Parent
    {
        public Options_Boundary options = new Options_Boundary();
        public List<Point2f> clusterPoints = new List<Point2f>();
        HeatMap_Basics heatmap = new HeatMap_Basics();
        public OpAuto_Peaks2D_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "2D Histogram view with highlighted peaks", "" };
            desc = "Find the peaks in a 2D histogram";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int desiredBoundaries = options.desiredBoundaries;
            int peakDistance = options.peakDistance;
            // input should be a 2D histogram.  If standaloneTest(), get one...
            if (standaloneTest())
            {
                heatmap.Run(src);
                dst2 = vbc.task.toggleOnOff ? heatmap.dst2 : heatmap.dst3;
                src = vbc.task.toggleOnOff ? heatmap.dst0.Clone() : heatmap.dst1.Clone();
            }
            clusterPoints.Clear();
            clusterPoints.Add(new cv.Point(0, 0));
            for (int i = 0; i < desiredBoundaries; i++)
            {
                var mm = GetMinMax(src);
                if (!clusterPoints.Contains(mm.maxLoc)) clusterPoints.Add(mm.maxLoc);
                DrawCircle(src, mm.maxLoc, peakDistance, cv.Scalar.All(0));
            }
            if (!standaloneTest()) dst2.SetTo(0);
            for (int i = 0; i < clusterPoints.Count(); i++)
            {
                cv.Point pt = new cv.Point(clusterPoints[i].X, clusterPoints[i].Y);
                DrawCircle(dst2, pt, vbc.task.DotSize * 3, Scalar.White);
            }
        }
    }




    public class OpAuto_Peaks2DGrid_CS : VB_Parent
    {
        public List<Point2f> clusterPoints = new List<Point2f>();
        Options_Boundary options = new Options_Boundary();
        Hist2D_Basics hist2d = new Hist2D_Basics();
        TrackBar boundarySlider;
        public OpAuto_Peaks2DGrid_CS()
        {
            boundarySlider = FindSlider("Desired boundary count");
            if (standaloneTest()) vbc.task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "2D Histogram view with highlighted peaks", "" };
            desc = "Find the peaks in a 2D histogram";
        }
        public void RunAlg(Mat src)
        {
            var desiredBoundaries = boundarySlider.Value;
            // input should be a 2D histogram.  If standaloneTest() or src is not a histogram, get one...
            if (standaloneTest() || src.Type() == MatType.CV_8UC3)
            {
                hist2d.Run(src);
                src = hist2d.histogram;
                dst2.SetTo(0);
            }
            var pointPop = new SortedList<float, cv.Point>(new CompareAllowIdenticalSingleInverted());
            foreach (var roi in vbc.task.gridRects)
            {
                var mm = GetMinMax(src[roi]);
                if (mm.maxVal == 0) continue;
                cv.Point wPt = new cv.Point(roi.X + mm.maxLoc.X, roi.Y + mm.maxLoc.Y);
                pointPop.Add((float)mm.maxVal, wPt);
            }
            clusterPoints.Clear();
            clusterPoints.Add(new cv.Point(0, 0));
            foreach (var entry in pointPop)
            {
                clusterPoints.Add(entry.Value);
                if (desiredBoundaries <= clusterPoints.Count()) break;
            }
            if (!standaloneTest()) dst2.SetTo(0);
            for (int i = 0; i < clusterPoints.Count(); i++)
            {
                var pt = clusterPoints[i];
                DrawCircle(dst2, pt, vbc.task.DotSize * 3, Scalar.White);
            }
            dst2.SetTo(Scalar.White, vbc.task.gridMask);
            labels[3] = pointPop.Count().ToString() + " grid samples trimmed to " + clusterPoints.Count().ToString();
        }
    }




    public class OpAuto_PixelDifference_CS : VB_Parent
    {
        Diff_Basics diff = new Diff_Basics();
        public OpAuto_PixelDifference_CS()
        {
            vbc.task.gOptions.pixelDiffThreshold = 2; // set it low so it will move up to the right value.
            labels = new string[] { "", "", "2D Histogram view with highlighted peaks", "" };
            desc = "Find the peaks in a 2D histogram";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat && vbc.task.frameCount > 10) return;
            if (standaloneTest())
            {
                diff.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
                src = diff.dst2;
            }
            int gridCount = 0;
            foreach (var roi in vbc.task.gridRects)
            {
                if (src[roi].CountNonZero() > 0) gridCount++;
            }
            if (vbc.task.gOptions.pixelDiffThreshold < vbc.task.gOptions.getPixelDifferenceMax())
            {
                if (gridCount > vbc.task.gridRects.Count() / 10) vbc.task.gOptions.pixelDiffThreshold++;
            }
            if (gridCount == 0 && vbc.task.gOptions.pixelDiffThreshold > 1) vbc.task.gOptions.pixelDiffThreshold--;
            SetTrueText("Pixel difference threshold is at " + vbc.task.gOptions.getPixelDifference().ToString());
            dst2 = src;
        }
    }




    public class OpAuto_MSER_CS : VB_Parent
    {
        MSER_Basics mBase = new MSER_Basics();
        public int classCount;
        bool checkOften = true;
        TrackBar minSlider;
        TrackBar maxSlider;
        public OpAuto_MSER_CS()
        {
            minSlider = FindSlider("MSER Min Area");
            maxSlider = FindSlider("MSER Max Area");
            desc = "Option Automation: find the best MSER max and min area values";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                mBase.Run(src);
                src = mBase.dst3;
                classCount = mBase.mserCells.Count();
            }
            dst2 = src.Clone();
            if (vbc.task.heartBeat || checkOften)
            {
                if (src.Channels() != 1) dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY); else dst1 = src;
                int count = dst1.CountNonZero();
                int desired = (int)(dst2.Total() * 0.6);
                if (count < desired)
                {
                    if (maxSlider.Value < maxSlider.Maximum - 1000) maxSlider.Value += 1000;
                }
                if (classCount > 35)
                {
                    if (minSlider.Value < minSlider.Maximum - 100) minSlider.Value += 100;
                }
                else
                {
                    if (classCount > 0) checkOften = false;
                    if (classCount < 25)
                    {
                        if (minSlider.Value > 100) minSlider.Value -= 100;
                    }
                }
                strOut = "NonZero pixel count = " + count.ToString() + "\n" +
                            "Desired pixel count (60% of total) = " + desired.ToString() + "\n";
                strOut += "maxSlider Value = " + maxSlider.Value.ToString() + "\n";
                strOut += "Cells identified = " + classCount.ToString() + "\n";
                strOut += "minSlider value = " + minSlider.Value.ToString() + "\n";
                strOut += "checkOften variable is " + checkOften.ToString();
            }
            SetTrueText(strOut, 3);
        }
    }




    public class OpenGL_Basics_CS : VB_Parent
    {
        MemoryMappedViewAccessor memMapWriter;
        readonly ProcessStartInfo startInfo = new ProcessStartInfo();
        IntPtr memMapPtr;
        public Mat dataInput = new Mat();
        public Mat pointCloudInput = new Mat();
        public int oglFunction = 0; // the default function is to display a point cloud.
        public Options_OpenGLFunctions options = new Options_OpenGLFunctions();
        byte[] rgbBuffer = new byte[1];
        byte[] dataBuffer = new byte[1];
        byte[] pointCloudBuffer = new byte[1];
        public OpenGL_Basics_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            UpdateAdvice(traceName + ": 'Show All' to see all the OpenGL options.");
            pointCloudInput = new Mat(dst2.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            desc = "Create an OpenGL window and update it with images";
        }
        double[] memMapFill()
        {
            double timeConversionUnits = 1000;
            double imuAlphaFactor = 0.98; // theta is a mix of acceleration data and gyro data.
            if (vbc.task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i")
            {
                timeConversionUnits = 1000 * 1000;
                imuAlphaFactor = 0.99;
            }
            int rgbBufferSize = rgbBuffer.Length > 1 ? rgbBuffer.Length : 0;
            int dataBufferSize = dataBuffer.Length > 1 ? dataBuffer.Length : 0;
            double showXYZaxis = 1;
            double[] memMapValues = {
                vbc.task.frameCount, dst2.Width, dst2.Height, rgbBufferSize,
                dataBufferSize, options.FOV, options.yaw, options.pitch, options.roll,
                options.zNear, options.zFar, options.PointSizeSlider.Value, dataInput.Width, dataInput.Height,
                vbc.task.IMU_AngularVelocity.X, vbc.task.IMU_AngularVelocity.Y, vbc.task.IMU_AngularVelocity.Z,
                vbc.task.IMU_Acceleration.X, vbc.task.IMU_Acceleration.Y, vbc.task.IMU_Acceleration.Z, vbc.task.IMU_TimeStamp,
                1, options.eye[0] / 100, options.eye[1] / 100, options.eye[2] / 100, options.zTrans,
                options.scaleXYZ[0] / 10, options.scaleXYZ[1] / 10, options.scaleXYZ[2] / 10, timeConversionUnits, imuAlphaFactor,
                vbc.task.OpenGLTitle.Length, pointCloudInput.Width, pointCloudInput.Height, oglFunction, showXYZaxis
            };
            return memMapValues;
        }
        void MemMapUpdate()
        {
            double[] memMap = memMapFill();
            Marshal.Copy(memMap, 0, memMapPtr, memMap.Length);
            memMapWriter.WriteArray<double>(0, memMap, 0, memMap.Length);
        }
        void StartOpenGLWindow()
        {
            vbc.task.pipeName = "OpenCVBImages" + vbc.task.pipeCount.ToString();
            try
            {
                vbc.task.openGLPipe = new NamedPipeServerStream(vbc.task.pipeName, PipeDirection.InOut, 1);
            }
            catch (Exception) { }
            vbc.task.pipeCount++;
            double[] memMap = memMapFill();
            int memMapbufferSize = 8 * memMap.Length;
            startInfo.FileName = vbc.task.OpenGLTitle + ".exe";
            int windowWidth = 720;
            int windowHeight = 720 * 240 / 320;
            startInfo.Arguments = windowWidth.ToString() + " " + windowHeight.ToString() + " " + memMapbufferSize.ToString() + " " + vbc.task.pipeName;
            if (!vbc.task.showConsoleLog) startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            Process.Start(startInfo);
            memMapPtr = Marshal.AllocHGlobal(memMapbufferSize);
            MemoryMappedFile memMapFile = MemoryMappedFile.CreateOrOpen("OpenCVBControl", memMapbufferSize);
            memMapWriter = memMapFile.CreateViewAccessor(0, memMapbufferSize);
            vbc.task.openGLPipe.WaitForConnection();
            while (true)
            {
                vbc.task.openGL_hwnd = FindWindow(null, vbc.task.OpenGLTitle);
                if (vbc.task.openGL_hwnd != IntPtr.Zero) break;
            }
            vbc.task.oglRect = new cv.Rect(vbc.task.OpenGL_Left, vbc.task.OpenGL_Top, windowWidth, windowHeight);
            MoveWindow(vbc.task.openGL_hwnd, vbc.task.OpenGL_Left, vbc.task.OpenGL_Top, vbc.task.oglRect.Width, vbc.task.oglRect.Height, true);
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest()) pointCloudInput = vbc.task.pointCloud;
            // adjust the point cloud if present and the 'move' sliders are non-zero
            options.RunOpt();
            cv.Scalar ptM = options.moveAmount;
            cv.Point3f shift = new cv.Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            if (pointCloudInput.Width != 0 && (shift.X != 0 ||
                shift.Y != 0 || shift.Z != 0)) pointCloudInput -= ptM;
            if (src.Width > 0)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2RGB); // OpenGL needs RGB, not BGR
                if (rgbBuffer.Length != src.Total() * src.ElemSize()) Array.Resize(ref rgbBuffer, (int)(src.Total() * src.ElemSize()));
            }
            if (dataInput.Width > 0)
            {
                if (dataBuffer.Length != dataInput.Total() * dataInput.ElemSize()) Array.Resize(ref dataBuffer, (int)(dataInput.Total() * dataInput.ElemSize()));
            }
            else
            {
                Array.Resize(ref dataBuffer, 1);
            }
            if (pointCloudInput.Width > 0)
            {
                if (pointCloudBuffer.Length != pointCloudInput.Total() * pointCloudInput.ElemSize()) Array.Resize(ref pointCloudBuffer, (int)(pointCloudInput.Total() * pointCloudInput.ElemSize()));
            }
            if (memMapPtr == IntPtr.Zero)
            {
                StartOpenGLWindow();
            }
            else
            {
                byte[] readPipe = new byte[4]; // we read 4 bytes because that is the signal that the other end of the named pipe wrote 4 bytes to indicate iteration complete.
                if (vbc.task.openGLPipe != null)
                {
                    int bytesRead = vbc.task.openGLPipe.Read(readPipe, 0, 4);
                    if (bytesRead == 0) SetTrueText("The OpenGL process appears to have stopped.", new cv.Point(20, 100));
                }
            }
            MemMapUpdate();
            if (src.Width > 0) Marshal.Copy(src.Data, rgbBuffer, 0, rgbBuffer.Length);
            if (dataInput.Width > 0) Marshal.Copy(dataInput.Data, dataBuffer, 0, dataBuffer.Length);
            if (pointCloudInput.Width > 0)
                Marshal.Copy(pointCloudInput.Data, pointCloudBuffer, 0,
                    (int)(pointCloudInput.Total() * pointCloudInput.ElemSize()));
            try
            {
                if (src.Width > 0) vbc.task.openGLPipe.Write(rgbBuffer, 0, rgbBuffer.Length);
                if (dataInput.Width > 0) vbc.task.openGLPipe.Write(dataBuffer, 0, dataBuffer.Length);
                if (pointCloudInput.Width > 0) vbc.task.openGLPipe.Write(pointCloudBuffer, 0, pointCloudBuffer.Length);
                byte[] buff = System.Text.Encoding.UTF8.GetBytes(vbc.task.OpenGLTitle);
                vbc.task.openGLPipe.Write(buff, 0, vbc.task.OpenGLTitle.Length);
                // lose a lot of performance doing this!
                if (vbc.task.gOptions.getOpenGLCapture())
                {
                    Bitmap snapshot = GetWindowImage(vbc.task.openGL_hwnd, new cv.Rect(0, 0, (int)(vbc.task.oglRect.Width * 1.4),
                                        (int)(vbc.task.oglRect.Height * 1.4)));
                    Mat snap = BitmapConverter.ToMat(snapshot);
                    snap = snap.CvtColor(ColorConversionCodes.BGRA2BGR);
                    dst3 = snap.Resize(new cv.Size(dst2.Width, dst2.Height), 0, 0, InterpolationFlags.Nearest);
                }
            }
            catch (Exception)
            {
                // OpenGL window was likely closed.  
            }
            // If standaloneTest() Then SetTrueText(vbc.task.gMat.strout, 3)
            if (standaloneTest()) SetTrueText(vbc.task.gMat.strOut, 3);
        }
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);
    }












    public class OpenGL_BasicsSliders_CS : VB_Parent
    {
        Options_OpenGL options = new Options_OpenGL();
        public Mat pointCloudInput;
        public OpenGL_BasicsSliders_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Basics";
            FindSlider("OpenGL FOV").Value = 150;
            desc = "Show the OpenGL point cloud with sliders support.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            vbc.task.ogl.pointCloudInput = standaloneTest() ? vbc.task.pointCloud : pointCloudInput;
            // update all the options from the slider values.
            vbc.task.ogl.options.FOV = options.FOV;
            vbc.task.ogl.options.yaw = options.yaw;
            vbc.task.ogl.options.pitch = options.pitch;
            vbc.task.ogl.options.roll = options.roll;
            vbc.task.ogl.options.zNear = options.zNear;
            vbc.task.ogl.options.zFar = options.zFar;
            vbc.task.ogl.options.PointSizeSlider.Value = options.pointSize;
            vbc.task.ogl.options.zTrans = options.zTrans;
            vbc.task.ogl.options.eye = options.eye;
            vbc.task.ogl.options.scaleXYZ = options.scaleXYZ;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_BasicsMouse_CS : VB_Parent
    {
        public OpenGL_BasicsMouse_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Show the OpenGL point cloud with mouse support.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.testAllRunning) return; // seems to not like it when running overnight but it runs fine.
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_ReducedXYZ_CS : VB_Parent
    {
        readonly Reduction_XYZ reduction = new Reduction_XYZ();
        public OpenGL_ReducedXYZ_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Display the pointCloud after reduction in X, Y, or Z dimensions.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst3;
            vbc.task.ogl.pointCloudInput = reduction.dst3;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_Reduction_CS : VB_Parent
    {
        readonly Reduction_PointCloud reduction;
        public OpenGL_Reduction_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            reduction = new Reduction_PointCloud();
            desc = "Use the reduced depth pointcloud in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2;
            vbc.task.ogl.pointCloudInput = reduction.dst3;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_ReducedSideView_CS : VB_Parent
    {
        readonly PointCloud_ReducedSideView sideView = new PointCloud_ReducedSideView();
        public OpenGL_ReducedSideView_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Use the reduced depth pointcloud in 3D but allow it to be rotated in Options_Common";
        }
        public void RunAlg(Mat src)
        {
            sideView.Run(src);
            dst2 = sideView.dst2;
            vbc.task.ogl.pointCloudInput = sideView.dst3;
            vbc.task.ogl.Run(vbc.task.color);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = sideView.labels[2];
        }
    }





    public class OpenGL_Rebuilt_CS : VB_Parent
    {
        readonly Structured_Rebuild rebuild = new Structured_Rebuild();
        public OpenGL_Rebuilt_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Review the rebuilt point cloud from Structured_Rebuild";
        }
        public void RunAlg(Mat src)
        {
            rebuild.Run(src);
            dst2 = rebuild.dst2;
            vbc.task.ogl.pointCloudInput = rebuild.pointcloud;
            vbc.task.ogl.Run(vbc.task.color);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_VerticalSingle_CS : VB_Parent
    {
        readonly FeatureLine_LongestV_Tutorial2 vLine = new FeatureLine_LongestV_Tutorial2();
        public OpenGL_VerticalSingle_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.verticalLines;
            desc = "Visualize the vertical line found with FeatureLine_LongestV_Tutorial";
        }
        public void RunAlg(Mat src)
        {
            vLine.Run(src);
            dst2 = vLine.dst2;
            dst3 = vLine.dst3;
            var pt1 = vLine.pt1;
            var pt2 = vLine.pt2;
            var linePairs3D = new List<Point3f>
            {
                new Point3f((pt1.X + pt2.X) / 2, pt1.Y, (pt1.Z + pt2.Z) / 2),
                new Point3f(pt1.X, pt2.Y, pt1.Z)
            };
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(linePairs3D.Count(), 1, MatType.CV_32FC3, linePairs3D.ToArray());
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(vbc.task.color);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }





    public class OpenGL_Pyramid_CS : VB_Parent
    {
        public OpenGL_Pyramid_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawPyramid; // all the work is done inside the switch statement in OpenGL_Functions.
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Draw the traditional OpenGL pyramid";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_DrawCube_CS : VB_Parent
    {
        public OpenGL_DrawCube_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawCube;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Draw the traditional OpenGL cube";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_QuadSimple_CS : VB_Parent
    {
        readonly Tessallate_QuadSimple tess = new Tessallate_QuadSimple();
        public OpenGL_QuadSimple_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.simplePlane;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Create a simple plane in each roi of the RedCloud data";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            dst2 = tess.dst2;
            dst3 = tess.dst3;
            labels = tess.labels;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.oglData.Count(), 1, MatType.CV_32FC3, tess.oglData.ToArray());
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(dst3);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_QuadHulls_CS : VB_Parent
    {
        readonly Tessallate_QuadHulls tess = new Tessallate_QuadHulls();
        public OpenGL_QuadHulls_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.simplePlane;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Create a simple plane in each roi of the RedCloud data";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            dst2 = tess.dst2;
            dst3 = tess.dst3;
            labels = tess.labels;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.oglData.Count(), 1, MatType.CV_32FC3, tess.oglData.ToArray());
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(dst3);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_QuadMinMax_CS : VB_Parent
    {
        readonly Tessallate_QuadMinMax tess = new Tessallate_QuadMinMax();
        public OpenGL_QuadMinMax_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.simplePlane;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Reflect the min and max for each roi of the RedCloud data";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            dst2 = tess.dst2;
            dst3 = tess.dst3;
            labels = tess.labels;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.oglData.Count(), 1, MatType.CV_32FC3, tess.oglData.ToArray());
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(dst3);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_Bricks_CS : VB_Parent
    {
        readonly Tessallate_Bricks tess = new Tessallate_Bricks();
        public OpenGL_Bricks_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.minMaxBlocks;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Create blocks in each roi using the min and max depth values";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.oglData.Count(), 1, MatType.CV_32FC3, tess.oglData.ToArray());
            dst2 = tess.dst3;
            dst3 = tess.hulls.dst3;
            int index = 0;
            foreach (var roi in vbc.task.gridRects)
            {
                if (index < tess.depths.Count())
                {
                    SetTrueText(tess.depths[index].ToString(vbc.fmt1) + "\n" + tess.depths[index + 1].ToString(vbc.fmt1),
                                new cv.Point(roi.X, roi.Y), 2);
                }
                index += 2;
            }
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_StructuredCloud_CS : VB_Parent
    {
        readonly Structured_Cloud sCloud = new Structured_Cloud();
        readonly RedCloud_Basics redC = new RedCloud_Basics();
        public OpenGL_StructuredCloud_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels[2] = "Structured cloud 32fC3 data";
            desc = "Visualize the Structured_Cloud";
        }
        public void RunAlg(Mat src)
        {
            sCloud.Run(src);
            redC.Run(src);
            dst2 = redC.dst2;
            labels = redC.labels;
            vbc.task.ogl.pointCloudInput = sCloud.dst2;
            vbc.task.ogl.Run(dst2);
            vbc.task.ogl.options.PointSizeSlider.Value = vbc.task.gridSize;
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_Tiles_CS : VB_Parent
    {
        Structured_Tiles sCloud = new Structured_Tiles();
        public OpenGL_Tiles_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawTiles;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            labels = new string[] { "", "", "Input from Structured_Tiles", "" };
            desc = "Display the quads built by Structured_Tiles in OpenGL - uses OpenGL's point size";
        }
        public void RunAlg(Mat src)
        {
            sCloud.Run(src);
            dst2 = sCloud.dst2;
            dst3 = sCloud.dst3;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(sCloud.oglData.Count(), 1, MatType.CV_32FC3, sCloud.oglData.ToArray());
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            vbc.task.ogl.options.PointSizeSlider.Value = vbc.task.gridSize;
        }
    }




    public class OpenGL_TilesQuad_CS : VB_Parent
    {
        Structured_TilesQuad sCloud = new Structured_TilesQuad();
        public OpenGL_TilesQuad_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.simplePlane;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            labels = new string[] { "", "", "Input from Structured_Tiles", "" };
            desc = "Display the quads built by Structured_TilesQuad in OpenGL - does NOT use OpenGL's point size";
        }
        public void RunAlg(Mat src)
        {
            sCloud.Run(src);
            dst2 = sCloud.dst2;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(sCloud.oglData.Count(), 1, MatType.CV_32FC3, sCloud.oglData.ToArray());
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_OnlyPlanes_CS : VB_Parent
    {
        readonly Plane_OnlyPlanes planes = new Plane_OnlyPlanes();
        public OpenGL_OnlyPlanes_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels = new string[] { "", "", "RedCloud Cells", "Planes built in the point cloud" };
            desc = "Display the pointCloud as a set of RedCloud cell planes";
        }
        public void RunAlg(Mat src)
        {
            planes.Run(src);
            dst2 = planes.dst2;
            dst3 = planes.dst3;
            vbc.task.ogl.pointCloudInput = planes.dst3;
            vbc.task.ogl.Run(vbc.task.color);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_FlatStudy1_CS : VB_Parent
    {
        readonly Structured_LinearizeFloor plane = new Structured_LinearizeFloor();
        public OpenGL_FlatStudy1_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels = new string[] { "", "", "Side view of point cloud - use mouse to highlight the floor", "Highlight the floor in BGR image" };
            desc = "Convert depth cloud floor to a plane and visualize it with OpenGL";
        }
        public void RunAlg(Mat src)
        {
            plane.Run(src);
            dst2 = plane.dst3;
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(plane.dst2);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_FlatStudy2_CS : VB_Parent
    {
        public Structured_LinearizeFloor plane = new Structured_LinearizeFloor();
        public OpenGL_FlatStudy2_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawFloor;
            desc = "Show the floor in the pointcloud as a plane";
        }
        public void RunAlg(Mat src)
        {
            plane.Run(src);
            dst2 = plane.dst3;
            List<float> oglData = new List<float>();
            var floorColor = vbc.task.color.Mean(plane.sliceMask);
            oglData.Add((float)floorColor[0]);
            oglData.Add((float)floorColor[1]);
            oglData.Add((float)floorColor[2]);
            oglData.Add(plane.floorYPlane);
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(4, 1, MatType.CV_32F, oglData.ToArray());
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(plane.dst2);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_FlatStudy3_CS : VB_Parent
    {
        Plane_FloorStudy plane = new Plane_FloorStudy();
        TrackBar cushionSlider;
        public OpenGL_FlatStudy3_CS()
        {
            cushionSlider = FindSlider("Structured Depth slice thickness in pixels");
            vbc.task.ogl.oglFunction = (int)oCase.floorStudy;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            labels = new string[] { "", "", "", "" };
            desc = "Create an OpenGL display where the floor is built as a quad";
        }
        public void RunAlg(Mat src)
        {
            plane.Run(src);
            dst2 = plane.dst2;
            labels[2] = plane.labels[2];
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(1, 1, MatType.CV_32F, new float[] { plane.planeY });
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_FlatFloor_CS : VB_Parent
    {
        Model_FlatSurfaces flatness = new Model_FlatSurfaces();
        public OpenGL_FlatFloor_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.floorStudy;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Using minimal cost, create an OpenGL display where the floor is built as a quad";
        }
        public void RunAlg(Mat src)
        {
            flatness.Run(src);
            SetTrueText(flatness.labels[2], 3);
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(1, 1, MatType.CV_32F, new float[] { vbc.task.pcFloor });
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = flatness.labels[2];
            labels[3] = flatness.labels[3];
        }
    }




    public class OpenGL_FlatCeiling_CS : VB_Parent
    {
        Model_FlatSurfaces flatness = new Model_FlatSurfaces();
        public OpenGL_FlatCeiling_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.floorStudy;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Using minimal cost, create an OpenGL display where the ceiling is built as a quad";
        }
        public void RunAlg(Mat src)
        {
            flatness.Run(src);
            SetTrueText(flatness.labels[2], 3);
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(1, 1, MatType.CV_32F, new float[] { vbc.task.pcCeiling });
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = flatness.labels[2];
            labels[3] = flatness.labels[3];
        }
    }




    public class OpenGL_PeakFlat_CS : VB_Parent
    {
        Plane_Histogram peak = new Plane_Histogram();
        Kalman_Basics kalman = new Kalman_Basics();
        public OpenGL_PeakFlat_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.floorStudy;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Display the peak flat level in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            peak.Run(src);
            dst2 = peak.dst2;
            labels[2] = peak.labels[3];
            kalman.kInput = new float[] { peak.peakFloor, peak.peakCeiling };
            kalman.Run(empty);
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(2, 1, MatType.CV_32F, new float[] { kalman.kOutput[0], kalman.kOutput[1] });
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_DrawHull_CS : VB_Parent
    {
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public OpenGL_DrawHull_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawCell;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            labels = new string[] { "", "", "RedCloud output", "" };
            desc = "Select a cell and display its hull in OpenGL as a polygon.";
        }
        public void RunAlg(Mat src)
        {
            hulls.Run(src);
            dst2 = hulls.dst2;
            List<Point3f> oglData = new List<Point3f>();
            var rc = vbc.task.rc;
            List<Point3f> hull = new List<Point3f>();
            if (rc.hull != null)
            {
                foreach (var pt in rc.hull)
                {
                    hull.Add(vbc.task.pointCloud[rc.rect].Get<Point3f>(pt.Y, pt.X));
                }
                for (int i = 0; i < hull.Count(); i += 3)
                {
                    oglData.Add(hull[i % hull.Count()]);
                    oglData.Add(hull[(i + 1) % hull.Count()]);
                    oglData.Add(hull[(i + 2) % hull.Count()]);
                }
            }
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(oglData.Count(), 1, MatType.CV_32FC3, oglData.ToArray());
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_FPolyCloud_CS : VB_Parent
    {
        FeaturePoly_PointCloud fpolyPC = new FeaturePoly_PointCloud();
        public OpenGL_FPolyCloud_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Display the pointcloud after FeaturePoly_PointCloud identifies the changes depth pixels";
        }
        public void RunAlg(Mat src)
        {
            fpolyPC.Run(src);
            dst1 = fpolyPC.dst1;
            dst2 = fpolyPC.dst2;
            dst3 = fpolyPC.dst3;
            SetTrueText(fpolyPC.fMask.fImage.strOut, 1);
            labels = fpolyPC.labels;
            vbc.task.ogl.pointCloudInput = fpolyPC.fPolyCloud;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_Sierpinski_CS : VB_Parent
    {
        public OpenGL_Sierpinski_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.sierpinski;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL Point Size").Value = 3;
            desc = "Draw the Sierpinski triangle pattern in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_DrawHulls_CS : VB_Parent
    {
        public Options_OpenGLFunctions options = new Options_OpenGLFunctions();
        public RedCloud_Hulls hulls = new RedCloud_Hulls();
        public OpenGL_DrawHulls_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawCells;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            labels = new string[] { "", "", "", "" };
            desc = "Draw all the hulls in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var ptM = options.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            hulls.Run(src);
            dst2 = hulls.dst2;
            var rcx = vbc.task.rc;
            List<Point3f> oglData = new List<Point3f>();
            oglData.Add(new Point3f());
            int polygonCount = 0;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.hull == null) continue;
                int hullIndex = oglData.Count();
                oglData.Add(new Point3f(rc.hull.Count(), 0, 0));
                if (rc.index == rcx.index)
                {
                    oglData.Add(new Point3f(1, 1, 1));
                }
                else
                {
                    oglData.Add(new Point3f(rc.color[2] / 255f, rc.color[1] / 255f, rc.color[0] / 255f));
                }
                int hullPoints = 0;
                foreach (var pt in rc.hull)
                {
                    var ptNew = pt;
                    if (pt.X > rc.rect.Width) ptNew.X = rc.rect.Width - 1;
                    if (pt.Y > rc.rect.Height) ptNew.Y = rc.rect.Height - 1;
                    var v = vbc.task.pointCloud[rc.rect].Get<Point3f>(ptNew.Y, ptNew.X);
                    if (v.Z > 0)
                    {
                        hullPoints++;
                        oglData.Add(new Point3f(v.X + shift.X, v.Y + shift.Y, v.Z + shift.Z));
                    }
                }
                oglData[hullIndex] = new Point3f(hullPoints, 0, 0);
                polygonCount++;
            }
            oglData[0] = new Point3f(polygonCount, 0, 0);
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(oglData.Count(), 1, MatType.CV_32FC3, oglData.ToArray());
            vbc.task.ogl.Run(dst2);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst2;
            SetTrueText(polygonCount.ToString() + " polygons were sent to OpenGL", 2);
        }
    }




    public class OpenGL_Contours_CS : VB_Parent
    {
        Options_OpenGL_Contours options2 = new Options_OpenGL_Contours();
        public Options_OpenGLFunctions options = new Options_OpenGLFunctions();
        RedCloud_Basics redC = new RedCloud_Basics();
        public OpenGL_Contours_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.drawCells;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL shift fwd/back (Z-axis)").Value = -150;
            labels = new string[] { "", "", "Output of RedCloud", "OpenGL snapshot" };
            desc = "Draw all the RedCloud contours in OpenGL with various settings.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var ptM = options.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            options2.RunOpt();
            redC.Run(src);
            dst2 = redC.dst2;
            var rcx = vbc.task.rc;
            int polygonCount = 0;
            var oglData = new List<Point3f>();
            Scalar lastDepth;
            oglData.Add(new Point3f());
            foreach (var rc in vbc.task.redCells)
            {
                var d = rc.depthMean[2];
                if (d == 0) continue;
                int dataIndex = oglData.Count();
                oglData.Add(new Point3f(rc.contour.Count(), 0, 0));
                if (rc.index == rcx.index)
                {
                    oglData.Add(new Point3f(1, 1, 1));
                }
                else
                {
                    oglData.Add(new Point3f(rc.color[2] / 255f, rc.color[1] / 255f, rc.color[0] / 255f));
                }
                lastDepth = rc.depthMean;
                foreach (var pt in rc.contour)
                {
                    var ptNew = pt;
                    if (pt.X > rc.rect.Width) ptNew.X = rc.rect.Width - 1;
                    if (pt.Y > rc.rect.Height) ptNew.Y = rc.rect.Height - 1;
                    var v = vbc.task.pointCloud[rc.rect].Get<Point3f>(ptNew.Y, ptNew.X);
                    if (options2.depthPointStyle == (int)pointStyle.flattened ||
                        options2.depthPointStyle == (int)pointStyle.flattenedAndFiltered) v.Z = (float)d;
                    if (options2.depthPointStyle == (int)pointStyle.filtered ||
                        options2.depthPointStyle == (int)pointStyle.flattenedAndFiltered)
                    {
                        if (Math.Abs(v.X - lastDepth[0]) > options2.filterThreshold) v.X = (float)lastDepth[0];
                        if (Math.Abs(v.Y - lastDepth[1]) > options2.filterThreshold) v.Y = (float)lastDepth[1];
                        if (Math.Abs(v.Z - lastDepth[2]) > options2.filterThreshold) v.Z = (float)lastDepth[2];
                    }
                    oglData.Add(new Point3f(v.X + shift.X, v.Y + shift.Y, v.Z + shift.Z));
                    lastDepth = new cv.Scalar(v.X, v.Y, v.Z);
                }
                oglData[dataIndex] = new Point3f(rc.contour.Count(), 0, 0);
                polygonCount++;
            }
            oglData[0] = new Point3f(polygonCount, 0, 0);
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(oglData.Count(), 1, MatType.CV_32FC3, oglData.ToArray());
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_PCLineCandidates_CS : VB_Parent
    {
        PointCloud_Basics pts = new PointCloud_Basics();
        public OpenGL_PCLineCandidates_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pcPointsAlone;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL Point Size").Value = 10;
            desc = "Display the output of the PointCloud_Basics";
        }
        public void RunAlg(Mat src)
        {
            pts.Run(src);
            dst2 = pts.dst2;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(pts.allPointsH.Count(), 1, MatType.CV_32FC3, pts.allPointsH.ToArray());
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = "Point cloud points found = " + (pts.actualCount / 2).ToString();
        }
    }




    public class OpenGL_PClinesFirstLast_CS : VB_Parent
    {
        Line3D_CandidatesFirstLast lines = new Line3D_CandidatesFirstLast();
        public OpenGL_PClinesFirstLast_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pcLines;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL Point Size").Value = 10;
            desc = "Draw the 3D lines found from the PCpoints";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            vbc.task.ogl.dataInput = lines.pcLinesMat.Rows == 0 ? new Mat() : lines.pcLinesMat;
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = "OpenGL_PClines found " + (lines.pcLinesMat.Rows / 3).ToString() + " lines";
        }
    }




    public class OpenGL_PClinesAll_CS : VB_Parent
    {
        Line3D_CandidatesAll lines = new Line3D_CandidatesAll();
        public OpenGL_PClinesAll_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pcLines;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL Point Size").Value = 10;
            desc = "Draw the 3D lines found from the PCpoints";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            vbc.task.ogl.dataInput = lines.pcLinesMat.Rows == 0 ? new Mat() : lines.pcLinesMat;
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = "OpenGL_PClines found " + (lines.pcLinesMat.Rows / 3).ToString() + " lines";
        }
    }




    public class OpenGL_PatchHorizontal_CS : VB_Parent
    {
        Pixel_NeighborsPatchNeighbors patch = new Pixel_NeighborsPatchNeighbors();
        public OpenGL_PatchHorizontal_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Draw the point cloud after patching z-values that are similar";
        }
        public void RunAlg(Mat src)
        {
            patch.Run(src);
            dst2 = patch.dst3;
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_PCpoints_CS : VB_Parent
    {
        PointCloud_PCPoints pts = new PointCloud_PCPoints();
        public OpenGL_PCpoints_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pcPoints;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL Point Size").Value = 10;
            desc = "Display the output of the PointCloud_Points";
        }
        public void RunAlg(Mat src)
        {
            pts.Run(src);
            dst2 = pts.dst2;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(pts.pcPoints.Count(), 1, MatType.CV_32FC3, pts.pcPoints.ToArray());
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = "Point cloud points found = " + (pts.pcPoints.Count() / 2).ToString();
        }
    }




    public class OpenGL_PCpointsPlane_CS : VB_Parent
    {
        PointCloud_PCPointsPlane pts = new PointCloud_PCPointsPlane();
        public OpenGL_PCpointsPlane_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pcPoints;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            FindSlider("OpenGL Point Size").Value = 10;
            desc = "Display the points that are likely to be in a plane - found by both the vertical and horizontal searches";
        }
        public void RunAlg(Mat src)
        {
            pts.Run(src);
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(pts.pcPoints.Count(), 1, MatType.CV_32FC3, pts.pcPoints.ToArray());
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = "Point cloud points found = " + pts.pcPoints.Count() / 2;
        }
    }




    public class OpenGL_PlaneClusters3D_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Plane_Equation eq = new Plane_Equation();
        public OpenGL_PlaneClusters3D_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pcPoints;
            FindSlider("OpenGL Point Size").Value = 10;
            labels[3] = "Only the cells with a high probability plane are presented - blue on X-axis, green on Y-axis, red on Z-axis";
            desc = "Cluster the plane equations to find major planes in the image and display the clusters in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3 = redC.dst3;
            List<Point3f> pcPoints = new List<Point3f>();
            Point3f blue = new Point3f(0, 0, 1), red = new Point3f(1, 0, 0), green = new Point3f(0, 1, 0);
            foreach (var rc in vbc.task.redCells)
            {
                rcData rcNew = rc;
                if (rc.maxVec.Z > 0)
                {
                    eq.rc = rc;
                    eq.Run(src);
                    rcNew = eq.rc;
                }
                if (rcNew.eq == new Vec4f()) continue;
                if (rcNew.eq.Item0 > rcNew.eq.Item1 && rcNew.eq.Item0 > rcNew.eq.Item2) pcPoints.Add(red);
                if (rcNew.eq.Item1 > rcNew.eq.Item0 && rcNew.eq.Item1 > rcNew.eq.Item2) pcPoints.Add(green);
                if (rcNew.eq.Item2 > rcNew.eq.Item0 && rcNew.eq.Item2 > rcNew.eq.Item1) pcPoints.Add(blue);
                pcPoints.Add(new Point3f(rcNew.eq.Item0 * 0.5f, rcNew.eq.Item1 * 0.5f, rcNew.eq.Item2 * 0.5f));
            }
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(pcPoints.Count(), 1, MatType.CV_32FC3, pcPoints.ToArray());
            vbc.task.ogl.Run(new Mat());
        }
    }




    public class OpenGL_Profile_CS : VB_Parent
    {
        public Profile_Basics sides = new Profile_Basics();
        public Profile_Rotation rotate = new Profile_Rotation();
        HeatMap_Basics heat = new HeatMap_Basics();
        public OpenGL_Profile_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setGravityUsage(false);
            vbc.task.ogl.oglFunction = (int)oCase.pcPointsAlone;
            labels[3] = "Contour of selected cell is shown below.  Blue dot represents the minimum X (leftmost) point and red the maximum X (rightmost)";
            desc = "Visualize a RedCloud Cell and rotate it using the Options_IMU Sliders";
        }
        public void RunAlg(Mat src)
        {
            sides.Run(src);
            dst2 = sides.dst2;
            var rc = vbc.task.rc;
            var contourMat = cv.Mat.FromPixelData(rc.contour.Count(), 1, MatType.CV_32SC2, rc.contour.ToArray());
            if (rc.contour.Count() == 0) return;
            var split = contourMat.Split();
            var mm = GetMinMax(split[0]);
            var p1 = rc.contour.ElementAt(mm.minLoc.Y);
            var p2 = rc.contour.ElementAt(mm.maxLoc.Y);
            dst3.SetTo(0);
            DrawContour(dst3[rc.rect], rc.contour, Scalar.Yellow);
            DrawCircle(dst3, new cv.Point(p1.X + rc.rect.X, p1.Y + rc.rect.Y), vbc.task.DotSize + 2, Scalar.Blue);
            DrawCircle(dst3, new cv.Point(p2.X + rc.rect.X, p2.Y + rc.rect.Y), vbc.task.DotSize + 2, Scalar.Red);
            if (rc.contour3D.Count() > 0)
            {
                var vecMat = cv.Mat.FromPixelData(rc.contour3D.Count(), 1, MatType.CV_32FC3, rc.contour3D.ToArray());
                rotate.Run(empty);
                Mat output = vecMat.Reshape(1, vecMat.Rows * vecMat.Cols) * rotate.gMat.gMatrix;
                vecMat = output.Reshape(3, vecMat.Rows);
                vbc.task.ogl.pointCloudInput = new Mat();
                vbc.task.ogl.dataInput = vecMat;
                heat.Run(vecMat);
                dst1 = heat.dst0.Threshold(0, 255, ThresholdTypes.Binary);
            }
            vbc.task.ogl.Run(new Mat());
        }
    }




    public class OpenGL_ProfileSweep_CS : VB_Parent
    {
        OpenGL_Profile visuals = new OpenGL_Profile();
        Options_IMU options = new Options_IMU();
        int testCase = 0;
        TrackBar xRotateSlider;
        TrackBar yRotateSlider;
        TrackBar zRotateSlider;
        public OpenGL_ProfileSweep_CS()
        {
            xRotateSlider = FindSlider("Rotate pointcloud around X-axis (degrees)");
            yRotateSlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            zRotateSlider = FindSlider("Rotate pointcloud around Z-axis (degrees)");
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Test the X-, Y-, and Z-axis rotation in sequence";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.gOptions.setGravityUsage(false);
            if (vbc.task.frameCount % 100 == 0)
            {
                testCase++;
                if (testCase >= 3) testCase = 0;
                options.RunOpt();
                options.rotateX = -45;
                options.rotateY = -45;
                options.rotateZ = -45;
            }
            int bump = 1;
            switch (testCase)
            {
                case 0:
                    zRotateSlider.Value += bump;
                    if (zRotateSlider.Value >= 45) zRotateSlider.Value = -45;
                    labels[3] = "Rotating around X-axis with " + zRotateSlider.Value + " degrees";
                    break;
                case 1:
                    yRotateSlider.Value += bump;
                    if (yRotateSlider.Value >= 45) yRotateSlider.Value = -45;
                    labels[3] = "Rotating around Y-axis with " + yRotateSlider.Value + " degrees";
                    break;
                case 2:
                    xRotateSlider.Value += bump;
                    if (xRotateSlider.Value >= 45) xRotateSlider.Value = -45;
                    labels[3] = "Rotating around Z-axis with " + xRotateSlider.Value + " degrees";
                    break;
            }
            SetTrueText("Top down view: " + labels[3], 1);
            visuals.Run(src);
            dst1 = visuals.dst1;
            dst2 = visuals.dst2;
            dst3 = visuals.dst3;
        }
    }




    public class OpenGL_FlatSurfaces_CS : VB_Parent
    {
        RedCloud_LikelyFlatSurfaces flat = new RedCloud_LikelyFlatSurfaces();
        public OpenGL_FlatSurfaces_CS()
        {
            labels[2] = "Display the point cloud pixels that appear to be vertical and horizontal regions.";
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Review the vertical and horizontal regions from Plane_Basics.";
        }
        public void RunAlg(Mat src)
        {
            flat.Run(src);
            vbc.task.pointCloud.CopyTo(dst2, flat.dst2);
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
        }
    }




    public class OpenGL_GradientPhase_CS : VB_Parent
    {
        Gradient_Depth gradient = new Gradient_Depth();
        public OpenGL_GradientPhase_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Show the depth gradient Phase in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            gradient.Run(src);
            dst2 = gradient.dst2;
            dst3 = gradient.dst3;
            dst1 = Convert32f_To_8UC3(gradient.dst3);
            labels = gradient.labels;
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(dst1);
        }
    }




    public class OpenGL_GravityTransform_CS : VB_Parent
    {
        public OpenGL_GravityTransform_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Use the IMU's acceleration values to build the transformation matrix of an OpenGL viewer";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_GravityAverage_CS : VB_Parent
    {
        readonly IMU_Average imuAvg = new IMU_Average();
        readonly IMU_Basics imu = new IMU_Basics();
        public OpenGL_GravityAverage_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Build the GMatrix with the Average IMU acceleration (not the raw or filtered values) and use the resulting GMatrix to stabilize the point cloud in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            strOut = "To remove the point cloud averaging, set the global option 'Frame History' to 1.\n" +
                        "Or, even alternatively, run the 'OpenGL_GravityTransform' algorithm.\n\n" +
                        "Before Averaging: Average IMU acceleration: X = " + string.Format(vbc.fmt3, vbc.task.IMU_RawAcceleration.X) + ", Y = " + string.Format(vbc.fmt3, vbc.task.IMU_RawAcceleration.Y) +
                        ", Z = " + string.Format(vbc.fmt3, vbc.task.IMU_RawAcceleration.Z) + "\n";
            imuAvg.Run(src);
            vbc.task.IMU_RawAcceleration = vbc.task.IMU_AverageAcceleration;
            imu.Run(src);
            vbc.task.accRadians.Z += (float)Cv2.PI / 2;
            strOut += "After Averaging: Average IMU accerlation: X = " + string.Format(vbc.fmt3, vbc.task.IMU_Acceleration.X) + ", Y = " + string.Format(vbc.fmt3, vbc.task.IMU_Acceleration.Y) +
                        ", Z = " + string.Format(vbc.fmt3, vbc.task.IMU_Acceleration.Z) + "\n";
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            SetTrueText(strOut, 3);
        }
    }




    public class OpenGL_GravityKalman_CS : VB_Parent
    {
        readonly IMU_Kalman imuKalman = new IMU_Kalman();
        readonly IMU_Basics imu = new IMU_Basics();
        public OpenGL_GravityKalman_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Build the GMatrix with the Average IMU acceleration (not the raw or filtered values) and use the resulting GMatrix to stabilize the point cloud in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            strOut = "To remove the point cloud averaging, set the global option 'Frame History' to 1.\n" +
                        "Or, even alternatively, run the 'OpenGL_GravityTransform' algorithm.\n\n" +
                        "Before Kalman: IMU acceleration: X = " + string.Format(vbc.fmt3, vbc.task.IMU_RawAcceleration.X) + ", Y = " + string.Format(vbc.fmt3, vbc.task.IMU_RawAcceleration.Y) +
                        ", Z = " + string.Format(vbc.fmt3, vbc.task.IMU_RawAcceleration.Z) + "\n";
            imuKalman.Run(src);
            vbc.task.IMU_RawAcceleration = vbc.task.IMU_Acceleration;
            imu.Run(src);
            vbc.task.accRadians.Z += (float)Cv2.PI / 2;
            strOut += "After Kalman: IMU acceleration: X = " + string.Format(vbc.fmt3, vbc.task.IMU_Acceleration.X) + ", Y = " + string.Format(vbc.fmt3, vbc.task.IMU_Acceleration.Y) +
                        ", Z = " + string.Format(vbc.fmt3, vbc.task.IMU_Acceleration.Z) + "\n";
            vbc.task.IMU_Acceleration = vbc.task.kalmanIMUacc;
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            SetTrueText(strOut, 3);
        }
    }




    public class OpenGL_StableMinMax_CS : VB_Parent
    {
        readonly Depth_MinMaxNone minmax = new Depth_MinMaxNone();
        public OpenGL_StableMinMax_CS()
        {
            vbc.task.gOptions.setUnfiltered(true);
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels = new string[] { "", "", "Pointcloud Max", "Pointcloud Min" };
            desc = "display the Pointcloud Min or Max in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            minmax.Run(vbc.task.pointCloud);
            dst2 = minmax.dst2;
            if (minmax.options.useMax || minmax.options.useMin) vbc.task.ogl.pointCloudInput = dst2;
            else vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(vbc.task.color);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            labels[2] = minmax.labels[2];
        }
    }





    public class OpenGL_CloudMisses_CS : VB_Parent
    {
        History_Basics frames = new History_Basics();
        public OpenGL_CloudMisses_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels = new string[] { "", "", "Point cloud after over the last X frames", "" };
            desc = "Run OpenGL removing all pixels not present for all X frames";
        }
        public void RunAlg(Mat src)
        {
            frames.Run(vbc.task.depthMask / 255);
            dst2 = frames.dst2;
            dst2 = dst2.Threshold(frames.saveFrames.Count() - 1, 255, ThresholdTypes.Binary);
            vbc.task.ogl.pointCloudInput.SetTo(0);
            vbc.task.pointCloud.CopyTo(vbc.task.ogl.pointCloudInput, dst2);
            vbc.task.ogl.Run(src);
        }
    }




    public class OpenGL_CloudHistory_CS : VB_Parent
    {
        History_Cloud hCloud = new History_Cloud();
        public OpenGL_CloudHistory_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels = new string[] { "", "", "Point cloud after over the last X frames", "Mask to remove partially missing pixels" };
            desc = "Run OpenGL with a masked point cloud averaged over the last X frames.";
        }
        public void RunAlg(Mat src)
        {
            hCloud.Run(vbc.task.pointCloud);
            dst2 = hCloud.dst2;
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
        }
    }




    public class OpenGL_TessellateCell_CS : VB_Parent
    {
        Triangle_Basics tess = new Triangle_Basics();
        public OpenGL_TessellateCell_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.tessalateTriangles;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Display a tessellated representation of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            dst2 = tess.dst2;
            dst3 = tess.dst3;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.triangles.Count(), 1, MatType.CV_32FC3, tess.triangles.ToArray());
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(tess.dst2);
            labels = tess.labels;
        }
    }




    public class OpenGL_Tessellate_CS : VB_Parent
    {
        Triangle_RedCloud tess = new Triangle_RedCloud();
        public OpenGL_Tessellate_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.tessalateTriangles;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Display a tessellated representation of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            dst2 = tess.dst2;
            dst3 = tess.dst3;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.triangles.Count(), 1, MatType.CV_32FC3, tess.triangles.ToArray());
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(tess.dst2);
            labels = tess.labels;
        }
    }




    public class OpenGL_TessellateRGB_CS : VB_Parent
    {
        Triangle_RedCloud tess = new Triangle_RedCloud();
        public OpenGL_TessellateRGB_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.tessalateTriangles;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            desc = "Display a tessellated representation of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            tess.Run(src);
            dst2 = tess.dst2;
            dst3 = tess.dst3;
            vbc.task.ogl.dataInput = cv.Mat.FromPixelData(tess.triangles.Count(), 1, MatType.CV_32FC3, tess.triangles.ToArray());
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(src);
            labels = tess.labels;
        }
    }




    public class OpenGL_RedTrack_CS : VB_Parent
    {
        RedTrack_Basics redCC = new RedTrack_Basics();
        public OpenGL_RedTrack_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Display all the RedCC cells in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            redCC.Run(src);
            dst2 = redCC.dst2;
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(dst2);
            SetTrueText(redCC.strOut, 3);
        }
    }




    public class OpenGL_Density2D_CS : VB_Parent
    {
        Density_Basics dense = new Density_Basics();
        public OpenGL_Density2D_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            dst2 = new Mat(dst2.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            desc = "Create a mask showing which pixels are close to each other and display the results.";
        }
        public void RunAlg(Mat src)
        {
            dense.Run(src);
            dst2.SetTo(0);
            vbc.task.pointCloud.CopyTo(dst2, dense.dst2);
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(new Mat(dst2.Size(), MatType.CV_8UC3, Scalar.White));
        }
    }




    public class OpenGL_ViewObjects_CS : VB_Parent
    {
        GuidedBP_Points bpDoctor = new GuidedBP_Points();
        public OpenGL_ViewObjects_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Identify the objects in the scene and display them in OpenGL with their respective colors.";
        }
        public void RunAlg(Mat src)
        {
            dst1 = vbc.task.pointCloud.Clone();
            bpDoctor.Run(src);
            dst2 = bpDoctor.dst2;
            dst0 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(0, 255, ThresholdTypes.Binary);
            dst1.SetTo(0, ~dst0);
            vbc.task.ogl.pointCloudInput = dst1;
            vbc.task.ogl.Run(dst2);
        }
    }




    public class OpenGL_NoSolo_CS : VB_Parent
    {
        BackProject_SoloTop hotTop = new BackProject_SoloTop();
        BackProject_SoloSide hotSide = new BackProject_SoloSide();
        public OpenGL_NoSolo_CS()
        {
            vbc.task.useXYRange = false;
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            labels[2] = "The points below were identified as solo points in the point cloud";
            desc = "Display point cloud without solo points";
        }
        public void RunAlg(Mat src)
        {
            hotTop.Run(src);
            dst2 = hotTop.dst3;
            hotSide.Run(src);
            dst2 = dst2 | hotSide.dst3;
            if (!vbc.task.gOptions.debugChecked)
                vbc.task.pointCloud.SetTo(0, dst2);
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            SetTrueText("Toggle the solo points on and off using the 'DebugCheckBox' global option.", 3);
        }
    }




    public class OpenGL_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public OpenGL_RedCloud_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Display all the RedCloud cells in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(dst2);
        }
    }




    public class OpenGL_RedCloudSpectrum_CS : VB_Parent
    {
        Spectrum_RedCloud redS = new Spectrum_RedCloud();
        public OpenGL_RedCloudSpectrum_CS()
        {
            vbc.task.redOptions.setUseDepth(true);
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Display all the RedCloud cells after Spectrum filtering.";
        }
        public void RunAlg(Mat src)
        {
            redS.Run(src);
            dst2 = redS.dst3;
            vbc.task.pointCloud.SetTo(0, dst2.InRange(0, 0));
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(dst2);
        }
    }




    public class OpenGL_RedCloudCell_CS : VB_Parent
    {
        Spectrum_Z specZ = new Spectrum_Z();
        Spectrum_Breakdown breakdown = new Spectrum_Breakdown();
        public OpenGL_RedCloudCell_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Isolate a RedCloud cell - after filtering by Spectrum_Depth - in an OpenGL display";
        }
        public void RunAlg(Mat src)
        {
            dst2 = specZ.options.runRedCloud(ref labels[2]);
            specZ.Run(src);
            SetTrueText(specZ.strOut, 3);
            if (vbc.task.ClickPoint == new cv.Point() && vbc.task.redCells.Count() > 1)
            {
                vbc.task.rc = vbc.task.redCells[1]; // pick the largest cell
                vbc.task.ClickPoint = vbc.task.rc.maxDist;
            }
            breakdown.Run(src);
            vbc.task.ogl.pointCloudInput.SetTo(0);
            vbc.task.pointCloud[vbc.task.rc.rect].CopyTo(vbc.task.ogl.pointCloudInput[vbc.task.rc.rect], vbc.task.rc.mask);
            vbc.task.ogl.Run(dst2);
            if (vbc.task.gOptions.getOpenGLCapture())
                dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_FilteredSideView_CS : VB_Parent
    {
        BackProject2D_FilterSide filter = new BackProject2D_FilterSide();
        public OpenGL_FilteredSideView_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Use the BackProject2D_FilterSide to remove low sample bins and trim the loose fragments in 3D";
        }
        public void RunAlg(Mat src)
        {
            filter.Run(src);
            dst2 = filter.dst2;
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
        }
    }




    public class OpenGL_FilteredTopView_CS : VB_Parent
    {
        BackProject2D_FilterTop filter = new BackProject2D_FilterTop();
        public OpenGL_FilteredTopView_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Use the BackProject2D_FilterSide to remove low sample bins and trim the loose fragments in 3D";
        }
        public void RunAlg(Mat src)
        {
            filter.Run(src);
            dst2 = filter.dst2;
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
        }
    }




    public class OpenGL_FilteredBoth_CS : VB_Parent
    {
        BackProject2D_FilterBoth filter = new BackProject2D_FilterBoth();
        public OpenGL_FilteredBoth_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Use the BackProject2D_FilterSide/Top to remove low sample bins and trim the loose fragments in 3D";
        }
        public void RunAlg(Mat src)
        {
            filter.Run(src);
            dst2 = filter.dst2;
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
        }
    }




    public class OpenGL_Filtered3D_CS : VB_Parent
    {
        Hist3Dcloud_BP_Filter filter = new Hist3Dcloud_BP_Filter();
        public OpenGL_Filtered3D_CS()
        {
            vbc.task.gOptions.setOpenGLCapture(true);
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Use the BackProject2D_FilterSide/Top to remove low sample bins and trim the loose fragments in 3D";
        }
        public void RunAlg(Mat src)
        {
            filter.Run(src);
            dst2 = filter.dst3;
            vbc.task.ogl.pointCloudInput = dst2;
            vbc.task.ogl.Run(src);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_HistNorm3D_CS : VB_Parent
    {
        public OpenGL_HistNorm3D_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Create an OpenGL plot using the BGR data normalized to between 0 and 1.";
        }
        public void RunAlg(Mat src)
        {
            src.ConvertTo(src, MatType.CV_32FC3);
            vbc.task.ogl.pointCloudInput = src.Normalize(0, 1, NormTypes.MinMax);
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_HistDepth3D_CS : VB_Parent
    {
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        public OpenGL_HistDepth3D_CS()
        {
            vbc.task.ogl.oglFunction = (int)oCase.Histogram3D;
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.options.PointSizeSlider.Value = 10;
            desc = "Display the 3D histogram of the depth in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            hcloud.Run(src);
            Mat histogram = cv.Mat.FromPixelData(vbc.task.redOptions.histBins3D, 1, MatType.CV_32F, hcloud.histogram.Data);
            vbc.task.ogl.dataInput = histogram;
            vbc.task.ogl.pointCloudInput = new Mat();
            vbc.task.ogl.Run(new Mat());
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
            SetTrueText("Use the sliders for X/Y/Z histogram bins to add more points");
        }
    }




    public class OpenGL_SoloPointsRemoved_CS : VB_Parent
    {
        Area_SoloPoints solos = new Area_SoloPoints();
        public OpenGL_SoloPointsRemoved_CS()
        {
            vbc.task.gOptions.setUnfiltered(true); // show all the unfiltered points so removing the points is obvious.
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            desc = "Remove the solo points and display the pointcloud";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.toggleOnOff)
            {
                solos.Run(src);
                dst2 = solos.dst2;
                vbc.task.pointCloud.SetTo(0, dst2);
            }
            else
            {
                dst2.SetTo(0);
            }
            vbc.task.ogl.pointCloudInput = vbc.task.pointCloud;
            vbc.task.ogl.Run(src);
            SetTrueText("You should see the difference in the OpenGL window as the solo points are toggled on an off.", 3);
        }
    }





    public class OpenGL_Duster_CS : VB_Parent
    {
        Duster_Basics duster = new Duster_Basics();
        Options_OpenGL_Duster options = new Options_OpenGL_Duster();
        public OpenGL_Duster_CS()
        {
            desc = "Show a dusted version point cloud";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            duster.Run(src);
            dst2 = duster.dst3;
            vbc.task.ogl.pointCloudInput = options.useTaskPointCloud ? vbc.task.pointCloud : duster.dst2;
            vbc.task.ogl.Run(options.useClusterColors == false ? vbc.task.color : dst2);
        }
    }




    public class OpenGL_DusterY_CS : VB_Parent
    {
        Duster_BasicsY duster = new Duster_BasicsY();
        Options_OpenGL_Duster options = new Options_OpenGL_Duster();
        public OpenGL_DusterY_CS()
        {
            desc = "Show a dusted version point cloud";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            duster.Run(src);
            dst2 = duster.dst3;
            vbc.task.ogl.pointCloudInput = options.useTaskPointCloud ? vbc.task.pointCloud : duster.dst2;
            vbc.task.ogl.Run(options.useClusterColors == false ? vbc.task.color : dst2);
        }
    }




    public class OpenGL_Color3D_CS : VB_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public OpenGL_Color3D_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            vbc.task.ogl.options.PointSizeSlider.Value = 10;
            desc = "Plot the results of a 3D histogram of the BGR data ";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            dst2 = hColor.dst3;
            labels[2] = hColor.labels[2];
            dst2.ConvertTo(dst1, MatType.CV_32FC3);
            dst1 = dst1.Normalize(0, 1, NormTypes.MinMax);
            var split = dst1.Split();
            split[1] *= -1;
            Cv2.Merge(split, vbc.task.ogl.pointCloudInput);
            vbc.task.ogl.Run(dst2);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }





    public class OpenGL_ColorReduced3D_CS : VB_Parent
    {
        private Color8U_Basics colorClass = new Color8U_Basics();

        public OpenGL_ColorReduced3D_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.oglFunction = (int) oCase.pointCloudAndRGB;
            FindSlider("OpenGL Point Size").Value = 20;
            desc = "Connect the 3D representation of the different color formats with colors in that format (see dst2)";
        }

        public void RunAlg(Mat src)
        {
            colorClass.Run(src);
            dst2 = colorClass.dst3;
            if (dst2.Channels() == 1)
                dst2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst2.ConvertTo(dst1, MatType.CV_32FC3);
            labels[2] = $"There are {colorClass.classCount} classes for {vbc.task.redOptions.colorInputName}";
            dst1 = dst1.Normalize(0, 1, NormTypes.MinMax);
            Mat[] split = dst1.Split();
            split[1] *= -1;
            Cv2.Merge(split, vbc.task.ogl.pointCloudInput);
            vbc.task.ogl.Run(dst2);
            if (vbc.task.gOptions.getOpenGLCapture())
                dst3 = vbc.task.ogl.dst3;
        }
    }



    public class OpenGL_ColorRaw_CS : VB_Parent
    {
        public OpenGL_ColorRaw_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            vbc.task.ogl.options.PointSizeSlider.Value = 10;
            desc = "Plot the results of a 3D histogram of the BGR data";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            src.ConvertTo(dst1, MatType.CV_32FC3);
            dst1 = dst1.Normalize(0, 1, NormTypes.MinMax);
            var split = dst1.Split();
            split[1] *= -1;
            Cv2.Merge(split, vbc.task.ogl.pointCloudInput);
            vbc.task.ogl.Run(dst2);
            if (vbc.task.gOptions.getOpenGLCapture()) dst3 = vbc.task.ogl.dst3;
        }
    }




    public class OpenGL_ColorBin4Way_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public OpenGL_ColorBin4Way_CS()
        {
            vbc.task.OpenGLTitle = "OpenGL_Functions";
            vbc.task.ogl.oglFunction = (int)oCase.pointCloudAndRGB;
            vbc.task.ogl.options.PointSizeSlider.Value = 10;
            dst0 = new Mat(dst0.Size(), MatType.CV_8UC3, Scalar.White);
            desc = "Plot the results of a 3D histogram of the lightest and darkest BGR data";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst1.SetTo(0);
            vbc.task.color[vbc.task.rc.rect].CopyTo(dst1[vbc.task.rc.rect], vbc.task.rc.mask);
            dst1.ConvertTo(dst3, MatType.CV_32FC3);
            dst3 = dst3.Normalize(0, 1, NormTypes.MinMax);
            var split = dst3.Split();
            split[1] *= -1;
            Cv2.Merge(split, vbc.task.ogl.pointCloudInput);
            vbc.task.ogl.Run(dst0);
        }
    }




    public class ORB_Basics_CS : VB_Parent
    {
        public KeyPoint[] keypoints;
        ORB orb;
        Options_ORB options = new Options_ORB();
        public ORB_Basics_CS()
        {
            desc = "Find keypoints using ORB - Oriented Fast and Rotated BRIEF";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Channels() == 3)
                src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            orb = ORB.Create(options.desiredCount);
            keypoints = orb.Detect(src);
            dst2 = src.Clone();
            foreach (KeyPoint kpt in keypoints)
            {
                DrawCircle(dst2, kpt.Pt, vbc.task.DotSize + 1, Scalar.Yellow);
            }
            labels[2] = keypoints.Length + " key points were identified";
        }
    }




    public class Palette_Basics_CS : VB_Parent
    {
        public bool whitebackground;
        ColormapTypes[] choices = { ColormapTypes.Autumn, ColormapTypes.Bone, ColormapTypes.Cividis, ColormapTypes.Cool,
                                    ColormapTypes.Hot, ColormapTypes.Hsv, ColormapTypes.Inferno, ColormapTypes.Jet,
                                    ColormapTypes.Magma, ColormapTypes.Ocean, ColormapTypes.Parula, ColormapTypes.Pink,
                                    ColormapTypes.Plasma, ColormapTypes.Rainbow, ColormapTypes.Spring, ColormapTypes.Summer,
                                    ColormapTypes.Twilight, ColormapTypes.TwilightShifted, ColormapTypes.Viridis,
                                    ColormapTypes.Winter};
        public Palette_Basics_CS()
    {
            desc = "Apply the different color maps in OpenCV";
        }
        public void RunAlg(Mat src)
        {
            labels[2] = "ColorMap = " + vbc.task.gOptions.getPalette();
            if (src.Type() == MatType.CV_32F)
            {
                src = Convert32f_To_8UC3(src);
                src.ConvertTo(src, MatType.CV_8U);
            }
            Cv2.ApplyColorMap(src, dst2, choices[vbc.task.paletteIndex]);
        }
    }




    public class Palette_Color_CS : VB_Parent
    {
        Options_Colors options = new Options_Colors();
        public Palette_Color_CS()
        {
            desc = "Define a color Using sliders.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2.SetTo(new Scalar(options.blueS, options.greenS, options.redS));
            dst3.SetTo(new Scalar(255 - options.blueS, 255 - options.greenS, 255 - options.redS));
            labels[2] = "Color (RGB) = " + options.blueS + " " + options.greenS + " " + options.redS;
            labels[3] = "Color (255 - RGB) = " + (255 - options.blueS) + " " + (255 - options.greenS) + " " +
                            (255 - options.redS);
        }
    }




    public class Palette_LinearPolar_CS : VB_Parent
    {
        public Options_Resize rotateOptions = new Options_Resize();
        Point2f pt;
        TrackBar radiusSlider;
        Options_Palette options = new Options_Palette();
        public Palette_LinearPolar_CS()
        {
            radiusSlider = FindSlider("LinearPolar radius");
            pt = new Point2f(msRNG.Next(0, dst2.Cols - 1), msRNG.Next(0, dst2.Rows - 1));
            desc = "Use LinearPolar To create gradient image";
        }
        public void RunAlg(Mat src)
        {
            dst2.SetTo(0);
            for (int i = 0; i < dst2.Rows; i++)
            {
                var c = i * 255 / dst2.Rows;
                dst2.Row(i).SetTo(new Scalar(c, c, c));
            }
            rotateOptions.RunOpt();
            dst3.SetTo(0);
            if (rotateOptions.warpFlag == InterpolationFlags.WarpInverseMap)
                radiusSlider.Value = radiusSlider.Maximum;
            Cv2.LinearPolar(dst2, dst2, pt, options.radius, rotateOptions.warpFlag);
            Cv2.LinearPolar(src, dst3, pt, options.radius, rotateOptions.warpFlag);
        }
    }




    public class Palette_Reduction_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        public Palette_Reduction_CS()
        {
            UpdateAdvice(traceName + ": redOptions 'Reduction' to control results.");
            desc = "Map colors To different palette";
            labels[2] = "Reduced Colors";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst3 = reduction.dst2;
            dst2 = ShowPalette(dst3 * 255 / reduction.classCount);
        }
    }




    public class Palette_DrawTest_CS : VB_Parent
    {
        Draw_Shapes draw = new Draw_Shapes();
        public Palette_DrawTest_CS()
        {
            desc = "Experiment With palette Using a drawn image";
        }
        public void RunAlg(Mat src)
        {
            draw.Run(src);
            dst2 = ShowPalette(draw.dst2);
        }
    }




    public class Palette_Gradient_CS : VB_Parent
    {
        public Scalar color1;
        public Scalar color2;
        public Palette_Gradient_CS()
        {
            labels[3] = "From And To colors";
            desc = "Create gradient image";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                if (standaloneTest())
                {
                    color1 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                    color2 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                    dst3.SetTo(color1);
                    dst3[new cv.Rect(0, 0, dst3.Width, dst3.Height / 2)].SetTo(color2);
                }
                var dst1 = new Mat(255, 1, MatType.CV_8UC3);
                double f = 1.0;
                for (int i = 0; i < dst1.Rows; i++)
                {
                    dst1.Set<Vec3b>(i, 0, new Vec3b((byte)(f * color2[0] + (1 - f) * color1[0]),
                                                    (byte)(f * color2[1] + (1 - f) * color1[1]),
                                                    (byte)(f * color2[2] + (1 - f) * color1[2])));
                    f -= 1 / (double)dst1.Rows;
                }
            }
            if (standaloneTest()) dst2 = dst1.Resize(dst2.Size());
        }
    }




    public class Palette_DepthColorMap_CS : VB_Parent
    {
        public Mat gradientColorMap = new Mat();
        Gradient_Color gColor = new Gradient_Color();
        Options_Palette options = new Options_Palette();
        public Palette_DepthColorMap_CS()
        {
            UpdateAdvice(traceName + ": adjust color with 'Convert and Scale' slider");
            labels[3] = "Palette used To color left image";
            desc = "Build a colormap that best shows the depth.  NOTE: custom color maps need to use C++ ApplyColorMap.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                gColor.color1 = Scalar.Yellow;
                gColor.color2 = Scalar.Red;
                var gradMat = new Mat();
                gColor.gradientWidth = dst1.Width;
                gColor.Run(empty);
                gradientColorMap = gColor.gradient;
                gColor.color2 = gColor.color1;
                gColor.color1 = Scalar.Blue;
                gColor.Run(empty);
                Cv2.HConcat(gradientColorMap, gColor.gradient, gradientColorMap);
                gradientColorMap = gradientColorMap.Resize(new cv.Size(255, 1));
                if (standaloneTest())
                {
                    if (dst3.Width < 255) dst3 = new Mat(dst3.Height, 255, MatType.CV_8UC3, cv.Scalar.All(0));
                    var r = new cv.Rect(0, 0, 255, 1);
                    for (int i = 0; i < dst3.Height; i++)
                    {
                        r.Y = i;
                        dst3[r] = gradientColorMap;
                    }
                }
            }
            var depth8u = vbc.task.pcSplit[2].ConvertScaleAbs(options.convertScale);
            var ColorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, gradientColorMap.Data);
            Cv2.ApplyColorMap(depth8u, dst2, ColorMap);
            dst2.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class Palette_RGBDepth_CS : VB_Parent
    {
        Mat gradientColorMap = new Mat();
        Gradient_Color gColor = new Gradient_Color();
        public Palette_RGBDepth_CS()
        {
            desc = "Build a colormap that best shows the depth.  NOTE: duplicate of Palette_DepthColorMap but no slider.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
            {
                gColor.color1 = Scalar.Yellow;
                gColor.color2 = Scalar.Red;
                var gradMat = new Mat();
                gColor.gradientWidth = dst1.Width;
                gColor.Run(empty);
                gradientColorMap = gColor.gradient;
                gColor.color2 = gColor.color1;
                gColor.color1 = Scalar.Blue;
                gColor.Run(empty);
                Cv2.HConcat(gradientColorMap, gColor.gradient, gradientColorMap);
                gradientColorMap = gradientColorMap.Resize(new cv.Size(255, 1));
            }
            var sliderVal = (vbc.task.cameraName == "Intel(R) RealSense(TM) Depth Camera 435i") ? 50 : 80;
            var depth8u = vbc.task.pcSplit[2].ConvertScaleAbs(sliderVal);
            var ColorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, gradientColorMap.Data);
            Cv2.ApplyColorMap(depth8u, dst2, ColorMap);
        }
    }




    public class Palette_Layout2D_CS : VB_Parent
    {
        public Palette_Layout2D_CS()
        {
            desc = "Layout the available colors in a 2D grid";
        }
        public void RunAlg(Mat src)
        {
            int index = 0;
            foreach (var r in vbc.task.gridRects)
            {
                dst2[r].SetTo(vbc.task.scalarColors[index % 256]);
                index++;
            }
            labels[2] = "Palette_Layout2D_CS - " + vbc.task.gridRects.Count().ToString() + " regions";
        }
    }




    public class Palette_LeftRightImages_CS : VB_Parent
    {
        public Palette_LeftRightImages_CS()
        {
            desc = "Use a palette with the left and right images.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = ShowPalette(vbc.task.leftView.ConvertScaleAbs());
            dst3 = ShowPalette(vbc.task.rightView.ConvertScaleAbs());
        }
    }




    public class Palette_TaskColors_CS : VB_Parent
    {
        int direction = 1;
        public Palette_TaskColors_CS()
        {
            labels = new string[] { "", "", "ScalarColors", "VecColors" };
            desc = "Display that vbc.task.scalarColors and vbc.task.vecColors";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.gridSize <= 10) direction *= -1;
            if (vbc.task.gridSize >= 100) direction *= -1;
            vbc.task.gridSize -= direction * 1;
            vbc.task.grid.Run(src);
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                dst2[roi].SetTo(vbc.task.scalarColors[i % 256]);
                dst3[roi].SetTo(vbc.task.vecColors[i % 256]);
            }
        }
    }




    public class Palette_Create_CS : VB_Parent
    {
        Mat colorGrad = new Mat();
        string activeSchemeName = "";
        int saveColorTransitionCount = -1;
        Options_Palette options = new Options_Palette();
        public Palette_Create_CS()
        {
            desc = "Create a new palette";
        }
        Mat colorTransition(Scalar color1, Scalar color2, int width)
        {
            double f = 1.0;
            var gradientColors = new Mat(1, width, MatType.CV_64FC3);
            for (int i = 0; i < width; i++)
            {
                gradientColors.Set(0, i, new Scalar(f * color2[0] + (1 - f) * color1[0], f * color2[1] + (1 - f) * color1[1],
                    f * color2[2] + (1 - f) * color1[2]));
                f -= 1.0 / width;
            }
            var result = new Mat(1, width, MatType.CV_8UC3);
            for (int i = 0; i < width; i++)
            {
                result.Col(i).SetTo(gradientColors.Get<Scalar>(0, i));
            }
            return result;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (activeSchemeName != options.schemeName || options.transitions != saveColorTransitionCount)
            {
                activeSchemeName = options.schemeName;
                saveColorTransitionCount = options.transitions;
                if (activeSchemeName == "schemeRandom")
                {
                    var msRNG = new Random();
                    var color1 = new Scalar(0, 0, 0);
                    var color2 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                    Mat gradMat = new Mat();
                    for (int i = 0; i <= options.transitions; i++)
                    {
                        gradMat = colorTransition(color1, color2, 255);
                        color1 = color2;
                        color2 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                        if (i == 0) colorGrad = gradMat; else Cv2.HConcat(colorGrad, gradMat, colorGrad);
                    }
                    colorGrad = colorGrad.Resize(new cv.Size(256, 1));
                    Cv2.ImWrite(vbc.task.HomeDir + "data\\nextScheme.jpg", colorGrad); // use this to create new color schemes.
                }
                else
                {
                    colorGrad = Cv2.ImRead(options.schemeName).Row(0).Clone();
                }
            }
            SetTrueText("Use the 'Color Transitions' slider and radio buttons to change the color ranges.", 3);
            var depth8u = vbc.task.pcSplit[2].ConvertScaleAbs(options.transitions);
            var colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, colorGrad.Data);
            Cv2.ApplyColorMap(depth8u, dst2, colorMap);
            dst2.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class Palette_Random_CS : VB_Parent
    {
        public Mat colorMap;
        public Palette_Random_CS()
        {
            UpdateAdvice(traceName + ": There are no options\nJust produces a colorMap filled with random vec3b's.");
            colorMap = new Mat(256, 1, MatType.CV_8UC3, cv.Scalar.All(0));
            for (int i = 0; i <= 255; i++)
            {
                colorMap.Set<Vec3b>(i, 0, randomCellColor());
            }
            desc = "Build a random colorGrad - no smooth transitions.";
        }
        public void RunAlg(Mat src)
        {
            Cv2.ApplyColorMap(src, dst2, colorMap);
        }
    }




    public class Palette_Variable_CS : VB_Parent
    {
        public Mat colorGrad;
        public Mat originalColorMap;
        public List<Vec3b> colors = new List<Vec3b>();
        public Palette_Variable_CS()
        {
            colorGrad = new Mat(1, 256, MatType.CV_8UC3, cv.Scalar.All(0));
            for (int i = 0; i <= 255; i++)
            {
                colorGrad.Set<Vec3b>(0, i, randomCellColor());
            }
            originalColorMap = colorGrad.Clone();
            desc = "Build a new palette for every frame.";
        }
        public void RunAlg(Mat src)
        {
            for (int i = 0; i < colors.Count(); i++)
            {
                colorGrad.Set<Vec3b>(0, i, colors[i]);
            }
            var colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, colorGrad.Data);
            Cv2.ApplyColorMap(src, dst2, colorMap);
        }
    }




    public class Palette_RandomColorMap_CS : VB_Parent
    {
        public Mat gradientColorMap = new Mat();
        public int transitionCount = -1;
        Gradient_Color gColor = new Gradient_Color();
        Options_Palette options = new Options_Palette();
        public Palette_RandomColorMap_CS()
        {
            labels[3] = "Generated colormap";
            desc = "Build a random colormap that smoothly transitions colors";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (transitionCount != options.transitions)
            {
                transitionCount = options.transitions;
                gColor.color1 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                gColor.color2 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                for (int i = 0; i < transitionCount; i++)
                {
                    gColor.gradientWidth = dst2.Width;
                    gColor.Run(empty);
                    gColor.color2 = gColor.color1;
                    gColor.color1 = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                    if (i == 0) gradientColorMap = gColor.gradient; else Cv2.HConcat(gradientColorMap, gColor.gradient, gradientColorMap);
                }
                gradientColorMap = gradientColorMap.Resize(new cv.Size(256, 1));
                if (standaloneTest()) dst3 = gradientColorMap;
                gradientColorMap.Set<Vec3b>(0, 0, new Vec3b()); // black is black!
            }
            var ColorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, gradientColorMap.Data);
            Cv2.ApplyColorMap(src, dst2, ColorMap);
        }
    }




    public class Palette_LoadColorMap_CS : VB_Parent
    {
        public bool whitebackground;
        public Mat colorMap = new Mat();
        DirectoryInfo cMapDir;
        public Palette_LoadColorMap_CS()
        {
            cMapDir = new DirectoryInfo(vbc.task.HomeDir + "opencv/modules/imgproc/doc/pics/colormaps");
            desc = "Apply the different color maps in OpenCV";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged || colorMap.Rows != 256)
            {
                labels[2] = "ColorMap = " + vbc.task.gOptions.getPalette();
                var str = cMapDir.FullName + "/colorscale_" + vbc.task.gOptions.getPalette() + ".jpg";
                var mapFile = new FileInfo(str);
                var tmp = Cv2.ImRead(mapFile.FullName);
                tmp.Col(0).SetTo(whitebackground ? Scalar.White : Scalar.Black);
                tmp = tmp.Row(0);
                colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, tmp.Data).Clone();
            }
            if (src.Type() == MatType.CV_32F)
            {
                src = Convert32f_To_8UC3(src);
                src.ConvertTo(src, MatType.CV_8U);
            }
            Cv2.ApplyColorMap(src, dst2, colorMap);
            if (standalone) dst3 = colorMap.Resize(dst3.Size());
        }
    }




    public class Palette_CustomColorMap_CS : VB_Parent
    {
        public Mat colorMap;
        public Palette_CustomColorMap_CS()
        {
            labels[2] = "ColorMap = " + vbc.task.gOptions.getPalette();
            if (standalone)
            {
                var cMapDir = new DirectoryInfo(vbc.task.HomeDir + "opencv/modules/imgproc/doc/pics/colormaps");
                var str = cMapDir.FullName + "/colorscale_" + vbc.task.gOptions.getPalette() + ".jpg";
                var mapFile = new FileInfo(str);
                var tmp = Cv2.ImRead(mapFile.FullName);
                colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, tmp.Data).Clone();
            }
            desc = "Apply the provided color map to the input image.";
        }
        public void RunAlg(Mat src)
        {
            if (colorMap == null)
            {
                SetTrueText("With " + traceName + " the colorMap must be provided.  Update the ColorMap Mat and then call Run(src)...");
                return;
            }
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (src.Type() == MatType.CV_32F)
            {
                src = Convert32f_To_8UC3(src);
                src.ConvertTo(src, MatType.CV_8U);
            }
            Cv2.ApplyColorMap(src, dst2, colorMap);
            if (standalone) dst3 = colorMap.Resize(dst3.Size());
        }
    }




    public class Palette_GrayToColor_CS : VB_Parent
    {
        public Palette_GrayToColor_CS()
        {
            desc = "Build a palette for the current image using samples from each gray level.  Everything turns out sepia-like.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var pixels = new List<byte>();
            var colors = new SortedList<byte, Vec3b>();
            for (int y = 0; y < dst2.Height; y++)
            {
                for (int x = 0; x < dst2.Width; x++)
                {
                    var val = dst2.Get<byte>(y, x);
                    var color = src.Get<Vec3b>(y, x);
                    if (!pixels.Contains(val))
                    {
                        pixels.Add(val);
                        colors.Add(val, color);
                    }
                    else
                    {
                        var sum = color[0] + color[1] + color[2];
                        var index = colors.Keys.IndexOf(val);
                        var lastColor = colors.ElementAt(index).Value;
                        var lastSum = lastColor[0] + lastColor[1] + lastColor[2];
                        if (sum > lastSum)
                        {
                            colors.RemoveAt(index);
                            colors.Add(val, color);
                        }
                    }
                }
            }
            var ColorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, colors.Values.ToArray());
            Cv2.ApplyColorMap(src, dst2, ColorMap);
        }
    }




    public class ParticleFilter_Example_CS : VB_Parent
    {
        int imageFrame = 12;
        public ParticleFilter_Example_CS()
        {
            cPtr = ParticleFilterTest_Open(vbc.task.HomeDir + "/Data/ballSequence/", dst2.Rows, dst2.Cols);
            desc = "Particle Filter example downloaded from github - hyperlink in the code shows URL.";
        }
        public void RunAlg(Mat src)
        {
            imageFrame += 1;
            if (imageFrame % 45 == 0)
            {
                imageFrame = 13;
                ParticleFilterTest_Close(cPtr);
                cPtr = ParticleFilterTest_Open(vbc.task.HomeDir + "/Data/ballSequence/", dst2.Rows, dst2.Cols);
            }
            var nextFile = new FileInfo(vbc.task.HomeDir + "Data/ballSequence/color_" + imageFrame.ToString() + ".png");
            dst3 = Cv2.ImRead(nextFile.FullName).Resize(dst2.Size());
            IntPtr imagePtr = ParticleFilterTest_Run(cPtr);
            dst2 = cv.Mat.FromPixelData(dst2.Rows, dst2.Cols, MatType.CV_8UC3, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = ParticleFilterTest_Close(cPtr);
        }
    }




    public class PCA_Prep_CPP_CS : VB_Parent
    {
        public Mat inputData = new Mat();
        public PCA_Prep_CPP_CS()
        {
            cPtr = PCA_Prep_Open();
            desc = "Take some pointcloud data and return the non-zero points in a point3f vector";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = PCA_Prep_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();
            int count = PCA_Prep_GetCount(cPtr);
            inputData = cv.Mat.FromPixelData(count, 3, MatType.CV_32F, imagePtr).Clone();
            SetTrueText("Data has been prepared and resides in inputData public");
        }
        public void Close()
        {
            PCA_Prep_Close(cPtr);
        }
    }




    public class PCA_Palettize_CS : VB_Parent
    {
        public byte[] palette;
        public byte[] rgb;
        public byte[] buff;
        Palette_CustomColorMap custom = new Palette_CustomColorMap();
        public byte[] paletteImage;
        public PCA_NColor_CS nColor;
        public Options_PCA_NColor options = new Options_PCA_NColor();
        public PCA_Palettize_CS()
        {
            nColor = new PCA_NColor_CS();
            FindSlider("Desired number of colors").Value = 256;
            desc = "Create a palette for the input image but don't use it.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            rgb = new byte[src.Total() * src.ElemSize()];
            buff = new byte[rgb.Length];
            Marshal.Copy(src.Data, rgb, 0, rgb.Length);
            Marshal.Copy(src.Data, buff, 0, buff.Length);
            palette = nColor.MakePalette(rgb, dst2.Width, dst2.Height, options.desiredNcolors);
            if (standaloneTest())
            {
                paletteImage = nColor.RgbToIndex(rgb, dst1.Width, dst1.Height, palette, options.desiredNcolors);
                Mat img8u = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
                Marshal.Copy(paletteImage, 0, img8u.Data, paletteImage.Length);
                custom.colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, palette);
                custom.Run(img8u);
                dst2 = custom.dst2;
            }
            labels[2] = "The palette found from the current image (repeated across the image) with " + options.desiredNcolors.ToString() + " entries";
        }
    }




    public class PCA_Basics_CS : VB_Parent
    {
        PCA_Prep_CPP_VB prep = new PCA_Prep_CPP_VB();
        public PCA pca_analysis = new PCA();
        public bool runRedCloud;
        RedCloud_Basics redC = new RedCloud_Basics();
        public PCA_Basics_CS()
        {
            desc = "Find the Principal Component Analysis vector for the 3D points in a RedCloud cell contour.";
        }
        public string displayResults()
        {
            string pcaStr = "EigenVector 3X3 matrix from PCA_Analysis of cell point cloud data at contour points:\n";
            for (int y = 0; y < pca_analysis.Eigenvectors.Rows; y++)
            {
                for (int x = 0; x < pca_analysis.Eigenvectors.Cols; x++)
                {
                    float val = pca_analysis.Eigenvectors.Get<float>(y, x);
                    pcaStr += string.Format("{0}\t", val.ToString("F3"));
                }
                pcaStr += "\n";
            }
            List<float> valList = new List<float>();
            pcaStr += "EigenValues (PCA)\t";
            for (int i = 0; i < pca_analysis.Eigenvalues.Rows; i++)
            {
                float val = pca_analysis.Eigenvalues.Get<float>(i, 0);
                pcaStr += string.Format("{0}\t", val.ToString("F3"));
                valList.Add(val);
            }
            if (valList.Count() == 0) return pcaStr;
            float best = valList.Min();
            int index = valList.IndexOf(best);
            pcaStr += "Min EigenValue = " + best.ToString("F3") + " at index = " + index.ToString() + "\n";
            pcaStr += "Principal Component Vector\t";
            for (int j = 0; j < pca_analysis.Eigenvectors.Cols; j++)
            {
                float val = pca_analysis.Eigenvectors.Get<float>(index, j);
                pcaStr += string.Format("{0}\t", val.ToString("F3"));
            }
            pcaStr += "\n";
            return pcaStr;
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || runRedCloud)
            {
                if (vbc.task.FirstPass) vbc.task.redOptions.setUseColorOnly(true);
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
            }
            var rc = vbc.task.rc;
            List<Point3f> inputPoints = new List<Point3f>();
            foreach (var pt in rc.contour)
            {
                var vec = vbc.task.pointCloud[rc.rect].Get<Point3f>(pt.Y, pt.X);
                if (vec.Z > 0) inputPoints.Add(vec);
            }
            if (inputPoints.Count() > 0)
            {
                Mat inputMat = cv.Mat.FromPixelData(inputPoints.Count(), 3, MatType.CV_32F, inputPoints.ToArray());
                pca_analysis = new PCA(inputMat, new Mat(), PCA.Flags.DataAsRow);
                strOut = displayResults();
                SetTrueText(strOut, 3);
            }
            else
            {
                SetTrueText("Select a cell to compute the eigenvector");
            }
        }
    }




    public class PCA_CellMask_CS : VB_Parent
    {
        PCA_Basics pca = new PCA_Basics();
        PCA_Prep_CPP_VB pcaPrep = new PCA_Prep_CPP_VB();
        public PCA_CellMask_CS()
        {
            pca.runRedCloud = true;
            desc = "Find the Principal Component Analysis vector for all the 3D points in a RedCloud cell.";
        }
        public void RunAlg(Mat src)
        {
            pca.Run(src);
            dst2 = pca.dst2;
            labels[2] = pca.labels[2];
            var rc = vbc.task.rc;
            if (rc.maxVec.Z > 0)
            {
                pcaPrep.Run(vbc.task.pointCloud[rc.rect].Clone());
                if (pcaPrep.inputData.Rows > 0)
                {
                    pca.pca_analysis = new PCA(pcaPrep.inputData, new Mat(), PCA.Flags.DataAsRow);
                    strOut = pca.displayResults();
                }
            }
            else
            {
                strOut = "Selected cell has no 3D data.";
                pca.pca_analysis = null;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class PCA_Reconstruct_CS : VB_Parent
    {
        Mat[] images = new Mat[8];
        Mat[] images32f = new Mat[8];
        Options_PCA options = new Options_PCA();
        public PCA_Reconstruct_CS()
        {
            desc = "Reconstruct a video stream as a composite of X images.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            int index = vbc.task.frameCount % images.Length;
            images[index] = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            images[index].ConvertTo(gray32f, MatType.CV_32F);
            gray32f = gray32f.Normalize(0, 255, NormTypes.MinMax);
            images32f[index] = gray32f.Reshape(1, 1);
            if (vbc.task.frameCount >= images.Length)
            {
                Mat data = new Mat(images.Length, src.Rows * src.Cols, MatType.CV_32F);
                for (int i = 0; i < images.Length; i++)
                {
                    images32f[i].CopyTo(data.Row(i));
                }
                PCA pca = new PCA(data, new Mat(), PCA.Flags.DataAsRow, options.retainedVariance);
                Mat point = pca.Project(data.Row(0));
                Mat reconstruction = pca.BackProject(point);
                reconstruction = reconstruction.Reshape(images[0].Channels(), images[0].Rows);
                reconstruction.ConvertTo(dst2, MatType.CV_8UC1);
            }
        }
    }




    public class PCA_Depth_CS : VB_Parent
    {
        PCA_Reconstruct pca = new PCA_Reconstruct();
        public PCA_Depth_CS()
        {
            desc = "Reconstruct a depth stream as a composite of X images.";
        }
        public void RunAlg(Mat src)
        {
            pca.Run(vbc.task.depthRGB);
            dst2 = pca.dst2;
        }
    }




    public class PCA_DrawImage_CS : VB_Parent
    {
        PCA_Reconstruct pca = new PCA_Reconstruct();
        Mat image = new Mat();
        public PCA_DrawImage_CS()
        {
            image = Cv2.ImRead(vbc.task.HomeDir + "opencv/Samples/Data/pca_test1.jpg");
            desc = "Use PCA to find the principal direction of an object.";
            labels[2] = "Original image";
            labels[3] = "PCA Output";
        }
        void drawAxis(Mat img, cv.Point p, cv.Point q, Scalar color, float scale)
        {
            double angle = Math.Atan2(p.Y - q.Y, p.X - q.X);
            double hypotenuse = Math.Sqrt((p.Y - q.Y) * (p.Y - q.Y) + (p.X - q.X) * (p.X - q.X));
            q.X = (int)(p.X - scale * hypotenuse * Math.Cos(angle));
            q.Y = (int)(p.Y - scale * hypotenuse * Math.Sin(angle));
            img.Line(p, q, color, vbc.task.lineWidth, vbc.task.lineType);
            p.X = (int)(q.X + 9 * Math.Cos(angle + Math.PI / 4));
            p.Y = (int)(q.Y + 9 * Math.Sin(angle + Math.PI / 4));
            img.Line(p, q, color, vbc.task.lineWidth, vbc.task.lineType);
            p.X = (int)(q.X + 9 * Math.Cos(angle - Math.PI / 4));
            p.Y = (int)(q.Y + 9 * Math.Sin(angle - Math.PI / 4));
            img.Line(p, q, color, vbc.task.lineWidth, vbc.task.lineType);
        }
        public void RunAlg(Mat src)
        {
            dst2 = image.Resize(dst2.Size());
            Mat gray = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(50, 255, ThresholdTypes.Binary | ThresholdTypes.Otsu);
            HierarchyIndex[] hierarchy;
            cv.Point[][] contours;
            Cv2.FindContours(gray, out contours, out hierarchy, RetrievalModes.List, ContourApproximationModes.ApproxNone);
            dst3.SetTo(0);
            for (int i = 0; i < contours.Length; i++)
            {
                double area = Cv2.ContourArea(contours[i]);
                if (area < 100 || area > 100000) continue;
                Cv2.DrawContours(dst3, contours, i, Scalar.Red, vbc.task.lineWidth, vbc.task.lineType);
                int sz = contours[i].Length;
                Mat data_pts = new Mat(sz, 2, MatType.CV_64FC1);
                for (int j = 0; j < data_pts.Rows; j++)
                {
                    data_pts.Set<double>(j, 0, contours[i][j].X);
                    data_pts.Set<double>(j, 1, contours[i][j].Y);
                }
                PCA pca_analysis = new PCA(data_pts, new Mat(), PCA.Flags.DataAsRow);
                cv.Point cntr = new cv.Point((int)pca_analysis.Mean.Get<double>(0, 0), (int)pca_analysis.Mean.Get<double>(0, 1));
                Point2d[] eigen_vecs = new Point2d[2];
                double[] eigen_val = new double[2];
                for (int j = 0; j < 2; j++)
                {
                    eigen_vecs[j] = new Point2d(pca_analysis.Eigenvectors.Get<double>(j, 0), pca_analysis.Eigenvectors.Get<double>(j, 1));
                    eigen_val[j] = pca_analysis.Eigenvalues.Get<double>(0, j);
                }
                DrawCircle(dst3, cntr, vbc.task.DotSize + 1, Scalar.BlueViolet);
                float factor = 0.02f;
                cv.Point ept1 = new cv.Point(cntr.X + (int)(factor * eigen_vecs[0].X * eigen_val[0]), cntr.Y + (int)(factor * eigen_vecs[0].Y * eigen_val[0]));
                cv.Point ept2 = new cv.Point(cntr.X - (int)(factor * eigen_vecs[1].X * eigen_val[1]), cntr.Y - (int)(factor * eigen_vecs[1].Y * eigen_val[1]));
                drawAxis(dst3, cntr, ept1, Scalar.Red, 1);
                drawAxis(dst3, cntr, ept2, Scalar.BlueViolet, 5);
            }
        }
    }




    public class PCA_NColor_CS : VB_Parent
    {
#region "PCS_Details"
        [StructLayout(LayoutKind.Sequential)]
        public struct paletteEntry
        {
            public int start;
            public int nCount;
            public byte red;
            public byte green;
            public byte blue;
            public double ErrorVal;
        }
        public double CDiff(byte[] a, int start, byte[] b, int startPal)
        {
            return (a[start + 0] - b[startPal + 0]) * (a[start + 0] - b[startPal + 0]) * 5 +
                    (a[start + 1] - b[startPal + 1]) * (a[start + 1] - b[startPal + 1]) * 8 +
                    (a[start + 2] - b[startPal + 2]) * (a[start + 2] - b[startPal + 2]) * 2;
        }
        public byte[] RgbToIndex(byte[] rgb, int width, int height, byte[] pal, int nColor)
        {
            byte[] answer = new byte[width * height];
            for (int i = 0; i < width * height; i++)
            {
                double best = CDiff(rgb, i * 3, pal, 0);
                int bestii = 0;
                for (int ii = 1; ii < nColor; ii++)
                {
                    double nextError = CDiff(rgb, i * 3, pal, ii * 3);
                    if (nextError < best)
                    {
                        best = nextError;
                        bestii = ii;
                    }
                }
                answer[i] = (byte)bestii;
            }
            return answer;
        }
        public byte[] MakePalette(byte[] rgb, int width, int height, int nColors)
        {
            byte[] buff = new byte[width * height * 3];
            paletteEntry[] entry = new paletteEntry[nColors];
            double best;
            int bestii;
            int i, ii;
            byte[] pal = new byte[256 * 3];
            Array.Copy(rgb, buff, width * height * 3);
            entry[0].start = 0;
            entry[0].nCount = width * height;
            CalcError(ref entry[0], ref buff);
            for (i = 1; i < nColors; i++)
            {
                best = entry[0].ErrorVal;
                bestii = 0;
                for (ii = 0; ii < i; ii++)
                {
                    if (entry[ii].ErrorVal > best)
                    {
                        best = entry[ii].ErrorVal;
                        bestii = ii;
                    }
                }
                SplitPCA(ref entry[bestii], ref entry[i], ref buff);
            }
            for (i = 0; i < nColors; i++)
            {
                pal[i * 3] = entry[i].red;
                pal[i * 3 + 1] = entry[i].green;
                pal[i * 3 + 2] = entry[i].blue;
            }
            return pal;
        }
        public void CalcError(ref paletteEntry entry, ref byte[] buff)
        {
            entry.red = (byte)MeanColor(buff, entry.start * 3, entry.nCount, 0);
            entry.green = (byte)MeanColor(buff, entry.start * 3, entry.nCount, 1);
            entry.blue = (byte)MeanColor(buff, entry.start * 3, entry.nCount, 2);
            entry.ErrorVal = 0;
            for (int i = 0; i < entry.nCount; i++)
            {
                entry.ErrorVal += Math.Abs(buff[(entry.start + i) * 3] - entry.red);
                entry.ErrorVal += Math.Abs(buff[(entry.start + i) * 3 + 1] - entry.green);
                entry.ErrorVal += Math.Abs(buff[(entry.start + i) * 3 + 2] - entry.blue);
            }
        }
        public double MeanColor(byte[] rgb, int start, int nnCount, int index)
        {
            if (nnCount == 0) return 0;
            double answer = 0;
            for (int i = 0; i < nnCount; i++)
            {
                answer += rgb[start + i * 3 + index];
            }
            return answer / nnCount;
        }
        public void PCA(ref double[] ret, byte[] pixels, int start, int nnCount)
        {
            double[,] cov = new double[3, 3];
            double[] mu = new double[3];
            int i, j, k;
            double var;
            double[] d = new double[3];
            double[,] v = new double[3, 3];
            for (i = 0; i < 3; i++)
            {
                mu[i] = MeanColor(pixels, start, nnCount, i);
            }
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j <= i; j++)
                {
                    var = 0;
                    for (k = 0; k < nnCount; k++)
                    {
                        var += (pixels[start + k * 3 + i] - mu[i]) * (pixels[start + k * 3 + j] - mu[j]);
                    }
                    cov[i, j] = var / nnCount;
                    cov[j, i] = var / nnCount;
                }
            }
            EigenDecomposition(cov, ref v, ref d);
            ret[0] = v[0, 2];
            ret[1] = v[1, 2];
            ret[2] = v[2, 2];
        }
        public int Project(byte[] rgb, int start, double[] comp)
        {
            return (int)(rgb[start] * comp[0] + rgb[start + 1] * comp[1] + rgb[start + 2] * comp[2]);
        }
        public void SplitPCA(ref paletteEntry entry, ref paletteEntry split, ref byte[] buff)
        {
            int low = 0;
            int high = entry.nCount - 1;
            int cut;
            double[] comp = new double[3];
            byte temp;
            int i;
            PCA(ref comp, buff, (entry.start * 3), entry.nCount);
            cut = GetOtsuThreshold2(buff, (entry.start * 3), entry.nCount, comp);
            while (low < high)
            {
                while (low < high && Project(buff, ((entry.start + low) * 3), comp) < cut)
                {
                    low += 1;
                }
                while (low < high && Project(buff, ((entry.start + high) * 3), comp) >= cut)
                {
                    high -= 1;
                }
                if (low < high)
                {
                    for (i = 0; i < 3; i++)
                    {
                        temp = buff[(entry.start + low) * 3 + i];
                        buff[(entry.start + low) * 3 + i] = buff[(entry.start + high) * 3 + i];
                        buff[(entry.start + high) * 3 + i] = temp;
                    }
                }
                low += 1;
                high -= 1;
            }
            split.start = entry.start + low;
            split.nCount = entry.nCount - low;
            entry.nCount = low;
            CalcError(ref entry, ref buff);
            CalcError(ref split, ref buff);
        }
        public int GetOtsuThreshold2(byte[] rgb, int start, int N, double[] remap)
        {
            int[] hist = new int[1024];
            int wB = 0;
            int wF;
            float mB, mF;
            float sum = 0;
            float sumB = 0;
            float varBetween;
            float varMax = 0.0F;
            int answer = 0;
            for (int i = 0; i < N; i++)
            {
                int nc = (int)(rgb[start + i * 3] * remap[0] + rgb[start + i * 3 + 1] * remap[1] + rgb[start + i * 3 + 2] * remap[2]);
                hist[512 + nc] += 1;
            }
            for (int k = 0; k < 1024; k++)
            {
                sum += k * hist[k];
            }
            for (int k = 0; k < 1024; k++)
            {
                wB += hist[k];
                if (wB == 0)
                {
                    continue;
                }
                wF = N - wB;
                if (wF == 0)
                {
                    break;
                }
                sumB += k * hist[k];
                mB = sumB / wB;
                mF = (sum - sumB) / wF;
                varBetween = wB * wF * (mB - mF) * (mB - mF);
                if (varBetween > varMax)
                {
                    varMax = varBetween;
                    answer = k;
                }
            }
            return answer - 512;
        }
        public void EigenDecomposition(double[,] A, ref double[,] V, ref double[] d)
        {
            int bufLen = A.GetLength(0);
            double[] e = new double[bufLen];
            for (int i = 0; i < bufLen; i++)
            {
                for (int j = 0; j < bufLen; j++)
                {
                    V[i, j] = A[i, j];
                }
            }
            Tred2(ref V, ref d, ref e);
            Tql2(ref V, ref d, ref e);
        }
        public void Tred2(ref double[,] V, ref double[] d, ref double[] e)
        {
            int dLen = d.Length;
            int i, j, k;
            for (j = 0; j < dLen; j++)
            {
                d[j] = V[dLen - 1, j];
            }
            for (i = dLen - 1; i > 0; i--)
            {
                double scale = 0.0;
                double h = 0.0;
                for (k = 0; k < i; k++)
                {
                    scale += Math.Abs(d[k]);
                }
                if (scale == 0.0)
                {
                    e[i] = d[i - 1];
                    for (j = 0; j < i; j++)
                    {
                        d[j] = V[i - 1, j];
                        V[i, j] = 0.0;
                        V[j, i] = 0.0;
                    }
                }
                else
                {
                    double f, g;
                    double hh;
                    for (k = 0; k < i; k++)
                    {
                        d[k] /= scale;
                        h += d[k] * d[k];
                    }
                    f = d[i - 1];
                    g = Math.Sqrt(h);
                    if (f > 0)
                    {
                        g = -g;
                    }
                    e[i] = scale * g;
                    h = h - f * g;
                    d[i - 1] = f - g;
                    for (j = 0; j < i; j++)
                    {
                        e[j] = 0.0;
                    }
                    for (j = 0; j < i; j++)
                    {
                        f = d[j];
                        V[j, i] = f;
                        g = e[j] + V[j, j] * f;
                        for (k = j + 1; k < i; k++)
                        {
                            g += V[k, j] * d[k];
                            e[k] += V[k, j] * f;
                        }
                        e[j] = g;
                    }
                    f = 0.0;
                    for (j = 0; j < i; j++)
                    {
                        e[j] /= h;
                        f += e[j] * d[j];
                    }
                    hh = f / (h + h);
                    for (j = 0; j < i; j++)
                    {
                        e[j] -= hh * d[j];
                    }
                    for (j = 0; j < i; j++)
                    {
                        f = d[j];
                        g = e[j];
                        for (k = j; k < i; k++)
                        {
                            V[k, j] -= (f * e[k] + g * d[k]);
                        }
                        d[j] = V[i - 1, j];
                        V[i, j] = 0.0;
                    }
                }
                d[i] = h;
            }
            for (i = 0; i < dLen - 1; i++)
            {
                double h = d[i + 1];
                V[dLen - 1, i] = V[i, i];
                V[i, i] = 1.0;
                if (h != 0.0)
                {
                    for (k = 0; k <= i; k++)
                    {
                        d[k] = V[k, i + 1] / h;
                    }
                    for (j = 0; j <= i; j++)
                    {
                        double g = 0.0;
                        for (k = 0; k <= i; k++)
                        {
                            g += V[k, i + 1] * V[k, j];
                        }
                        for (k = 0; k <= i; k++)
                        {
                            V[k, j] -= g * d[k];
                        }
                    }
                }
                for (k = 0; k <= i; k++)
                {
                    V[k, i + 1] = 0.0;
                }
            }
            for (j = 0; j < dLen; j++)
            {
                d[j] = V[dLen - 1, j];
                V[dLen - 1, j] = 0.0;
            }
            V[dLen - 1, dLen - 1] = 1.0;
            e[0] = 0.0;
        }
        public void Tql2(ref double[,] V, ref double[] d, ref double[] e)
        {
            int dLen = d.Length;
            int i, j, k, l;
            double f, tst1, eps;
            for (i = 1; i < dLen; i++)
            {
                e[i - 1] = e[i];
            }
            e[dLen - 1] = 0.0;
            f = 0.0;
            tst1 = 0.0;
            eps = Math.Pow(2.0, -52.0);
            for (l = 0; l < dLen; l++)
            {
                tst1 = Math.Max(tst1, Math.Abs(d[l]) + Math.Abs(e[l]));
                int m = l;
                while (m < dLen)
                {
                    if (Math.Abs(e[m]) <= eps * tst1)
                    {
                        break;
                    }
                    m++;
                }
                if (m > l)
                {
                    int iter = 0;
                    do
                    {
                        double g, p, r;
                        double dl1;
                        double h;
                        double c;
                        double c2;
                        double c3;
                        double el1;
                        double s;
                        double s2;
                        iter++;
                        g = d[l];
                        p = (d[l + 1] - g) / (2.0 * e[l]);
                        r = Hypot(p, 1.0);
                        if (p < 0)
                        {
                            r = -r;
                        }
                        d[l] = e[l] / (p + r);
                        d[l + 1] = e[l] * (p + r);
                        dl1 = d[l + 1];
                        h = g - d[l];
                        for (i = l + 2; i < dLen; i++)
                        {
                            d[i] -= h;
                        }
                        f += h;
                        p = d[m];
                        c = 1.0;
                        c2 = c;
                        c3 = c;
                        el1 = e[l + 1];
                        s = 0.0;
                        s2 = 0.0;
                        for (i = m - 1; i >= l; i--)
                        {
                            c3 = c2;
                            c2 = c;
                            s2 = s;
                            g = c * e[i];
                            h = c * p;
                            r = Hypot(p, e[i]);
                            e[i + 1] = s * r;
                            s = e[i] / r;
                            c = p / r;
                            p = c * d[i] - s * g;
                            d[i + 1] = h + s * (c * g + s * d[i]);
                            for (k = 0; k < dLen; k++)
                            {
                                h = V[k, i + 1];
                                V[k, i + 1] = s * V[k, i] + c * h;
                                V[k, i] = c * V[k, i] - s * h;
                            }
                        }
                        p = -s * s2 * c3 * el1 * e[l] / dl1;
                        e[l] = s * p;
                        d[l] = c * p;
                    } while (Math.Abs(e[l]) > eps * tst1);
                }
                d[l] += f;
                e[l] = 0.0;
            }
            for (i = 0; i < dLen - 1; i++)
            {
                int k1 = i;
                double p = d[i];
                for (j = i + 1; j < dLen; j++)
                {
                    if (d[j] < p)
                    {
                        k1 = j;
                        p = d[j];
                    }
                }
                if (k1 != i)
                {
                    d[k1] = d[i];
                    d[i] = p;
                    for (j = 0; j < dLen; j++)
                    {
                        p = V[j, i];
                        V[j, i] = V[j, k1];
                        V[j, k1] = p;
                    }
                }
            }
        }
        public double Hypot(double a, double b)
        {
            return Math.Sqrt(a * a + b * b);
        }
#endregion
        public Palette_CustomColorMap custom = new Palette_CustomColorMap();
        public Options_PCA_NColor options = new Options_PCA_NColor();
        public byte[] palette = new byte[256 * 3];
        public byte[] rgb;
        public byte[] buff;
        public byte[] answer;
        public PCA_NColor_CS()
        {
            rgb = new byte[dst2.Total() * dst2.ElemSize()];
            buff = new byte[rgb.Length];
            answer = new byte[rgb.Length];
            custom.colorMap = new Mat(256, 1, MatType.CV_8UC3);
            desc = "Use PCA to build a palettized CV_8U image from the input using a palette.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Marshal.Copy(src.Data, rgb, 0, rgb.Length);
            Marshal.Copy(src.Data, buff, 0, buff.Length);
            palette = MakePalette(rgb, dst2.Width, dst2.Height, options.desiredNcolors);
            byte[] paletteImage = RgbToIndex(rgb, dst1.Width, dst1.Height, palette, options.desiredNcolors);
            Mat img8u = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            Marshal.Copy(paletteImage, 0, img8u.Data, paletteImage.Length);
            Marshal.Copy(palette, 0, custom.colorMap.Data, palette.Length);
            custom.Run(img8u);
            dst2 = custom.dst2;
            Mat tmp = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, palette);
            int paletteCount = tmp.CvtColor(ColorConversionCodes.BGR2GRAY).CountNonZero();
            if (standaloneTest())
            {
                vbc.task.palette.Run(img8u * 256 / options.desiredNcolors);
                dst3 = vbc.task.palette.dst2;
                labels[3] = "dst2 is palettized using global palette option: " + vbc.task.gOptions.getPalette();
            }
            labels[2] = "The image above is mapped to " + paletteCount.ToString() + " colors below.  ";
        }
    }




    public class PCA_NColor_CPP_CS : VB_Parent
    {
        Palette_CustomColorMap custom = new Palette_CustomColorMap();
        PCA_Palettize palettize = new PCA_Palettize();
        public byte[] rgb;
        public int classCount;
        public PCA_NColor_CPP_CS()
        {
            cPtr = PCA_NColor_Open();
            FindSlider("Desired number of colors").Value = 8;
            UpdateAdvice(traceName + ": Adjust the 'Desired number of colors' between 1 and 256");
            labels = new string[] { "", "", "Palettized (CV_8U) version of color image.", "" };
            desc = "Create a faster version of the PCA_NColor algorithm.";
            rgb = new byte[dst1.Total() * dst1.ElemSize()];
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat) palettize.Run(src); // get the palette in C#
            Marshal.Copy(src.Data, rgb, 0, rgb.Length);
            classCount = palettize.options.desiredNcolors;
            GCHandle handleSrc = GCHandle.Alloc(rgb, GCHandleType.Pinned);
            GCHandle handlePalette = GCHandle.Alloc(palettize.palette, GCHandleType.Pinned);
            IntPtr imagePtr = PCA_NColor_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), handlePalette.AddrOfPinnedObject(), src.Rows, src.Cols, classCount);
            handlePalette.Free();
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(dst2.Height, dst2.Width, MatType.CV_8U, imagePtr);
            custom.colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, palettize.palette);
            custom.Run(dst2);
            dst3 = custom.dst2;
            labels[2] = "The CV_8U image is below.  Values range from 0 to " + classCount.ToString();
            labels[3] = "The upper left image is mapped to " + classCount.ToString() + " colors below.";
        }
        public void Close()
        {
            PCA_NColor_Close(cPtr);
        }
        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr PCA_NColor_Open();

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void PCA_NColor_Close(IntPtr cPtr);

        [DllImport("CPP_Native.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr PCA_NColor_RunCPP(IntPtr cPtr, IntPtr imagePtr, IntPtr palettePtr, int rows, int cols, int desiredNcolors);
    }




    public class PCA_NColorPalettize_CS : VB_Parent
    {
        Palette_CustomColorMap custom = new Palette_CustomColorMap();
        PCA_Palettize palettize = new PCA_Palettize();
        public byte[] answer;
        PCA_NColor_CS nColor;
        public byte[] rgb;
        public PCA_NColorPalettize_CS()
        {
            nColor = new PCA_NColor_CS();
            FindSlider("Desired number of colors").Value = 8;
            desc = "Create a faster version of the PCA_NColor algorithm.";
            answer = new byte[dst2.Width * dst2.Height];
            rgb = new byte[dst1.Total() * dst1.ElemSize()];
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat) palettize.Run(src); // get the palette in C# which is very fast.
            Marshal.Copy(src.Data, rgb, 0, rgb.Length);
            var paletteImage = nColor.RgbToIndex(rgb, dst1.Width, dst1.Height, palettize.palette, palettize.options.desiredNcolors);
            Mat img8u = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            Marshal.Copy(paletteImage, 0, img8u.Data, paletteImage.Length);
            custom.colorMap = cv.Mat.FromPixelData(256, 1, MatType.CV_8UC3, palettize.palette);
            custom.Run(img8u);
            dst2 = custom.dst2;
        }
    }




    public class Pendulum_Basics_CS : VB_Parent
    {
        float l1 = 150, l2 = 150, m1 = 10, m2 = 10;
        float o1 = (float)(2 * Cv2.PI / 2);
        float o2 = (float)(2 * Cv2.PI / 3);
        float w1, w2;
        float g = 9.81f;
        float dw = 2, dh = 4;
        Point2f center;
        float fps = 300;
        Options_Pendulum options = new Options_Pendulum();
        public Pendulum_Basics_CS()
        {
            center = new Point2f(dst2.Width / 2, 0);
            labels = new string[] { "", "", "A double pendulum representation", "Trace of the pendulum end points (p1 and p2)" };
            desc = "Build a double pendulum";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            float accumulator = 0;
            if (vbc.task.frameCount % 1000 == 0 || vbc.task.optionsChanged)
            {
                dst2.SetTo(0);
                dst3.SetTo(0);
            }
            if (options.initialize)
            {
                l1 = msRNG.Next(50, 300);
                l2 = msRNG.Next(50, 300);
                dw = msRNG.Next(2, 4);
                dh = 2 * dw;
            }
            fps = options.fps;
            float dt = 1 / fps;
            float alfa1 = (float)((-g * (2 * m1 + m2) * Math.Sin(o1) - g * m2 * Math.Sin(o1 - 2 * o2) - 2 * m2 * Math.Sin(o1 - o2) * (w2 * w2 * l2 + w1 * w1 * l1 * Math.Cos(o1 - o2))) / (l1 * (2 * m1 + m2 - m2 * Math.Cos(2 * o1 - 2 * o2))));
            float alfa2 = (float)((2 * Math.Sin(o1 - o2)) * (w1 * w1 * l1 * (m1 + m2) + g * (m1 + m2) * Math.Cos(o1) + w2 * w2 * l2 * m2 * Math.Cos(o1 - o2)) / l2 / (2 * m1 + m2 - m2 * Math.Cos(2 * o1 - 2 * o2)));
            w1 += 10 * dt * alfa1;
            w2 += 10 * dt * alfa2;
            o1 += 10 * dt * w1;
            o2 += 10 * dt * w2;
            accumulator += dt;
            Point2f p1 = new Point2f((float)(dst2.Width / 2 + Math.Sin(o1) * l1 + dw * 0.5f) / dw,
                                        (float)(dst2.Height - (Math.Cos(o1) * l1 + dh * 0.5f) / dh + dst2.Height / dh / 2));
            // adjust to fit in the image better
            p1 = new Point2f(p1.X * 2, p1.Y * 0.5f);
            Point2f p2 = new Point2f((float)(p1.X + (Math.Sin(o2) * l2 + dw * 0.5f) / dw),
                                        (float)(p1.Y - (Math.Cos(o2) * l2 + dh * 0.5f) / dh));
            DrawLine(dst2, center, p1, vbc.task.scalarColors[vbc.task.frameCount % 255]);
            DrawLine(dst2, p1, p2, vbc.task.scalarColors[vbc.task.frameCount % 255]);
            DrawCircle(dst3, p1, vbc.task.DotSize, vbc.task.scalarColors[vbc.task.frameCount % 255]);
            DrawCircle(dst3, p2, vbc.task.DotSize, vbc.task.scalarColors[vbc.task.frameCount % 255]);
        }
    }





    public class PhaseCorrelate_Basics_CS : VB_Parent
    {
        Mat hanning = new Mat();
        public cv.Rect stableRect;
        public cv.Rect srcRect;
        public cv.Point center;
        public float radius;
        public Point2d shift;
        public Mat lastFrame;
        public double response;
        public bool resetLastFrame;
        Options_PhaseCorrelate options = new Options_PhaseCorrelate();
        public PhaseCorrelate_Basics_CS()
        {
            Cv2.CreateHanningWindow(hanning, dst2.Size(), MatType.CV_64F);
            desc = "Look for a shift between the current frame and the previous";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            Mat input = src;
            if (input.Channels() != 1) input = input.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            Mat input64 = new Mat();
            input.ConvertTo(input64, MatType.CV_64F);
            if (lastFrame == null) lastFrame = input64.Clone();
            shift = Cv2.PhaseCorrelate(lastFrame, input64, hanning, out response);
            if (double.IsNaN(response))
            {
                SetTrueText("PhaseCorrelate_Basics_CS has detected NaN's in the input image.", 3);
            }
            else
            {
                radius = (float)Math.Sqrt(shift.X * shift.X + shift.Y * shift.Y);
                resetLastFrame = false;
                if (options.shiftThreshold < radius) resetLastFrame = true;
                int x1 = shift.X < 0 ? Math.Abs((int)shift.X) : 0;
                int y1 = shift.Y < 0 ? Math.Abs((int)shift.Y) : 0;
                stableRect = new cv.Rect(x1, y1, src.Width - Math.Abs((int)shift.X), src.Height - Math.Abs((int)shift.Y));
                stableRect = ValidateRect(stableRect);
                if (stableRect.Width > 0 && stableRect.Height > 0)
                {
                    int x2 = shift.X < 0 ? 0 : (int)shift.X;
                    int y2 = shift.Y < 0 ? 0 : (int)shift.Y;
                    srcRect = ValidateRect(new cv.Rect(x2, y2, stableRect.Width, stableRect.Height));
                    center = new cv.Point(input64.Cols / 2, input64.Rows / 2);
                    if (src.Channels() == 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                    dst2 = src.Clone();
                    DrawCircle(dst2, center, (int)radius, Scalar.Yellow, vbc.task.lineWidth + 2);
                    DrawLine(dst2, center, new cv.Point(center.X + shift.X, center.Y + shift.Y), Scalar.Red, vbc.task.lineWidth + 1);
                    src[srcRect].CopyTo(dst3[stableRect]);
                    if (radius > 5)
                    {
                        DrawCircle(dst3, center, (int)radius, Scalar.Yellow, vbc.task.lineWidth + 2);
                        DrawLine(dst3, center, new cv.Point(center.X + shift.X, center.Y + shift.Y), Scalar.Red, vbc.task.lineWidth + 1);
                    }
                }
                else
                {
                    resetLastFrame = true;
                }
            }
            labels[3] = resetLastFrame ? "lastFrame Reset" : "Restored lastFrame";
            if (resetLastFrame) lastFrame = input64;
            labels[2] = "Shift = (" + shift.X.ToString(vbc.fmt2) + "," + shift.Y.ToString(vbc.fmt2) + ") with radius = " + radius.ToString(vbc.fmt2);
        }
    }




    public class PhaseCorrelate_BasicsTest_CS : VB_Parent
    {
        Stabilizer_BasicsRandomInput random = new Stabilizer_BasicsRandomInput();
        PhaseCorrelate_Basics stable = new PhaseCorrelate_Basics();
        public PhaseCorrelate_BasicsTest_CS()
        {
            labels[2] = "Unstable input to PhaseCorrelate_Basics";
            labels[3] = "Stabilized output from Phase_Correlate_Basics";
            desc = "Test the PhaseCorrelate_Basics with random movement";
        }
        public void RunAlg(Mat src)
        {
            random.Run(src);
            stable.Run(random.dst3.Clone());
            dst2 = stable.dst2;
            dst3 = stable.dst3;
            labels[3] = stable.labels[3];
        }
    }




    public class PhaseCorrelate_Depth_CS : VB_Parent
    {
        PhaseCorrelate_Basics phaseC = new PhaseCorrelate_Basics();
        Mat lastFrame;
        public PhaseCorrelate_Depth_CS()
        {
            desc = "Use phase correlation on the depth data";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) lastFrame = vbc.task.pcSplit[2].Clone();
            phaseC.Run(vbc.task.pcSplit[2]);
            dst2 = vbc.task.pcSplit[2];
            Mat tmp = new Mat(dst2.Size(), MatType.CV_32F, cv.Scalar.All(0));
            if (phaseC.resetLastFrame) vbc.task.pcSplit[2].CopyTo(lastFrame);
            if (double.IsNaN(phaseC.response))
            {
                SetTrueText("PhaseCorrelate_Basics has detected NaN's in the input image.", 3);
            }
            if (phaseC.srcRect.Width == phaseC.stableRect.Width && phaseC.srcRect.Width != 0)
            {
                lastFrame[phaseC.srcRect].CopyTo(tmp[phaseC.stableRect]);
                labels[2] = phaseC.labels[2];
                labels[3] = phaseC.labels[3];
                tmp = tmp.Normalize(0, 255, NormTypes.MinMax);
                tmp.ConvertTo(dst3, MatType.CV_8UC1);
                DrawCircle(dst3, phaseC.center, (int)phaseC.radius, Scalar.Yellow, vbc.task.lineWidth + 2);
                DrawLine(dst3, phaseC.center, new cv.Point(phaseC.center.X + phaseC.shift.X, phaseC.center.Y + phaseC.shift.Y), Scalar.Red, vbc.task.lineWidth + 1);
            }
            lastFrame = vbc.task.pcSplit[2].Clone();
        }
    }




    public class PhaseCorrelate_HanningWindow_CS : VB_Parent
    {
        public PhaseCorrelate_HanningWindow_CS()
        {
            labels[2] = "Looking down on a bell curve in 2 dimensions";
            desc = "Show what a Hanning window looks like";
        }
        public void RunAlg(Mat src)
        {
            Cv2.CreateHanningWindow(dst2, src.Size(), MatType.CV_32F);
        }
    }




    public class Photon_Basics_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Mat lastImage = new cv.Mat();
        public Photon_Basics_CS()
        {
            labels = new string[] { "", "", "Points where B, G, or R differ from the previous image", "Histogram showing distribution of absolute value of differences" };
            desc = "With no motion the camera values will show the random photon differences.  Are they random?";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) lastImage = src;
            Cv2.Absdiff(src, lastImage, dst1);
            dst0 = dst1.Reshape(1, dst1.Rows * 3);
            dst1 = dst1.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            if (Cv2.CountNonZero(dst0) > 0)
            {
                dst2 = dst1.Clone();
                hist.Run(dst0);
                dst3 = hist.dst2;
            }
            lastImage = src;
        }
    }




    public class Photon_Test_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        List<int>[] counts = new List<int>[4];
        Mat_4to1 mats = new Mat_4to1();
        public Photon_Test_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            for (int i = 0; i < counts.Length; i++)
            {
                counts[i] = new List<int>();
            }
            labels = new string[] { "", "", "5 color levels from reduction (black not shown)", "Selected distribution" };
            desc = "";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.redOptions.setSimpleReductionBar(64); // for now...
            int reduce = 64;
            reduction.Run(src);
            dst1 = reduction.dst2;
            int testCount = dst2.Width - 1;
            string strOut = "";
            for (int i = 0; i < counts.Length; i++)
            {
                mats.mat[i] = dst1.InRange(new Scalar(reduce * i), new Scalar(reduce * i));
                counts[i].Add(Cv2.CountNonZero(mats.mat[i]));
                if (counts[i].Count() > testCount) counts[i].RemoveAt(0);
                strOut += "for " + (i * reduce).ToString() + " average = " + counts[i].Average().ToString("###,##0") + " min = " + counts[i].Min().ToString("###,##0.0") + " max = " +
                            counts[i].Max().ToString("###,##0.0") + "\n";
            }
            SetTrueText(strOut, 3);
            mats.Run(empty);
            dst2 = mats.dst2;
            int colWidth = dst2.Width / testCount;
            dst3.SetTo(0);
            cv.Scalar[] choices = { Scalar.Red, Scalar.LightGreen, Scalar.Blue, Scalar.Yellow };
            for (int i = 0; i < counts[0].Count(); i++)
            {
                int colTop = 0;
                for (int j = 0; j < counts.Length; j++)
                {
                    int h = (int)((dst2.Height - 1) * (counts[j][i] / dst2.Total())); // extra parens to avoid overflow at high res.
                    cv.Rect r = new cv.Rect(colWidth * i, colTop, colWidth, h);
                    if (h > 0) dst3[r].SetTo(choices[j]);
                    colTop += h;
                }
            }
        }
    }




    public class Photon_Subtraction_CS : VB_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Mat lastImage = new cv.Mat();
        public Photon_Subtraction_CS()
        {
            labels = new string[] { "", "", "Points where B, G, or R differ", "Histogram showing distribution of differences" };
            desc = "Same as Photon_Basics but without ignoring sign.";
        }
        public void RunAlg(Mat src)
        {
            src = src.Reshape(1, src.Rows * 3);
            src.ConvertTo(src, MatType.CV_32F);
            if (vbc.task.FirstPass) lastImage = src.Clone();
            Mat subOutput = new Mat();
            Cv2.Subtract(src, lastImage, subOutput);
            Mat histInput = subOutput.Add(new Scalar(100)).ToMat();
            hist.Run(histInput);
            dst2 = hist.dst2;
            subOutput = subOutput.Reshape(3, dst2.Height);
            dst1 = subOutput.CvtColor(cv.ColorConversionCodes.BGR2GRAY).Threshold(0, 255, ThresholdTypes.Binary);
            if (Cv2.CountNonZero(dst1) > 0) dst3 = dst1.Clone(); // occasionally the image returned is identical to the last.  hmmm...
            lastImage = src.Clone();
        }
    }




    public class Plane_Basics_CS : VB_Parent
    {
        History_Basics frames = new History_Basics();
        public Plane_Basics_CS()
        {
            labels = new string[] { "", "Top down mask after after thresholding heatmap", "Vertical regions", "Horizontal regions" };
            desc = "Find the regions that are mostly vertical and mostly horizontal.";
        }
        public void RunAlg(Mat src)
        {
            Mat topHist = new Mat(), sideHist = new Mat(), topBackP = new Mat(), sideBackP = new Mat();
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, new Mat(), topHist, 2,
                            new int[] { dst2.Height, dst2.Width }, vbc.task.rangesTop);
            topHist.Row(0).SetTo(0);
            Cv2.InRange(topHist, vbc.task.projectionThreshold, topHist.Total(), dst1);
            dst1.ConvertTo(dst1, MatType.CV_32F);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, dst1, topBackP, vbc.task.rangesTop);
            frames.Run(topBackP);
            frames.dst2.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ~dst2;
            dst3.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class Plane_From3Points_CS : VB_Parent
    {
        public Point3f[] input = new Point3f[3];
        public bool showWork = true;
        public Point3f cross;
        public float k;
        public Plane_From3Points_CS()
        {
            labels = new string[] { "", "", "Plane Equation", "" };
            input = new Point3f[] { new Point3f(2, 1, -1), new Point3f(0, -2, 0), new Point3f(1, -1, 2) };
            desc = "Build a plane equation from 3 points in 3-dimensional space";
        }
        public string vbFormatEquation(Vec4f eq)
        {
            string s1 = eq.Item1 < 0 ? " - " : " +";
            string s2 = eq.Item2 < 0 ? " - " : " +";
            return (eq.Item0 < 0 ? "-" : " ") + Math.Abs(eq.Item0).ToString(vbc.fmt3) + "*x " + s1 +
                    Math.Abs(eq.Item1).ToString(vbc.fmt3) + "*y " + s2 +
                    Math.Abs(eq.Item2).ToString(vbc.fmt3) + "*z = " +
                    eq.Item3.ToString(vbc.fmt3) + "\n";
        }
        public void RunAlg(Mat src)
        {
            Point3f v1 = input[1] - input[0];
            Point3f v2 = input[1] - input[2];
            cross = crossProduct(v1, v2);
            k = -cross.X * input[0].X - cross.Y * input[0].Y - cross.Z * input[0].Z;
            strOut = "Input: " + "\n";
            for (int i = 0; i < input.Length; i++)
            {
                strOut += "p" + i + " = " + input[i].X.ToString(vbc.fmt3) + ", " + input[i].Y.ToString(vbc.fmt3) + ", " + input[i].Z.ToString(vbc.fmt3) + "\n";
            }
            strOut += "First " + "\t" + "difference = " + v1.X.ToString(vbc.fmt3) + ", " + v1.Y.ToString(vbc.fmt3) + ", " + v1.Z.ToString(vbc.fmt3) + "\n";
            strOut += "Second " + "\t" + "difference = " + v2.X.ToString(vbc.fmt3) + ", " + v2.Y.ToString(vbc.fmt3) + ", " + v2.Z.ToString(vbc.fmt3) + "\n";
            strOut += "Cross Product = " + cross.X.ToString(vbc.fmt3) + ", " + cross.Y.ToString(vbc.fmt3) + ", " + cross.Z.ToString(vbc.fmt3) + "\n";
            strOut += "k = " + k.ToString() + "\n";
            strOut += vbFormatEquation(new Vec4f(cross.X, cross.Y, cross.Z, k));
            string s1 = cross.Y < 0 ? " - " : " + ";
            string s2 = cross.Z < 0 ? " - " : " + ";
            strOut += "Plane equation: " + cross.X.ToString(vbc.fmt3) + "x" + s1 + Math.Abs(cross.Y).ToString(vbc.fmt3) + "y" + s2 +
                        Math.Abs(cross.Z).ToString(vbc.fmt3) + "z + " + (-k).ToString(vbc.fmt3) + "\n";
            if (showWork) SetTrueText(strOut, 2);
        }
    }




    public class Plane_FlatSurfaces_CS : VB_Parent
    {
        AddWeighted_Basics addW = new AddWeighted_Basics();
        Plane_CellColor plane = new Plane_CellColor();
        public Plane_FlatSurfaces_CS()
        {
            labels = new string[] { "RedCloud Cell contours", "", "RedCloud cells", "" };
            addW.src2 = dst2.Clone();
            desc = "Find all the cells from a RedCloud_Basics output that are likely to be flat";
        }
        public void RunAlg(Mat src)
        {
            plane.Run(src);
            dst2 = plane.dst2;
            if (!vbc.task.cameraStable || vbc.task.heartBeat) addW.src2.SetTo(0);
            int flatCount = 0;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.depthMean[2] < 1.0) continue; // close objects look like planes.
                double RMSerror = 0;
                int pixelCount = 0;
                for (int y = 0; y < rc.rect.Height; y++)
                {
                    for (int x = 0; x < rc.rect.Width; x++)
                    {
                        byte val = rc.mask.Get<byte>(y, x);
                        if (val > 0)
                        {
                            if (msRNG.Next(100) < 10)
                            {
                                Point3f pt = vbc.task.pointCloud[rc.rect].Get<Point3f>(y, x);
                                // a*x + b*y + c*z + k = 0 ---> z = -(k + a*x + b*y) / c
                                double depth = -(rc.eq[0] * pt.X + rc.eq[1] * pt.Y + rc.eq[3]) / rc.eq[2];
                                RMSerror += Math.Abs(pt.Z - depth);
                                pt.Z = (float)depth;
                                pixelCount++;
                            }
                        }
                    }
                }
                if (RMSerror / pixelCount <= plane.options.rmsThreshold)
                {
                    addW.src2[rc.rect].SetTo(Scalar.White, rc.mask);
                    flatCount++;
                }
            }
            addW.Run(vbc.task.color);
            dst3 = addW.dst2;
            labels[3] = "There were " + flatCount + " RedCloud Cells with an average RMSerror per pixel less than " + (plane.options.rmsThreshold * 100).ToString(vbc.fmt0) + " cm";
        }
    }




    public class Plane_OnlyPlanes_CS : VB_Parent
    {
        public Plane_CellColor plane = new Plane_CellColor();
        public List<cv.Point> contours;
        public Plane_OnlyPlanes_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            labels = new string[] { "", "", "RedCloud Cells", "gCloud reworked with planes instead of depth data" };
            desc = "Replace the gCloud with planes in every RedCloud cell";
        }
        public void buildCloudPlane(rcData rc)
        {
            for (int y = 0; y < rc.rect.Height; y++)
            {
                for (int x = 0; x < rc.rect.Width; x++)
                {
                    if (rc.mask.Get<byte>(y, x) > 0)
                    {
                        Point3f pt = vbc.task.pointCloud[rc.rect].Get<Point3f>(y, x);
                        // a*x + b*y + c*z + k = 0 ---> z = -(k + a*x + b*y) / c
                        pt.Z = -(rc.eq[0] * pt.X + rc.eq[1] * pt.Y + rc.eq[3]) / rc.eq[2];
                        if (rc.minVec.Z <= pt.Z && rc.maxVec.Z >= pt.Z) dst3[rc.rect].Set<Point3f>(y, x, pt);
                    }
                }
            }
        }
        public void RunAlg(Mat src)
        {
            plane.Run(src);
            dst2 = plane.dst2;
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                if (!plane.options.reuseRawDepthData) buildCloudPlane(rc);
            }
            if (plane.options.reuseRawDepthData) dst3 = vbc.task.pointCloud;
            var rcX = vbc.task.rc;
        }
    }




    public class Plane_EqCorrelation_CS : VB_Parent
    {
        Plane_Points plane = new Plane_Points();
        public List<float> correlations = new List<float>();
        public List<Vec4f> equations = new List<Vec4f>();
        public List<List<cv.Point>> ptList2D = new List<List<cv.Point>>();
        Kalman_Basics kalman = new Kalman_Basics();
        public Plane_EqCorrelation_CS()
        {
            desc = "Classify equations based on the correlation of their coefficients";
        }
        public void RunAlg(Mat src)
        {
            plane.Run(src);
            dst2 = plane.dst2;
            if (plane.equations.Count() == 0)
            {
                dst0 = src;
                SetTrueText("Select a RedCloud cell to analyze.", 3);
                return;
            }
            equations = new List<Vec4f>(plane.equations);
            ptList2D = new List<List<cv.Point>>(plane.ptList2D);
            correlations.Clear();
            Mat correlationMat = new Mat();
            int[] count = new int[plane.equations.Count()];
            for (int i = 0; i < equations.Count(); i++)
            {
                Vec4f p1 = equations[i];
                Mat data1 = cv.Mat.FromPixelData(4, 1, MatType.CV_32F, new float[] { p1.Item0, p1.Item1, p1.Item2, p1.Item3 });
                for (int j = i + 1; j < equations.Count(); j++)
                {
                    Vec4f p2 = equations[j];
                    Mat data2 = cv.Mat.FromPixelData(4, 1, MatType.CV_32F, new float[] { p2.Item0, p2.Item1, p2.Item2, p2.Item3 });
                    Cv2.MatchTemplate(data1, data2, correlationMat, TemplateMatchModes.CCoeffNormed);
                    float correlation = correlationMat.At<float>(0, 0);
                    correlations.Add(correlation);
                    if (correlation >= 0.999) count[i]++;
                }
            }
            List<int> countList = new List<int>(count);
            int index = countList.IndexOf(countList.Max());
            Vec4f pt = equations[index];
            string s1 = pt.Item1 < 0 ? " - " : " + ";
            string s2 = pt.Item2 < 0 ? " - " : " + ";
            if (count[index] > plane.equations.Count() / 4)
            {
                kalman.kInput = new float[] { pt.Item0, pt.Item1, pt.Item2, pt.Item3 };
                kalman.Run(empty);
                strOut = "Normalized Plane equation: " + string.Format(vbc.fmt3, kalman.kOutput[0]) + "x" + s1 + string.Format(vbc.fmt3, Math.Abs(kalman.kOutput[1])) + "y" + s2 +
                            string.Format(vbc.fmt3, Math.Abs(kalman.kOutput[2])) + "z = " + string.Format(vbc.fmt3, -kalman.kOutput[3]) + " with " + count[index] +
                            " closely matching plane equations." + "\n";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Plane_CellColor_CS : VB_Parent
    {
        public Options_Plane options = new Options_Plane();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Plane_CellColor_CS()
        {
            labels = new string[] { "", "", "RedCloud Cells", "Blue - normal is closest to the X-axis, green - to the Y-axis, and Red - to the Z-axis" };
            desc = "Create a plane equation from the points in each RedCloud cell and color the cell with the direction of the normal";
        }
        public List<Point3f> buildContourPoints(rcData rc)
        {
            List<Point3f> fitPoints = new List<Point3f>();
            foreach (var pt in rc.contour)
            {
                if (pt.X >= rc.rect.Width || pt.Y >= rc.rect.Height) continue;
                if (rc.mask.At<byte>(pt.Y, pt.X) == 0) continue;
                fitPoints.Add(vbc.task.pointCloud[rc.rect].At<Point3f>(pt.Y, pt.X)); // each contour point is guaranteed to be in the mask and have depth.
            }
            return fitPoints;
        }
        public List<Point3f> buildMaskPointEq(rcData rc)
        {
            List<Point3f> fitPoints = new List<Point3f>();
            for (int y = 0; y < rc.rect.Height; y++)
            {
                for (int x = 0; x < rc.rect.Width; x++)
                {
                    if (rc.mask.At<byte>(y, x) != 0) fitPoints.Add(vbc.task.pointCloud[rc.rect].At<Point3f>(y, x));
                }
            }
            return fitPoints;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            redC.Run(src);
            dst2 = redC.dst2;
            dst3.SetTo(0);
            List<rcData> newCells = new List<rcData>();
            var rcX = vbc.task.rc;
            foreach (var rc in vbc.task.redCells)
            {
                rc.eq = new Vec4f();
                if (options.useMaskPoints)
                {
                    rc.eq = fitDepthPlane(buildMaskPointEq(rc));
                }
                else if (options.useContourPoints)
                {
                    rc.eq = fitDepthPlane(buildContourPoints(rc));
                }
                else if (options.use3Points)
                {
                    rc.eq = build3PointEquation(rc);
                }
                newCells.Add(rc);
                dst3[rc.rect].SetTo(new Scalar(Math.Abs(255 * rc.eq.Item0),
                                                Math.Abs(255 * rc.eq.Item1),
                                                Math.Abs(255 * rc.eq.Item2)), rc.mask);
            }
            vbc.task.redCells = new List<rcData>(newCells);
        }
    }




    public class Plane_Points_CS : VB_Parent
    {
        Plane_From3Points plane = new Plane_From3Points();
        public List<Vec4f> equations = new List<Vec4f>();
        public List<Point3f> ptList = new List<Point3f>();
        public List<List<cv.Point>> ptList2D = new List<List<cv.Point>>();
        RedCloud_Basics redC = new RedCloud_Basics();
        bool needOutput = false;
        public Plane_Points_CS()
        {
            labels = new string[] { "", "", "RedCloud Basics output - click to highlight a cell", "" };
            desc = "Detect if a some or all points in a RedCloud cell are in a plane.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            var rc = vbc.task.rc;
            labels[2] = "Selected cell has " + rc.contour.Count() + " points.";
            // this contour will have more depth data behind it.  Simplified contours will lose lots of depth data.
            rc.contour = ContourBuild(rc.mask, ContourApproximationModes.ApproxNone);
            Point3f pt;
            List<cv.Point> list2D = new List<cv.Point>();
            ptList.Clear();
            for (int i = 0; i < rc.contour.Count(); i++)
            {
                pt = vbc.task.pointCloud.Get<Point3f>(rc.contour[i].Y, rc.contour[i].X);
                if (pt.Z > 0)
                {
                    ptList.Add(pt);
                    list2D.Add(rc.contour[i]);
                    if (ptList.Count() > 100) break;
                }
            }
            if (vbc.task.heartBeat || needOutput)
            {
                ptList2D.Clear();
                equations.Clear();
                needOutput = false;
                strOut = "";
                if (ptList.Count() < 3)
                {
                    needOutput = true;
                    strOut = "There weren't enough points in that cell contour with depth.  Select another cell.";
                }
                else
                {
                    int c = ptList.Count();
                    for (int i = 0; i < ptList.Count(); i++)
                    {
                        List<cv.Point> list2Dinput = new List<cv.Point>();
                        for (int j = 0; j < 3; j++)
                        {
                            int ptIndex = i;
                            if (j == 1) ptIndex = (i + c / 3) % c;
                            if (j == 2) ptIndex = (i + 2 * c / 3) % c;
                            plane.input[j] = ptList[ptIndex];
                            list2Dinput.Add(list2D[ptIndex]);
                        }
                        plane.Run(empty);
                        strOut += plane.vbFormatEquation(new Vec4f(plane.cross.X, plane.cross.Y, plane.cross.Z, plane.k));
                        equations.Add(new Vec4f(plane.cross.X, plane.cross.Y, plane.cross.Z, plane.k));
                        ptList2D.Add(list2Dinput);
                    }
                }
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Plane_Histogram_CS : VB_Parent
    {
        PointCloud_Solo solo = new PointCloud_Solo();
        Hist_Basics hist = new Hist_Basics();
        public double peakCeiling;
        public double peakFloor;
        public double ceilingPop;
        public double floorPop;
        public Plane_Histogram_CS()
        {
            labels = new string[] { "", "", "Histogram of Y-Values of the point cloud after masking", "Mask used to isolate histogram input" };
            desc = "Create a histogram plot of the Y-values in the backprojection of solo points.";
        }
        public void RunAlg(Mat src)
        {
            solo.Run(src);
            dst3 = solo.dst3;
            Mat points = dst3.FindNonZero();
            List<float> yList = new List<float>();
            for (int i = 0; i < points.Rows; i++)
            {
                cv.Point pt = points.At<cv.Point>(i, 0);
                float yVal = vbc.task.pcSplit[1].At<float>(pt.Y, pt.X);
                if (yVal != 0) yList.Add(yVal);
            }
            if (yList.Count() == 0) return;
            hist.mm.minVal = yList.Min();
            hist.mm.maxVal = yList.Max();
            hist.Run(cv.Mat.FromPixelData(yList.Count(), 1, MatType.CV_32F, yList.ToArray()));
            dst2 = hist.dst2;
            double binWidth = dst2.Width / vbc.task.histogramBins;
            double rangePerBin = (hist.mm.maxVal - hist.mm.minVal) / vbc.task.histogramBins;
            int midHist = vbc.task.histogramBins / 2;
            mmData mm = GetMinMax(hist.histogram[new cv.Rect(0, midHist, 1, midHist)]);
            floorPop = mm.maxVal;
            double peak = hist.mm.minVal + (midHist + mm.maxLoc.Y + 1) * rangePerBin;
            int rX = (midHist + mm.maxLoc.Y) * (int)binWidth;
            dst2.Rectangle(new cv.Rect(rX, 0, (int)binWidth, dst2.Height), Scalar.Black, vbc.task.lineWidth);
            if (Math.Abs(peak - peakCeiling) > rangePerBin) peakCeiling = peak;
            mm = GetMinMax(hist.histogram[new cv.Rect(0, 0, 1, midHist)]);
            ceilingPop = mm.maxVal;
            peak = hist.mm.minVal + (mm.maxLoc.Y + 1) * rangePerBin;
            rX = mm.maxLoc.Y * (int)binWidth;
            dst2.Rectangle(new cv.Rect(rX, 0, (int)binWidth, dst2.Height), Scalar.Yellow, vbc.task.lineWidth);
            if (Math.Abs(peak - peakFloor) > rangePerBin * 2) peakFloor = peak;
            labels[3] = "Peak Ceiling = " + string.Format(vbc.fmt3, peakCeiling) + " and Peak Floor = " + string.Format(vbc.fmt3, peakFloor);
            SetTrueText("Yellow rectangle is likely floor and black is likely ceiling.");
        }
    }




    public class Plane_Equation_CS : VB_Parent
    {
        public rcData rc = new rcData();
        public string justEquation;
        RedCloud_Basics redC = new RedCloud_Basics();
        public Plane_Equation_CS()
        {
            desc = "Compute the coefficients for an estimated plane equation given the rc contour";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                rc = vbc.task.rc;
                if (rc.index == 0) SetTrueText("Select a cell in the image at left.");
            }
            int offset = (int)(rc.contour.Count() / 4) - 1;
            List<float> xList = new List<float>();
            List<float> yList = new List<float>();
            List<float> zList = new List<float>();
            List<float> kList = new List<float>();
            List<float> dotlist = new List<float>();
            for (int j = 0; j <= offset - 1; j++)
            {
                var p1 = rc.contour[j + offset * 0];
                var p2 = rc.contour[j + offset * 1];
                var p3 = rc.contour[j + offset * 2];
                var p4 = rc.contour[j + offset * 3];
                var v1 = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(p1.Y, p1.X);
                var v2 = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(p2.Y, p2.X);
                var v3 = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(p3.Y, p3.X);
                var v4 = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(p4.Y, p4.X);
                var cross1 = crossProduct(v1 - v2, v2 - v3);
                var cross2 = crossProduct(v1 - v4, v4 - v3);
                float dot = dotProduct3D(cross1, cross2);
                dotlist.Add(dot);
                float k = -cross1.X * v1.X - cross1.Y * v1.Y - cross1.Z * v1.Z;
                xList.Add(cross1.X);
                yList.Add(cross1.Y);
                zList.Add(cross1.Z);
                kList.Add(k);
            }
            if (dotlist.Count() > 0)
            {
                int dotIndex = dotlist.IndexOf(dotlist.Max());
                rc.eq = new Vec4f(xList[dotIndex], yList[dotIndex], zList[dotIndex], kList[dotIndex]);
            }
            if (dotlist.Count() > 0)
            {
                if (vbc.task.heartBeat)
                {
                    justEquation = string.Format("{0}*X + {1}*Y + {2}*Z + {3}\n",
                        rc.eq.Item0.ToString("F3"), rc.eq.Item1.ToString("F3"),
                        rc.eq.Item2.ToString("F3"), rc.eq.Item3.ToString("F3"));
                    if (xList.Count() > 0)
                    {
                        strOut = "The rc.contour has " + rc.contour.Count() + " points\n";
                        strOut += "Estimated 3D plane equation:\n";
                        strOut += justEquation + "\n";
                    }
                    else
                    {
                        if (!strOut.Contains("Insufficient points"))
                        {
                            strOut += "\nInsufficient points or best dot product too low at " + dotlist.Max().ToString("0.00");
                        }
                    }
                    strOut += xList.Count() + " 3D plane equations were tested with an average dot product = " +
                                dotlist.Average().ToString("0.00");
                }
            }
            if (standaloneTest())
            {
                SetTrueText(strOut, 3);
                dst3.SetTo(0);
                DrawContour(dst3[rc.rect], rc.contour, vecToScalar(rc.color), -1);
            }
        }
    }




    public class Plane_Verticals_CS : VB_Parent
    {
        PointCloud_Solo solo = new PointCloud_Solo();
        History_Basics frames = new History_Basics();
        public Plane_Verticals_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] {
        "RGB image with highlights for likely vertical surfaces over X frames.",
        "Heatmap top view", "Single frame backprojection of red areas in the heatmap",
        "Thresholded heatmap top view mask"
    };
            desc = "Use a heatmap to isolate vertical walls - incomplete!";
        }
        public void RunAlg(Mat src)
        {
            solo.Run(src);
            dst3 = solo.heat.topframes.dst2.InRange(vbc.task.projectionThreshold * vbc.task.frameHistoryCount, dst2.Total());
            dst1 = new Mat(dst1.Size(), MatType.CV_32FC1, cv.Scalar.All(0));
            solo.heat.dst0.CopyTo(dst1, dst3);
            dst1.ConvertTo(dst1, MatType.CV_32FC1);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsTop, dst1, dst2, vbc.task.rangesTop);
            frames.Run(dst2);
            frames.dst2.ConvertTo(dst2, MatType.CV_8U);
            dst2 = frames.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            dst2.ConvertTo(dst0, MatType.CV_8U);
            vbc.task.color.SetTo(Scalar.White, dst0);
        }
    }




    public class Plane_Horizontals_CS : VB_Parent
    {
        PointCloud_Solo solo = new PointCloud_Solo();
        History_Basics frames = new History_Basics();
        public Plane_Horizontals_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] {
        "RGB image with highlights for likely floor or ceiling over X frames.",
        "Heatmap side view", "Single frame backprojection areas in the heatmap",
        "Thresholded heatmap side view mask"
    };
            desc = "Use the solo points to isolate horizontal surfaces - floor or ceiling or table tops.";
        }
        public void RunAlg(Mat src)
        {
            solo.Run(src);
            dst3 = solo.heat.sideframes.dst2.InRange(vbc.task.projectionThreshold * vbc.task.frameHistoryCount, dst2.Total());
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            solo.heat.dst1.CopyTo(dst1, dst3);
            dst1.ConvertTo(dst1, MatType.CV_32FC1);
            Cv2.CalcBackProject(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, dst1, dst2, vbc.task.rangesSide);
            frames.Run(dst2);
            frames.dst2.ConvertTo(dst2, MatType.CV_8U);
            dst2 = frames.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            dst2.ConvertTo(dst0, MatType.CV_8U);
            vbc.task.color.SetTo(Scalar.White, dst0);
        }
    }




    public class Plane_FloorStudy_CS : VB_Parent
    {
        public Structured_SliceH slice = new Structured_SliceH();
        List<float> yList = new List<float>();
        public float planeY;
        Options_PlaneFloor options = new Options_PlaneFloor();
        public Plane_FloorStudy_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "", "" };
            desc = "Find the floor plane (if present)";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            slice.Run(src);
            dst1 = slice.dst3;
            dst0 = dst1.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            float thicknessCMs = vbc.task.metersPerPixel * 1000 / 100, nextY = 0;
            cv.Rect rect = new cv.Rect();
            for (int y = dst0.Height - 2; y >= 0; y--)
            {
                rect = new cv.Rect(0, y, dst0.Width - 1, 1);
                int count = dst0[rect].CountNonZero();
                if (count > options.countThreshold)
                {
                    nextY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - y) / vbc.task.sideCameraPoint.Y - thicknessCMs / 2.5f; // narrow it down to about 1 cm
                    labels[2] = "Y = " + string.Format(vbc.fmt3, planeY) + " separates the floor.";
                    SetTrueText(labels[2], 3);
                    Mat sliceMask = vbc.task.pcSplit[1].InRange(new Scalar(planeY), new Scalar(3.0));
                    dst2 = src;
                    dst2.SetTo(new Scalar(255, 255, 255), sliceMask);
                    break;
                }
            }
            yList.Add(nextY);
            planeY = yList.Average();
            if (yList.Count() > 20) yList.RemoveAt(0);
            dst1.Line(new cv.Point(0, rect.Y), new cv.Point(dst2.Width, rect.Y), Scalar.Yellow, slice.options.sliceSize, vbc.task.lineType);
        }
    }





    public class Plot_Basics_CS : VB_Parent
    {
        Plot_Basics_CPP_CS plot;
        Hist_Graph hist = new Hist_Graph();
        public int plotCount = 3;
        public Plot_Basics_CS()
        {
            plot = new Plot_Basics_CPP_CS();
            hist.plotRequested = true;
            labels[2] = "Plot of grayscale histogram";
            labels[3] = "Same Data but using OpenCV C++ plot";
            desc = "Plot data provided in src Mat";
        }
        public void RunAlg(Mat src)
        {
            hist.plotColors[0] = Scalar.White;
            hist.Run(src);
            dst2 = hist.dst2;
            for (int i = 0; i < hist.histRaw[0].Rows; i++)
            {
                plot.srcX.Add(i);
                plot.srcY.Add(hist.histRaw[0].At<float>(i, 0));
            }
            plot.RunAlg(empty);
            dst3 = plot.dst2;
            labels[2] = hist.labels[2];
        }
    }




    public class Plot_Histogram_CS : VB_Parent
    {
        public Mat histogram = new Mat();
        public float[] histArray;
        public float minRange = 0;
        public float maxRange = 255;
        public Scalar backColor = Scalar.Red;
        public float maxValue;
        public float minValue;
        public float plotCenter;
        public float barWidth;
        public bool addLabels = true;
        public bool removeZeroEntry = true;
        public bool createHistogram = false;
        public mmData mm;
        public Plot_Histogram_CS()
        {
            desc = "Plot histogram data with a stable scale at the left of the image.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || createHistogram)
            {
                if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                Rangef[] ranges = new Rangef[1] { new Rangef(minRange, maxRange) };
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), histogram, 1,
                                new int[] { vbc.task.histogramBins }, ranges);
            }
            else
            {
                histogram = src;
            }
            if (removeZeroEntry) histogram.Set<float>(0, 0, 0); // let's not plot the values at zero...
            dst2.SetTo(backColor);
            barWidth = dst2.Width / histogram.Rows;
            plotCenter = barWidth * histogram.Rows / 2 + barWidth / 2;
            histArray = new float[histogram.Rows];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            mm = GetMinMax(histogram);
            if (mm.maxVal > 0 && histogram.Rows > 0)
            {
                float incr = 255f / histogram.Rows;
                for (int i = 0; i < histArray.Length; i++)
                {
                    if (float.IsNaN(histArray[i])) histArray[i] = 0;
                    if (histArray[i] > 0)
                    {
                        int h = (int)(histArray[i] * dst2.Height / mm.maxVal);
                        float sIncr = (i % 256) * incr;
                        Scalar color = new Scalar(sIncr, sIncr, sIncr);
                        if (histogram.Rows > 255) color = Scalar.Black;
                        Cv2.Rectangle(dst2, new cv.Rect((int)(i * barWidth), dst2.Height - h, (int)Math.Max(1, barWidth), h),
                                        color, -1);
                    }
                }
                if (addLabels) AddPlotScale(dst2, mm.minVal, mm.maxVal);
            }
        }
    }




    public class Plot_Depth_CS : VB_Parent
    {
        Plot_Basics_CPP_VB plotDepth = new Plot_Basics_CPP_VB();
        Hist_Basics hist = new Hist_Basics();
        public Plot_Depth_CS()
        {
            desc = "Show depth using OpenCV's plot format with variable bins.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            hist.Run(src);
            plotDepth.srcX.Clear();
            plotDepth.srcY.Clear();
            for (int i = 0; i < vbc.task.histogramBins; i++)
            {
                plotDepth.srcX.Add(i * vbc.task.MaxZmeters / vbc.task.histogramBins);
                plotDepth.srcY.Add(hist.histogram.At<float>(i, 0));
            }
            plotDepth.Run(empty);
            dst2 = plotDepth.dst2;
            if (vbc.task.heartBeat) labels[2] = plotDepth.labels[2];
            var split = Regex.Split(labels[2], @"\W+");
            int lineCount = int.Parse(split[4]);
            if (lineCount > 0)
            {
                int meterDepth = src.Width / lineCount;
                for (int i = 1; i <= lineCount; i++)
                {
                    int x = i * meterDepth;
                    DrawLine(dst2, new cv.Point(x, 0), new cv.Point(x, src.Height), Scalar.White);
                    SetTrueText($"{i}m", new cv.Point(x + 4, src.Height - 10));
                }
            }
        }
    }




    public class Plot_Histogram2D_CS : VB_Parent
    {
        public Color_Basics colorFmt = new Color_Basics();
        public Plot_Histogram2D_CS()
        {
            labels = new string[] { "", "", "2D Histogram", "" };
            desc = "Plot a 2D histogram from the input Mat";
        }
        public void RunAlg(Mat src)
        {
            Mat histogram = src.Clone();
            if (standaloneTest())
            {
                colorFmt.Run(src);
                src = colorFmt.dst2;
                int bins = vbc.task.histogramBins;
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1 }, new Mat(), histogram, 2, new int[] { bins, bins }, vbc.task.redOptions.rangesBGR);
            }
            dst2 = histogram.Resize(dst2.Size(), 0, 0, InterpolationFlags.Nearest);
            if (standaloneTest()) dst3 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }




    public class Plot_OverTimeSingle_CS : VB_Parent
    {
        public float plotData;
        public Scalar backColor = Scalar.DarkGray;
        public float max, min, avg;
        public string fmt;
        public Scalar plotColor = Scalar.Blue;
        List<float> inputList = new List<float>();
        public Plot_OverTimeSingle_CS()
        {
            labels[2] = "Plot_OverTime ";
            desc = "Plot an input variable over time";
        }
        public void RunAlg(Mat src)
        {
            dst2 = dst2.Resize(vbc.task.quarterRes);
            if (standaloneTest()) plotData = (float)vbc.task.color.Mean(vbc.task.depthMask)[0];
            if (inputList.Count() >= dst2.Width) inputList.RemoveAt(0);
            inputList.Add(plotData);
            dst2.ColRange(new cv.Range(0, inputList.Count())).SetTo(backColor);
            max = inputList.Max();
            min = inputList.Min();
            for (int i = 0; i < inputList.Count(); i++)
            {
                float y = 1 - (inputList[i] - min) / (max - min);
                y *= dst2.Height - 1;
                cv.Point c = new cv.Point(i, y);
                if (c.X < 1) c.X = 1;
                DrawCircle(dst2, c, 1, plotColor);
            }
            if (inputList.Count() > dst2.Width / 8)
            {
                float diff = max - min;
                fmt = diff > 10 ? vbc.fmt0 : (diff > 2 ? vbc.fmt1 : (diff > 0.5 ? vbc.fmt2 : vbc.fmt3));
                for (int i = 0; i < 3; i++)
                {
                    string nextText = max.ToString(fmt);
                    if (i == 1) nextText = inputList.Average().ToString(fmt);
                    if (i == 2) nextText = min.ToString(fmt);
                    cv.Point pt = new cv.Point(0, 10);
                    if (i == 1) pt = new cv.Point(0, dst2.Height / 2 - 5);
                    if (i == 2) pt = new cv.Point(0, dst2.Height - 3);
                    Cv2.PutText(dst2, nextText, pt, HersheyFonts.HersheyPlain, 0.7, Scalar.White, 1, vbc.task.lineType);
                }
            }
            cv.Point p1 = new cv.Point(0, dst2.Height / 2);
            cv.Point p2 = new cv.Point(dst2.Width, dst2.Height / 2);
            dst2.Line(p1, p2, Scalar.White, vbc.task.cvFontThickness);
            if (standaloneTest()) SetTrueText("standaloneTest() test is with the blue channel mean of the color image.", 3);
        }
    }




    public class Plot_OverTimeScalar_CS : VB_Parent
    {
        public Scalar plotData;
        public int plotCount = 3;
        public List<Plot_OverTimeSingle> plotList = new List<Plot_OverTimeSingle>();
        Mat_4Click mats = new Mat_4Click();
        public Plot_OverTimeScalar_CS()
        {
            cv.Scalar[] choices = { Scalar.Blue, Scalar.Green, Scalar.Red, Scalar.Yellow };
            for (int i = 0; i < 4; i++)
            {
                plotList.Add(new Plot_OverTimeSingle());
                plotList[i].plotColor = choices[i];
            }
            desc = "Plot the requested number of entries in the cv.scalar input";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest()) plotData = vbc.task.color.Mean();
            for (int i = 0; i < Math.Min(plotCount, 4); i++)
            {
                plotList[i].plotData = (float)plotData[i];
                plotList[i].Run(src);
                mats.mat[i] = plotList[i].dst2;
            }
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class Plot_OverTime_CS : VB_Parent
    {
        public Scalar plotData;
        public int plotCount = 3;
        public Scalar[] plotColors = { Scalar.Blue, Scalar.LawnGreen, Scalar.Red, Scalar.White };
        public Scalar backColor = Scalar.DarkGray;
        public int minScale = 50;
        public int maxScale = 200;
        public int plotTriggerRescale = 50;
        public int columnIndex;
        public int offChartCount;
        public List<Scalar> lastXdelta = new List<Scalar>();
        public bool controlScale; // Use this to programmatically control the scale (rather than let the automated way below keep the scale.)
        public Plot_OverTime_CS()
        {
            desc = "Plot an input variable over time";
            switch (vbc.task.dst2.Width)
            {
                case 1920:
                    vbc.task.gOptions.setLineWidth(10);
                    break;
                case 1280:
                    vbc.task.gOptions.setLineWidth(7);
                    break;
                case 640:
                    vbc.task.gOptions.setLineWidth(4);
                    break;
                case 320:
                    vbc.task.gOptions.setLineWidth(2);
                    break;
                default:
                    vbc.task.gOptions.setLineWidth(1);
                    break;
            }
            vbc.task.gOptions.SetDotSize(vbc.task.lineWidth);
        }
        public void RunAlg(Mat src)
        {
            const int plotSeriesCount = 100;
            lastXdelta.Add(plotData);
            if (columnIndex + vbc.task.DotSize >= dst2.Width)
            {
                dst2.ColRange(columnIndex, dst2.Width).SetTo(backColor);
                columnIndex = 1;
            }
            dst2.ColRange(columnIndex, columnIndex + vbc.task.DotSize).SetTo(backColor);
            if (standaloneTest()) plotData = vbc.task.color.Mean();
            for (int i = 0; i < plotCount; i++)
            {
                if (Math.Floor(plotData[i]) < minScale || Math.Ceiling(plotData[i]) > maxScale)
                {
                    offChartCount++;
                    break;
                }
            }
            // if enough points are off the charted area or if manually requested, then redo the scale.
            if (offChartCount > plotTriggerRescale && lastXdelta.Count() >= plotSeriesCount && !controlScale)
            {
                if (!vbc.task.FirstPass)
                {
                    maxScale = int.MinValue;
                    minScale = int.MaxValue;
                    for (int i = 0; i < lastXdelta.Count(); i++)
                    {
                        var nextVal = lastXdelta[i];
                        for (int j = 0; j < plotCount; j++)
                        {
                            if (Math.Floor(nextVal[j]) < minScale) minScale = (int)Math.Floor(nextVal[j]);
                            if (Math.Floor(nextVal[j]) > maxScale) maxScale = (int)Math.Ceiling(nextVal[j]);
                        }
                    }
                }
                lastXdelta.Clear();
                offChartCount = 0;
                columnIndex = 1; // restart at the left side of the chart
            }
            if (lastXdelta.Count() >= plotSeriesCount) lastXdelta.RemoveAt(0);
            for (int i = 0; i < plotCount; i++)
            {
                var y = 1 - (plotData[i] - minScale) / (maxScale - minScale);
                y *= dst2.Height - 1;
                var c = new cv.Point(columnIndex - vbc.task.DotSize, y - vbc.task.DotSize);
                if (c.X < 1) c.X = 1;
                DrawCircle(dst2, c, vbc.task.DotSize, plotColors[i]);
            }
            if (vbc.task.heartBeat)
            {
                dst2.Line(new cv.Point(columnIndex, 0), new cv.Point(columnIndex, dst2.Height), Scalar.White, 1);
            }
            columnIndex += vbc.task.DotSize;
            dst2.Col(columnIndex).SetTo(0);
            if (standaloneTest()) labels[2] = "RGB Means: blue = " + string.Format(vbc.fmt1, plotData[0]) + " green = " + string.Format(vbc.fmt1, plotData[1]) + " red = " + string.Format(vbc.fmt1, plotData[2]);
            var lineCount = (int)(maxScale - minScale - 1);
            if (lineCount > 3 || lineCount < 0) lineCount = 3;
            AddPlotScale(dst2, minScale, maxScale, lineCount);
        }
    }




    public class Plot_OverTimeFixedScale_CS : VB_Parent
    {
        public Scalar plotData;
        public int plotCount = 3;
        public Scalar[] plotColors = { Scalar.Blue, Scalar.Green, Scalar.Red, Scalar.White };
        public Scalar backColor = Scalar.DarkGray;
        public int minScale = 50;
        public int maxScale = 200;
        public int plotTriggerRescale = 50;
        public int columnIndex;
        public int offChartCount;
        public List<Scalar> lastXdelta = new List<Scalar>();
        public bool controlScale; // Use this to programmatically control the scale (rather than let the automated way below keep the scale.)
        public bool showScale = true;
        public bool fixedScale;
        Mat plotOutput;
        public Plot_OverTimeFixedScale_CS()
        {
            plotOutput = new Mat(new cv.Size(320, 180), MatType.CV_8UC3, cv.Scalar.All(0));
            desc = "Plot an input variable over time";
            vbc.task.gOptions.setLineWidth(1);
            vbc.task.gOptions.SetDotSize(2);
        }
        public void RunAlg(Mat src)
        {
            const int plotSeriesCount = 100;
            lastXdelta.Add(plotData);
            if (columnIndex + vbc.task.DotSize >= plotOutput.Width)
            {
                plotOutput.ColRange(columnIndex, plotOutput.Width).SetTo(backColor);
                columnIndex = 1;
            }
            plotOutput.ColRange(columnIndex, columnIndex + vbc.task.DotSize).SetTo(backColor);
            if (standaloneTest()) plotData = vbc.task.color.Mean();
            for (int i = 0; i < plotCount; i++)
            {
                if (Math.Floor(plotData[i]) < minScale || Math.Ceiling(plotData[i]) > maxScale)
                {
                    offChartCount++;
                    break;
                }
            }
            if (!fixedScale)
            {
                // if enough points are off the charted area or if manually requested, then redo the scale.
                if (offChartCount > plotTriggerRescale && lastXdelta.Count() >= plotSeriesCount && !controlScale)
                {
                    if (!vbc.task.FirstPass)
                    {
                        maxScale = int.MinValue;
                        minScale = int.MaxValue;
                        for (int i = 0; i < lastXdelta.Count(); i++)
                        {
                            var nextVal = lastXdelta[i];
                            for (int j = 0; j < plotCount; j++)
                            {
                                if (Math.Floor(nextVal[j]) < minScale) minScale = (int)Math.Floor(nextVal[j]);
                                if (Math.Floor(nextVal[j]) > maxScale) maxScale = (int)Math.Ceiling(nextVal[j]);
                            }
                        }
                    }
                    lastXdelta.Clear();
                    offChartCount = 0;
                    columnIndex = 1; // restart at the left side of the chart
                }
            }
            if (lastXdelta.Count() >= plotSeriesCount) lastXdelta.RemoveAt(0);
            if (vbc.task.heartBeat)
            {
                plotOutput.Line(new cv.Point(columnIndex, 0), new cv.Point(columnIndex, plotOutput.Height), Scalar.White, vbc.task.lineWidth);
            }
            for (int i = 0; i < plotCount; i++)
            {
                if (plotData[i] != 0)
                {
                    var y = 1 - (plotData[i] - minScale) / (maxScale - minScale);
                    y *= plotOutput.Height - 1;
                    var c = new cv.Point(columnIndex - vbc.task.DotSize, y - vbc.task.DotSize);
                    if (c.X < 1) c.X = 1;
                    DrawCircle(plotOutput, c, vbc.task.DotSize, plotColors[i]);
                }
            }
            columnIndex += 1;
            plotOutput.Col(columnIndex).SetTo(0);
            labels[2] = "Blue = " + string.Format(vbc.fmt1, plotData[0]) + " Green = " + string.Format(vbc.fmt1, plotData[1]) +
                        " Red = " + string.Format(vbc.fmt1, plotData[2]) + " Yellow = " + string.Format(vbc.fmt1, plotData[3]);
            strOut = "Blue = " + string.Format(vbc.fmt1, plotData[0]) + "\n";
            strOut += "Green = " + string.Format(vbc.fmt1, plotData[1]) + "\n";
            strOut += "Red = " + string.Format(vbc.fmt1, plotData[2]) + "\n";
            strOut += "White = " + string.Format(vbc.fmt1, plotData[3]) + "\n";
            SetTrueText(strOut, 3);
            var lineCount = (int)(maxScale - minScale - 1);
            if (lineCount > 3 || lineCount < 0) lineCount = 3;
            if (showScale) AddPlotScale(plotOutput, minScale, maxScale, lineCount);
            dst2 = plotOutput.Resize(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height));
        }
    }




    public class Plot_Beats_CS : VB_Parent
    {
        Plot_OverTimeFixedScale plot = new Plot_OverTimeFixedScale();
        public Plot_Beats_CS()
        {
            plot.plotCount = 4;
            plot.showScale = false;
            plot.fixedScale = true;
            plot.minScale = 0;
            plot.maxScale = 5;
            desc = "Plot the beats.";
        }
        public void RunAlg(Mat src)
        {
            plot.plotData[0] = vbc.task.heartBeat ? 1 : -1;
            plot.plotData[1] = vbc.task.midHeartBeat ? 2 : -1;
            plot.plotData[2] = vbc.task.quarterBeat ? 3 : -1;
            plot.plotData[3] = vbc.task.almostHeartBeat ? 4 : -1;
            plot.Run(src);
            dst2 = plot.dst2;
            strOut = "vbc.task.heartBeat (blue) = " + plot.plotData[0] + "\n";
            strOut += "vbc.task.midHeartBeat (green) = " + plot.plotData[1] + "\n";
            strOut += "vbc.task.quarterBeat (red) = " + plot.plotData[2] + "\n";
            strOut += "vbc.task.almostHeartBeat (white) = " + plot.plotData[3] + "\n";
            SetTrueText(strOut, 3);
        }
    }




    public class Plot_Basics_CPP_CS : VB_Parent
    {
        public List<double> srcX = new List<double>();
        public List<double> srcY = new List<double>();
        public Plot_Basics_CPP_CS()
        {
            for (int i = 0; i <= (int)vbc.task.MaxZmeters; i++) // something to plot if standaloneTest().
            {
                srcX.Add(i);
                srcY.Add(i * i * i);
            }
            cPtr = PlotOpenCV_Open();
            desc = "Demo the use of the integrated 2D plot available in OpenCV (only accessible in C++)";
        }
        public void RunAlg(Mat src)
        {
            GCHandle handleX = GCHandle.Alloc(srcX.ToArray(), GCHandleType.Pinned);
            GCHandle handleY = GCHandle.Alloc(srcY.ToArray(), GCHandleType.Pinned);
            var imagePtr = PlotOpenCV_Run(cPtr, handleX.AddrOfPinnedObject(), handleY.AddrOfPinnedObject(), srcX.Count(),
                                            dst2.Rows, dst2.Cols);
            handleX.Free();
            handleY.Free();

            dst2 = cv.Mat.FromPixelData(dst2.Rows, dst2.Cols, MatType.CV_8UC3, imagePtr);
            var maxX = srcX.Max();
            var minX = srcX.Min();
            var maxY = srcY.Max();
            var minY = srcY.Min();
            labels[2] = "x-Axis: " + minX + " to " + maxX + ", y-axis: " + minY + " to " + maxY;
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = PlotOpenCV_Close(cPtr);
        }
    }




    public class Plot_Dots_CS : VB_Parent
    {
        public List<double> srcX = new List<double>();
        public List<double> srcY = new List<double>();
        public Scalar plotColor = Scalar.Yellow;
        public bool wipeSlate = true;
        public Plot_Dots_CS()
        {
            for (int i = 0; i <= 50; i++) // something to plot if standaloneTest().
            {
                srcX.Add(i);
                srcY.Add(i * i * i);
            }
            desc = "Plot the requested points...";
        }
        public void RunAlg(Mat src)
        {
            var maxX = srcX.Max();
            var minX = srcX.Min();
            var maxY = srcY.Max();
            var minY = srcY.Min();
            if (wipeSlate) dst2.SetTo(0);
            for (int i = 0; i < srcX.Count(); i++)
            {
                var pt = new cv.Point(dst2.Width * srcX[i] / maxX, dst2.Height - dst2.Height * srcY[i] / maxY);
                DrawCircle(dst2, pt, vbc.task.DotSize, plotColor);
            }
            labels[2] = "x-Axis: " + minX + " to " + maxX + ", y-axis: " + minY + " to " + maxY;
        }
    }




    public class PlyFormat_Basics_CS : VB_Parent
    {
        public Options_PlyFormat options = new Options_PlyFormat();
        string saveFileName;
        public PlyFormat_Basics_CS()
        {
            desc = "Create a .ply format file with the pointcloud.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.fileName.Length != 0)
            {
                var fileInfo = new FileInfo(options.fileName);
                if (saveFileName != fileInfo.FullName)
                {
                    using (var sw = new StreamWriter(fileInfo.FullName))
                    {
                        saveFileName = fileInfo.FullName;
                        sw.WriteLine("ply");
                        sw.WriteLine("format ascii 1.0");
                        sw.WriteLine("element vertex " + vbc.task.pointCloud.Total());
                        sw.WriteLine("property float x");
                        sw.WriteLine("property float y");
                        sw.WriteLine("property float z");
                        sw.WriteLine("end_header");
                        for (int y = 0; y < vbc.task.pointCloud.Height; y++)
                        {
                            for (int x = 0; x < vbc.task.pointCloud.Width; x++)
                            {
                                var vec = vbc.task.pointCloud.Get<Vec3f>(y, x);
                                sw.WriteLine($"{vec[0]:F3} {vec[1]:F3} {vec[2]:F3}");
                            }
                        }
                    }
                }
                SetTrueText(".ply format file saved in " + options.fileName);
            }
        }
    }




    public class PlyFormat_PlusRGB_CS : VB_Parent
    {
        public Options_PlyFormat options = new Options_PlyFormat();
        string saveFileName;
        public PlyFormat_PlusRGB_CS()
        {
            desc = "Save the pointcloud in .ply format and include the RGB data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.fileName.Length != 0)
            {
                var fileInfo = new FileInfo(options.fileName);
                if (saveFileName != fileInfo.FullName)
                {
                    using (var sw = new StreamWriter(fileInfo.FullName))
                    {
                        saveFileName = fileInfo.FullName;
                        sw.WriteLine("ply");
                        sw.WriteLine("format ascii 1.0");
                        sw.WriteLine("element vertex " + vbc.task.pointCloud.Total());
                        sw.WriteLine("property float x");
                        sw.WriteLine("property float y");
                        sw.WriteLine("property float z");
                        sw.WriteLine("property uchar red");
                        sw.WriteLine("property uchar green");
                        sw.WriteLine("property uchar blue");
                        sw.WriteLine("end_header");
                        for (int y = 0; y < vbc.task.pointCloud.Height; y++)
                        {
                            for (int x = 0; x < vbc.task.pointCloud.Width; x++)
                            {
                                var vec = vbc.task.pointCloud.Get<Vec3f>(y, x);
                                var bgr = src.Get<Vec3b>(y, x);
                                sw.WriteLine($"{vec[0]:F3} {vec[1]:F3} {vec[2]:F3} {bgr[2]} {bgr[1]} {bgr[0]}");
                            }
                        }
                    }
                }
                SetTrueText(".ply format file saved in " + options.fileName);
            }
        }
    }




    public class PointCloud_Basics_CS : VB_Parent
    {
        Options_PointCloud options = new Options_PointCloud();
        public int actualCount;
        public List<cv.Point3f> allPointsH = new List<cv.Point3f>();
        public List<cv.Point3f> allPointsV = new List<cv.Point3f>();
        public List<List<cv.Point3f>> hList = new List<List<cv.Point3f>>();
        public List<List<cv.Point>> xyHList = new List<List<cv.Point>>();
        public List<List<cv.Point3f>> vList = new List<List<cv.Point3f>>();
        public List<List<cv.Point>> xyVList = new List<List<cv.Point>>();
        public PointCloud_Basics_CS()
        {
            setPointCloudGrid();
            desc = "Reduce the point cloud to a manageable number points in 3D";
        }
        public List<List<cv.Point3f>> findHorizontalPoints(ref List<List<cv.Point>> xyList)
        {
            var ptlist = new List<List<cv.Point3f>>();
            var lastVec = new cv.Point3f();
            for (int y = 0; y < vbc.task.pointCloud.Height; y += vbc.task.gridRects[0].Height - 1)
            {
                var vecList = new List<cv.Point3f>();
                var xyVec = new List<cv.Point>();
                for (int x = 0; x < vbc.task.pointCloud.Width; x += vbc.task.gridRects[0].Width - 1)
                {
                    var vec = vbc.task.pointCloud.Get<cv.Point3f>(y, x);
                    bool jumpZ = false;
                    if (vec.Z > 0)
                    {
                        if ((Math.Abs(lastVec.Z - vec.Z) < options.deltaThreshold && lastVec.X < vec.X) || lastVec.Z == 0)
                        {
                            actualCount++;
                            DrawCircle(dst2, new cv.Point(x, y), vbc.task.DotSize, Scalar.White);
                            vecList.Add(vec);
                            xyVec.Add(new cv.Point(x, y));
                        }
                        else
                        {
                            jumpZ = true;
                        }
                    }
                    if (vec.Z == 0 || jumpZ)
                    {
                        if (vecList.Count() > 1)
                        {
                            ptlist.Add(new List<cv.Point3f>(vecList));
                            xyList.Add(new List<cv.Point>(xyVec));
                        }
                        vecList.Clear();
                        xyVec.Clear();
                    }
                    lastVec = vec;
                }
            }
            return ptlist;
        }
        public List<List<cv.Point3f>> findVerticalPoints(ref List<List<cv.Point>> xyList)
        {
            var ptlist = new List<List<Point3f>>();
            var lastVec = new Point3f();
            for (int x = 0; x < vbc.task.pointCloud.Width; x += vbc.task.gridRects[0].Width - 1)
            {
                var vecList = new List<Point3f>();
                var xyVec = new List<cv.Point>();
                for (int y = 0; y < vbc.task.pointCloud.Height; y += vbc.task.gridRects[0].Height - 1)
                {
                    var vec = vbc.task.pointCloud.Get<Point3f>(y, x);
                    bool jumpZ = false;
                    if (vec.Z > 0)
                    {
                        if ((Math.Abs(lastVec.Z - vec.Z) < options.deltaThreshold && lastVec.Y < vec.Y) || lastVec.Z == 0)
                        {
                            actualCount++;
                            DrawCircle(dst2, new cv.Point(x, y), vbc.task.DotSize, Scalar.White);
                            vecList.Add(vec);
                            xyVec.Add(new cv.Point(x, y));
                        }
                        else
                        {
                            jumpZ = true;
                        }
                    }
                    if (vec.Z == 0 || jumpZ)
                    {
                        if (vecList.Count() > 1)
                        {
                            ptlist.Add(new List<cv.Point3f>(vecList));
                            xyList.Add(new List<cv.Point>(xyVec));
                        }
                        vecList.Clear();
                        xyVec.Clear();
                    }
                    lastVec = vec;
                }
            }
            return ptlist;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            dst2 = src;
            actualCount = 0;
            xyHList.Clear();
            hList = findHorizontalPoints(ref xyHList);
            allPointsH.Clear();
            foreach (var h in hList)
            {
                foreach (var pt in h)
                {
                    allPointsH.Add(pt);
                }
            }
            xyVList.Clear();
            vList = findVerticalPoints(ref xyVList);
            allPointsV.Clear();
            foreach (var v in vList)
            {
                foreach (var pt in v)
                {
                    allPointsV.Add(pt);
                }
            }
            labels[2] = "Point series found = " + (hList.Count() + vList.Count()).ToString();
        }
    }




    public class PointCloud_Point3f_CS : VB_Parent
    {
        public PointCloud_Point3f_CS()
        {
            desc = "Display the point cloud CV_32FC3 format";
        }
        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.pointCloud;
        }
    }




    public class PointCloud_Spin2_CS : VB_Parent
    {
        PointCloud_Spin spin = new PointCloud_Spin();
        RedCloud_Basics redC = new RedCloud_Basics();
        RedCloud_Basics redCSpin = new RedCloud_Basics();
        public PointCloud_Spin2_CS()
        {
            labels = new string[] { "", "", "RedCloud output", "Spinning RedCloud output - use options to spin on different axes." };
            desc = "Spin the RedCloud output exercise";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            spin.Run(src);
            vbc.task.pointCloud = spin.dst2;
            redCSpin.Run(src);
            dst3 = redCSpin.dst2;
        }
    }




    public class PointCloud_SetupSide_CS : VB_Parent
    {
        int arcSize;
        public PointCloud_SetupSide_CS()
        {
            arcSize = dst2.Width / 15;
            labels[2] = "Layout markers for side view";
            desc = "Create the colorized mat used for side projections";
        }
        public void RunAlg(Mat src)
        {
            float distanceRatio = 1;
            if (src.Channels() != 3) src = src.CvtColor(ColorConversionCodes.GRAY2BGR);
            if (standaloneTest()) dst2.SetTo(0); else src.CopyTo(dst2);
            DrawCircle(dst2, vbc.task.sideCameraPoint, vbc.task.DotSize, Scalar.BlueViolet);
            for (int i = 1; i <= vbc.task.MaxZmeters; i++)
            {
                int xmeter = (int)(dst2.Width * i / vbc.task.MaxZmeters * distanceRatio);
                dst2.Line(new cv.Point(xmeter, 0), new cv.Point(xmeter, dst2.Height), Scalar.AliceBlue, 1);
                SetTrueText(i.ToString() + "m", new cv.Point(xmeter - src.Width / 24, dst2.Height - 10));
            }
            var cam = vbc.task.sideCameraPoint;
            var marker = new Point2f(dst2.Width / (vbc.task.MaxZmeters * distanceRatio), 0);
            marker.Y = (float)(marker.X * Math.Tan((vbc.task.vFov / 2) * Cv2.PI / 180));
            var markerLeft = new cv.Point(marker.X, cam.Y - marker.Y);
            var markerRight = new cv.Point(marker.X, cam.Y + marker.Y);
            int offset = (int)(Math.Sin(vbc.task.accRadians.X) * marker.Y);
            if (vbc.task.useGravityPointcloud)
            {
                if (vbc.task.accRadians.X > 0)
                {
                    markerLeft.Y -= offset;
                    markerRight.Y += offset;
                }
                else
                {
                    markerLeft.Y += offset;
                    markerRight.Y -= offset;
                }
                markerLeft = new cv.Point(markerLeft.X - cam.X, markerLeft.Y - cam.Y);
                markerLeft = new cv.Point(markerLeft.X * Math.Cos(vbc.task.accRadians.Z) - markerLeft.Y * Math.Sin(vbc.task.accRadians.Z),
                                        markerLeft.Y * Math.Cos(vbc.task.accRadians.Z) + markerLeft.X * Math.Sin(vbc.task.accRadians.Z));
                markerLeft = new cv.Point(markerLeft.X + cam.X, markerLeft.Y + cam.Y);
                markerRight = new cv.Point((markerRight.X - cam.X) * Math.Cos(vbc.task.accRadians.Z) - (markerRight.Y - cam.Y) * Math.Sin(vbc.task.accRadians.Z) + cam.X,
                                        (markerRight.Y - cam.Y) * Math.Cos(vbc.task.accRadians.Z) + (markerRight.X - cam.X) * Math.Sin(vbc.task.accRadians.Z) + cam.Y);
            }
            if (!standaloneTest())
            {
                DrawCircle(dst2, markerLeft, vbc.task.DotSize, Scalar.Red);
                DrawCircle(dst2, markerRight, vbc.task.DotSize, Scalar.Red);
            }
            float startAngle = (180 - vbc.task.vFov) / 2;
            float y = (float)(dst2.Width / Math.Tan(startAngle * Cv2.PI / 180));
            var fovTop = new cv.Point(dst2.Width, cam.Y - y);
            var fovBot = new cv.Point(dst2.Width, cam.Y + y);
            dst2.Line(cam, fovTop, Scalar.White, 1, vbc.task.lineType);
            dst2.Line(cam, fovBot, Scalar.White, 1, vbc.task.lineType);
            DrawCircle(dst2, markerLeft, vbc.task.DotSize + 3, Scalar.Red);
            DrawCircle(dst2, markerRight, vbc.task.DotSize + 3, Scalar.Red);
            dst2.Line(cam, markerLeft, Scalar.Red, 1, vbc.task.lineType);
            dst2.Line(cam, markerRight, Scalar.Red, 1, vbc.task.lineType);
            var labelLocation = new cv.Point(src.Width * 0.02, src.Height * 7 / 8);
            SetTrueText("vFOV=" + string.Format("{0:0.0}", 180 - startAngle * 2) + " deg.", new cv.Point(4, dst2.Height * 3 / 4));
        }
    }




    public class PointCloud_SetupTop_CS : VB_Parent
    {
        int arcSize;
        public PointCloud_SetupTop_CS()
        {
            arcSize = dst2.Width / 15;
            labels[2] = "Layout markers for top view";
            desc = "Create the colorize the mat for a topdown projections";
        }
        public void RunAlg(Mat src)
        {
            float distanceRatio = 1;
            if (src.Channels() != 3) src = src.CvtColor(ColorConversionCodes.GRAY2BGR);
            if (standaloneTest()) dst2.SetTo(0); else src.CopyTo(dst2);
            DrawCircle(dst2, vbc.task.topCameraPoint, vbc.task.DotSize, Scalar.BlueViolet);
            for (int i = 1; i <= vbc.task.MaxZmeters; i++)
            {
                int ymeter = (int)(dst2.Height - dst2.Height * i / (vbc.task.MaxZmeters * distanceRatio));
                dst2.Line(new cv.Point(0, ymeter), new cv.Point(dst2.Width, ymeter), Scalar.AliceBlue, 1);
                SetTrueText(i.ToString() + "m", new cv.Point(10, ymeter));
            }
            var cam = vbc.task.topCameraPoint;
            var marker = new Point2f(cam.X, dst2.Height / vbc.task.MaxZmeters);
            float topLen = (float)(marker.Y * Math.Tan((vbc.task.hFov / 2) * Cv2.PI / 180));
            float sideLen = (float)(marker.Y * Math.Tan((vbc.task.vFov / 2) * Cv2.PI / 180));
            var markerLeft = new cv.Point(cam.X - topLen, marker.Y);
            var markerRight = new cv.Point(cam.X + topLen, marker.Y);
            float offset = (float)Math.Sin(vbc.task.accRadians.Z) * topLen;
            if (vbc.task.useGravityPointcloud)
            {
                if (vbc.task.accRadians.Z > 0)
                {
                    markerLeft.X -= (int)offset;
                    markerRight.X += (int)offset;
                }
                else
                {
                    markerLeft.X += (int)offset;
                    markerRight.X -= (int)offset;
                }
            }
            float startAngle = (180 - vbc.task.hFov) / 2;
            float x = (float)(dst2.Height / Math.Tan(startAngle * Cv2.PI / 180));
            var fovRight = new cv.Point(vbc.task.topCameraPoint.X + x, 0);
            var fovLeft = new cv.Point(vbc.task.topCameraPoint.X - x, fovRight.Y);
            dst2.Line(vbc.task.topCameraPoint, fovLeft, Scalar.White, 1, vbc.task.lineType);
            DrawCircle(dst2, markerLeft, vbc.task.DotSize + 3, Scalar.Red);
            DrawCircle(dst2, markerRight, vbc.task.DotSize + 3, Scalar.Red);
            dst2.Line(cam, markerLeft, Scalar.Red, 1, vbc.task.lineType);
            dst2.Line(cam, markerRight, Scalar.Red, 1, vbc.task.lineType);
            float shift = (src.Width - src.Height) / 2;
            var labelLocation = new cv.Point(dst2.Width / 2 + shift, dst2.Height * 15 / 16);
            SetTrueText("hFOV=" + string.Format("{0:0.0}", 180 - startAngle * 2) + " deg.", new cv.Point(4, dst2.Height * 7 / 8));
            DrawLine(dst2, vbc.task.topCameraPoint, fovRight, Scalar.White);
        }
    }




    public class PointCloud_Raw_CPP_CS : VB_Parent
    {
        byte[] depthBytes;
        public PointCloud_Raw_CPP_CS()
        {
            labels[2] = "Top View";
            labels[3] = "Side View";
            desc = "Project the depth data onto a top view And side view.";
            cPtr = SimpleProjectionOpen();
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.FirstPass) Array.Resize(ref depthBytes, (int)(vbc.task.pcSplit[2].Total() * vbc.task.pcSplit[2].ElemSize()));
            Marshal.Copy(vbc.task.pcSplit[2].Data, depthBytes, 0, depthBytes.Length);
            var handleDepth = GCHandle.Alloc(depthBytes, GCHandleType.Pinned);
            IntPtr imagePtr = SimpleProjectionRun(cPtr, handleDepth.AddrOfPinnedObject(), 0, vbc.task.MaxZmeters, vbc.task.pcSplit[2].Height, vbc.task.pcSplit[2].Width);
            dst2 = cv.Mat.FromPixelData(vbc.task.pcSplit[2].Rows, vbc.task.pcSplit[2].Cols, MatType.CV_8U, imagePtr).CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3 = cv.Mat.FromPixelData(vbc.task.pcSplit[2].Rows, vbc.task.pcSplit[2].Cols, MatType.CV_8U, SimpleProjectionSide(cPtr)).CvtColor(ColorConversionCodes.GRAY2BGR);
            handleDepth.Free();
            labels[2] = "Top View (looking down)";
            labels[3] = "Side View";
        }
        public void Close()
        {
            SimpleProjectionClose(cPtr);
        }
    }




    public class PointCloud_Raw_CS : VB_Parent
    {
        public PointCloud_Raw_CS()
        {
            labels[2] = "Top View";
            labels[3] = "Side View";
            desc = "Project the depth data onto a top view And side view - Using only VB code (too slow.)";
            cPtr = SimpleProjectionOpen();
        }
        public void RunAlg(Mat src)
        {
            float range = vbc.task.MaxZmeters;
            dst2 = src.EmptyClone().SetTo(Scalar.White);
            dst3 = dst2.Clone();
            var black = new Vec3b(0, 0, 0);
            Parallel.ForEach(vbc.task.gridRects, roi =>
            {
                for (int y = roi.Y; y < roi.Y + roi.Height; y++)
                {
                    for (int x = roi.X; x < roi.X + roi.Width; x++)
                    {
                        byte m = vbc.task.depthMask.Get<byte>(y, x);
                        if (m > 0)
                        {
                            float depth = vbc.task.pcSplit[2].Get<float>(y, x);
                            int dy = (int)(src.Height * depth / range);
                            if (dy < src.Height && dy > 0) dst2.Set<Vec3b>(src.Height - dy, x, black);
                            int dx = (int)(src.Width * depth / range);
                            if (dx < src.Width && dx > 0) dst3.Set<Vec3b>(y, dx, black);
                        }
                    }
                }
            });
            labels[2] = "Top View (looking down)";
            labels[3] = "Side View";
        }
        public void Close()
        {
            SimpleProjectionClose(cPtr);
        }
    }




    public class PointCloud_Solo_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public PointCloud_Solo_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = true;
            labels[2] = "Top down view after inrange sampling";
            labels[3] = "Histogram after filtering For Single-only histogram bins";
            desc = "Find floor And ceiling Using gravity aligned top-down view And selecting bins With exactly 1 sample";
        }
        public void RunAlg(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst0.InRange(vbc.task.frameHistoryCount, vbc.task.frameHistoryCount).ConvertScaleAbs();
            dst3 = heat.dst1.InRange(vbc.task.frameHistoryCount, vbc.task.frameHistoryCount).ConvertScaleAbs();
        }
    }




    public class PointCloud_SoloRegions_CS : VB_Parent
    {
        public PointCloud_Solo solo = new PointCloud_Solo();
        Dilate_Basics dilate = new Dilate_Basics();
        public PointCloud_SoloRegions_CS()
        {
            labels[2] = "Top down view before inrange sampling";
            labels[3] = "Histogram after filtering For Single-only histogram bins";
            desc = "Find floor And ceiling Using gravity aligned top-down view And selecting bins With exactly 1 sample";
        }
        public void RunAlg(Mat src)
        {
            solo.Run(src);
            dst2 = solo.dst2;
            dst3 = solo.dst3;
            dilate.Run(dst3.Clone());
            dst3 = dilate.dst2;
        }
    }




    public class PointCloud_SurfaceH_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public Plot_Basics_CPP_VB plot = new Plot_Basics_CPP_VB();
        public int topRow;
        public int botRow;
        public int peakRow;
        public PointCloud_SurfaceH_CS()
        {
            desc = "Find the horizontal surfaces With a projects Of the SideView histogram.";
        }
        public void RunAlg(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst3;
            topRow = 0;
            botRow = 0;
            peakRow = 0;
            int peakVal = 0;
            for (int i = 0; i < dst2.Height; i++)
            {
                plot.srcX.Add(i);
                if (dst2.Channels() == 1) plot.srcY.Add(dst2.Row(i).CountNonZero());
                else plot.srcY.Add(dst2.Row(i).CvtColor(ColorConversionCodes.BGR2GRAY).CountNonZero());
                if (peakVal < plot.srcY[i])
                {
                    peakVal = (int)plot.srcY[i];
                    peakRow = i;
                }
                if (topRow == 0 && plot.srcY[i] > 10) topRow = i;
            }
            for (int i = plot.srcY.Count() - 1; i >= 0; i--)
            {
                if (botRow == 0 && plot.srcY[i] > 10) botRow = i;
            }
            plot.Run(empty);
            dst3 = plot.dst2.Transpose();
            dst3 = dst3.Flip(FlipMode.Y);
            labels[2] = "Top row = " + topRow.ToString() + " peak row = " + peakRow.ToString() + " bottom row = " + botRow.ToString();
        }
    }




    public class PointCloud_NeighborV_CS : VB_Parent
    {
        Options_Neighbors options = new Options_Neighbors();
        public PointCloud_NeighborV_CS()
        {
            desc = "Show where vertical neighbor depth values are within Y mm's";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Type() != MatType.CV_32F) src = vbc.task.pcSplit[2];
            var tmp32f = new Mat(dst2.Size(), MatType.CV_32F, cv.Scalar.All(0));
            var r1 = new cv.Rect(options.pixels, 0, dst2.Width - options.pixels, dst2.Height);
            var r2 = new cv.Rect(0, 0, dst2.Width - options.pixels, dst2.Height);
            Cv2.Absdiff(src[r1], src[r2], tmp32f[r1]);
            tmp32f = tmp32f.Threshold(options.threshold, 255, ThresholdTypes.BinaryInv);
            dst2 = tmp32f.ConvertScaleAbs(255);
            dst2.SetTo(0, vbc.task.noDepthMask);
            dst2[new cv.Rect(0, dst2.Height - options.pixels, dst2.Width, options.pixels)].SetTo(0);
            labels[2] = "White: z is within " + (options.threshold * 1000).ToString(vbc.fmt0) + " mm's with Y pixel offset " + options.pixels.ToString();
        }
    }




    public class PointCloud_Visualize_CS : VB_Parent
    {
        public PointCloud_Visualize_CS()
        {
            labels = new string[] { "", "", "Pointcloud visualized", "" };
            desc = "Display the pointcloud as a BGR image.";
        }
        public void RunAlg(Mat src)
        {
            var pcSplit = new Mat[] { vbc.task.pcSplit[0].ConvertScaleAbs(255), vbc.task.pcSplit[1].ConvertScaleAbs(255), vbc.task.pcSplit[2].ConvertScaleAbs(255) };
            Cv2.Merge(pcSplit, dst2);
        }
    }




    public class PointCloud_PCpointsMask_CS : VB_Parent
    {
        public Mat pcPoints;
        public int actualCount;
        public PointCloud_PCpointsMask_CS()
        {
            setPointCloudGrid();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Reduce the point cloud to a manageable number points in 3D representing the averages of X, Y, and Z in that roi.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged) pcPoints = new Mat(vbc.task.gridRows, vbc.task.gridCols, MatType.CV_32FC3, cv.Scalar.All(0));
            dst2.SetTo(0);
            actualCount = 0;
            float lastMeanZ = 0;
            for (int y = 0; y < vbc.task.gridRows; y++)
            {
                for (int x = 0; x < vbc.task.gridCols; x++)
                {
                    var roi = vbc.task.gridRects[y * vbc.task.gridCols + x];
                    var mean = vbc.task.pointCloud[roi].Mean(vbc.task.depthMask[roi]);
                    bool depthPresent = vbc.task.depthMask[roi].CountNonZero() > roi.Width * roi.Height / 2;
                    if ((depthPresent && mean[2] > 0 && Math.Abs(lastMeanZ - mean[2]) < 0.2 && mean[2] < vbc.task.MaxZmeters) || (lastMeanZ == 0 && mean[2] > 0))
                    {
                        pcPoints.Set<Point3f>(y, x, new Point3f((float)mean[0], (float)mean[1], (float)mean[2]));
                        actualCount++;
                        DrawCircle(dst2, new cv.Point(roi.X, roi.Y), (int)(vbc.task.DotSize * Math.Max(mean[2], 1)),
                                    Scalar.White);
                    }
                    lastMeanZ = (float)mean[2];
                }
            }
            labels[2] = "PointCloud cv.Point Points found = " + actualCount.ToString();
        }
    }




    public class PointCloud_PCPoints_CS : VB_Parent
    {
        public List<Point3f> pcPoints = new List<Point3f>();
        public PointCloud_PCPoints_CS()
        {
            setPointCloudGrid();
            desc = "Reduce the point cloud to a manageable number points in 3D using the mean value";
        }
        public void RunAlg(Mat src)
        {
            int rw = vbc.task.gridRects[0].Width / 2, rh = vbc.task.gridRects[0].Height / 2;
            cv.Scalar red32 = new cv.Scalar(0, 0, 1);
            cv.Scalar blue32 = new cv.Scalar(1, 0, 0);
            cv.Scalar white32 = new cv.Scalar(1, 1, 1);
            cv.Scalar red = Scalar.Red;
            cv.Scalar blue = Scalar.Blue;
            cv.Scalar white = Scalar.White;
            pcPoints.Clear();
            dst2 = src;
            foreach (var roi in vbc.task.gridRects)
            {
                var pt = new cv.Point(roi.X + rw, roi.Y + rh);
                var mean = vbc.task.pointCloud[roi].Mean(vbc.task.depthMask[roi]);
                if (mean[2] > 0)
                {
                    if (pt.Y % 3 == 0) pcPoints.Add(new cv.Point3f((float)red32[0], (float)red32[1], (float)red32[2]));
                    if (pt.Y % 3 == 1) pcPoints.Add(new cv.Point3f((float)blue32[0], (float)blue32[1], (float)blue32[2]));
                    if (pt.Y % 3 == 2) pcPoints.Add(new cv.Point3f((float)white32[0], (float)white32[1], (float)white32[2]));
                    pcPoints.Add(new cv.Point3f((float)mean[0], (float)mean[1], (float)mean[2]));
                    if (pt.Y % 3 == 0) DrawCircle(dst2, pt, vbc.task.DotSize, red);
                    if (pt.Y % 3 == 1) DrawCircle(dst2, pt, vbc.task.DotSize, blue);
                    if (pt.Y % 3 == 2) DrawCircle(dst2, pt, vbc.task.DotSize, white);
                }
            }
            labels[2] = "PointCloud cv.Point Points found = " + (pcPoints.Count() / 2).ToString();
        }
    }




    public class PointCloud_PCPointsPlane_CS : VB_Parent
    {
        PointCloud_Basics pcBasics = new PointCloud_Basics();
        public List<cv.Point3f> pcPoints = new List<cv.Point3f>();
        public List<cv.Point> xyList = new List<cv.Point>();
        cv.Point3f white32 = new cv.Point3f(1, 1, 1);
        public PointCloud_PCPointsPlane_CS()
        {
            setPointCloudGrid();
            desc = "Find planes using a reduced set of 3D points and the intersection of vertical and horizontal lines through those points.";
        }
        public void RunAlg(Mat src)
        {
            pcBasics.Run(src);
            pcPoints.Clear();
            // points in both the vertical and horizontal lists are likely to designate a plane
            foreach (var pt in pcBasics.allPointsH)
            {
                if (pcBasics.allPointsV.Contains(pt))
                {
                    pcPoints.Add(white32);
                    pcPoints.Add(pt);
                }
            }
            labels[2] = "Point series found = " + (pcPoints.Count() / 2).ToString();
        }
    }




    public class PointCloud_Inspector_CS : VB_Parent
    {
        public PointCloud_Inspector_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.mouseMovePoint.X = dst2.Width / 2;
            desc = "Inspect x, y, and z values in a row or column";
        }
        public void RunAlg(Mat src)
        {
            int yLines = 20;
            int cLine = vbc.task.mouseMovePoint.X;
            Mat input = src;
            if (input.Type() != MatType.CV_32F) input = vbc.task.pcSplit[2];
            Point2f topPt = new Point2f(cLine, 0);
            Point2f botPt = new Point2f(cLine, dst2.Height);
            dst2 = vbc.task.depthRGB;
            DrawLine(dst2, topPt, botPt, cv.Scalar.All(255));
            double stepY = dst2.Height / yLines;
            SetTrueText("\t   X\t  Y\t  Z", 3);
            for (int i = 1; i < yLines - 1; i++)
            {
                Point2f pt1 = new Point2f(dst2.Width, (float)(i * stepY));
                Point2f pt2 = new Point2f(0, (float)(i * stepY));
                DrawLine(dst2, pt1, pt2, Scalar.White);
                Point2f pt = new Point2f(cLine, (float)(i * stepY));
                Vec3f xyz = vbc.task.pointCloud.Get<Vec3f>((int)pt.Y, (int)pt.X);
                SetTrueText("Row " + i.ToString() + "\t" + xyz[0].ToString(vbc.fmt2) + "\t" + xyz[1].ToString(vbc.fmt2) +
                            "\t" + xyz[2].ToString(vbc.fmt2), new cv.Point(5, (int)pt.Y), 3);
            }
            labels[2] = "Values displayed are the point cloud X, Y, and Z values for column " + cLine.ToString();
            labels[3] = "Move mouse in the image at left to see the point cloud X, Y, and Z values.";
        }
    }




    public class PointCloud_Average_CS : VB_Parent
    {
        List<Mat> pcHistory = new List<Mat>();
        public PointCloud_Average_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            desc = "Average all 3 elements of the point cloud - not just depth.";
        }
        public void RunAlg(Mat src)
        {
            pcHistory.Add(vbc.task.pointCloud);
            if (pcHistory.Count() >= vbc.task.frameHistoryCount) pcHistory.RemoveAt(0);
            dst3.SetTo(0);
            foreach (var m in pcHistory)
            {
                dst3 += m;
            }
            dst3 *= 1.0 / pcHistory.Count();
        }
    }




    public class PointCloud_FrustrumTop_CS : VB_Parent
    {
        Draw_Frustrum frustrum = new Draw_Frustrum();
        HeatMap_Basics heat = new HeatMap_Basics();
        PointCloud_SetupTop setupTop = new PointCloud_SetupTop();
        public PointCloud_FrustrumTop_CS()
        {
            vbc.task.gOptions.setGravityUsage(false);
            FindCheckBox("Top View (Unchecked Side View)").Checked = true;
            labels[3] = "Draw the frustrum from the top view";
            desc = "Draw the top view of the frustrum";
        }
        public void RunAlg(Mat src)
        {
            frustrum.Run(src);
            heat.Run(frustrum.dst3.Resize(dst2.Size()));
            setupTop.Run(heat.dst2);
            dst2 = setupTop.dst2;
        }
    }




    public class PointCloud_FrustrumSide_CS : VB_Parent
    {
        Draw_Frustrum frustrum = new Draw_Frustrum();
        HeatMap_Basics heat = new HeatMap_Basics();
        PointCloud_SetupSide setupSide = new PointCloud_SetupSide();
        public PointCloud_FrustrumSide_CS()
        {
            vbc.task.gOptions.setGravityUsage(false);
            FindCheckBox("Top View (Unchecked Side View)").Checked = false;
            labels[2] = "Draw the frustrum from the side view";
            desc = "Draw the side view of the frustrum";
        }
        public void RunAlg(Mat src)
        {
            frustrum.Run(src);
            heat.Run(frustrum.dst3.Resize(dst2.Size()));
            setupSide.Run(heat.dst3);
            dst2 = setupSide.dst2;
        }
    }




    public class PointCloud_Histograms_CS : VB_Parent
    {
        Plot_Histogram2D plot2D = new Plot_Histogram2D();
        Plot_Histogram plot = new Plot_Histogram();
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        Grid_Basics grid = new Grid_Basics();
        public Mat histogram = new Mat();
        public PointCloud_Histograms_CS()
        {
            vbc.task.gOptions.setHistogramBins(9);
            vbc.task.redOptions.setXYReduction(true);
            labels = new string[] { "", "", "Plot of 2D histogram", "All non-zero entries in the 2D histogram" };
            desc = "Create a 2D histogram of the point cloud data - which 2D inputs is in options.";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.redOptions.Sync(); // make sure settings are consistent
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.redOptions.channels, new Mat(), histogram, vbc.task.redOptions.channelCount,
                            vbc.task.redOptions.histBinList, vbc.task.redOptions.ranges);
            switch (vbc.task.redOptions.PointCloudReduction)
            {
                case 0:
                case 1:
                case 2: // "X Reduction", "Y Reduction", "Z Reduction"
                    plot.Run(histogram);
                    dst2 = plot.histogram;
                    labels[2] = "2D plot of 1D histogram.";
                    break;
                case 3:
                case 4:
                case 5: // "XY Reduction", "XZ Reduction", "YZ Reduction"
                    plot2D.Run(histogram);
                    dst2 = plot2D.dst2;
                    labels[2] = "2D plot of 2D histogram.";
                    break;
                case 6: // "XYZ Reduction"
                    if (dst2.Type() != MatType.CV_8U) dst2 = new Mat(dst2.Size(), MatType.CV_8U);
                    hcloud.Run(vbc.task.pointCloud);
                    histogram = hcloud.histogram;
                    float[] histData = new float[histogram.Total()];
                    Marshal.Copy(histogram.Data, histData, 0, histData.Length);
                    if (histData.Length > 255 && vbc.task.histogramBins > 3)
                    {
                        vbc.task.histogramBins -= 1;
                    }
                    if (histData.Length < 128 && vbc.task.histogramBins < vbc.task.gOptions.getHistBinBarMax())
                    {
                        vbc.task.histogramBins += 1;
                    }
                    if (vbc.task.gridRects.Count() < histData.Length && vbc.task.gridSize > 2)
                    {
                        vbc.task.gridSize -= 1;
                        grid.Run(src);
                        dst2.SetTo(0);
                    }
                    histData[0] = 0; // count of zero pixels - distorts results..
                    float maxVal = histData.Max();
                    for (int i = 0; i < vbc.task.gridRects.Count(); i++)
                    {
                        var roi = vbc.task.gridRects[i];
                        if (i >= histData.Length)
                        {
                            dst2[roi].SetTo(0);
                        }
                        else
                        {
                            dst2[roi].SetTo(255 * histData[i] / maxVal);
                        }
                    }
                    labels[2] = "2D plot of the resulting 3D histogram.";
                    break;
            }
            var mm = GetMinMax(dst2);
            dst3 = ShowPalette(dst2 * 255 / mm.maxVal);
        }
    }




    public class PointCloud_ReduceSplit2_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        public PointCloud_ReduceSplit2_CS()
        {
            UpdateAdvice(traceName + ": redOptions 'X/Y-Range X100' sliders to test further.");
            desc = "Reduce the vbc.task.pcSplit[2] for use in several algorithms.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = vbc.task.pcSplit[2] * 1000;
            dst2.ConvertTo(dst2, MatType.CV_32S);
            reduction.Run(dst2);
            reduction.dst2.ConvertTo(dst1, MatType.CV_32F);
            dst1 *= 0.001;
            if (standaloneTest())
            {
                dst3 = vbc.task.pointCloud;
            }
            else
            {
                var mm = GetMinMax(dst1);
                dst1 *= vbc.task.MaxZmeters / mm.maxVal;
                Cv2.Merge(new Mat[] { vbc.task.pcSplit[0], vbc.task.pcSplit[1], dst1 }, dst3);
            }
        }
    }




    public class PointCloud_ReducedTopView_CS : VB_Parent
    {
        PointCloud_ReduceSplit2 split2 = new PointCloud_ReduceSplit2();
        public PointCloud_ReducedTopView_CS()
        {
            UpdateAdvice(traceName + ": redOptions 'Reduction Sliders' have high impact.");
            desc = "Create a stable side view of the point cloud";
        }
        public void RunAlg(Mat src)
        {
            split2.Run(vbc.task.pointCloud);
            Cv2.CalcHist(new Mat[] { split2.dst3 }, vbc.task.channelsTop, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesTop);
            dst1 = dst1.Flip(FlipMode.X);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
        }
    }




    public class PointCloud_ReducedSideView_CS : VB_Parent
    {
        PointCloud_ReduceSplit2 split2 = new PointCloud_ReduceSplit2();
        public PointCloud_ReducedSideView_CS()
        {
            desc = "Show where vertical neighbor depth values are within X mm's";
        }
        public void RunAlg(Mat src)
        {
            split2.Run(null);
            Cv2.CalcHist(new Mat[] { split2.dst3 }, vbc.task.channelsSide, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesSide);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
        }
    }




    public class PointCloud_ReducedViews_CS : VB_Parent
    {
        PointCloud_ReduceSplit2 split2 = new PointCloud_ReduceSplit2();
        public PointCloud_ReducedViews_CS()
        {
            labels = new string[] { "", "", "Reduced side view", "Reduced top view" };
            desc = "Show where vertical neighbor depth values are within X mm's";
        }
        public void RunAlg(Mat src)
        {
            split2.Run(null);
            Cv2.CalcHist(new Mat[] { split2.dst3 }, vbc.task.channelsSide, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesSide);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
            Cv2.CalcHist(new Mat[] { split2.dst3 }, vbc.task.channelsTop, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesTop);
            dst1 = dst1.Flip(FlipMode.X);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1.ConvertTo(dst3, MatType.CV_8UC1);
        }
    }




    public class PointCloud_XRangeTest_CS : VB_Parent
    {
        PointCloud_ReduceSplit2 split2 = new PointCloud_ReduceSplit2();
        public PointCloud_XRangeTest_CS()
        {
            UpdateAdvice(traceName + ": redOptions 'X-Range X100' slider has high impact.");
            desc = "Test adjusting the X-Range value to squeeze a histogram into dst2.";
        }
        public void RunAlg(Mat src)
        {
            split2.Run(src);
            Cv2.CalcHist(new Mat[] { split2.dst3 }, vbc.task.channelsTop, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesTop);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1 = dst1.Flip(FlipMode.X);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
        }
    }




    public class PointCloud_YRangeTest_CS : VB_Parent
    {
        PointCloud_ReduceSplit2 split2 = new PointCloud_ReduceSplit2();
        public PointCloud_YRangeTest_CS()
        {
            UpdateAdvice(traceName + ": redOptions 'Y-Range X100' slider has high impact.");
            desc = "Test adjusting the Y-Range value to squeeze a histogram into dst2.";
        }
        public void RunAlg(Mat src)
        {
            split2.Run(src);
            Cv2.CalcHist(new Mat[] { split2.dst3 }, vbc.task.channelsSide, new Mat(), dst1, 2, vbc.task.bins2D, vbc.task.rangesSide);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
        }
    }




    public class Polylines_IEnumerableExample_CS : VB_Parent
    {
        Options_PolyLines options = new Options_PolyLines();
        public Polylines_IEnumerableExample_CS()
        {
            desc = "Manually create an IEnumerable<IEnumerable<cv.Point>>.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var points = Enumerable.Range(0, options.polyCount).Select(i =>
                new cv.Point(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height))).ToList();
            var pts = new List<List<cv.Point>> { points };
            dst2 = new Mat(src.Size(), MatType.CV_8U, cv.Scalar.All(0));
            // NOTE: when there are 2 points, there will be 1 line.
            Cv2.Polylines(dst2, pts, options.polyClosed, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
        }
    }
    // C# implementation of the browse example in Opencv.
    // https://github.com/opencv/opencv/blob/master/samples/python/browse.py




    public class Polylines_Random_CS : VB_Parent
    {
        Pixel_Zoom zoom = new Pixel_Zoom();
        public Polylines_Random_CS()
        {
            labels[2] = "To zoom move the mouse over the image";
            desc = "Create a random procedural image";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.frameCount % (vbc.task.fpsRate * 3) == 0) // every x frames.
            {
                int h = src.Height, w = src.Width;
                Random autorand = new Random();
                Point2f[] points2f = new Point2f[10000];
                var pts = new List<List<cv.Point>>();
                var points = new List<cv.Point>();
                points2f[0] = new Point2f((float)(autorand.NextDouble() - 0.5), (float)(autorand.NextDouble() - 0.5));
                for (int i = 1; i < points2f.Length; i++)
                {
                    points2f[i] = new Point2f((float)(autorand.NextDouble() - 0.5 + points2f[i - 1].X),
                                                (float)(autorand.NextDouble() - 0.5 + points2f[i - 1].Y));
                    points.Add(new cv.Point((int)(points2f[i].X * 10 + w / 2), (int)(points2f[i].Y * 10 + h / 2)));
                }
                pts.Add(points);
                dst2 = new Mat(src.Size(), MatType.CV_8U, cv.Scalar.All(0));
                Cv2.Polylines(dst2, pts, false, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
                dst2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            }
            zoom.Run(dst2);
            dst3 = zoom.dst2;
        }
    }




    public class PongWars_Basics_CS : VB_Parent
    {
        int sqWidth = 25;
        int sqHeight;
        int numSquaresX;
        int numSquaresY;
        const int DAY_COLOR = 1, DAY_BALL_COLOR = 2, NIGHT_COLOR = 3, NIGHT_BALL_COLOR = 4;
        int[,] squares;
        cv.Point p1;
        Point2f d1;
        cv.Point p2;
        Point2f d2;
        int iteration = 0;
        cv.Point p1Last = new cv.Point();
        cv.Point p2Last = new cv.Point();
        public PongWars_Basics_CS()
        {
            sqHeight = 25 * vbc.task.dst2.Height / vbc.task.dst2.Width;
            numSquaresX = vbc.task.dst2.Width / sqWidth;
            numSquaresY = vbc.task.dst2.Height / sqHeight;
            squares = new int[numSquaresX, numSquaresY];
            p1 = new cv.Point(vbc.task.dst2.Width / 4, vbc.task.dst2.Height / 2);
            d1 = new Point2f(12.5f, -12.5f);
            p2 = new cv.Point((vbc.task.dst2.Width / 4) * 3, vbc.task.dst2.Height / 2);
            d2 = new Point2f(-12.5f, 12.5f);
            for (int i = 0; i < numSquaresX; i++)
            {
                for (int j = 0; j < numSquaresY; j++)
                {
                    squares[i, j] = (i < numSquaresX / 2) ? DAY_COLOR : NIGHT_COLOR;
                }
            }
            p1 = new cv.Point(msRNG.Next(0, dst2.Width / 4), msRNG.Next(0, dst2.Height / 2));
            p2 = new cv.Point(msRNG.Next(dst2.Width / 2, dst2.Width), msRNG.Next(dst2.Height / 4, dst2.Height));
            UpdateAdvice(traceName + ": <place advice here on any options that are useful>");
            desc = "Pong as war between the forces of light and darkness.";
        }
        Point2f UpdateSquareAndBounce(cv.Point pt, Point2f dxy, int sqClass)
        {
            for (double angle = 0; angle <= Math.PI * 2; angle += Math.PI / 4)
            {
                double checkX = pt.X + Math.Cos(angle) * (sqWidth / 2);
                double checkY = pt.Y + Math.Sin(angle) * (sqHeight / 2);
                int i = (int)Math.Floor(checkX / sqWidth);
                int j = (int)Math.Floor(checkY / sqHeight);
                if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY)
                {
                    if (squares[i, j] != sqClass)
                    {
                        squares[i, j] = sqClass;
                        if (Math.Abs(Math.Cos(angle)) > Math.Abs(Math.Sin(angle)))
                        {
                            dxy.X = -dxy.X;
                        }
                        else
                        {
                            dxy.Y = -dxy.Y;
                        }
                    }
                }
            }
            return dxy;
        }
        Point2f CheckBoundaryCollision(cv.Point pt, Point2f dxy)
        {
            if (pt.X + dxy.X > dst2.Width - sqWidth / 2 || pt.X + dxy.X < sqWidth / 2) dxy.X = -dxy.X;
            if (pt.Y + dxy.Y > dst2.Height - sqHeight / 2 || pt.Y + dxy.Y < sqHeight / 2) dxy.Y = -dxy.Y;
            return dxy;
        }
        void UpdateScoreElement()
        {
            int dayScore = 0;
            int nightScore = 0;
            for (int i = 0; i < numSquaresX; i++)
            {
                for (int j = 0; j < numSquaresY; j++)
                {
                    if (squares[i, j] == DAY_COLOR)
                    {
                        dayScore += 1;
                    }
                    else if (squares[i, j] == NIGHT_COLOR)
                    {
                        nightScore += 1;
                    }
                }
            }
            if (vbc.task.heartBeat) labels[2] = $"Pong War: day {dayScore} | night {nightScore}";
        }
        public void RunAlg(Mat src)
        {
            iteration += 1;
            if (iteration % 1000 == 0)
            {
                Debug.WriteLine("iteration " + iteration);
            }
            d1 = UpdateSquareAndBounce(p1, d1, DAY_COLOR);
            d2 = UpdateSquareAndBounce(p2, d2, NIGHT_COLOR);
            d1 = CheckBoundaryCollision(p1, d1);
            d2 = CheckBoundaryCollision(p2, d2);
            p1.X += (int)d1.X;
            p1.Y += (int)d1.Y;
            p2.X += (int)d2.X;
            p2.Y += (int)d2.Y;
            if (p1Last == p1) p1 = new cv.Point(msRNG.Next(0, dst2.Width / 2), msRNG.Next(0, dst2.Height / 2));
            p1Last = p1;
            if (p2Last == p2) p2 = new cv.Point(msRNG.Next(0, dst2.Width / 2), msRNG.Next(0, dst2.Height / 2));
            p2Last = p2;
            UpdateScoreElement();
            dst2.SetTo(0);
            for (int i = 0; i < numSquaresX; i++)
            {
                for (int j = 0; j < numSquaresY; j++)
                {
                    var rect = new cv.Rect(i * sqWidth, j * sqHeight, sqWidth, sqHeight);
                    int index = squares[i, j];
                    dst2.Rectangle(rect, vbc.task.scalarColors[index], -1);
                }
            }
            var pt = new cv.Point((int)(p1.X - sqWidth / 2), (int)(p1.Y - sqHeight / 2));
            DrawCircle(dst2, pt, vbc.task.DotSize + 5, vbc.task.scalarColors[DAY_BALL_COLOR]);
            pt = new cv.Point((int)(p2.X - sqWidth / 2), (int)(p2.Y - sqHeight / 2));
            DrawCircle(dst2, pt, vbc.task.DotSize + 5, vbc.task.scalarColors[NIGHT_BALL_COLOR]);
        }
    }




    public class PongWars_Two_CS : VB_Parent
    {
        PongWars_Basics pong1 = new PongWars_Basics();
        PongWars_Basics pong2 = new PongWars_Basics();
        public PongWars_Two_CS()
        {
            desc = "Running 2 pong wars at once.  Randomness inserted with starting location.";
        }
        public void RunAlg(Mat src)
        {
            pong1.Run(src);
            dst2 = pong1.dst2.Clone();
            labels[2] = pong1.labels[2];
            pong2.Run(src);
            dst3 = pong2.dst2.Clone();
            labels[3] = pong2.labels[2];
        }
    }




    public class ProCon_Basics_CS : VB_Parent
    {
        readonly object _lockObject = new object();
        public Thread p;
        public Thread c;
        public int head = -1;
        public int tail = -1;
        public int frameCount = 1;
        public Font_FlowText flow = new Font_FlowText();
        public bool terminateConsumer;
        public bool terminateProducer;
        public Options_ProCon options = new Options_ProCon();
        public ProCon_Basics_CS()
        {
            flow.parentData = this;
            p = new Thread(Producer);
            p.Name = "Producer";
            p.Start();
            c = new Thread(Consumer);
            c.Name = "Consumer";
            c.Start();
            desc = "DijKstra's Producer/Consumer 'Cooperating Sequential Process'.  Consumer must see every item produced.";
        }
        public int success(int index)
        {
            return (index + 1) % options.buffer.Length;
        }
        public void Consumer()
        {
            while (true)
            {
                if (vbc.task.frameCount < 0) break;
                lock (_lockObject)
                {
                    head = success(head);
                    var item = options.buffer[head];
                    if (item != -1)
                    {
                        flow.nextMsg = "Consumer: = " + item.ToString();
                        options.buffer[head] = -1;
                    }
                }
                if (terminateConsumer) break;
                cv.Cv2.WaitKey();
            }
        }
        void Producer()
        {
            while (true)
            {
                if (vbc.task.frameCount < 0) break;
                lock (_lockObject)
                {
                    tail = success(tail);
                    if (options.buffer[tail] == -1)
                    {
                        flow.nextMsg = "producer: = " + frameCount.ToString();
                        options.buffer[tail] = frameCount;
                        frameCount += 1;
                    }
                }
                if (terminateProducer) break;
                cv.Cv2.WaitKey();
            }
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.testAllRunning)
            {
                SetTrueText("ProCon_Basics is well-tested but threads hang around during overnight testing. " + Environment.NewLine + "Skipping for now...");
                return;
            }
            
            options.RunOpt();
            if (options.buffer.Length != options.bufferSize)
            {
                lock (_lockObject)
                {
                    options.buffer = new int[options.bufferSize];
                    options.buffer = Enumerable.Repeat(-1, options.buffer.Length).ToArray();
                    frameCount = 0;
                    head = -1;
                    tail = -1;
                };
            }
            lock (_lockObject)
            {
                flow.Run(empty);
            }
        }
        public void Close()
        {
            terminateProducer = true;
            terminateConsumer = true;
        }
    }




    public class ProCon_Variation_CS : VB_Parent
    {
        readonly object _lockObject = new object();
        ProCon_Basics procon;
        int frameCount;
        public ProCon_Variation_CS()
        {
            procon = new ProCon_Basics();
            procon.terminateProducer = true; // we don't need a 2 producer vbc.task.  RunVB below provides the second thread.
            desc = "DijKstra's Producer/Consumer - similar to Basics above but producer is the algorithm thread.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.testAllRunning)
            {
                SetTrueText("ProCon_Variation is well-tested but threads hang around during overnight testing. " + Environment.NewLine + "Skipping for now...");
                return;
            }
            
            lock (_lockObject)
            {
                procon.tail = procon.success((int)procon.tail);
                if (procon.options.buffer[(int)procon.tail] == -1)
                {
                    procon.flow.nextMsg = "producer: = " + frameCount.ToString();
                    procon.options.buffer[(int)procon.tail] = frameCount;
                    frameCount += 1;
                }
            }

            procon.Run(src);
        }
        public void Close()
        {
            procon.terminateConsumer = true;
            procon.terminateProducer = true;
        }
    }




    public class Profile_Basics_CS : VB_Parent
    {
        public Point3f ptLeft, ptRight, ptTop, ptBot, ptFront, ptBack;
        public List<string> cornerNames = new List<string> { "   First (white)", "   Left (light blue)", "   Right (red)", "   Top (green)",
                                                        "   Bottom (white)", "   Front (yellow)", "   Back (blue)" };
        public List<Scalar> cornerColors = new List<Scalar> { Scalar.White, Scalar.LightBlue, Scalar.Red, Scalar.Green,
                                                            Scalar.White, Scalar.Yellow, Scalar.Blue };
        public List<cv.Point3f> corners3D = new List<cv.Point3f>();
        public List<cv.Point> corners = new List<cv.Point>();
        public List<cv.Point> cornersRaw = new List<cv.Point>();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Profile_Basics_CS()
        {
            desc = "Find the left/right, top/bottom, and near/far sides of a cell";
        }
        string point3fToString(Point3f v)
        {
            return string.Format("{0}\t{1}\t{2}", v.X.ToString(vbc.fmt3), v.Y.ToString(vbc.fmt3), v.Z.ToString(vbc.fmt3));
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            var rc = vbc.task.rc;
            if (rc.depthPixels == 0)
            {
                strOut = "There is no depth data for that cell.";
                return;
            }
            if (rc.contour.Count() < 4) return;
            dst3.SetTo(0);
            DrawContour(dst3[rc.rect], rc.contour, Scalar.Yellow);
            var sortLeft = new SortedList<int, int>(new compareAllowIdenticalInteger());
            var sortTop = new SortedList<int, int>(new compareAllowIdenticalInteger());
            var sortFront = new SortedList<int, int>(new compareAllowIdenticalInteger());
            var sort2Dleft = new SortedList<int, int>(new compareAllowIdenticalInteger());
            var sort2Dtop = new SortedList<int, int>(new compareAllowIdenticalInteger());
            rc.contour3D = new List<cv.Point3f>();
            for (int i = 0; i < rc.contour.Count(); i++)
            {
                var pt = rc.contour[i];
                var vec = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(pt.Y, pt.X);
                if (float.IsNaN(vec.Z) || float.IsInfinity(vec.Z)) continue;
                if (vec.Z > 0)
                {
                    sortLeft.Add(pt.X, i);
                    sortTop.Add(pt.Y, i);
                    sortFront.Add((int)(vec.Z * 1000), i);
                    rc.contour3D.Add(vec);
                }
                else
                {
                    sort2Dleft.Add(pt.X, i);
                    sort2Dtop.Add(pt.Y, i);
                }
            }
            if (sortLeft.Count() == 0)
            {
                sortLeft = sort2Dleft;
                sortTop = sort2Dtop;
            }
            corners3D.Clear();
            corners.Clear();
            cornersRaw.Clear();
            corners.Add(new cv.Point(rc.rect.X + rc.contour[0].X, rc.rect.Y + rc.contour[0].Y)); // show the first contour point...
            cornersRaw.Add(rc.contour[0]); // show the first contour point...
            corners3D.Add(vbc.task.pointCloud.Get<cv.Point3f>(rc.rect.Y + rc.contour[0].Y, rc.rect.X + rc.contour[0].X));
            for (int i = 0; i < 6; i++)
            {
                int index = 0;
                if (i == 1) index = sortLeft.Count() - 1;
                if (i == 2) index = 0;
                if (i == 3) index = sortFront.Count() - 1;
                var ptList = sortLeft;
                if (i == 1) ptList = sortLeft;
                if (i == 2) ptList = sortTop;
                if (i == 3) ptList = sortTop;
                if (i == 4) ptList = sortFront;
                if (i == 5) ptList = sortFront;
                if (ptList.Count() > 0)
                {
                    var pt = rc.contour[ptList.ElementAt(index).Value];
                    cornersRaw.Add(pt);
                    corners.Add(new cv.Point(rc.rect.X + pt.X, rc.rect.Y + pt.Y));
                    corners3D.Add(vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(pt.Y, pt.X));
                }
            }
            for (int i = 0; i < corners.Count(); i++)
            {
                DrawCircle(dst3, corners[i], vbc.task.DotSize + 2, cornerColors[i]);
            }
            if (vbc.task.heartBeat)
            {
                strOut = "X\tY\tZ\tunits=meters\n";
                var w = vbc.task.gridSize;
                for (int i = 0; i < corners.Count(); i++)
                {
                    strOut += point3fToString(corners3D[i]) + "\t" + cornerNames[i] + "\n";
                }
                strOut += "\nThe contour may show points further away but they don't have depth.";
                if (sortFront.Count() == 0) strOut += "\nNone of the contour points had depth.";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Profile_Rotation_CS : VB_Parent
    {
        public IMU_GMatrix gMat = new IMU_GMatrix();
        public string strMsg = "Then use the 'Options_IMU' sliders to rotate the cell\n" +
                                "It is a common mistake to the OpenGL sliders to try to move cell but they don't - use 'Options_IMU' sliders";
        Options_IMU options = new Options_IMU();
        TrackBar ySlider;
        public Profile_Rotation_CS()
        {
            ySlider = FindSlider("Rotate pointcloud around Y-axis");
            if (standaloneTest()) vbc.task.gOptions.setGravityUsage(false);
            labels[2] = "Top matrix is the current gMatrix while the bottom one includes the Y-axis rotation.";
            desc = "Build the rotation matrix around the Y-axis";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                ySlider.Value += 1;
                if (ySlider.Value == ySlider.Maximum) ySlider.Value = ySlider.Minimum;
                SetTrueText("When running standaloneTest(), the Y-axis slider is rotating from -90 to 90.", 3);
            }
            gMat.Run(src);
            if (standaloneTest())
            {
                options.RunOpt();
                strOut = "Gravity-oriented gMatrix\n";
                strOut += vbc.task.gMat.strOut + "\n";
                strOut += "\nNew gMatrix from sliders\n";
                strOut += gMatrixToStr(gMat.gMatrix) + "\n\n";
                strOut += "Angle X = " + options.rotateX.ToString(vbc.fmt1) + "\n";
                strOut += "Angle Y = " + options.rotateY.ToString(vbc.fmt1) + "\n";
                strOut += "Angle Z = " + options.rotateZ.ToString(vbc.fmt1) + "\n";
                SetTrueText(strOut + "\n\n" + strMsg);
            }
        }
    }




    public class Profile_Derivative_CS : VB_Parent
    {
        public Profile_Basics sides = new Profile_Basics();
        List<TrueText> saveTrueText = new List<TrueText>();
        public Profile_Derivative_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Select a cell to analyze its contour", "Selected cell:  yellow = closer, blue = farther, white = no depth" };
            desc = "Visualize the derivative of X, Y, and Z in the contour of a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            sides.Run(src);
            dst2 = sides.dst2;
            var rc = vbc.task.rc;
            int offset = 30;
            float rsizeX = (dst2.Width - offset * 2) / (float)rc.rect.Width;
            float rsizeY = (dst2.Height - offset * 2) / (float)rc.rect.Height;
            saveTrueText.Clear();
            vbc.task.trueData.Clear();
            dst3.SetTo(0);
            Scalar color, near = Scalar.Yellow, far = Scalar.Blue;
            if (rc.index > 0)
            {
                for (int i = 0; i < rc.contour.Count(); i++)
                {
                    var pt = rc.contour[i];
                    var vec = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(pt.Y, pt.X);
                    pt = new cv.Point(pt.X * rsizeX + offset, pt.Y * rsizeY + offset);
                    float t = (rc.maxVec.Z == 0) ? 0 : (vec.Z - rc.minVec.Z) / (rc.maxVec.Z - rc.minVec.Z);
                    if (vec.Z > 0 && t > 0)
                    {
                        byte b = (byte)((1 - t) * near[0] + t * far[0]);
                        byte g = (byte)((1 - t) * near[1] + t * far[1]);
                        byte r = (byte)((1 - t) * near[2] + t * far[2]);
                        color = new Scalar(b, g, r);
                    }
                    else
                    {
                        color = Scalar.White;
                    }
                    DrawCircle(dst3, pt, vbc.task.DotSize, color);
                    if (sides.cornersRaw.Contains(rc.contour[i]))
                    {
                        int index = sides.cornersRaw.IndexOf(rc.contour[i]);
                        DrawCircle(dst1, pt, vbc.task.DotSize + 5, Scalar.White);
                        DrawCircle(dst1, pt, vbc.task.DotSize + 3, sides.cornerColors[index]);
                        SetTrueText(sides.cornerNames[index], pt, 3);
                    }
                }
            }
            strOut = "Points are presented clockwise starting at White dot (leftmost top point)\n" +
                        "yellow = closer, blue = farther,\n\n" + sides.strOut;
            dst1 = sides.dst3.Clone();
            for (int i = 0; i < sides.corners.Count(); i++)
            {
                color = sides.cornerColors[i];
                SetTrueText(sides.cornerNames[i], sides.corners[i], 1);
                DrawCircle(dst1, sides.corners[i], vbc.task.DotSize, color);
            }
            SetTrueText(strOut, 1);
            saveTrueText = new List<TrueText>(trueData);
            if (saveTrueText != null) trueData = new List<TrueText>(saveTrueText);
        }
    }




    public class Profile_ConcentrationSide_CS : VB_Parent
    {
        Profile_ConcentrationTop profile = new Profile_ConcentrationTop();
        public Profile_ConcentrationSide_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = false;
            labels = new string[] { "", "The outline of the selected RedCloud cell", traceName + " - click any RedCloud cell to visualize it's side view in the upper right image.", "" };
            desc = "Rotate around Y-axis to find peaks - this algorithm fails to find the optimal rotation to find walls";
        }
        public void RunAlg(Mat src)
        {
            profile.Run(src);
            dst1 = profile.dst1;
            dst2 = profile.dst2;
            dst3 = profile.dst3;
            labels[3] = profile.labels[3];
        }
    }




    public class Profile_ConcentrationTop_CS : VB_Parent
    {
        Plot_OverTimeSingle plot = new Plot_OverTimeSingle();
        Profile_Rotation rotate = new Profile_Rotation();
        public Profile_Basics sides = new Profile_Basics();
        HeatMap_Basics heat = new HeatMap_Basics();
        Options_HeatMap options = new Options_HeatMap();
        float maxAverage;
        int peakRotation;
        TrackBar ySlider;
        public Profile_ConcentrationTop_CS()
        {
            ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            vbc.task.gOptions.setGravityUsage(false);
            vbc.task.gOptions.setDisplay1();
            desc = "Rotate around Y-axis to find peaks - this algorithm fails to find the optimal rotation to find walls";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            sides.Run(src);
            dst2 = sides.dst2;
            var rc = vbc.task.rc;
            if (rc.contour3D.Count() == 0)
            {
                SetTrueText("The selected cell has no 3D data.  The 3D data can only be computed from cells with depth data.", 1);
                return;
            }
            var vecMat = cv.Mat.FromPixelData(rc.contour3D.Count(), 1, MatType.CV_32FC3, rc.contour3D.ToArray());
            ySlider.Value += 1;
            rotate.Run(empty);
            Mat output = (vecMat.Reshape(1, vecMat.Rows * vecMat.Cols) * rotate.gMat.gMatrix);  // <<< this is the XYZ-axis rotation...
            vecMat = output.Reshape(3, vecMat.Rows);
            heat.Run(vecMat);
            if (options.topView)
            {
                dst1 = heat.dst0.Threshold(0, 255, ThresholdTypes.Binary);
            }
            else
            {
                dst1 = heat.dst1.Threshold(0, 255, ThresholdTypes.Binary);
            }
            var count = dst1.CountNonZero();
            if (maxAverage < count)
            {
                maxAverage = count;
                peakRotation = ySlider.Value;
            }
            plot.plotData = count;
            plot.Run(empty);
            dst3 = plot.dst2;
            if (ySlider.Value >= 45)
            {
                maxAverage = 0;
                peakRotation = -45;
                ySlider.Value = -45;
            }
            labels[3] = "Peak cell concentration in the histogram = " + ((int)maxAverage).ToString() + " at " + peakRotation.ToString() + " degrees";
        }
    }




    public class Profile_OpenGL_CS : VB_Parent
    {
        Profile_Basics sides = new Profile_Basics();
        public Profile_Rotation rotate = new Profile_Rotation();
        HeatMap_Basics heat = new HeatMap_Basics();
        public Profile_OpenGL_CS()
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            if (standaloneTest()) vbc.task.gOptions.setGravityUsage(false);
            vbc.task.ogl.options.PointSizeSlider.Value = 10;
            vbc.task.ogl.oglFunction = (int)oCase.pcPointsAlone;
            desc = "Visualize just the RedCloud cell contour in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            sides.Run(src);
            dst2 = sides.dst2;
            dst3 = sides.dst3;
            var rc = vbc.task.rc;
            if (rc.contour3D.Count() > 0)
            {
                Mat vecMat = cv.Mat.FromPixelData(rc.contour3D.Count(), 1, MatType.CV_32FC3, rc.contour3D.ToArray());
                rotate.Run(empty);
                Mat output = vecMat.Reshape(1, vecMat.Rows * vecMat.Cols) * rotate.gMat.gMatrix;  // <<<<<<<<<<<<<<<<<<<<<<< this is the XYZ-axis rotation...
                vbc.task.ogl.dataInput = output.Reshape(3, vecMat.Rows);
                vbc.task.ogl.pointCloudInput = new Mat();
                vbc.task.ogl.Run(new Mat());
                heat.Run(vecMat);
                dst1 = heat.dst0.Threshold(0, 255, ThresholdTypes.Binary);
            }
            SetTrueText("Select a RedCloud Cell to display the contour in OpenGL." + "\n" + rotate.strMsg, 3);
        }
    }




    public class Profile_Kalman_CS : VB_Parent
    {
        Profile_Basics sides = new Profile_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        public Profile_Kalman_CS()
        {
            kalman.kInput = new float[12];
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Profile_Basics output without Kalman", "Profile_Basics output with Kalman" };
            desc = "Use Kalman to smooth the results of the contour key points";
        }
        public void RunAlg(Mat src)
        {
            sides.Run(src);
            dst0 = sides.redC.dst0;
            dst1 = sides.dst2;
            dst2 = sides.dst3;
            var rc = vbc.task.rc;
            if (kalman.kInput.Length != sides.corners.Count() * 2) Array.Resize(ref kalman.kInput, sides.corners.Count() * 2);
            for (int i = 0; i < sides.corners.Count(); i++)
            {
                kalman.kInput[i * 2] = sides.corners[i].X;
                kalman.kInput[i * 2 + 1] = sides.corners[i].Y;
            }
            kalman.Run(empty);
            if (rc.index > 0)
            {
                dst3.SetTo(0);
                DrawContour(dst3[rc.rect], rc.contour, Scalar.Yellow);
                for (int i = 0; i < sides.corners.Count(); i++)
                {
                    var pt = new cv.Point((int)kalman.kOutput[i * 2], (int)kalman.kOutput[i * 2 + 1]);
                    DrawCircle(dst3, pt, vbc.task.DotSize + 2, sides.cornerColors[i]);
                }
            }
            SetTrueText(sides.strOut, 3);
            SetTrueText("Select a cell in the upper right image", 2);
        }
    }




    public class Puzzle_Basics_CS : VB_Parent
    {
        public List<cv.Rect> scrambled = new List<cv.Rect>(); // this is every roi regardless of size.
        public List<cv.Rect> unscrambled = new List<cv.Rect>(); // this is every roi regardless of size.
        public Mat image = new Mat();
        public Puzzle_Basics_CS()
        {
            desc = "Create the puzzle pieces to solve with correlation.";
        }
        public List<T> Shuffle<T>(IEnumerable<T> collection)
        {
            Random r = new Random();
            return collection.OrderBy(a => r.Next()).ToList();
        }
        public void RunAlg(Mat src)
        {
            unscrambled.Clear();
            List<cv.Rect> inputROI = new List<cv.Rect>();
            for (int j = 0; j < vbc.task.gridRects.Count(); j++)
            {
                var roi = vbc.task.gridRects[j];
                if (roi.Width == vbc.task.gridSize && roi.Height == vbc.task.gridSize)
                    inputROI.Add(vbc.task.gridRects[j]);
            }
            scrambled = Shuffle(inputROI);
            image = src.Clone();
            // display image with shuffled roi's
            for (int i = 0; i < scrambled.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                var roi2 = scrambled[i];
                if (roi.Width == vbc.task.gridSize && roi.Height == vbc.task.gridSize &&
                    roi2.Width == vbc.task.gridSize && roi2.Height == vbc.task.gridSize)
                    dst2[roi2] = src[roi];
            }
        }
    }




    public class Puzzle_Solver_CS : VB_Parent
    {
        public Puzzle_Basics puzzle = new Puzzle_Basics();
        List<cv.Rect> solution = new List<cv.Rect>();
        Match_Basics match = new Match_Basics();
        public Mat grayMat;
        int puzzleIndex;
        Options_Puzzle options = new Options_Puzzle();
        public Puzzle_Solver_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setGridSize(8);
            labels = new string[] { "", "", "Puzzle Input", "Puzzle Solver Output - missing pieces can result from identical cells (usually bright white)" };
            desc = "Solve the puzzle using matchTemplate";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.optionsChanged || options.startPuzzle)
            {
                puzzle.Run(src);
                dst2 = puzzle.dst2;
                dst3.SetTo(0);
                grayMat = puzzle.image.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                puzzleIndex = 0;
            }
            if (puzzle.scrambled.Count() > puzzle.unscrambled.Count())
            {
                // find one piece of the puzzle on each iteration.
                var rect = puzzle.scrambled[puzzleIndex];
                match.template = grayMat[rect];
                match.Run(grayMat);
                var bestRect = ValidateRect(new cv.Rect(match.matchCenter.X, match.matchCenter.Y, rect.Width, rect.Height));
                puzzle.unscrambled.Add(bestRect);
                puzzleIndex++;
                dst3[bestRect] = puzzle.image[bestRect];
            }
        }
    }




    public class Puzzle_SolverDynamic_CS : VB_Parent
    {
        Puzzle_Solver puzzle = new Puzzle_Solver();
        public Puzzle_SolverDynamic_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setGridSize(8);
            labels = new string[] { "", "", "Latest Puzzle input image", "Puzzle Solver Output - missing pieces can occur because of motion or when cells are identical." };
            desc = "Instead of matching the original image as Puzzle_Solver, match the latest image from the camera.";
        }
        public void RunAlg(Mat src)
        {
            puzzle.puzzle.image = src.Clone();
            puzzle.grayMat = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            puzzle.Run(src);
            dst2 = puzzle.dst2;
            dst3 = puzzle.dst3;
        }
    }




    public class Pyramid_Basics_CS : VB_Parent
    {
        Options_Pyramid options = new Options_Pyramid();
        public Pyramid_Basics_CS()
        {
            desc = "Use pyrup and pyrdown to zoom in and out of an image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.zoom != 0)
            {
                if (options.zoom < 0)
                {
                    var tmp = src.PyrDown(new cv.Size(src.Cols / 2, src.Rows / 2));
                    var roi = new cv.Rect((src.Cols - tmp.Cols) / 2, (src.Rows - tmp.Rows) / 2, tmp.Width, tmp.Height);
                    dst2[roi] = tmp;
                }
                else
                {
                    var tmp = src.PyrUp(new cv.Size(src.Cols * 2, src.Rows * 2));
                    var roi = new cv.Rect((tmp.Cols - src.Cols) / 2, (tmp.Rows - src.Rows) / 2, src.Width, src.Height);
                    dst2 = tmp[roi];
                }
            }
            else
            {
                src.CopyTo(dst2);
            }
        }
    }




    public class Pyramid_Filter_CS : VB_Parent
    {
        Laplacian_PyramidFilter laplace = new Laplacian_PyramidFilter();
        public Pyramid_Filter_CS()
        {
            desc = "Link to Laplacian_PyramidFilter that uses pyrUp and pyrDown extensively";
        }
        public void RunAlg(Mat src)
        {
            laplace.Run(src);
            dst2 = laplace.dst2;
        }
    }




    public class PyrFilter_Basics_CS : VB_Parent
    {
        Options_PyrFilter options = new Options_PyrFilter();
        public PyrFilter_Basics_CS()
        {
            desc = "Use PyrMeanShiftFiltering to segment an image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Cv2.PyrMeanShiftFiltering(src, dst2, options.spatialRadius, options.colorRadius, options.maxPyramid);
        }
    }




    public class PyrFilter_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Reduction_Basics reduction = new Reduction_Basics();
        PyrFilter_Basics pyr = new PyrFilter_Basics();
        public PyrFilter_RedCloud_CS()
        {
            labels = new string[] { "", "", "RedCloud_Basics output", "PyrFilter output before reduction" };
            desc = "Use RedColor to segment the output of PyrFilter";
        }
        public void RunAlg(Mat src)
        {
            pyr.Run(src);
            dst3 = pyr.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            reduction.Run(dst3);
            redC.Run(reduction.dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class Python_Basics_CS : VB_Parent
    {
        public bool StartPython(string arguments)
        {
            var pythonApp = new FileInfo(vbc.task.pythonTaskName);
            if (pythonApp.Exists)
            {
                vbc.task.pythonProcess = new Process();
                vbc.task.pythonProcess.StartInfo.FileName = "python";
                vbc.task.pythonProcess.StartInfo.WorkingDirectory = pythonApp.DirectoryName;
                if (string.IsNullOrEmpty(arguments))
                {
                    vbc.task.pythonProcess.StartInfo.Arguments = "\"" + pythonApp.Name + "\"";
                }
                else
                {
                    vbc.task.pythonProcess.StartInfo.Arguments = "\"" + pythonApp.Name + "\" " + arguments;
                }
                Debug.WriteLine("Starting Python with the following command:\n" + vbc.task.pythonProcess.StartInfo.Arguments + "\n");
                if (!vbc.task.showConsoleLog) vbc.task.pythonProcess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                try
                {
                    vbc.task.pythonProcess.Start();
                }
                catch (Exception ex)
                {
                    System.Windows.Forms.MessageBox.Show("The python algorithm " + pythonApp.Name +
                                                            " failed with " + ex.Message + ".  Is python in the path?");
                }
            }
            else
            {
                if (pythonApp.Name.EndsWith("Python_MemMap") || pythonApp.Name.EndsWith("Python_Run"))
                {
                    strOut = pythonApp.Name + " is a support algorithm for PyStream apps.";
                }
                else
                {
                    strOut = pythonApp.FullName + " is missing.";
                }
                return false;
            }
            return true;
        }
        public Python_Basics_CS()
        {
            desc = "Access Python from OpenCVB - contains the startPython interface";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("There is no output from " + traceName + ".  It contains the interface to python.");
        }
    }




    public class Python_Run_CS : VB_Parent
    {
        Python_Basics python = new Python_Basics();
        public Python_Stream pyStream;
        FileInfo pythonApp;
        bool testPyStreamOakD = false; // set this to true to test the PyStream problem with the OakD Python camera
        public void OakDPipeIssue()
        {
            SetTrueText("Python Stream ('_PS.py') algorithms don't work reliably when using the Oak-D Python camera interface.\n" +
                        "They both use named pipes to communicate between OpenCVB and the external processes (a camera and a Python algorithm.)\n" +
                        "To experiment with Python Stream algorithms, any of the other supported cameras work fine.\n" +
                        "To see the problem: comment out the camera test in RunVB below to test any '_PS.py' algorithm.  It may work but\n" +
                        "if you move the algorithm window (separate from OpenCVB), the algorithm will hang.  More importantly,\n" +
                        "several of the algorithms just hang without moving the window.  Any suggestions would be gratefully received.\n" +
                        "Using another camera is the best option to observe all the Python Stream algorithms.");
        }
        public Python_Run_CS()
        {
            pythonApp = new FileInfo(vbc.task.pythonTaskName);
            if (pythonApp.Name.EndsWith("_PS.py"))
            {
                if (testPyStreamOakD)
                {
                    pyStream = new Python_Stream();
                }
                else
                {
                    if (vbc.task.cameraName != "Oak-D camera") pyStream = new Python_Stream();
                }
            }
            else
            {
                python.StartPython("");
                if (!string.IsNullOrEmpty(python.strOut)) SetTrueText(python.strOut);
            }
            desc = "Run Python app: " + pythonApp.Name;
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.cameraName == "Oak-D camera" && pythonApp.Name.EndsWith("_PS.py") && !testPyStreamOakD)
            {
                OakDPipeIssue();
            }
            else
            {
                if (pyStream != null)
                {
                    pyStream.Run(src);
                    dst2 = pyStream.dst2;
                    dst3 = pyStream.dst3;
                    labels[2] = "Output of Python Backend";
                    labels[3] = "Second Output of Python Backend";
                }
                else
                {
                    if (pythonApp.Name == "PyStream.py")
                    {
                        SetTrueText("The PyStream.py algorithm is used by a wide variety of apps but has no output when run by itself.");
                    }
                }
            }
        }
    }




    public class Python_MemMap_CS : VB_Parent
    {
        Python_Basics python = new Python_Basics();
        MemoryMappedViewAccessor memMapWriter;
        MemoryMappedFile memMapFile;
        IntPtr memMapPtr;
        public double[] memMapValues = new double[50]; // more than we need - buffer for growth.  PyStream assumes 400 bytes length!  Do not change without changing everywhere.
        public int memMapbufferSize;
        public Python_MemMap_CS()
        {
            memMapbufferSize = Marshal.SizeOf(typeof(double)) * memMapValues.Length;
            memMapPtr = Marshal.AllocHGlobal(memMapbufferSize);
            memMapFile = MemoryMappedFile.CreateOrOpen("Python_MemMap_CS", memMapbufferSize);
            memMapWriter = memMapFile.CreateViewAccessor(0, memMapbufferSize);
            Marshal.Copy(memMapValues, 0, memMapPtr, memMapValues.Length);
            memMapWriter.WriteArray(0, memMapValues, 0, memMapValues.Length);
            if (standaloneTest())
            {
                if (!vbc.task.externalPythonInvocation)
                {
                    python.StartPython("--MemMapLength=" + memMapbufferSize.ToString());
                    if (!string.IsNullOrEmpty(python.strOut)) SetTrueText(python.strOut);
                }
                var pythonApp = new FileInfo(vbc.task.pythonTaskName);
                SetTrueText("No output for Python_MemMap_CS - see Python console log (see Options/'Show Console Log for external processes' in the main form)");
                desc = "Run Python app: " + pythonApp.Name + " to share memory with OpenCVB and Python.";
            }
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText(traceName + " has no output when run standaloneTest().");
                return;
            }
            memMapValues[0] = vbc.task.frameCount;
            Marshal.Copy(memMapValues, 0, memMapPtr, memMapValues.Length);
            memMapWriter.WriteArray(0, memMapValues, 0, memMapValues.Length);
        }
    }




    public class Python_Stream_CS : VB_Parent
    {
        Python_Basics python = new Python_Basics();
        byte[] rgbBuffer = new byte[2];
        byte[] depthBuffer = new byte[2];
        byte[] dst1Buffer = new byte[2];
        byte[] dst2Buffer = new byte[2];
        Python_MemMap memMap;
        public Python_Stream_CS()
        {
            vbc.task.pipeName = "PyStream2Way";
            try
            {
                vbc.task.pythonPipeOut = new NamedPipeServerStream(vbc.task.pipeName, PipeDirection.Out);
            }
            catch (Exception ex)
            {
                SetTrueText("Python_Stream_CS: pipeOut NamedPipeServerStream failed to open.  Error: " + ex.Message);
                return;
            }
            vbc.task.pythonPipeIn = new NamedPipeServerStream(vbc.task.pipeName + "Results", PipeDirection.In);
            // Was this class invoked standaloneTest()?  Then just run something that works with BGR and depth...
            if (vbc.task.pythonTaskName.EndsWith("Python_Stream_CS"))
            {
                vbc.task.pythonTaskName = vbc.task.HomeDir + "Python/Python_Stream_CS_PS.py";
            }
            memMap = new Python_MemMap();
            if (vbc.task.externalPythonInvocation)
            {
                vbc.task.pythonReady = true; // python was already running and invoked OpenCVB.
            }
            else
            {
                vbc.task.pythonReady = python.StartPython("--MemMapLength=" + memMap.memMapbufferSize + " --pipeName=" + vbc.task.pipeName);
                if (!string.IsNullOrEmpty(python.strOut)) SetTrueText(python.strOut);
            }
            if (vbc.task.pythonReady)
            {
                vbc.task.pythonPipeOut.WaitForConnection();
                vbc.task.pythonPipeIn.WaitForConnection();
            }
            labels[2] = "Output of Python Backend";
            desc = "General purpose class to pipe BGR and Depth to Python scripts.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText(traceName + " has no output when run standaloneTest().");
                return;
            }
            if (vbc.task.pythonReady && vbc.task.pcSplit[2].Width > 0)
            {
                Mat depth32f = vbc.task.pcSplit[2] * 1000;
                double[] vals = new double[] {vbc.task.frameCount, src.Total() * src.ElemSize(),
                                            (double)(depth32f.Total() * depth32f.ElemSize()), src.Rows, src.Cols,
                                            vbc.task.drawRect.X, vbc.task.drawRect.Y, vbc.task.drawRect.Width,
                                            vbc.task.drawRect.Height};
                for (int i = 0; i < memMap.memMapValues.Length; i++)
                {
                    memMap.memMapValues[i] = vals[i];
                }
                memMap.Run(src);
                if (rgbBuffer.Length != src.Total() * src.ElemSize()) Array.Resize(ref rgbBuffer, (int)(src.Total() * src.ElemSize()));
                if (depthBuffer.Length != depth32f.Total() * depth32f.ElemSize()) Array.Resize(ref depthBuffer, (int)(depth32f.Total() * depth32f.ElemSize()));
                if (dst1Buffer.Length != dst2.Total() * dst2.ElemSize()) Array.Resize(ref dst1Buffer, (int)(dst2.Total() * dst2.ElemSize()));
                if (dst2Buffer.Length != dst3.Total() * dst3.ElemSize()) Array.Resize(ref dst2Buffer, (int)(dst3.Total() * dst3.ElemSize()));
                Marshal.Copy(src.Data, rgbBuffer, 0, (int)(src.Total() * src.ElemSize()));
                Marshal.Copy(depth32f.Data, depthBuffer, 0, depthBuffer.Length);
                if (vbc.task.pythonPipeOut.IsConnected)
                {
                    try
                    {
                        vbc.task.pythonPipeOut.Write(rgbBuffer, 0, rgbBuffer.Length);
                        vbc.task.pythonPipeOut.Write(depthBuffer, 0, depthBuffer.Length);
                        vbc.task.pythonPipeIn.Read(dst1Buffer, 0, dst1Buffer.Length);
                        vbc.task.pythonPipeIn.Read(dst2Buffer, 0, dst2Buffer.Length);
                        Marshal.Copy(dst1Buffer, 0, dst2.Data, dst1Buffer.Length);
                        Marshal.Copy(dst2Buffer, 0, dst3.Data, dst2Buffer.Length);
                    }
                    catch { }
                }
            }
        }
        public void Close()
        {
            if (vbc.task.pythonPipeOut != null) vbc.task.pythonPipeOut.Close();
            if (vbc.task.pythonPipeIn != null) vbc.task.pythonPipeIn.Close();
        }
    }




    public class QRcode_Basics_CS : VB_Parent
    {
        QRCodeDetector qrDecoder = new QRCodeDetector();
        Mat qrInput1 = new Mat();
        Mat qrInput2 = new Mat();
        public QRcode_Basics_CS()
        {
            var fileInfo = new FileInfo(vbc.task.HomeDir + "data/QRcode1.png");
            if (fileInfo.Exists) qrInput1 = Cv2.ImRead(fileInfo.FullName);
            fileInfo = new FileInfo(vbc.task.HomeDir + "Data/QRCode2.png");
            if (fileInfo.Exists) qrInput2 = Cv2.ImRead(fileInfo.FullName);
            if (dst2.Width < 480) // for the smallest configurations the default size can be too big!
            {
                qrInput1 = qrInput1.Resize(new cv.Size(120, 160));
                qrInput2 = qrInput2.Resize(new cv.Size(120, 160));
            }
            desc = "Read a QR code";
        }
        public void RunAlg(Mat src)
        {
            if (src.Height < 240)
            {
                SetTrueText("This QR Code test does not run at low resolutions");
                return;
            }
            var x = msRNG.Next(0, src.Width - Math.Max(qrInput1.Width, qrInput2.Width));
            var y = msRNG.Next(0, src.Height - Math.Max(qrInput1.Height, qrInput2.Height));
            if ((vbc.task.frameCount / 50) % 2 == 0)
            {
                var roi = new cv.Rect(x, y, qrInput1.Width, qrInput1.Height);
                src[roi] = qrInput1;
            }
            else
            {
                var roi = new cv.Rect(x, y, qrInput2.Width, qrInput2.Height);
                src[roi] = qrInput2;
            }
            Point2f[] box;
            var rectifiedImage = new Mat();
            var refersTo = qrDecoder.DetectAndDecode(src, out box, rectifiedImage);
            src.CopyTo(dst2);
            for (int i = 0; i < box.Length; i++)
            {
                DrawLine(dst2, box[i], box[(i + 1) % 4], Scalar.Red, vbc.task.lineWidth + 2);
            }
            if (!string.IsNullOrEmpty(refersTo)) labels[2] = refersTo;
        }
    }




    public class Quadrant_Basics_CS : VB_Parent
    {
        cv.Point p1 = new cv.Point();
        cv.Point p2;
        cv.Point p3;
        cv.Point p4;
        cv.Rect rect = new cv.Rect();
        Mat mask = new Mat();
        public Quadrant_Basics_CS()
        {
            p2 = new cv.Point(dst2.Width - 1, 0);
            p3 = new cv.Point(0, dst2.Height - 1);
            p4 = new cv.Point(dst2.Width - 1, dst2.Height - 1);
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[2] = "dst1 contains a map defining the quadrant value for each pixel";
            desc = "Divide the color and depth images into 4 quadrants based on the horizon and gravity vectors";
        }
        public void RunAlg(Mat src)
        {
            dst1.SetTo(0);
            DrawLine(dst1, vbc.task.gravityVec.p1, vbc.task.gravityVec.p2, cv.Scalar.All(255), 1);
            DrawLine(dst1, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, cv.Scalar.All(255), 1);
            var flags = FloodFillFlags.FixedRange | (FloodFillFlags)(255 << 8);
            if (dst1.At<byte>(p1.Y, p1.X) == 0) 
                Cv2.FloodFill(dst1, new Mat(), p1, cv.Scalar.All(1 * 255 / 4), out rect, cv.Scalar.All(0), cv.Scalar.All(0), flags);
            if (dst1.At<byte>(p2.Y, p2.X) == 0) 
                Cv2.FloodFill(dst1, new Mat(), p2, cv.Scalar.All(2 * 255 / 4), out rect, cv.Scalar.All(0), cv.Scalar.All(0), flags);
            if (dst1.At<byte>(p3.Y, p3.X) == 0) 
                Cv2.FloodFill(dst1, new Mat(), p3, cv.Scalar.All(3 * 255 / 4), out rect, cv.Scalar.All(0), cv.Scalar.All(0), flags);
            if (dst1.At<byte>(p4.Y, p4.X) == 0) 
                Cv2.FloodFill(dst1, new Mat(), p4, cv.Scalar.All(4 * 255 / 4), out rect, cv.Scalar.All(0), cv.Scalar.All(0), flags);
            dst2 = ShowPalette(dst1);
        }
    }




    public class Quaterion_Basics_CS : VB_Parent
    {
        Options_Quaternion options = new Options_Quaternion();
        public Quaterion_Basics_CS()
        {
            desc = "Use the quaternion values to multiply and compute conjugate";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            var quatmul = Quaternion.Multiply(options.q1, options.q2);
            SetTrueText("q1 = " + options.q1.ToString() + "\n" + "q2 = " + options.q2.ToString() + "\n" +
                        "Multiply q1 * q2" + quatmul.ToString());
        }
    }




    public class Quaterion_IMUPrediction_CS : VB_Parent
    {
        IMU_PlotHostFrameTimes host = new IMU_PlotHostFrameTimes();
        public Quaterion_IMUPrediction_CS()
        {
            labels[2] = "Quaternion_IMUPrediction";
            labels[3] = "";
            desc = "IMU data arrives at the CPU after a delay.  Predict changes to the image based on delay and motion data.";
        }
        public Quaternion quaternion_exp(Point3f v)
        {
            v *= 0.5f;
            var theta2 = v.X * v.X + v.Y * v.Y + v.Z * v.Z;
            var theta = Math.Sqrt(theta2);
            var c = Math.Cos(theta);
            var s = (theta2 < Math.Sqrt(120 * Single.Epsilon)) ? 1 - theta2 / 6 : Math.Sin(theta) / theta2;
            return new Quaternion((float)(s * v.X), (float)(s * v.Y), (float)(s * v.Z), (float)c);
        }
        public void RunAlg(Mat src)
        {
            host.Run(src);
            var dt = host.HostInterruptDelayEstimate;
            var t = vbc.task.IMU_Translation;
            var predictedTranslation = new Point3f(
                (float)(dt * (dt / 2 * vbc.task.IMU_Acceleration.X + vbc.task.IMU_AngularVelocity.X) + t.X),
                (float)(dt * (dt / 2 * vbc.task.IMU_Acceleration.Y + vbc.task.IMU_AngularVelocity.Y) + t.Y),
                (float)(dt * (dt / 2 * vbc.task.IMU_Acceleration.Z + vbc.task.IMU_AngularVelocity.Z) + t.Z));
            var predictedW = new Point3f(
                (float)(dt * (dt / 2 * vbc.task.IMU_AngularAcceleration.X + vbc.task.IMU_AngularVelocity.X)),
                (float)(dt * (dt / 2 * vbc.task.IMU_AngularAcceleration.Y + vbc.task.IMU_AngularVelocity.Y)),
                (float)(dt * (dt / 2 * vbc.task.IMU_AngularAcceleration.Z + vbc.task.IMU_AngularVelocity.Z)));
            Quaternion predictedRotation = Quaternion.Multiply(quaternion_exp(predictedW), vbc.task.IMU_Rotation);
            var diffq = Quaternion.Subtract(vbc.task.IMU_Rotation, predictedRotation);
            SetTrueText("IMU_Acceleration = " + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_Acceleration.X) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_Acceleration.Y) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_Acceleration.Z) + "\t" + "\n" +
                            "IMU_AngularAccel. = " + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_AngularAcceleration.X) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_AngularAcceleration.Y) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_AngularAcceleration.Z) + "\t" + "\n" +
                            "IMU_AngularVelocity = " + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_AngularVelocity.X) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_AngularVelocity.Y) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_AngularVelocity.Z) + "\t" + "\n" + "\n" +
                            "dt = " + dt.ToString() + "\n" + "\n" +
                            "Pose quaternion = " + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_Rotation.X) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_Rotation.Y) + "\t" +
                            string.Format("{0:F3}", vbc.task.IMU_Rotation.Z) + "\t" + "\n" +
                            "Prediction Rotation = " + "\t" +
                            string.Format("{0:F3}", predictedRotation.X) + "\t" +
                            string.Format("{0:F3}", predictedRotation.Y) + "\t" +
                            string.Format("{0:F3}", predictedRotation.Z) + "\t" + "\n" +
                            "difference = " + "\t" + "\t" +
                            string.Format("{0:F3}", diffq.X) + "\t" +
                            string.Format("{0:F3}", diffq.Y) + "\t" +
                            string.Format("{0:F3}", diffq.Z) + "\t");
        }
    }




    public class Random_Basics_CS : VB_Parent
    {
        public List<cv.Point2f> PointList = new List<cv.Point2f>();
        public List<cv.Point2d> PointList2d = new List<cv.Point2d>();
        public cv.Rect range;
        public Options_Random options = new Options_Random();

        public Random_Basics_CS()
        {
            range = new cv.Rect(0, 0, dst2.Cols, dst2.Rows);
            desc = "Create a uniform random mask with a specified number of pixels.";
        }

        public void RunAlg(Mat src)
        {
            options.RunOpt();

            int sizeRequest = options.count;
            if (!vbc.task.paused)
            {
                PointList.Clear();
                Random msRNG = new Random();
                while (PointList.Count < sizeRequest)
                {
                    PointList.Add(new cv.Point2f(msRNG.Next(range.X, range.X + range.Width),
                                                 msRNG.Next(range.Y, range.Y + range.Height)));
                    PointList2d.Add(new cv.Point2d(msRNG.Next(range.X, range.X + range.Width),
                                                   msRNG.Next(range.Y, range.Y + range.Height)));
                }
                if (standaloneTest())
                {
                    dst2.SetTo(0);
                    foreach (var pt in PointList)
                    {
                        DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Yellow);
                    }
                }
            }
        }
    }




    public class Random_Point2d_CS : VB_Parent
    {
        public List<cv.Point2d> PointList { get; } = new List<cv.Point2d>();
        public cv.Rect range;
        Options_Random options = new Options_Random();
        public Random_Point2d_CS()
        {
            range = new cv.Rect(0, 0, dst2.Cols, dst2.Rows);
            desc = "Create a uniform random mask with a specificied number of pixels.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            PointList.Clear();
            if (!vbc.task.paused)
            {
                for (int i = 0; i < options.count; i++)
                {
                    PointList.Add(new Point2d(msRNG.Next(range.X, range.X + range.Width), msRNG.Next(range.Y, range.Y + range.Height)));
                }
                if (standaloneTest())
                {
                    dst2.SetTo(0);
                    foreach (var pt in PointList)
                    {
                        DrawCircle(dst2, new cv.Point2f((float)pt.X, (float)pt.Y), vbc.task.DotSize, Scalar.Yellow, -1);
                    }
                }
            }
        }
    }




    public class Random_Enumerable_CS : VB_Parent
    {
        public Options_Random options = new Options_Random();
        public Point2f[] points;
        public Random_Enumerable_CS()
        {
            FindSlider("Random Pixel Count").Value = 100;
            desc = "Create an enumerable list of points using a lambda function";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            points = Enumerable.Range(0, options.count).Select(i =>
                new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height))).ToArray();
            dst2.SetTo(0);
            foreach (var pt in points)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Yellow);
            }
        }
    }




    public class Random_Basics3D_CS : VB_Parent
    {
        public Point3f[] Points3f;
        Options_Random options = new Options_Random();
        public List<cv.Point3f> PointList { get; } = new List<cv.Point3f>();
        public float[] ranges;
        public Random_Basics3D_CS()
        {
            ranges = new float[] { 0, dst2.Width, 0, dst2.Height, 0, vbc.task.MaxZmeters, 0, vbc.task.MaxZmeters };
            FindSlider("Random Pixel Count").Value = 20;
            FindSlider("Random Pixel Count").Maximum = dst2.Cols * dst2.Rows;
            desc = "Create a uniform random mask with a specificied number of pixels.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            PointList.Clear();
            if (!vbc.task.paused)
            {
                for (int i = 0; i < options.count; i++)
                {
                    PointList.Add(new Point3f(msRNG.Next((int)ranges[0], (int)ranges[1]),
                                                            msRNG.Next((int)ranges[2], (int)ranges[3]),
                                                            msRNG.Next((int)ranges[4], (int)ranges[5])));
                }
                if (standaloneTest())
                {
                    dst2.SetTo(0);
                    foreach (var pt in PointList)
                    {
                        DrawCircle(dst2, new Point2f(pt.X, pt.Y), vbc.task.DotSize, Scalar.Yellow);
                    }
                }
                Points3f = PointList.ToArray();
            }
        }
    }




    public class Random_Basics4D_CS : VB_Parent
    {
        public Vec4f[] vec4f;
        public List<Vec4f> PointList { get; } = new List<Vec4f>();
        public float[] ranges;
        Options_Random options = new Options_Random();
        System.Windows.Forms.TrackBar countSlider;
        public Random_Basics4D_CS()
        {
            ranges = new float[] { 0, dst2.Width, 0, dst2.Height, 0, vbc.task.MaxZmeters, 0, vbc.task.MaxZmeters };
            desc = "Create a uniform random mask with a specificied number of pixels.";
            countSlider = FindSlider("Random Pixel Count");
        }
        public void RunAlg(Mat src)
        {
            PointList.Clear();
            var count = countSlider.Value;
            if (!vbc.task.paused)
            {
                for (int i = 0; i < count; i++)
                {
                    PointList.Add(new Vec4f(msRNG.Next((int)ranges[0], (int)ranges[1]),
                                                    msRNG.Next((int)ranges[2], (int)ranges[3]),
                                                    msRNG.Next((int)ranges[4], (int)ranges[5]),
                                                    msRNG.Next((int)ranges[6], (int)ranges[7])));
                }
                if (standaloneTest())
                {
                    dst2.SetTo(0);
                    foreach (var v in PointList)
                    {
                        DrawCircle(dst2, new Point2f(v[0], v[1]), vbc.task.DotSize, Scalar.Yellow);
                    }
                }
                vec4f = PointList.ToArray();
            }
        }
    }




    public class Random_Shuffle_CS : VB_Parent
    {
        RNG myRNG = new RNG();
        public Random_Shuffle_CS()
        {
            desc = "Use randomShuffle to reorder an image.";
        }
        public void RunAlg(Mat src)
        {
            src.CopyTo(dst2);
            Cv2.RandShuffle(dst2, 1.0, ref myRNG); // don't remove that myRNG!  It will fail in RandShuffle.
            labels[2] = "Random_shuffle - wave at camera";
        }
    }




    public class Random_LUTMask_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();
        KMeans_Image km = new KMeans_Image();
        Mat lutMat;
        public Random_LUTMask_CS()
        {
            desc = "Use a random Look-Up-Table to modify few colors in a kmeans image.";
            labels[3] = "kmeans run to get colors";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat || vbc.task.frameCount < 10)
            {
                random.Run(empty);
                lutMat = new Mat(new cv.Size(1, 256), MatType.CV_8UC3, cv.Scalar.All(0));
                int lutIndex = 0;
                km.Run(src);
                dst2 = km.dst2;
                foreach (var pt in random.PointList)
                {
                    lutMat.Set(lutIndex, 0, dst2.Get<Vec3b>((int)pt.Y, (int)pt.X));
                    lutIndex++;
                    if (lutIndex >= lutMat.Rows) break;
                }
            }
            dst3 = src.LUT(lutMat);
            labels[2] = "Using kmeans colors with interpolation";
        }
    }




    public class Random_UniformDist_CS : VB_Parent
    {
        double minVal = 0, maxVal = 255;
        public Random_UniformDist_CS()
        {
            desc = "Create a uniform distribution.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            Cv2.Randu(dst2, minVal, maxVal);
        }
    }




    public class Random_NormalDist_CS : VB_Parent
    {
        Options_NormalDist options = new Options_NormalDist();
        public Random_NormalDist_CS()
        {
            desc = "Create a normal distribution in all 3 colors with a variable standard deviation.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.grayChecked && dst2.Channels() != 1) dst2 = new Mat(dst2.Size(), MatType.CV_8U);
            Cv2.Randn(dst2, new Scalar(options.blueVal, options.greenVal, options.redVal), Scalar.All(options.stdev));
        }
    }




    public class Random_CheckUniformSmoothed_CS : VB_Parent
    {
        Hist_Basics histogram = new Hist_Basics();
        Random_UniformDist rUniform = new Random_UniformDist();
        public Random_CheckUniformSmoothed_CS()
        {
            desc = "Display the smoothed histogram for a uniform distribution.";
        }
        public void RunAlg(Mat src)
        {
            rUniform.Run(src);
            dst2 = rUniform.dst2;
            histogram.plot.maxRange = 255;
            histogram.Run(dst2);
            dst3 = histogram.dst2;
        }
    }




    public class Random_CheckUniformDist_CS : VB_Parent
    {
        Hist_Graph histogram = new Hist_Graph();
        Random_UniformDist rUniform = new Random_UniformDist();
        public Random_CheckUniformDist_CS()
        {
            desc = "Display the histogram for a uniform distribution.";
        }
        public void RunAlg(Mat src)
        {
            rUniform.Run(src);
            dst2 = rUniform.dst2;
            histogram.plotRequested = true;
            histogram.Run(dst2);
            dst3 = histogram.dst2;
        }
    }




    public class Random_CheckNormalDist_CS : VB_Parent
    {
        Hist_Graph histogram = new Hist_Graph();
        Random_NormalDist normalDist = new Random_NormalDist();
        public Random_CheckNormalDist_CS()
        {
            desc = "Display the histogram for a Normal distribution.";
        }
        public void RunAlg(Mat src)
        {
            normalDist.Run(src);
            dst3 = normalDist.dst2;
            histogram.plotRequested = true;
            histogram.Run(dst3);
            dst2 = histogram.dst2;
        }
    }




    public class Random_CheckNormalDistSmoothed_CS : VB_Parent
    {
        Hist_Basics histogram = new Hist_Basics();
        Random_NormalDist normalDist = new Random_NormalDist();
        public Random_CheckNormalDistSmoothed_CS()
        {
            histogram.plot.minRange = 1;
            desc = "Display the histogram for a Normal distribution.";
        }
        public void RunAlg(Mat src)
        {
            normalDist.Run(src);
            dst3 = normalDist.dst2;
            histogram.Run(dst3);
            dst2 = histogram.dst2;
        }
    }




    public class Random_PatternGenerator_CS : VB_Parent
    {
        public Random_PatternGenerator_CS()
        {
            cPtr = Random_PatternGenerator_Open();
            desc = "Generate random patterns for use with 'Random Pattern Calibration'";
        }
        public void RunAlg(Mat src)
        {
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            IntPtr imagePtr = Random_PatternGenerator_Run(cPtr, src.Rows, src.Cols);
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Random_PatternGenerator_Close(cPtr);
        }
    }




    public class Random_CustomDistribution_CS : VB_Parent
    {
        public Mat inputCDF; // place a cumulative distribution function here (or just put the histogram that reflects the desired random number distribution)
        public Mat outputRandom = new Mat(10000, 1, MatType.CV_32S, cv.Scalar.All(0)); // allocate the desired number of random numbers - size can be just one to get the next random value
        public Mat outputHistogram;
        public Plot_Histogram plot = new Plot_Histogram();
        public Random_CustomDistribution_CS()
        {
            float[] loadedDice = { 1, 3, 0.5f, 0.5f, 0.75f, 0.25f };
            inputCDF = cv.Mat.FromPixelData(loadedDice.Length, 1, MatType.CV_32F, loadedDice);
            desc = "Create a custom random number distribution from any histogram";
        }
        public void RunAlg(Mat src)
        {
            float lastValue = inputCDF.At<float>(inputCDF.Rows - 1, 0);
            if (!(lastValue > 0.99 && lastValue <= 1.0)) // convert the input histogram to a cdf.
            {
                inputCDF *= 1 / (inputCDF.Sum()[0]);
                for (int i = 1; i < inputCDF.Rows; i++)
                {
                    inputCDF.Set<float>(i, 0, inputCDF.At<float>(i - 1, 0) + inputCDF.At<float>(i, 0));
                }
            }
            outputHistogram = new Mat(inputCDF.Size(), MatType.CV_32F, cv.Scalar.All(0));
            int size = outputHistogram.Rows;
            for (int i = 0; i < outputRandom.Rows; i++)
            {
                double uniformR1 = msRNG.NextDouble();
                for (int j = 0; j < size; j++)
                {
                    if (uniformR1 < inputCDF.At<float>(j, 0))
                    {
                        outputHistogram.Set<float>(j, 0, outputHistogram.At<float>(j, 0) + 1);
                        outputRandom.Set<int>(i, 0, j); // the output is an integer reflecting a bin in the histogram.
                        break;
                    }
                }
            }
            plot.Run(outputHistogram);
            dst2 = plot.dst2;
        }
    }




    public class Random_MonteCarlo_CS : VB_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        Options_MonteCarlo options = new Options_MonteCarlo();
        public Mat outputRandom = new Mat(new cv.Size(1, 4000), MatType.CV_32S, cv.Scalar.All(0)); // allocate the desired number of random numbers - size can be just one to get the next random value
        public Random_MonteCarlo_CS()
        {
            plot.maxRange = 100;
            desc = "Generate random numbers but prefer higher values - a linearly increasing random distribution";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat histogram = new Mat(options.dimension, 1, MatType.CV_32F, cv.Scalar.All(0));
            for (int i = 0; i < outputRandom.Rows; i++)
            {
                while (true)
                {
                    double r1 = msRNG.NextDouble();
                    double r2 = msRNG.NextDouble();
                    if (r2 < r1)
                    {
                        int index = (int)(options.dimension * r1);
                        histogram.Set<float>(index, 0, histogram.At<float>(index, 0) + 1);
                        outputRandom.Set<int>(i, 0, index);
                        break;
                    }
                }
            }
            if (standaloneTest())
            {
                plot.Run(histogram);
                dst2 = plot.dst2;
            }
        }
    }





    public class Random_StaticTV_CS : VB_Parent
    {
        Options_StaticTV options = new Options_StaticTV();
        public Random_StaticTV_CS()
        {
            vbc.task.drawRect = new cv.Rect(10, 10, 50, 50);
            labels[2] = "Draw anywhere to select a test region";
            labels[3] = "Resized selection rectangle in dst2";
            desc = "Imitate an old TV appearance using randomness.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = dst2[vbc.task.drawRect];
            for (int y = 0; y < dst3.Height; y++)
            {
                for (int x = 0; x < dst3.Width; x++)
                {
                    if (255 * msRNG.NextDouble() <= options.threshPercent)
                    {
                        byte v = dst3.At<byte>(y, x);
                        dst3.Set<byte>(y, x, (byte)(msRNG.NextDouble() * 2 == 0 ? Math.Min(v +
                                (options.rangeVal + 1) * msRNG.NextDouble(), 255) : Math.Max(v - (options.rangeVal + 1) * msRNG.NextDouble(), 0)));
                    }
                }
            }
        }
    }




    public class Random_StaticTVFaster_CS : VB_Parent
    {
        Random_UniformDist random = new Random_UniformDist();
        Mat_4to1 mats = new Mat_4to1();
        Random_StaticTV options = new Random_StaticTV();
        TrackBar valSlider;
        TrackBar percentSlider;
        public Random_StaticTVFaster_CS()
        {
            valSlider = FindSlider("Range of noise to apply (from 0 to this value)");
            percentSlider = FindSlider("Percentage of pixels to include noise");
            labels[3] = "Changed pixels, add/sub mask, plusMask, minusMask";
            desc = "A faster way to apply noise to imitate an old TV appearance using randomness and thresholding.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            random.Run(src);
            mats.mat[0] = random.dst2.Threshold(255 - percentSlider.Value * 255 / 100, 255, ThresholdTypes.Binary);
            Mat nochangeMask = random.dst2.Threshold(255 - percentSlider.Value * 255 / 100, 255, ThresholdTypes.BinaryInv);
            Mat valMat = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            Cv2.Randu(valMat, 0, valSlider.Value);
            valMat.SetTo(0, nochangeMask);
            random.Run(src);
            Mat plusMask = random.dst2.Threshold(128, 255, ThresholdTypes.Binary);
            Mat minusMask = random.dst2.Threshold(128, 255, ThresholdTypes.BinaryInv);
            mats.mat[2] = plusMask;
            mats.mat[3] = minusMask;
            mats.mat[1] = (plusMask + minusMask).ToMat().SetTo(0, nochangeMask);
            Cv2.Add(dst2, valMat, dst2, plusMask);
            Cv2.Subtract(dst2, valMat, dst2, minusMask);
            mats.Run(empty);
            dst3 = mats.dst2;
        }
    }




    public class Random_StaticTVFastSimple_CS : VB_Parent
    {
        Random_UniformDist random = new Random_UniformDist();
        Random_StaticTV options = new Random_StaticTV();
        TrackBar valSlider;
        TrackBar percentSlider;
        public Random_StaticTVFastSimple_CS()
        {
            valSlider = FindSlider("Range of noise to apply (from 0 to this value)");
            percentSlider = FindSlider("Percentage of pixels to include noise");
            desc = "Remove diagnostics from the faster algorithm to simplify code.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            random.Run(src);
            var nochangeMask = random.dst2.Threshold(255 - percentSlider.Value * 255 / 100, 255, ThresholdTypes.BinaryInv);
            dst3 = new Mat(dst2.Size(), MatType.CV_8U);
            Cv2.Randu(dst3, 0, valSlider.Value);
            dst3.SetTo(0, nochangeMask);
            var tmp = new Mat(dst2.Size(), MatType.CV_8U);
            Cv2.Randu(tmp, 0, 255);
            var plusMask = tmp.Threshold(128, 255, ThresholdTypes.Binary);
            var minusMask = tmp.Threshold(128, 255, ThresholdTypes.BinaryInv);
            Cv2.Add(dst2, dst3, dst2, plusMask);
            Cv2.Subtract(dst2, dst3, dst2, minusMask);
            labels[3] = "Mat of random values < " + valSlider.Value.ToString();
        }
    }




    public class Random_KalmanPoints_CS : VB_Parent
    {
        Random_Basics random = new Random_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        List<cv.Point2f> targetSet = new List<cv.Point2f>();
        List<cv.Point2f> currSet = new List<cv.Point2f>();
        bool refreshPoints = true;
        public Random_KalmanPoints_CS()
        {
            var offset = dst2.Width / 5;
            random.range = new cv.Rect(offset, offset, Math.Abs(dst2.Width - offset * 2), Math.Abs(dst2.Height - offset * 2));
            FindSlider("Random Pixel Count").Value = 10;
            desc = "Smoothly transition a random point from location to location.";
        }
        public void RunAlg(Mat src)
        {
            if (refreshPoints)
            {
                random.Run(empty);
                targetSet = new List<cv.Point2f>(random.PointList);
                currSet = new List<cv.Point2f>(random.PointList); // just to get the updated size
                refreshPoints = false;
                if (targetSet.Count() * 2 != kalman.kInput.Length)
                    Array.Resize(ref kalman.kInput, targetSet.Count() * 2);
            }
            for (int i = 0; i < targetSet.Count(); i++)
            {
                var pt = targetSet[i];
                kalman.kInput[i * 2] = pt.X;
                kalman.kInput[i * 2 + 1] = pt.Y;
            }
            kalman.Run(src);
            for (int i = 0; i < kalman.kOutput.Count(); i += 2)
            {
                currSet[i / 2] = new cv.Point(kalman.kOutput[i], kalman.kOutput[i + 1]);
            }
            dst2.SetTo(0);
            for (int i = 0; i < currSet.Count(); i++)
            {
                DrawCircle(dst2, currSet[i], vbc.task.DotSize + 2, Scalar.Yellow);
                DrawCircle(dst2, targetSet[i], vbc.task.DotSize + 2, Scalar.Red);
            }
            bool noChanges = true;
            for (int i = 0; i < currSet.Count(); i++)
            {
                var pt = currSet[i];
                if (Math.Abs(targetSet[i].X - pt.X) > 1 && Math.Abs(targetSet[i].Y - pt.Y) > 1)
                    noChanges = false;
            }
            if (noChanges) refreshPoints = true;
        }
    }




    public class Random_Clusters_CS : VB_Parent
    {
        public List<List<int>> clusterLabels = new List<List<int>>();
        public List<List<cv.Point2f>> clusters = new List<List<cv.Point2f>>();
        Options_Clusters options = new Options_Clusters();
        public Random_Clusters_CS()
        {
            vbc.task.scalarColors[0] = Scalar.Yellow;
            vbc.task.scalarColors[1] = Scalar.Blue;
            vbc.task.scalarColors[2] = Scalar.Red;
            labels = new string[] { "", "", "Colorized sets", "" };
            desc = "Use OpenCV's randN API to create a cluster around a random mean with a requested stdev";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            options.RunOpt();
            var ptMat = new Mat(1, 1, MatType.CV_32FC2);
            dst2.SetTo(0);
            clusters.Clear();
            clusterLabels.Clear();
            for (int i = 0; i < options.numClusters; i++)
            {
                var mean = new Scalar(msRNG.Next(dst2.Width / 8, dst2.Width * 7 / 8), msRNG.Next(dst2.Height / 8, dst2.Height * 7 / 8), 0);
                var cList = new List<cv.Point2f>();
                var labelList = new List<int>();
                for (int j = 0; j < options.numPoints; j++)
                {
                    Cv2.Randn(ptMat, mean, Scalar.All(options.stdev));
                    var pt = ptMat.Get<cv.Point2f>(0, 0);
                    if (pt.X < 0) pt.X = 0;
                    if (pt.X >= dst2.Width) pt.X = dst2.Width - 1;
                    if (pt.Y < 0) pt.Y = 0;
                    if (pt.Y >= dst2.Height) pt.Y = dst2.Height - 1;
                    DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.scalarColors[i % 256]);
                    cList.Add(pt);
                    labelList.Add(i);
                }
                clusterLabels.Add(labelList);
                clusters.Add(cList);
            }
        }
    }




    public class Rectangle_Basics_CS : VB_Parent
    {
        public List<cv.Rect> rectangles = new List<cv.Rect>();
        public List<RotatedRect> rotatedRectangles = new List<RotatedRect>();
        public Options_Draw options = new Options_Draw();
        public Rectangle_Basics_CS()
        {
            desc = "Draw the requested number of rectangles.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                rectangles.Clear();
                rotatedRectangles.Clear();
                for (int i = 0; i < options.drawCount; i++)
                {
                    var nPoint = new Point2f(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height));
                    var width = msRNG.Next(0, src.Cols - (int)nPoint.X - 1);
                    var height = msRNG.Next(0, src.Rows - (int)nPoint.Y - 1);
                    var eSize = new Size2f((float)msRNG.Next(0, src.Cols - (int)nPoint.X - 1), (float)msRNG.Next(0, src.Rows - (int)nPoint.Y - 1));
                    var angle = 180.0f * (float)(msRNG.Next(0, 1000) / 1000.0);
                    var nextColor = new Scalar(vbc.task.vecColors[i][0], vbc.task.vecColors[i][1], vbc.task.vecColors[i][2]);
                    var rr = new RotatedRect(nPoint, eSize, angle);
                    var r = new cv.Rect((int)nPoint.X, (int)nPoint.Y, width, height);
                    if (options.drawRotated)
                    {
                        DrawRotatedRect(rr, dst2, nextColor);
                    }
                    else
                    {
                        Cv2.Rectangle(dst2, r, nextColor, options.drawFilled);
                    }
                    rotatedRectangles.Add(rr);
                    rectangles.Add(r);
                }
            }
        }
    }




    public class Rectangle_Rotated_CS : VB_Parent
    {
        public Rectangle_Basics rectangle = new Rectangle_Basics();
        public Rectangle_Rotated_CS()
        {
            FindCheckBox("Draw Rotated Rectangles - unchecked will draw ordinary rectangles (unrotated)").Checked = true;
            desc = "Draw the requested number of rectangles.";
        }
        public void RunAlg(Mat src)
        {
            rectangle.Run(src);
            dst2 = rectangle.dst2;
        }
    }




    public class Rectangle_Overlap_CS : VB_Parent
    {
        public cv.Rect rect1;
        public cv.Rect rect2;
        public cv.Rect enclosingRect;
        Rectangle_Basics draw = new Rectangle_Basics();
        public Rectangle_Overlap_CS()
        {
            FindSlider("DrawCount").Value = 2;
            desc = "Test if 2 rectangles overlap";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            if (standaloneTest())
            {
                draw.Run(src);
                dst2 = draw.dst2;
            }
            dst3.SetTo(0);
            if (draw.options.drawRotated)
            {
                var r1 = draw.rotatedRectangles[0];
                var r2 = draw.rotatedRectangles[1];
                rect1 = r1.BoundingRect();
                rect2 = r2.BoundingRect();
                DrawRotatedOutline(r1, dst3, Scalar.Yellow);
                DrawRotatedOutline(r2, dst3, Scalar.Yellow);
            }
            else
            {
                rect1 = draw.rectangles[0];
                rect2 = draw.rectangles[1];
            }
            enclosingRect = new cv.Rect();
            if (rect1.IntersectsWith(rect2))
            {
                enclosingRect = rect1.Union(rect2);
                dst3.Rectangle(enclosingRect, Scalar.White, 4);
                labels[3] = "Rectangles intersect - red marks overlapping rectangle";
                dst3.Rectangle(rect1.Intersect(rect2), Scalar.Red, -1);
            }
            else
            {
                labels[3] = "Rectangles don't intersect";
            }
            dst3.Rectangle(rect1, Scalar.Yellow, 2);
            dst3.Rectangle(rect2, Scalar.Yellow, 2);
        }
    }





    public class Rectangle_Union_CS : VB_Parent
    {
        Rectangle_Basics draw = new Rectangle_Basics();
        public List<cv.Rect> inputRects = new List<cv.Rect>();
        public cv.Rect allRect; // a rectangle covering all the input
        public Rectangle_Union_CS()
        {
            desc = "Create a rectangle that contains all the input rectangles";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                var countSlider = FindSlider("DrawCount");
                var rotatedCheck = FindCheckBox("Draw Rotated Rectangles - unchecked will draw ordinary rectangles (unrotated)");
                rotatedCheck.Enabled = false;
                countSlider.Value = msRNG.Next(2, 10);
                labels[2] = "Input rectangles = " + draw.rectangles.Count();
                draw.Run(src);
                dst2 = draw.dst2;
                inputRects = new List<cv.Rect>(draw.rectangles);
            }
            else
            {
                dst2.SetTo(0);
                foreach (var r in inputRects)
                {
                    dst2.Rectangle(r, Scalar.Yellow, 1);
                }
                labels[2] = "Input rectangles = " + inputRects.Count();
            }
            if (inputRects.Count() == 0) return;
            allRect = inputRects[0];
            for (int i = 1; i < inputRects.Count(); i++)
            {
                var r = inputRects[i];
                if (r.X < 0) r.X = 0;
                if (r.Y < 0) r.Y = 0;
                if (allRect.Width > 0 && allRect.Height > 0)
                {
                    allRect = r.Union(allRect);
                    if (allRect.X + allRect.Width >= dst2.Width) allRect.Width = dst2.Width - allRect.X;
                    if (allRect.Height >= dst2.Height) allRect.Height = dst2.Height - allRect.Y;
                }
            }
            if (allRect.X + allRect.Width >= dst2.Width) allRect.Width = dst2.Width - allRect.X;
            if (allRect.Y + allRect.Height >= dst2.Height) allRect.Height = dst2.Height - allRect.Y;
            dst2.Rectangle(allRect, Scalar.Red, 2);
        }
    }




    public class Rectangle_MultiOverlap_CS : VB_Parent
    {
        public List<cv.Rect> inputRects = new List<cv.Rect>();
        public List<cv.Rect> outputRects = new List<cv.Rect>();
        Rectangle_Basics draw = new Rectangle_Basics();
        System.Windows.Forms.CheckBox rotatedCheck;
        TrackBar countSlider;
        public Rectangle_MultiOverlap_CS()
        {
            rotatedCheck = FindCheckBox("Draw Rotated Rectangles - unchecked will draw ordinary rectangles (unrotated)");
            countSlider = FindSlider("DrawCount");
            desc = "Given a group of rectangles, merge all the rectangles that overlap";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                rotatedCheck.Enabled = vbc.task.toggleOnOff;
                countSlider.Value = msRNG.Next(2, 10);
                labels[2] = "Input rectangles = " + countSlider.Value.ToString();
                draw.Run(src);
                dst2 = draw.dst2;
                inputRects = draw.rectangles;
            }
            bool unionAdded;
            do
            {
                unionAdded = false;
                for (int i = 0; i < inputRects.Count(); i++)
                {
                    var r1 = inputRects[i];
                    int rectCount = inputRects.Count();
                    for (int j = i + 1; j < inputRects.Count(); j++)
                    {
                        var r2 = inputRects[j];
                        if (r1.IntersectsWith(r2))
                        {
                            inputRects.RemoveAt(j);
                            inputRects.RemoveAt(i);
                            inputRects.Add(r1.Union(r2));
                            unionAdded = true;
                            break;
                        }
                    }
                    if (rectCount != inputRects.Count()) break;
                }
            } while (unionAdded);
            outputRects = inputRects;
            if (standaloneTest())
            {
                dst3.SetTo(0);
                foreach (var r in outputRects)
                {
                    dst3.Rectangle(r, Scalar.Yellow, 2);
                }
                dst3 = dst2 * 0.5 + dst3;
                labels[3] = outputRects.Count().ToString() + " output rectangles";
            }
        }
    }




    public class Rectangle_EnclosingPoints_CS : VB_Parent
    {
        public List<cv.Point2f> pointList = new List<cv.Point2f>();
        public Rectangle_EnclosingPoints_CS()
        {
            desc = "Build an enclosing rectangle for the supplied pointlist";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                pointList = quickRandomPoints(20);
                dst2.SetTo(0);
                foreach (var pt in pointList)
                {
                    DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                }
            }
            var minRect = Cv2.MinAreaRect(pointList.ToArray());
            DrawRotatedOutline(minRect, dst2, Scalar.Yellow);
        }
    }




    public class Rectangle_Intersection_CS : VB_Parent
    {
        public List<cv.Rect> inputRects = new List<cv.Rect>();
        Rectangle_Basics draw = new Rectangle_Basics();
        public List<cv.Rect> enclosingRects = new List<cv.Rect>();
        List<cv.Rect> otherRects = new List<cv.Rect>();
        System.Windows.Forms.CheckBox rotatedCheck;
        TrackBar countSlider;
        public Rectangle_Intersection_CS()
        {
            rotatedCheck = FindCheckBox("Draw Rotated Rectangles - unchecked will draw ordinary rectangles (unrotated)");
            countSlider = FindSlider("DrawCount");
            desc = "Test if any number of rectangles intersect.";
        }
        cv.Rect findEnclosingRect(List<cv.Rect> rects, int proximity)
        {
            cv.Rect enclosing = rects[0];
            List<cv.Rect> newOther = new List<cv.Rect>();
            for (int i = 1; i < rects.Count(); i++)
            {
                cv.Rect r1 = rects[i];
                if (enclosing.IntersectsWith(r1) || Math.Abs(r1.X - enclosing.X) < proximity)
                {
                    enclosing = enclosing.Union(r1);
                }
                else
                {
                    newOther.Add(r1);
                }
            }
            otherRects = new List<cv.Rect>(newOther);
            return enclosing;
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (vbc.task.heartBeat)
                {
                    rotatedCheck.Checked = vbc.task.toggleOnOff;
                    countSlider.Value = msRNG.Next(2, 10);
                    labels[2] = "Input rectangles = " + countSlider.Value.ToString();
                    draw.Run(src);
                    dst2 = draw.dst2;
                    inputRects = new List<cv.Rect>(draw.rectangles);
                }
            }
            else
            {
                dst2.SetTo(0);
                foreach (Rect r in inputRects)
                {
                    dst2.Rectangle(r, Scalar.Yellow, 1);
                }
            }
            SortedList<float, cv.Rect> sortedRect = new SortedList<float, cv.Rect>(new compareAllowIdenticalSingleInverted());
            foreach (Rect r in inputRects)
            {
                sortedRect.Add(r.Width * r.Height, r);
            }
            otherRects = new List<cv.Rect>(sortedRect.Values);
            enclosingRects.Clear();
            while (otherRects.Count() > 0)
            {
                cv.Rect enclosing = findEnclosingRect(otherRects, draw.options.proximity);
                enclosingRects.Add(enclosing);
            }
            labels[3] = enclosingRects.Count().ToString() + " enclosing rectangles were found";
            dst3.SetTo(0);
            foreach (Rect r in enclosingRects)
            {
                dst3.Rectangle(r, Scalar.Yellow, 2);
            }
            dst3 = dst2 * 0.5 + dst3;
        }
    }




    public class RecursiveBilateralFilter_CPP_CS : VB_Parent
    {
        byte[] dataSrc = new byte[1];
        Options_RBF options = new Options_RBF();
        public RecursiveBilateralFilter_CPP_CS()
        {
            cPtr = RecursiveBilateralFilter_Open();
            desc = "Apply the recursive bilateral filter - edge-preserving but faster.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (dataSrc.Length != src.Total() * src.ElemSize())
                Array.Resize(ref dataSrc, (int)(src.Total() * src.ElemSize()));
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = RecursiveBilateralFilter_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols,
                                                            options.RBFCount);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = RecursiveBilateralFilter_Close(cPtr);
        }
    }




    public class RedCloud_Basics_CS : VB_Parent
    {
        public Cell_Generate genCells = new Cell_Generate();
        RedCloud_CPP_VB redCPP = new RedCloud_CPP_VB();
        public Mat inputMask = new Mat();
        Color8U_Basics color;
        public RedCloud_Basics_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            inputMask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            UpdateAdvice(traceName + ": there is dedicated panel for RedCloud algorithms." + "\n" +
                            "It is behind the global options (which affect most algorithms.)");
            desc = "Find cells and then match them to the previous generation with minimum boundary";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
            {
                if (color == null) color = new Color8U_Basics();
                color.Run(src);
                src = color.dst2;
            }
            redCPP.inputMask = inputMask;
            redCPP.Run(src);
            if (redCPP.classCount == 0) return; // no data to process.
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.rectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            labels[2] = genCells.labels[2];
            dst3.SetTo(0);
            var smallCellThreshold = src.Total() / 1000;
            int cellCount = 0;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.pixels > smallCellThreshold)
                {
                    DrawCircle(dst3, rc.maxDist, vbc.task.DotSize, vbc.task.HighlightColor);
                    cellCount++;
                }
            }
            labels[3] = cellCount.ToString() + " RedCloud cells with more than " + smallCellThreshold + " pixels.  " + vbc.task.redCells.Count() + " cells present.";
        }
    }




    public class RedCloud_Reduction_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_Reduction_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            vbc.task.redOptions.setColorSource("Reduction_Basics");
            vbc.task.gOptions.setHistogramBins(20);
            desc = "Segment the image based on both the reduced color";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst3 = vbc.task.cellMap;
            dst2 = redC.dst2;
            labels = redC.labels;
        }
    }




    public class RedCloud_Hulls_CS : VB_Parent
    {
        Convex_RedCloudDefects convex = new Convex_RedCloudDefects();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_Hulls_CS()
        {
            labels = new string[] { "", "Cells where convexity defects failed", "", "Improved contour results using OpenCV's ConvexityDefects" };
            desc = "Add hulls and improved contours using ConvexityDefects to each RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3.SetTo(0);
            int defectCount = 0;
            vbc.task.cellMap.SetTo(0);
            var redCells = new List<rcData>();
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.contour.Count() >= 5)
                {
                    rc.hull = Cv2.ConvexHull(rc.contour.ToArray(), true).ToList();
                    var hullIndices = Cv2.ConvexHullIndices(rc.hull.ToArray(), false);
                    try
                    {
                        var defects = Cv2.ConvexityDefects(rc.contour, hullIndices);
                        rc.contour = convex.betterContour(rc.contour, defects);
                    }
                    catch (Exception)
                    {
                        defectCount++;
                    }
                    DrawContour(dst3[rc.rect], rc.hull, vecToScalar(rc.color), -1);
                    DrawContour(vbc.task.cellMap[rc.rect], rc.hull, cv.Scalar.All(rc.index), -1);
                }
                redCells.Add(rc);
            }
            vbc.task.redCells = new List<rcData>(redCells);
            labels[2] = vbc.task.redCells.Count() + " hulls identified below.  " + defectCount + " hulls failed to build the defect list.";
        }
    }




    public class RedCloud_FindCells_CPP_CS : VB_Parent
    {
        public List<int> cellList = new List<int>();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_FindCells_CPP_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            vbc.task.gOptions.pixelDiffThreshold = 25;
            cPtr = RedCloud_FindCells_Open();
            desc = "Find all the RedCloud cells touched by the mask created by the Motion_History rectangle";
        }
        public void RunAlg(Mat src)
        {
            cellList = new List<int>();
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            int count = 0;
            dst3.SetTo(0);
            if (vbc.task.motionDetected)
            {
                dst1 = vbc.task.cellMap[vbc.task.motionRect].Clone();
                var cppData = new byte[dst1.Total() - 1];
                Marshal.Copy(dst1.Data, cppData, 0, cppData.Length);
                var handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
                var imagePtr = RedCloud_FindCells_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), dst1.Rows, dst1.Cols);
                handleSrc.Free();
                count = RedCloud_FindCells_TotalCount(cPtr);
                if (count == 0) return;
                var cellsFound = new int[count];
                Marshal.Copy(imagePtr, cellsFound, 0, cellsFound.Length);
                cellList = new List<int>(cellsFound);
                dst0 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
                dst0 = dst0.Threshold(0, 255, ThresholdTypes.BinaryInv);
                foreach (var index in cellList)
                {
                    if (vbc.task.redCells.Count() <= index) continue;
                    var rc = vbc.task.redCells[index];
                    DrawContour(dst3[rc.rect], rc.contour, vecToScalar(rc.color), -1);
                    if (vbc.task.redOptions.getNaturalColor())
                        dst3[rc.rect].SetTo(rc.naturalColor, rc.mask);
                    else
                        dst3[rc.rect].SetTo(Scalar.White, rc.mask);
                }
                dst2.Rectangle(vbc.task.motionRect, Scalar.White, vbc.task.lineWidth);
            }
            labels[3] = count + " cells were found using the motion mask";
        }
        public void Close()
        {
            RedCloud_FindCells_Close(cPtr);
        }
    }




    public class RedCloud_Planes_CS : VB_Parent
    {
        public RedCloud_PlaneColor planes = new RedCloud_PlaneColor();
        public RedCloud_Planes_CS()
        {
            desc = "Create a plane equation from the points in each RedCloud cell and color the cell with the direction of the normal";
        }
        public void RunAlg(Mat src)
        {
            planes.Run(src);
            dst2 = planes.dst2;
            dst3 = planes.dst3;
            labels = planes.labels;
        }
    }




    public class RedCloud_Equations_CS : VB_Parent
    {
        Plane_Equation eq = new Plane_Equation();
        public List<rcData> redCells = new List<rcData>();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_Equations_CS()
        {
            labels[3] = "The estimated plane equations for the largest 20 RedCloud cells.";
            desc = "Show the estimated plane equations for all the cells.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                redCells = new List<rcData>(vbc.task.redCells);
            }
            var newCells = new List<rcData>();
            foreach (var rc in redCells)
            {
                if (rc.contour.Count() > 4)
                {
                    eq.rc = rc;
                    eq.Run(empty);
                    newCells.Add(eq.rc);
                }
            }
            redCells = new List<rcData>(newCells);
            if (vbc.task.heartBeat)
            {
                int index = 0;
                strOut = "";
                foreach (var rc in redCells)
                {
                    if (rc.contour.Count() > 4)
                    {
                        var justEquation = $"{rc.eq[0]:vbc.fmt3}*X + {rc.eq[1]:vbc.fmt3}*Y + " +
                                            $"{rc.eq[2]:vbc.fmt3}*Z + {rc.eq[3]:vbc.fmt3}" + "\n";
                        strOut += justEquation;
                        index++;
                        if (index >= 20) break;
                    }
                }
            }
            SetTrueText(strOut, 3);
        }
    }





    public class RedCloud_CellsAtDepth_CS : VB_Parent
    {
        Plot_Histogram plot = new Plot_Histogram();
        Kalman_Basics kalman = new Kalman_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_CellsAtDepth_CS()
        {
            plot.removeZeroEntry = false;
            labels[3] = "Histogram of depth weighted by the size of the cell.";
            desc = "Create a histogram of depth using RedCloud cells";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            int histBins = vbc.task.histogramBins;
            List<int>[] slotList = new List<int>[histBins];
            for (int i = 0; i < slotList.Length; i++)
            {
                slotList[i] = new List<int>();
            }
            float[] hist = new float[histBins];
            foreach (var rc in vbc.task.redCells)
            {
                int slot;
                if (rc.depthMean[2] > vbc.task.MaxZmeters) rc.depthMean[2] = vbc.task.MaxZmeters;
                slot = (int)((rc.depthMean[2] / vbc.task.MaxZmeters) * histBins);
                if (slot >= hist.Length) slot = hist.Length - 1;
                slotList[slot].Add(rc.index);
                hist[slot] += rc.pixels;
            }
            kalman.kInput = hist;
            kalman.Run(src);
            Mat histMat = Mat.FromArray(kalman.kOutput);
            plot.Run(histMat);
            dst3 = plot.dst2;
            int barWidth = dst3.Width / histBins;
            int histIndex = (int)Math.Floor((double)(vbc.task.mouseMovePoint.X / barWidth));
            if (histIndex >= slotList.Length) histIndex = slotList.Length - 1;
            Cv2.Rectangle(dst3, new cv.Rect(histIndex * barWidth, 0, barWidth, dst3.Height), Scalar.Yellow, vbc.task.lineWidth);
            foreach (int i in slotList[histIndex])
            {
                var rc = vbc.task.redCells[i];
                DrawContour(dst2[rc.rect], rc.contour, Scalar.Yellow);
                DrawContour(vbc.task.color[rc.rect], rc.contour, Scalar.Yellow);
            }
        }
    }




    public class RedCloud_ShapeCorrelation_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_ShapeCorrelation_CS()
        {
            desc = "A shape correlation is between each x and y in list of contours points.  It allows classification based on angle and shape.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            var rc = vbc.task.rc;
            if (rc.contour.Count() > 0)
            {
                float shape = shapeCorrelation(rc.contour);
                strOut = "Contour correlation for selected cell contour X to Y = " + shape.ToString("F3") + "\n" + "\n" +
                            "Select different cells and notice the pattern for the correlation of the contour.X to contour.Y values:" + "\n" +
                            "(The contour correlation - contour.x to contour.y - Is computed above.)" + "\n" + "\n" +
                            "If shape leans left, correlation Is positive And proportional to the lean." + "\n" +
                            "If shape leans right, correlation Is negative And proportional to the lean. " + "\n" +
                            "If shape Is symmetric (i.e. rectangle Or circle), correlation Is near zero." + "\n" +
                            "(Remember that Y increases from the top of the image to the bottom.)";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class RedCloud_FPS_CS : VB_Parent
    {
        Grid_FPS fps = new Grid_FPS();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_FPS_CS()
        {
            vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.setDisplay1();
            desc = "Display RedCloud output at a fixed frame rate";
        }
        public void RunAlg(Mat src)
        {
            fps.Run(empty);
            if (fps.heartBeat)
            {
                redC.Run(src);
                dst0 = vbc.task.color.Clone();
                dst1 = vbc.task.depthRGB.Clone();
                dst2 = redC.dst2.Clone();
            }
            labels[2] = redC.labels[2] + " " + fps.strOut;
        }
    }




    public class RedCloud_PlaneColor_CS : VB_Parent
    {
        public Options_Plane options = new Options_Plane();
        public RedCloud_Basics redC = new RedCloud_Basics();
        RedCloud_PlaneFromMask planeMask = new RedCloud_PlaneFromMask();
        RedCloud_PlaneFromContour planeContour = new RedCloud_PlaneFromContour();
        Plane_CellColor planeCells = new Plane_CellColor();
        public RedCloud_PlaneColor_CS()
        {
            labels[3] = "Blue - normal is closest to the X-axis, green - to the Y-axis, and Red - to the Z-axis";
            desc = "Create a plane equation from the points in each RedCloud cell and color the cell with the direction of the normal";
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.motionDetected) return;
            options.RunOpt();
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            List<cv.Point3f> fitPoints = new List<cv.Point3f>();
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.eq == new Vec4f())
                {
                    rc.eq = new Vec4f();
                    if (options.useMaskPoints)
                    {
                        rc.eq = fitDepthPlane(planeCells.buildMaskPointEq(rc));
                    }
                    else if (options.useContourPoints)
                    {
                        rc.eq = fitDepthPlane(planeCells.buildContourPoints(rc));
                    }
                    else if (options.use3Points)
                    {
                        rc.eq = build3PointEquation(rc);
                    }
                }
                dst3[rc.rect].SetTo(new Scalar(Math.Abs(255 * rc.eq.Item0),
                                                Math.Abs(255 * rc.eq.Item1),
                                                Math.Abs(255 * rc.eq.Item2)), rc.mask);
            }
        }
    }




    public class RedCloud_PlaneFromContour_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_PlaneFromContour_CS()
        {
            labels[3] = "Blue - normal is closest to the X-axis, green - to the Y-axis, and Red - to the Z-axis";
            desc = "Create a plane equation each cell's contour";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
            }
            var rc = vbc.task.rc;
            List<cv.Point3f> fitPoints = new List<cv.Point3f>();
            foreach (var pt in rc.contour)
            {
                if (pt.X >= rc.rect.Width || pt.Y >= rc.rect.Height) continue;
                if (rc.mask.Get<byte>(pt.Y, pt.X) == 0) continue;
                fitPoints.Add(vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(pt.Y, pt.X));
            }
            rc.eq = fitDepthPlane(fitPoints);
            if (standaloneTest())
            {
                dst3.SetTo(0);
                dst3[rc.rect].SetTo(new Scalar(Math.Abs(255 * rc.eq.Item0), Math.Abs(255 * rc.eq.Item1), Math.Abs(255 * rc.eq.Item2)), rc.mask);
            }
        }
    }




    public class RedCloud_PlaneFromMask_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_PlaneFromMask_CS()
        {
            labels[3] = "Blue - normal is closest to the X-axis, green - to the Y-axis, and Red - to the Z-axis";
            desc = "Create a plane equation from the pointcloud samples in a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
            }
            var rc = vbc.task.rc;
            var fitPoints = new List<cv.Point3f>();
            for (int y = 0; y < rc.rect.Height; y++)
            {
                for (int x = 0; x < rc.rect.Width; x++)
                {
                    if (rc.mask.Get<byte>(y, x) != 0)
                    {
                        fitPoints.Add(vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(y, x));
                    }
                }
            }
            rc.eq = fitDepthPlane(fitPoints);
            if (standaloneTest())
            {
                dst3.SetTo(0);
                dst3[rc.rect].SetTo(new Scalar(Math.Abs(255 * rc.eq[0]), Math.Abs(255 * rc.eq[1]), Math.Abs(255 * rc.eq[2])), rc.mask);
            }
        }
    }




    public class RedCloud_BProject3D_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        public RedCloud_BProject3D_CS()
        {
            desc = "Run RedCloud_Basics on the output of the RGB 3D backprojection";
        }
        public void RunAlg(Mat src)
        {
            hcloud.Run(src);
            dst3 = hcloud.dst2;
            dst3.ConvertTo(dst0, MatType.CV_8U);
            redC.Run(dst0);
            dst2 = redC.dst2;
        }
    }




    public class RedCloud_YZ_CS : VB_Parent
    {
        Cell_Basics stats = new Cell_Basics();
        public RedCloud_YZ_CS()
        {
            stats.runRedCloud = true;
            desc = "Build horizontal RedCloud cells";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.redOptions.setYZReduction(true);
            stats.Run(src);
            dst0 = stats.dst0;
            dst1 = stats.dst1;
            dst2 = stats.dst2;
            SetTrueText(stats.strOut, 3);
        }
    }




    public class RedCloud_XZ_CS : VB_Parent
    {
        Cell_Basics stats = new Cell_Basics();
        public RedCloud_XZ_CS()
        {
            stats.runRedCloud = true;
            desc = "Build vertical RedCloud cells.";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.redOptions.setXZReduction(true);
            stats.Run(src);
            dst0 = stats.dst0;
            dst1 = stats.dst1;
            dst2 = stats.dst2;
            SetTrueText(stats.strOut, 3);
        }
    }




    public class RedCloud_World_CS : VB_Parent
    {
        RedCloud_Reduce redC = new RedCloud_Reduce();
        Depth_World world = new Depth_World();
        public RedCloud_World_CS()
        {
            labels[3] = "Generated pointcloud";
            desc = "Display the output of a generated pointcloud as RedCloud cells";
        }
        public void RunAlg(Mat src)
        {
            world.Run(src);
            vbc.task.pointCloud = world.dst2;
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            if (vbc.task.FirstPass) FindSlider("RedCloud_Reduce Reduction").Value = 1000;
        }
    }




    public class RedCloud_KMeans_CS : VB_Parent
    {
        KMeans_MultiChannel km = new KMeans_MultiChannel();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_KMeans_CS()
        {
            labels = new string[] { "", "", "KMeans_MultiChannel output", "RedCloud_Basics output" };
            desc = "Use RedCloud to identify the regions created by kMeans";
        }
        public void RunAlg(Mat src)
        {
            km.Run(src);
            dst3 = km.dst2;
            redC.Run(km.dst3);
            dst2 = redC.dst2;
        }
    }




    public class RedCloud_Diff_CS : VB_Parent
    {
        Diff_RGBAccum diff = new Diff_RGBAccum();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_Diff_CS()
        {
            labels = new string[] { "", "", "Diff output, RedCloud input", "RedCloud output" };
            desc = "Isolate blobs in the diff output with RedCloud";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("Wave at the camera to see the segmentation of the motion.", 3);
            diff.Run(src);
            dst3 = diff.dst2;
            redC.Run(dst3);
            dst2.SetTo(0);
            redC.dst2.CopyTo(dst2, dst3);
            labels[3] = vbc.task.redCells.Count() + " objects identified in the diff output";
        }
    }




    public class RedCloud_ProjectCell_CS : VB_Parent
    {
        Hist_ShapeTop topView = new Hist_ShapeTop();
        Hist_ShapeSide sideView = new Hist_ShapeSide();
        Mat_4Click mats = new Mat_4Click();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_ProjectCell_CS()
        {
            vbc.task.gOptions.setDisplay1();
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[3] = "Top: XZ values and mask, Bottom: ZY values and mask";
            desc = "Visualize the top and side projection of a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            // The commented code is omitted for clarity
        }
    }




    public class RedCloud_LikelyFlatSurfaces_CS : VB_Parent
    {
        Plane_Basics verts = new Plane_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public List<rcData> vCells = new List<rcData>();
        public List<rcData> hCells = new List<rcData>();
        public RedCloud_LikelyFlatSurfaces_CS()
        {
            labels[1] = "RedCloud output";
            desc = "Use the mask for vertical surfaces to identify RedCloud cells that appear to be flat.";
        }
        public void RunAlg(Mat src)
        {
            verts.Run(src);
            redC.Run(src);
            dst2.SetTo(0);
            dst3.SetTo(0);
            vCells.Clear();
            hCells.Clear();
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.depthMean[2] >= vbc.task.MaxZmeters) continue;
                Mat tmp = verts.dst2[rc.rect] & rc.mask;
                if (rc.pixels == 0) continue;
                if (tmp.CountNonZero() / rc.pixels > 0.5)
                {
                    DrawContour(dst2[rc.rect], rc.contour, vecToScalar(rc.color), -1);
                    vCells.Add(rc);
                }
                tmp = verts.dst3[rc.rect] & rc.mask;
                int count = tmp.CountNonZero();
                if (count / rc.pixels > 0.5)
                {
                    DrawContour(dst3[rc.rect], rc.contour, vecToScalar(rc.color), -1);
                    hCells.Add(rc);
                }
            }
            var rcX = vbc.task.rc;
            SetTrueText("mean depth = " + rcX.depthMean[2].ToString("0.0"), 3);
            labels[2] = redC.labels[2];
        }
    }




    public class RedCloud_PlaneEq3D_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Plane_Equation eq = new Plane_Equation();
        public RedCloud_PlaneEq3D_CS()
        {
            desc = "If a RedColor cell contains depth then build a plane equation";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            var rc = vbc.task.rc;
            if (rc.maxVec.Z != 0)
            {
                eq.rc = rc;
                eq.Run(empty);
                rc = eq.rc;
            }
            dst3.SetTo(0);
            DrawContour(dst3[rc.rect], rc.contour, vecToScalar(rc.color), -1);
            SetTrueText(eq.strOut, 3);
        }
    }




    public class RedCloud_DelaunayGuidedFeatures_CS : VB_Parent
    {
        Feature_Delaunay features = new Feature_Delaunay();
        RedCloud_Basics redC = new RedCloud_Basics();
        List<List<cv.Point2f>> goodList = new List<List<cv.Point2f>>();
        public RedCloud_DelaunayGuidedFeatures_CS()
        {
            labels = new[] { "", "Format CV_8U of Delaunay data", "RedCloud output", "RedCloud Output of GoodFeature points" };
            desc = "Track the GoodFeatures points using RedCloud.";
        }
        public void RunAlg(Mat src)
        {
            features.Run(src);
            dst1 = features.dst3;
            redC.Run(dst1);
            dst2 = redC.dst2;
            if (vbc.task.heartBeat) goodList.Clear();
            var nextGood = new List<cv.Point2f>(vbc.task.features);
            goodList.Add(nextGood);
            if (goodList.Count() >= vbc.task.frameHistoryCount) goodList.RemoveAt(0);
            dst3.SetTo(0);
            foreach (var ptList in goodList)
            {
                foreach (var pt in ptList)
                {
                    var c = dst2.Get<Vec3b>((int)pt.Y, (int)pt.X);
                    DrawCircle(dst3, pt, vbc.task.DotSize, vecToScalar(c));
                }
            }
        }
    }




    public class RedCloud_UnstableCells_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        List<cv.Point> prevList = new List<cv.Point>();
        public RedCloud_UnstableCells_CS()
        {
            labels = new[] { "", "", "Current generation of cells", "Recently changed cells highlighted - indicated by rc.maxDStable changing" };
            desc = "Use maxDStable to identify unstable cells - cells which were NOT present in the previous generation.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            if (vbc.task.heartBeat || vbc.task.frameCount == 2)
            {
                dst1 = dst2.Clone();
                dst3.SetTo(0);
            }
            var currList = new List<cv.Point>();
            foreach (var rc in vbc.task.redCells)
            {
                if (!prevList.Contains(rc.maxDStable))
                {
                    DrawContour(dst1[rc.rect], rc.contour, Scalar.White, -1);
                    DrawContour(dst1[rc.rect], rc.contour, Scalar.Black);
                    DrawContour(dst3[rc.rect], rc.contour, Scalar.White, -1);
                }
                currList.Add(rc.maxDStable);
            }
            prevList = new List<cv.Point>(currList);
        }
    }




    public class RedCloud_UnstableHulls_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        List<cv.Point> prevList = new List<cv.Point>();
        public RedCloud_UnstableHulls_CS()
        {
            labels = new[] { "", "", "Current generation of cells", "Recently changed cells highlighted - indicated by rc.maxDStable changing" };
            desc = "Use maxDStable to identify unstable cells - cells which were NOT present in the previous generation.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            if (vbc.task.heartBeat || vbc.task.frameCount == 2)
            {
                dst1 = dst2.Clone();
                dst3.SetTo(0);
            }
            var currList = new List<cv.Point>();
            foreach (var rc in vbc.task.redCells)
            {
                rc.hull = Cv2.ConvexHull(rc.contour.ToArray(), true).ToList();
                if (!prevList.Contains(rc.maxDStable))
                {
                    DrawContour(dst1[rc.rect], rc.hull, Scalar.White, -1);
                    DrawContour(dst1[rc.rect], rc.hull, Scalar.Black);
                    DrawContour(dst3[rc.rect], rc.hull, Scalar.White, -1);
                }
                currList.Add(rc.maxDStable);
            }
            prevList = new List<cv.Point>(currList);
        }
    }




    public class RedCloud_CellChanges_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Mat dst2Last;
        public RedCloud_CellChanges_CS()
        {
            dst2Last = dst2.Clone();
            if (standaloneTest()) redC = new RedCloud_Basics();
            desc = "Count the cells that have changed in a RedCloud generation";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3 = (dst2 - dst2Last).ToMat();
            int changedPixels = dst3.CvtColor(ColorConversionCodes.BGR2GRAY).CountNonZero();
            int changedCells = 0;
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.indexLast == 0) changedCells++;
            }
            dst2Last = dst2.Clone();
            if (vbc.task.heartBeat)
            {
                labels[2] = "Changed cells = " + changedCells.ToString("000") + " cells or " + (changedCells / vbc.task.redCells.Count()).ToString("0%");
                labels[3] = "Changed pixel total = " + (changedPixels / 1000.0).ToString("0.0") + "k or " + (changedPixels / dst2.Total()).ToString("0%");
            }
        }
    }




    public class RedCloud_FloodPoint_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Cell_Basics stats = new Cell_Basics();
        public RedCloud_FloodPoint_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Verify that floodpoints correctly determine if depth is present.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst1 = vbc.task.depthRGB;
            foreach (var rc in vbc.task.redCells)
            {
                DrawCircle(dst1, rc.floodPoint, vbc.task.DotSize, Scalar.White);
                DrawCircle(dst2, rc.floodPoint, vbc.task.DotSize, Scalar.Yellow);
            }
            stats.Run(src);
            SetTrueText(stats.strOut, 3);
        }
    }




    public class RedCloud_CellStatsPlot_CS : VB_Parent
    {
        Cell_BasicsPlot cells = new Cell_BasicsPlot();
        public RedCloud_CellStatsPlot_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            cells.runRedCloud = true;
            desc = "Display the stats for the requested cell";
        }
        public void RunAlg(Mat src)
        {
            cells.Run(src);
            dst1 = cells.dst1;
            dst2 = cells.dst2;
            labels[2] = cells.labels[2];
            SetTrueText(cells.strOut, 3);
        }
    }




    public class RedCloud_MostlyColor_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_MostlyColor_CS()
        {
            labels[3] = "Cells that have no depth data.";
            desc = "Identify cells that have no depth";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.depthPixels > 0) dst3[rc.rect].SetTo(rc.color, rc.mask);
            }
        }
    }




    public class RedCloud_OutlineColor_CS : VB_Parent
    {
        Depth_Outline outline = new Depth_Outline();
        RedCloud_Basics redC = new RedCloud_Basics();
        Color8U_Basics colorClass = new Color8U_Basics();
        public RedCloud_OutlineColor_CS()
        {
            labels[3] = "Color input to RedCloud_Basics with depth boundary blocking color connections.";
            desc = "Use the depth outline as input to RedCloud_Basics";
        }
        public void RunAlg(Mat src)
        {
            outline.Run(vbc.task.depthMask);
            colorClass.Run(src);
            dst1 = colorClass.dst2 + cv.Scalar.All(1);
            dst1.SetTo(0, outline.dst2);
            dst3 = ShowPalette(dst1 * 255 / colorClass.classCount);
            redC.Run(dst1);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class RedCloud_DepthOutline_CS : VB_Parent
    {
        Depth_Outline outline = new Depth_Outline();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_DepthOutline_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Use the Depth_Outline output over time to isolate high quality cells";
        }
        public void RunAlg(Mat src)
        {
            outline.Run(vbc.task.depthMask);
            if (vbc.task.heartBeat) dst3.SetTo(0);
            dst3 = dst3 | outline.dst2;
            dst1.SetTo(0);
            src.CopyTo(dst1, ~dst3);
            redC.Run(dst1);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class RedCloud_MeterByMeter_CS : VB_Parent
    {
        BackProject_MeterByMeter meter = new BackProject_MeterByMeter();
        public RedCloud_MeterByMeter_CS()
        {
            desc = "Run RedCloud meter by meter";
        }
        public void RunAlg(Mat src)
        {
            meter.Run(src);
            dst2 = meter.dst3;
            labels[2] = meter.labels[3];
            for (int i = 0; i <= vbc.task.MaxZmeters; i++)
            {
            }
        }
    }




    public class RedCloud_FourColor_CS : VB_Parent
    {
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_FourColor_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            vbc.task.redOptions.setUseColorOnly(true);
            labels[3] = "A 4-way split of the input grayscale image based on brightness";
            desc = "Use RedCloud on a 4-way split based on light to dark in the image.";
        }
        public void RunAlg(Mat src)
        {
            binar4.Run(src);
            dst3 = ShowPalette(binar4.dst2 * 255 / 5);
            redC.Run(binar4.dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
        }
    }




    public class RedCloud_CCompColor_CS : VB_Parent
    {
        CComp_Both ccomp = new CComp_Both();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_CCompColor_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Identify each Connected component as a RedCloud Cell.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            ccomp.Run(src);
            dst3 = Convert32f_To_8UC3(ccomp.dst1);
            labels[3] = ccomp.labels[2];
            redC.Run(dst3);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
        }
    }




    public class RedCloud_Cells_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Mat cellmap = new Mat();
        public List<rcData> redCells = new List<rcData>();
        public RedCloud_Cells_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Create RedCloud output using only color";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            cellmap = vbc.task.cellMap;
            redCells = vbc.task.redCells;
        }
    }




    public class RedCloud_Flippers_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Mat lastMap;
        public RedCloud_Flippers_CS()
        {
            lastMap = vbc.task.cellMap.Clone();
            vbc.task.redOptions.setIdentifyCells(true);
            vbc.task.redOptions.setUseColorOnly(true);
            labels[3] = "Highlighted below are the cells which flipped in color from the previous frame.";
            desc = "Identify the 4-way split cells that are flipping between brightness boundaries.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst3 = redC.dst3;
            labels[3] = redC.labels[2];
            dst2.SetTo(0);
            int unMatched = 0;
            int unMatchedPixels = 0;
            foreach (var cell in vbc.task.redCells)
            {
                var lastColor = lastMap.Get<Vec3b>(cell.maxDist.Y, cell.maxDist.X);
                if (lastColor != cell.color)
                {
                    dst2[cell.rect].SetTo(cell.color, cell.mask);
                    unMatched++;
                    unMatchedPixels += cell.pixels;
                }
            }
            lastMap = redC.dst3.Clone();
            if (vbc.task.heartBeat)
            {
                labels[3] = "Unmatched to previous frame: " + unMatched + " totaling " + unMatchedPixels + " pixels.";
            }
        }
    }




    public class RedCloud_Overlaps_CS : VB_Parent
    {
        public List<rcData> redCells = new List<rcData>();
        public Mat cellMap;
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_Overlaps_CS()
        {
            cellMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Remove the overlapping cells.  Keep the largest.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels = redC.labels;
            List<int> overlappingCells = new List<int>();
            cellMap.SetTo(0);
            redCells.Clear();
            foreach (var rc in vbc.task.redCells)
            {
                var valMap = cellMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                cellMap[rc.rect].SetTo(rc.index, rc.mask);
                redCells.Add(rc);
            }
            dst3.SetTo(0);
            for (int i = overlappingCells.Count() - 1; i >= 0; i--)
            {
                var rc = redCells[overlappingCells[i]];
                dst3[rc.rect].SetTo(rc.color, rc.mask);
                redCells.RemoveAt(overlappingCells[i]);
            }
            labels[3] = "Before removing overlapping cells: " + vbc.task.redCells.Count().ToString() + ". After: " + redCells.Count().ToString();
        }
    }




    public class RedCloud_OnlyColorHist3D_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public RedCloud_OnlyColorHist3D_CS()
        {
            desc = "Use the backprojection of the 3D RGB histogram as input to RedCloud_Basics.";
        }
        public void RunAlg(Mat src)
        {
            hColor.Run(src);
            dst2 = hColor.dst3;
            labels[2] = hColor.labels[3];
            redC.Run(dst2);
            dst3 = vbc.task.cellMap;
            dst3.SetTo(0, vbc.task.noDepthMask);
            labels[3] = redC.labels[2];
        }
    }




    public class RedCloud_OnlyColorAlt_CS : VB_Parent
    {
        public RedCloud_Basics redMasks = new RedCloud_Basics();
        public RedCloud_OnlyColorAlt_CS()
        {
            desc = "Track the color cells from floodfill - trying a minimalist approach to build cells.";
        }
        public void RunAlg(Mat src)
        {
            redMasks.Run(src);
            List<rcData> lastCells = new List<rcData>(vbc.task.redCells);
            Mat lastMap = vbc.task.cellMap.Clone();
            Mat lastColors = dst3.Clone();
            List<rcData> newCells = new List<rcData>();
            vbc.task.cellMap.SetTo(0);
            dst3.SetTo(0);
            List<Vec3b> usedColors = new List<Vec3b> { black };
            int unmatched = 0;
            foreach (var cell in vbc.task.redCells)
            {
                int index = lastMap.Get<byte>(cell.maxDist.Y, cell.maxDist.X);
                if (index < lastCells.Count())
                {
                    cell.color = lastColors.Get<Vec3b>(cell.maxDist.Y, cell.maxDist.X);
                }
                else
                {
                    unmatched++;
                }
                if (usedColors.Contains(cell.color))
                {
                    unmatched++;
                    cell.color = randomCellColor();
                }
                usedColors.Add(cell.color);
                if (vbc.task.cellMap.Get<byte>(cell.maxDist.Y, cell.maxDist.X) == 0)
                {
                    cell.index = vbc.task.redCells.Count();
                    newCells.Add(cell);
                    vbc.task.cellMap[cell.rect].SetTo(cell.index, cell.mask);
                    dst3[cell.rect].SetTo(cell.color, cell.mask);
                }
            }
            vbc.task.redCells = new List<rcData>(newCells);
            labels[3] = vbc.task.redCells.Count().ToString() + " cells were identified.  The top " +
                vbc.task.redOptions.getIdentifyCount().ToString() + " are numbered";
            labels[2] = redMasks.labels[3] + " " + unmatched.ToString() + " cells were not matched to previous frame.";
            if (vbc.task.redCells.Count() > 0) dst2 = ShowPalette(lastMap * 255 / vbc.task.redCells.Count());
        }
    }




    public class RedCloud_Gaps_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        History_Basics frames = new History_Basics();
        public RedCloud_Gaps_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Find the gaps that are different in the RedCloud_Basics results.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
            frames.Run(vbc.task.cellMap.InRange(0, 0));
            dst3 = frames.dst2;
            if (vbc.task.redCells.Count() > 0)
            {
                dst2[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
            }
            if (vbc.task.redCells.Count() > 0)
            {
                var rc = vbc.task.redCells[0]; // index can now be zero.
                dst3[rc.rect].SetTo(0, rc.mask);
            }
            int count = dst3.CountNonZero();
            labels[3] = "Unclassified pixel count = " + count.ToString() + " or " + (count / src.Total()).ToString("0%");
        }
    }




    public class RedCloud_SizeOrder_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_SizeOrder_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            UpdateAdvice(traceName + ": Use the goptions 'DebugSlider' to select which cell is isolated.");
            vbc.task.gOptions.setDebugSlider(0);
            desc = "Select blobs by size using the DebugSlider in the global options";
        }
        public void RunAlg(Mat src)
        {
            SetTrueText("Use the goptions 'DebugSlider' to select cells by size." + "\n" + "Size order changes frequently.", 3);
            redC.Run(src);
            dst2 = redC.dst3;
            labels[2] = redC.labels[3];
            int index = vbc.task.gOptions.getDebugSlider();
            if (index < vbc.task.redCells.Count())
            {
                dst3.SetTo(0);
                var cell = vbc.task.redCells[index];
                dst3[cell.rect].SetTo(cell.color, cell.mask);
            }
        }
    }




    public class RedCloud_StructuredH_CS : VB_Parent
    {
        RedCloud_MotionBGsubtract motion = new RedCloud_MotionBGsubtract();
        Structured_TransformH transform = new Structured_TransformH();
        Projection_HistTop histTop = new Projection_HistTop();
        public RedCloud_StructuredH_CS()
        {
            if (standalone)
            {
                vbc.task.redOptions.setIdentifyCells(false);
                vbc.task.gOptions.setDisplay1();
                vbc.task.gOptions.setDisplay1();
            }
            desc = "Display the RedCloud cells found with a horizontal slice through the cellMap.";
        }
        public void RunAlg(Mat src)
        {
            Mat sliceMask = transform.createSliceMaskH();
            dst0 = src;
            motion.Run(sliceMask.Clone());
            if (vbc.task.heartBeat) dst1.SetTo(0);
            dst1.SetTo(Scalar.White, sliceMask);
            labels = motion.labels;
            dst2.SetTo(0);
            foreach (var rc in motion.redCells)
            {
                if (rc.motionFlag) DrawContour(dst2[rc.rect], rc.contour, vecToScalar(rc.color), -1);
            }
            Mat pc = new Mat(vbc.task.pointCloud.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            vbc.task.pointCloud.CopyTo(pc, dst2.CvtColor(ColorConversionCodes.BGR2GRAY));
            histTop.Run(pc);
            dst3 = histTop.dst2;
            dst2.SetTo(Scalar.White, sliceMask);
            dst0.SetTo(Scalar.White, sliceMask);
        }
    }




    public class RedCloud_StructuredV_CS : VB_Parent
    {
        RedCloud_MotionBGsubtract motion = new RedCloud_MotionBGsubtract();
        Structured_TransformV transform = new Structured_TransformV();
        Projection_HistSide histSide = new Projection_HistSide();
        public RedCloud_StructuredV_CS()
        {
            if (standalone)
            {
                vbc.task.redOptions.setIdentifyCells(false);
                vbc.task.gOptions.setDisplay1();
                vbc.task.gOptions.setDisplay1();
            }
            desc = "Display the RedCloud cells found with a vertical slice through the cellMap.";
        }
        public void RunAlg(Mat src)
        {
            Mat sliceMask = transform.createSliceMaskV();
            dst0 = src;
            motion.Run(sliceMask.Clone());
            if (vbc.task.heartBeat) dst1.SetTo(0);
            dst1.SetTo(Scalar.White, sliceMask);
            labels = motion.labels;
            SetTrueText("Move mouse in image to see impact.", 3);
            dst2.SetTo(0);
            foreach (var rc in motion.redCells)
            {
                if (rc.motionFlag) DrawContour(dst2[rc.rect], rc.contour, vecToScalar(rc.color), -1);
            }
            Mat pc = new Mat(vbc.task.pointCloud.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            vbc.task.pointCloud.CopyTo(pc, dst2.CvtColor(ColorConversionCodes.BGR2GRAY));
            histSide.Run(pc);
            dst3 = histSide.dst2;
            dst2.SetTo(Scalar.White, sliceMask);
            dst0.SetTo(Scalar.White, sliceMask);
        }
    }




    public class RedCloud_MotionBasics_CS : VB_Parent
    {
        public RedCloud_Basics redMasks = new RedCloud_Basics();
        public List<rcData> redCells = new List<rcData>();
        public RedCloud_MotionBGsubtract rMotion = new RedCloud_MotionBGsubtract();
        Mat lastColors;
        Mat lastMap;
        public RedCloud_MotionBasics_CS()
        {
            lastColors = dst3.Clone();
            lastMap = dst2.Clone();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "Mask of active RedCloud cells", "CV_8U representation of redCells", "" };
            desc = "Track the color cells from floodfill - trying a minimalist approach to build cells.";
        }
        public void RunAlg(Mat src)
        {
            redMasks.Run(src);
            rMotion.Run(vbc.task.color.Clone());
            List<rcData> lastCells = new List<rcData>(redCells);
            redCells.Clear();
            dst2.SetTo(0);
            dst3.SetTo(0);
            List<Vec3b> usedColors = new List<Vec3b> { black };
            int motionCount = 0;
            foreach (var nextCell in rMotion.redCells)
            {
                rcData cell = nextCell;
                int index = lastMap.At<byte>(cell.maxDist.Y, cell.maxDist.X);
                if (!cell.motionFlag)
                {
                    if (index > 0 && index < lastCells.Count()) cell = lastCells[index - 1];
                }
                else
                {
                    motionCount++;
                }
                if (index > 0 && index < lastCells.Count())
                {
                    cell.color = lastColors.At<Vec3b>(cell.maxDist.Y, cell.maxDist.X);
                }
                if (usedColors.Contains(cell.color)) cell.color = randomCellColor();
                usedColors.Add(cell.color);
                if (dst2.At<byte>(cell.maxDist.Y, cell.maxDist.X) == 0)
                {
                    cell.index = redCells.Count() + 1;
                    redCells.Add(cell);
                    dst2[cell.rect].SetTo(cell.index, cell.mask);
                    dst3[cell.rect].SetTo(cell.color, cell.mask);
                    SetTrueText(cell.index.ToString(), cell.maxDist, 2);
                    SetTrueText(cell.index.ToString(), cell.maxDist, 3);
                }
            }
            labels[3] = "There were " + redCells.Count() + " collected cells and " + motionCount +
                        " cells removed because of motion.  ";
            lastColors = dst3.Clone();
            lastMap = dst2.Clone();
            if (redCells.Count() > 0) dst1 = ShowPalette(lastMap * 255 / redCells.Count());
        }
    }




    public class RedCloud_ContourVsFeatureLess_CS : VB_Parent
    {
        RedCloud_Basics redMasks = new RedCloud_Basics();
        Contour_WholeImage contour = new Contour_WholeImage();
        FeatureLess_Basics fLess = new FeatureLess_Basics();
        System.Windows.Forms.RadioButton useContours;
        public RedCloud_ContourVsFeatureLess_CS()
        {
            useContours = FindRadio("Use Contour_WholeImage");
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Contour_WholeImage Input", "RedCloud_Basics - toggling between Contour and Featureless inputs", "FeatureLess_Basics Input" };
            desc = "Compare Contour_WholeImage and FeatureLess_Basics as input to RedCloud_Basics";
        }
        public void RunAlg(Mat src)
        {
            contour.Run(src);
            dst1 = contour.dst2;
            fLess.Run(src);
            dst3 = fLess.dst2;
            if (vbc.task.toggleOnOff) redMasks.Run(dst3);
            else redMasks.Run(dst1);
            dst2 = redMasks.dst3;
        }
    }




    public class RedCloud_UnmatchedCount_CS : VB_Parent
    {
        public List<rcData> redCells = new List<rcData>();
        int myFrameCount;
        List<int> changedCellCounts = new List<int>();
        List<int> framecounts = new List<int>();
        List<cv.Point> frameLoc = new List<cv.Point>();
        public RedCloud_UnmatchedCount_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Count the unmatched cells and display them.";
        }
        public void RunAlg(Mat src)
        {
            myFrameCount++;
            if (standaloneTest())
            {
                SetTrueText("RedCloud_UnmatchedCount_CS has no output when run standaloneTest()." + "\n" +
                            "It requires redCells and RedCloud_Basics is the only way to create redCells." + "\n" +
                            "Since RedCloud_Basics calls RedCloud_UnmatchedCount_CS, it would be circular and never finish the initialize.");
                return;
            }
            int unMatchedCells = 0;
            int mostlyColor = 0;
            for (int i = 0; i < redCells.Count(); i++)
            {
                var rc = redCells[i];
                if (redCells[i].depthPixels / redCells[i].pixels < 0.5) mostlyColor++;
                if (rc.indexLast != 0)
                {
                    byte val = dst3.At<byte>(rc.maxDist.Y, rc.maxDist.X);
                    if (val == 0)
                    {
                        dst3[rc.rect].SetTo(255, rc.mask);
                        unMatchedCells++;
                        frameLoc.Add(rc.maxDist);
                        framecounts.Add(myFrameCount);
                    }
                }
            }
            if (ShowIntermediate())
            {
                for (int i = 0; i < framecounts.Count(); i++)
                {
                    SetTrueText(framecounts[i].ToString(), frameLoc[i], 2);
                }
            }
            changedCellCounts.Add(unMatchedCells);
            if (vbc.task.heartBeat)
            {
                dst3.SetTo(0);
                framecounts.Clear();
                frameLoc.Clear();
                myFrameCount = 0;
                int sum = changedCellCounts.Sum();
                double avg = changedCellCounts.Count() > 0 ? changedCellCounts.Average() : 0;
                labels[3] = sum + " new/moved cells in the last second " + string.Format(vbc.fmt1, avg) + " changed per frame";
                labels[2] = redCells.Count() + " cells, unmatched cells = " + unMatchedCells + "   " +
                            mostlyColor + " cells were mostly color and " + (redCells.Count() - mostlyColor) + " had depth.";
                changedCellCounts.Clear();
            }
        }
    }




    public class RedCloud_ContourUpdate_CS : VB_Parent
    {
        public List<rcData> redCells = new List<rcData>();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_ContourUpdate_CS()
        {
            desc = "For each cell, add a contour if its count is zero.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels = redC.labels;
                redCells = vbc.task.redCells;
            }
            dst3.SetTo(0);
            for (int i = 1; i < redCells.Count(); i++)
            {
                var rc = redCells[i];
                rc.contour = ContourBuild(rc.mask, ContourApproximationModes.ApproxNone);
                DrawContour(rc.mask, rc.contour, cv.Scalar.All(255), -1);
                redCells[i] = rc;
                DrawContour(dst3[rc.rect], rc.contour, vecToScalar(rc.color), -1);
            }
        }
    }




    public class RedCloud_MaxDist_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        RedCloud_ContourUpdate addTour = new RedCloud_ContourUpdate();
        public RedCloud_MaxDist_CS()
        {
            desc = "Show the maxdist before and after updating the mask with the contour.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels = redC.labels;
            foreach (var rc in vbc.task.redCells)
            {
                DrawCircle(dst2, rc.maxDist, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            addTour.redCells = vbc.task.redCells;
            addTour.Run(src);
            dst3 = addTour.dst3;
            for (int i = 1; i < addTour.redCells.Count(); i++)
            {
                var rc = addTour.redCells[i];
                rc.maxDist = GetMaxDist(ref rc);
                DrawCircle(dst3, rc.maxDist, vbc.task.DotSize, vbc.task.HighlightColor);
            }
        }
    }




    public class RedCloud_Tiers_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Depth_Tiers tiers = new Depth_Tiers();
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        public RedCloud_Tiers_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Use the Depth_Tiers algorithm to create a color-based RedCloud";
        }
        public void RunAlg(Mat src)
        {
            binar4.Run(src);
            dst1 = ShowPalette((binar4.dst2 * 255 / binar4.classCount).ToMat());
            tiers.Run(src);
            dst3 = tiers.dst3;
            dst0 = tiers.dst2 + binar4.dst2;
            redC.Run(dst0);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class RedCloud_TiersBinarize_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Depth_Tiers tiers = new Depth_Tiers();
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        public RedCloud_TiersBinarize_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Use the Depth_Tiers with Bin4Way_Regions algorithm to create a color-based RedCloud";
        }
        public void RunAlg(Mat src)
        {
            binar4.Run(src);
            tiers.Run(src);
            dst2 = tiers.dst2 + binar4.dst2;
            redC.Run(dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }




    public class RedCloud_Combine_CS : VB_Parent
    {
        public Color8U_Basics colorClass = new Color8U_Basics();
        public GuidedBP_Depth guided = new GuidedBP_Depth();
        public RedCloud_Basics redMasks = new RedCloud_Basics();
        public List<rcData> combinedCells = new List<rcData>();
        Depth_MaxMask maxDepth = new Depth_MaxMask();
        RedCloud_Reduce prep = new RedCloud_Reduce();
        public RedCloud_Combine_CS()
        {
            desc = "Combined the color and cloud as indicated in the RedOptions panel.";
        }
        public void RunAlg(Mat src)
        {
            maxDepth.Run(src);
            if (vbc.task.redOptions.getUseColorOnly() || vbc.task.redOptions.getUseGuidedProjection())
            {
                redMasks.inputMask.SetTo(0);
                if (src.Channels() == 3)
                {
                    colorClass.Run(src);
                    dst2 = colorClass.dst2.Clone();
                }
                else
                {
                    dst2 = src;
                }
            }
            else
            {
                redMasks.inputMask = vbc.task.noDepthMask;
                dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            }
            if (vbc.task.redOptions.getUseDepth() || vbc.task.redOptions.getUseGuidedProjection())
            {
                switch (vbc.task.redOptions.depthInputIndex)
                {
                    case 0: // "GuidedBP_Depth"
                        guided.Run(src);
                        if (colorClass.classCount > 0) guided.dst2 += cv.Scalar.All(colorClass.classCount);
                        guided.dst2.CopyTo(dst2, vbc.task.depthMask);
                        break;
                    case 1: // "RedCloud_Reduce"
                        prep.Run(vbc.task.pointCloud);
                        if (colorClass.classCount > 0) prep.dst2 += cv.Scalar.All(colorClass.classCount);
                        prep.dst2.CopyTo(dst2, vbc.task.depthMask);
                        break;
                }
            }
            redMasks.Run(dst2);
            dst2 = redMasks.dst2;
            dst3 = redMasks.dst3;
            combinedCells.Clear();
            bool drawRectOnlyRun = vbc.task.drawRect.Width * vbc.task.drawRect.Height > 10;
            foreach (var rc in vbc.task.redCells)
            {
                if (drawRectOnlyRun && !vbc.task.drawRect.Contains(rc.floodPoint)) continue;
                combinedCells.Add(rc);
            }
        }
    }





    public class RedCloud_TopX_CS : VB_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Options_TopX options = new Options_TopX();
        public RedCloud_TopX_CS()
        {
            desc = "Show only the top X cells";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            redC.Run(src);
            dst2.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                dst2[rc.rect].SetTo(rc.color, rc.mask);
                if (rc.index > options.topX) break;
            }
            labels[2] = $"The top {options.topX} RedCloud cells by size.";
        }
    }




    public class RedCloud_TopXNeighbors_CS : VB_Parent
    {
        Options_TopX options = new Options_TopX();
        Neighbors_Precise nab = new Neighbors_Precise();
        public RedCloud_TopXNeighbors_CS()
        {
            nab.runRedCloud = true;
            desc = "Add unused neighbors to each of the top X cells";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            nab.Run(src);
            SetTrueText("Review the neighbors_Precise algorithm");
            // The commented code has been omitted for brevity
        }
    }




    public class RedCloud_TopXHulls_CS : VB_Parent
    {
        RedCloud_TopX topX = new RedCloud_TopX();
        public RedCloud_TopXHulls_CS()
        {
            desc = "Build the hulls for the top X RedCloud cells";
        }
        public void RunAlg(Mat src)
        {
            topX.Run(src);
            labels = topX.redC.labels;
            var newCells = new List<rcData>();
            vbc.task.cellMap.SetTo(0);
            dst2.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.contour.Count() >= 5)
                {
                    rc.hull = Cv2.ConvexHull(rc.contour.ToArray(), true).ToList();
                    DrawContour(dst2[rc.rect], rc.hull, vecToScalar(rc.color), -1);
                    DrawContour(rc.mask, rc.hull, cv.Scalar.All(255), -1);
                    vbc.task.cellMap[rc.rect].SetTo(rc.index, rc.mask);
                }
                newCells.Add(rc);
                if (rc.index > topX.options.topX) break;
            }
            vbc.task.redCells = new List<rcData>(newCells);
            vbc.task.setSelectedContour();
        }
    }




    public class RedCloud_Hue_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Color8U_Hue hue = new Color8U_Hue();
        public RedCloud_Hue_CS()
        {
            vbc.task.redOptions.setUseColorOnly(true);
            desc = "Run RedCloud on just the red hue regions.";
        }
        public void RunAlg(Mat src)
        {
            hue.Run(src);
            dst3 = hue.dst2;
            redC.inputMask = ~dst3;
            redC.Run(src);
            dst2 = redC.dst2;
        }
    }




    public class RedCloud_GenCellContains_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Flood_ContainedCells contains = new Flood_ContainedCells();
        public RedCloud_GenCellContains_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            desc = "Merge cells contained in the top X cells and remove all other cells.";
        }
        public void RunAlg(Mat src)
        {
            flood.Run(src);
            dst3 = flood.dst2;
            if (vbc.task.heartBeat) return;
            labels[2] = flood.labels[2];
            contains.Run(src);
            dst2.SetTo(0);
            int count = Math.Min(vbc.task.redOptions.identifyCount, vbc.task.redCells.Count());
            for (int i = 0; i < count; i++)
            {
                var rc = vbc.task.redCells[i];
                dst2[rc.rect].SetTo(rc.color, rc.mask);
                dst2.Rectangle(rc.rect, vbc.task.HighlightColor, vbc.task.lineWidth);
            }
            for (int i = vbc.task.redOptions.identifyCount; i < vbc.task.redCells.Count(); i++)
            {
                var rc = vbc.task.redCells[i];
                dst2[rc.rect].SetTo(vbc.task.redCells[rc.container].color, rc.mask);
            }
        }
    }




    public class RedCloud_PlusTiers_CS : VB_Parent
    {
        Depth_Tiers tiers = new Depth_Tiers();
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_PlusTiers_CS()
        {
            desc = "Add the depth tiers to the input for RedCloud_Basics.";
        }
        public void RunAlg(Mat src)
        {
            tiers.Run(src);
            binar4.Run(src);
            redC.Run(binar4.dst2 + tiers.dst2);
            dst2 = redC.dst2;
            labels = redC.labels;
        }
    }





    public class RedCloud_Depth_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        public RedCloud_Depth_CS()
        {
            vbc.task.redOptions.setUseDepth(true);
            desc = "Create RedCloud output using only depth.";
        }
        public void RunAlg(Mat src)
        {
            flood.Run(src);
            dst2 = flood.dst2;
            labels[2] = flood.labels[2];
        }
    }




    public class RedCloud_Consistent1_CS : VB_Parent
    {
        Bin3Way_RedCloud redC = new Bin3Way_RedCloud();
        Diff_Basics diff = new Diff_Basics();
        List<Mat> cellmaps = new List<Mat>();
        List<List<rcData>> cellLists = new List<List<rcData>>();
        List<Mat> diffs = new List<Mat>();
        public RedCloud_Consistent1_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.gOptions.pixelDiffThreshold = 1;
            desc = "Remove RedCloud results that are inconsistent with the previous frame.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            diff.Run(vbc.task.cellMap);
            dst1 = diff.dst2;
            cellLists.Add(new List<rcData>(vbc.task.redCells));
            cellmaps.Add(vbc.task.cellMap & ~dst1);
            diffs.Add(dst1.Clone());
            vbc.task.redCells.Clear();
            vbc.task.redCells.Add(new rcData());
            for (int i = 0; i < cellLists.Count(); i++)
            {
                foreach (var rc in cellLists[i])
                {
                    bool present = true;
                    for (int j = 0; j < cellmaps.Count(); j++)
                    {
                        var val = cellmaps[i].At<byte>(rc.maxDist.Y, rc.maxDist.X);
                        if (val == 0)
                        {
                            present = false;
                            break;
                        }
                    }
                    if (present)
                    {
                        rc.index = vbc.task.redCells.Count();
                        vbc.task.redCells.Add(rc);
                    }
                }
            }
            dst2.SetTo(0);
            vbc.task.cellMap.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                dst2[rc.rect].SetTo(rc.color, rc.mask);
                vbc.task.cellMap[rc.rect].SetTo(rc.index, rc.mask);
            }
            foreach (var mat in diffs)
            {
                dst2.SetTo(0, mat);
            }
            if (cellmaps.Count() > vbc.task.frameHistoryCount)
            {
                cellmaps.RemoveAt(0);
                cellLists.RemoveAt(0);
                diffs.RemoveAt(0);
            }
        }
    }




    public class RedCloud_Consistent2_CS : VB_Parent
    {
        Bin3Way_RedCloud redC = new Bin3Way_RedCloud();
        Diff_Basics diff = new Diff_Basics();
        List<Mat> cellmaps = new List<Mat>();
        List<List<rcData>> cellLists = new List<List<rcData>>();
        List<Mat> diffs = new List<Mat>();
        public RedCloud_Consistent2_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            vbc.task.gOptions.pixelDiffThreshold = 1;
            desc = "Remove RedCloud results that are inconsistent with the previous frame.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            diff.Run(vbc.task.cellMap);
            dst1 = diff.dst2;
            cellLists.Add(new List<rcData>(vbc.task.redCells));
            cellmaps.Add(vbc.task.cellMap & ~dst1);
            diffs.Add(dst1.Clone());
            vbc.task.redCells.Clear();
            vbc.task.redCells.Add(new rcData());
            for (int i = 0; i < cellLists.Count(); i++)
            {
                foreach (var rc in cellLists[i])
                {
                    bool present = true;
                    for (int j = 0; j < cellmaps.Count(); j++)
                    {
                        var val = cellmaps[i].At<byte>(rc.maxDist.Y, rc.maxDist.X);
                        if (val == 0)
                        {
                            present = false;
                            break;
                        }
                    }
                    if (present)
                    {
                        rc.index = vbc.task.redCells.Count();
                        vbc.task.redCells.Add(rc);
                    }
                }
            }
            dst2.SetTo(0);
            vbc.task.cellMap.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                dst2[rc.rect].SetTo(rc.color, rc.mask);
                vbc.task.cellMap[rc.rect].SetTo(rc.index, rc.mask);
            }
            foreach (var mat in diffs)
            {
                dst2.SetTo(0, mat);
            }
            if (cellmaps.Count() > vbc.task.frameHistoryCount)
            {
                cellmaps.RemoveAt(0);
                cellLists.RemoveAt(0);
                diffs.RemoveAt(0);
            }
        }
    }




    public class RedCloud_Consistent_CS : VB_Parent
    {
        Bin3Way_RedCloud redC = new Bin3Way_RedCloud();
        List<Mat> cellmaps = new List<Mat>();
        List<List<rcData>> cellLists = new List<List<rcData>>();
        Mat lastImage;
        public RedCloud_Consistent_CS()
        {
            lastImage = redC.dst2.Clone();
            desc = "Remove RedCloud results that are inconsistent with the previous frame(s).";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            cellLists.Add(new List<rcData>(vbc.task.redCells));
            cellmaps.Add(vbc.task.cellMap.Clone());
            List<rcData> newCells = new List<rcData>();
            newCells.Add(new rcData());
            foreach (var rc in vbc.task.redCells)
            {
                var maxDStable = rc.maxDStable;
                int count = 0;
                List<int> sizes = new List<int>();
                List<rcData> redData = new List<rcData>();
                for (int i = 0; i < cellmaps.Count(); i++)
                {
                    int index = cellmaps[i].Get<Byte>(rc.maxDStable.Y, rc.maxDStable.X);
                    if (cellLists[i][index].maxDStable == maxDStable)
                    {
                        count++;
                        sizes.Add(cellLists[i][index].pixels);
                        redData.Add(cellLists[i][index]);
                    }
                    else
                    {
                        break;
                    }
                }
                if (count == cellmaps.Count())
                {
                    int index = sizes.IndexOf(sizes.Max());
                    rcData rcNext = rc;
                    rcNext = redData[index];
                    var color = lastImage.Get<Vec3b>(rcNext.maxDStable.Y, rcNext.maxDStable.X);
                    if (color != black) rcNext.color = color;
                    rcNext.index = newCells.Count();
                    newCells.Add(rcNext);
                }
            }
            vbc.task.redCells = new List<rcData>(newCells);
            dst2 = DisplayCells();
            lastImage = dst2.Clone();
            if (cellmaps.Count() > vbc.task.frameHistoryCount)
            {
                cellmaps.RemoveAt(0);
                cellLists.RemoveAt(0);
            }
        }
    }




    public class RedCloud_NaturalColor_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_NaturalColor_CS()
        {
            desc = "Display the RedCloud results with the mean color of the cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            labels[2] = redC.labels[2];
            dst2 = DisplayCells();
        }
    }





    public class RedCloud_MotionBGsubtract_CS : VB_Parent
    {
        public BGSubtract_Basics bgSub = new BGSubtract_Basics();
        public List<rcData> redCells = new List<rcData>();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedCloud_MotionBGsubtract_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            vbc.task.gOptions.pixelDiffThreshold = 25;
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Use absDiff to build a mask of cells that changed.";
        }
        public void RunAlg(Mat src)
        {
            bgSub.Run(src);
            dst3 = bgSub.dst2;
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
            redCells.Clear();
            dst1.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                Mat tmp = rc.mask & bgSub.dst2[rc.rect];
                if (tmp.CountNonZero() > 0)
                {
                    dst1[rc.rect].SetTo(rc.color, rc.mask);
                    rc.motionFlag = true;
                }
                redCells.Add(rc);
            }
        }
    }




    public class RedCloud_JoinCells_CS : VB_Parent
    {
        FeatureLess_RedCloud fLess = new FeatureLess_RedCloud();
        public RedCloud_JoinCells_CS()
        {
            vbc.task.gOptions.setHistogramBins(20);
            labels = new string[] { "", "FeatureLess_RedCloud output.", "RedCloud_Basics output", "RedCloud_Basics cells joined by using the color from the FeatureLess_RedCloud cellMap" };
            desc = "Run RedCloud_Basics and use FeatureLess_RedCloud to join cells that are in the same featureless regions.";
        }
        public void RunAlg(Mat src)
        {
            fLess.Run(src);
            dst2 = fLess.dst2;
            labels[2] = fLess.labels[2];
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                var color = fLess.dst2.Get<Vec3b>(rc.maxDist.Y, rc.maxDist.X);
                dst3[rc.rect].SetTo(color, rc.mask);
            }
        }
    }




    public class RedCloud_LeftRight_CS : VB_Parent
    {
        Flood_LeftRight redC = new Flood_LeftRight();
        public RedCloud_LeftRight_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            desc = "Placeholder to make it easier to find where left and right images are floodfilled.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst1 = redC.dst1;
            dst2 = redC.dst2;
            dst3 = redC.dst3;
            labels = redC.labels;
        }
    }




    public class RedCloud_ColorAndDepth_CS : VB_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Flood_Basics floodPC = new Flood_Basics();
        List<rcData> colorCells = new List<rcData>();
        Mat colorMap;
        List<rcData> depthCells = new List<rcData>();
        Mat depthMap;
        int mousePicTag;
        public RedCloud_ColorAndDepth_CS()
        {
            colorMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            depthMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            mousePicTag = vbc.task.mousePicTag;
            vbc.task.redOptions.setIdentifyCells(false);
            desc = "Run Flood_Basics and use the cells to map the depth cells";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.redOptions.setUseColorOnly(true);
            vbc.task.redCells = new List<rcData>(colorCells);
            vbc.task.cellMap = colorMap.Clone();
            flood.Run(src);
            dst2 = flood.dst2;
            colorCells = new List<rcData>(vbc.task.redCells);
            colorMap = vbc.task.cellMap.Clone();
            labels[2] = flood.labels[2];
            vbc.task.redOptions.setUseDepth(true);
            vbc.task.redCells = new List<rcData>(depthCells);
            vbc.task.cellMap = depthMap.Clone();
            floodPC.Run(src);
            dst3 = floodPC.dst2;
            depthCells = new List<rcData>(vbc.task.redCells);
            depthMap = vbc.task.cellMap.Clone();
            labels[3] = floodPC.labels[2];
            if (vbc.task.mouseClickFlag) mousePicTag = vbc.task.mousePicTag;
            switch (mousePicTag)
            {
                case 1:
                    // setSelectedContour();
                    break;
                case 2:
                    vbc.task.setSelectedContour(ref colorCells, ref colorMap);
                    break;
                case 3:
                    vbc.task.setSelectedContour(ref depthCells, ref depthMap);
                    break;
            }
            dst2.Rectangle(vbc.task.rc.rect, vbc.task.HighlightColor, vbc.task.lineWidth);
            dst3[vbc.task.rc.rect].SetTo(Scalar.White, vbc.task.rc.mask);
        }
    }




    public class RedCloud_Delaunay_CS : VB_Parent
    {
        RedCloud_CPP_VB redCPP = new RedCloud_CPP_VB();
        Feature_Delaunay delaunay = new Feature_Delaunay();
        Color8U_Basics color;
        public RedCloud_Delaunay_CS()
        {
            desc = "Test Feature_Delaunay points after Delaunay contours have been added.";
        }
        public void RunAlg(Mat src)
        {
            delaunay.Run(src);
            dst1 = delaunay.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (src.Channels() != 1)
            {
                if (color == null) color = new Color8U_Basics();
                color.Run(src);
                src = color.dst2;
            }
            redCPP.inputMask = dst1;
            redCPP.Run(src);
            dst2 = redCPP.dst2;
            labels[2] = redCPP.labels[2];
        }
    }




    public class RedCloud_CPP_CS : VB_Parent
    {
        public Mat inputMask;
        public int classCount;
        public List<cv.Rect> rectList = new List<cv.Rect>();
        public List<cv.Point> floodPoints = new List<cv.Point>();
        Color8U_Basics color;
        public RedCloud_CPP_CS()
        {
            inputMask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            cPtr = RedCloud_Open();
            desc = "Run the C++ RedCloud interface with or without a mask";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
            {
                if (color == null) color = new Color8U_Basics();
                color.Run(src);
                src = color.dst2;
            }
            IntPtr imagePtr;
            byte[] inputData = new byte[src.Total()];
            Marshal.Copy(src.Data, inputData, 0, inputData.Length);
            GCHandle handleInput = GCHandle.Alloc(inputData, GCHandleType.Pinned);
            byte[] maskData = new byte[inputMask.Total()];
            Marshal.Copy(inputMask.Data, maskData, 0, maskData.Length);
            GCHandle handleMask = GCHandle.Alloc(maskData, GCHandleType.Pinned);
            imagePtr = RedCloud_Run(cPtr, handleInput.AddrOfPinnedObject(), handleMask.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleMask.Free();
            handleInput.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
            classCount = RedCloud_Count(cPtr);
            if (classCount == 0) return; // no data to process.
            Mat rectData = cv.Mat.FromPixelData(classCount, 1, MatType.CV_32SC4, RedCloud_Rects(cPtr));
            Mat floodPointData = cv.Mat.FromPixelData(classCount, 1, MatType.CV_32SC2, RedCloud_FloodPoints(cPtr));
            int[] rects = new int[classCount * 4];
            Marshal.Copy(rectData.Data, rects, 0, rects.Length);
            int[] ptList = new int[classCount * 2];
            Marshal.Copy(floodPointData.Data, ptList, 0, ptList.Length);
            rectList.Clear();
            for (int i = 0; i < rects.Length - 4; i += 4)
            {
                rectList.Add(new cv.Rect(rects[i], rects[i + 1], rects[i + 2], rects[i + 3]));
            }
            floodPoints.Clear();
            for (int i = 0; i < ptList.Length - 2; i += 2)
            {
                floodPoints.Add(new cv.Point(ptList[i], ptList[i + 1]));
            }
            if (standalone) dst3 = ShowPalette(dst2 * 255 / classCount);
            if (vbc.task.heartBeat) labels[2] = "CV_8U result with " + classCount.ToString() + " regions.";
            if (vbc.task.heartBeat) labels[3] = "Palette version of the data in dst2 with " + classCount.ToString() + " regions.";
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = RedCloud_Close(cPtr);
        }
    }




    public class RedCloud_MaxDist_CPP_CS : VB_Parent
    {
        public int classCount;
        public List<cv.Rect> RectList = new List<cv.Rect>();
        public List<cv.Point> floodPoints = new List<cv.Point>();
        public List<int> maxList = new List<int>();
        Color8U_Basics color = new Color8U_Basics();
        public RedCloud_MaxDist_CPP_CS()
        {
            cPtr = RedCloudMaxDist_Open();
            desc = "Run the C++ RedCloudMaxDist interface without a mask";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
            {
                color.Run(src);
                src = color.dst2;
            }
            if (vbc.task.heartBeat) maxList.Clear(); // reevaluate all cells.
            int[] maxArray = maxList.ToArray();
            GCHandle handleMaxList = GCHandle.Alloc(maxArray, GCHandleType.Pinned);
            RedCloudMaxDist_SetPoints(cPtr, maxList.Count() / 2, handleMaxList.AddrOfPinnedObject());
            handleMaxList.Free();
            IntPtr imagePtr;
            byte[] inputData = new byte[src.Total()];
            Marshal.Copy(src.Data, inputData, 0, inputData.Length);
            GCHandle handleInput = GCHandle.Alloc(inputData, GCHandleType.Pinned);
            imagePtr = RedCloudMaxDist_Run(cPtr, handleInput.AddrOfPinnedObject(), (IntPtr)0, src.Rows, src.Cols);
            handleInput.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
            dst3 = ShowPalette(dst2);
            classCount = RedCloudMaxDist_Count(cPtr);
            labels[2] = "CV_8U version with " + classCount.ToString() + " cells.";
            if (classCount == 0) return; // no data to process.
            Mat rectData = cv.Mat.FromPixelData(classCount, 1, MatType.CV_32SC4, RedCloudMaxDist_Rects(cPtr));
            Mat floodPointData = cv.Mat.FromPixelData(classCount, 1, MatType.CV_32SC2, RedCloudMaxDist_FloodPoints(cPtr));
            int[] rects = new int[classCount * 4];
            Marshal.Copy(rectData.Data, rects, 0, rects.Length);
            int[] ptList = new int[classCount * 2];
            Marshal.Copy(floodPointData.Data, ptList, 0, ptList.Length);
            for (int i = 0; i < rects.Length - 4; i += 4)
            {
                RectList.Add(new cv.Rect(rects[i], rects[i + 1], rects[i + 2], rects[i + 3]));
            }
            for (int i = 0; i < ptList.Length - 2; i += 2)
            {
                floodPoints.Add(new cv.Point(ptList[i], ptList[i + 1]));
            }
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = RedCloudMaxDist_Close(cPtr);
        }
    }





    public class RedCloud_Reduce_CS : VB_Parent
    {
        public int classCount;
        Options_RedCloudOther options = new Options_RedCloudOther();
        public RedCloud_Reduce_CS()
        {
            desc = "Reduction transform for the point cloud";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            vbc.task.pointCloud.ConvertTo(dst0, MatType.CV_32S, 1000 / options.reduceAmt);
            var split = dst0.Split();
            switch (vbc.task.redOptions.PointCloudReduction)
            {
                case 0: // "X Reduction"
                    dst0 = (split[0] * options.reduceAmt).ToMat();
                    break;
                case 1: // "Y Reduction"
                    dst0 = (split[1] * options.reduceAmt).ToMat();
                    break;
                case 2: // "Z Reduction"
                    dst0 = (split[2] * options.reduceAmt).ToMat();
                    break;
                case 3: // "XY Reduction"
                    dst0 = (split[0] * options.reduceAmt + split[1] * options.reduceAmt).ToMat();
                    break;
                case 4: // "XZ Reduction"
                    dst0 = (split[0] * options.reduceAmt + split[2] * options.reduceAmt).ToMat();
                    break;
                case 5: // "YZ Reduction"
                    dst0 = (split[1] * options.reduceAmt + split[2] * options.reduceAmt).ToMat();
                    break;
                case 6: // "XYZ Reduction"
                    dst0 = (split[0] * options.reduceAmt + split[1] * options.reduceAmt + split[2] * options.reduceAmt).ToMat();
                    break;
            }
            var mm = GetMinMax(dst0);
            dst2 = dst0 - cv.Scalar.All(mm.minVal);
            dst2 = dst2 * 255 / (mm.maxVal - mm.minVal);
            dst2.ConvertTo(dst2, MatType.CV_8U);
            labels[2] = "Reduced Pointcloud - reduction factor = " + options.reduceAmt.ToString() + " produced " + classCount.ToString() + " regions";
        }
    }




    public class RedCloud_NaturalGray_CS : VB_Parent
    {
        RedCloud_Consistent redC = new RedCloud_Consistent();
        Options_RedCloudOther options = new Options_RedCloudOther();
        public RedCloud_NaturalGray_CS()
        {
            desc = "Display the RedCloud results with the mean grayscale value of the cell +- delta";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            var rc = vbc.task.rc;
            var val = (int)(0.299 * rc.colorMean[0] + 0.587 * rc.colorMean[1] + 0.114 * rc.colorMean[2]);
            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst0 = dst1.InRange(val - options.range, val + options.range);
            var color = new Vec3b((byte)rc.colorMean[0], (byte)rc.colorMean[1], (byte)rc.colorMean[2]);
            dst3.SetTo(0);
            dst3.SetTo(Scalar.White, dst0);
        }
    }




    public class RedCloud_FeatureLessReduce_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        FeatureROI_Basics devGrid = new FeatureROI_Basics();
        public List<rcData> redCells = new List<rcData>();
        public Mat cellMap;
        AddWeighted_Basics addw = new AddWeighted_Basics();
        Options_RedCloudOther options = new Options_RedCloudOther();
        public RedCloud_FeatureLessReduce_CS()
        {
            cellMap = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Remove any cells which are in a featureless region - they are part of the neighboring (and often surrounding) region.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            devGrid.Run(src);
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            redCells.Clear();
            foreach (var rc in vbc.task.redCells)
            {
                var tmp = new Mat(rc.mask.Size(), MatType.CV_8U, cv.Scalar.All(0));
                devGrid.dst3[rc.rect].CopyTo(tmp, rc.mask);
                var count = tmp.CountNonZero();
                if (count == 0 || rc.pixels == 0) continue;
                if (count / rc.pixels < options.threshold)
                {
                    dst3[rc.rect].SetTo(rc.color, rc.mask);
                    rc.index = redCells.Count();
                    redCells.Add(rc);
                    cellMap[rc.rect].SetTo(rc.index, rc.mask);
                }
            }
            addw.src2 = devGrid.dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.Run(dst2);
            dst2 = addw.dst2;
            labels[3] = $"{redCells.Count()} cells after removing featureless cells that were part of their surrounding.  " +
                        $"{vbc.task.redCells.Count() - redCells.Count()} were removed.";
            vbc.task.setSelectedContour();
        }
    }




    public class RedCloud_Features_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Options_RedCloudFeatures options = new Options_RedCloudFeatures();
        public RedCloud_Features_CS()
        {
            desc = "Display And validate the keyPoints for each RedCloud cell";
        }
        Vec3b vbNearFar(float factor)
        {
            var nearYellow = new Vec3b(255, 0, 0);
            var farBlue = new Vec3b(0, 255, 255);
            if (float.IsNaN(factor)) return new Vec3b();
            if (factor > 1) factor = 1;
            if (factor < 0) factor = 0;
            return new Vec3b((byte)((1 - factor) * farBlue.Item0 + factor * nearYellow.Item0),
                                (byte)((1 - factor) * farBlue.Item1 + factor * nearYellow.Item1),
                                (byte)((1 - factor) * farBlue.Item2 + factor * nearYellow.Item2));
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            redC.Run(src);
            dst2 = redC.dst2;
            var rc = vbc.task.rc;
            dst0 = vbc.task.color;
            var correlationMat = new Mat();
            float correlationXtoZ = 0.0f, correlationYtoZ = 0.0f;
            dst3.SetTo(0);
            switch (options.selection)
            {
                case 0:
                    var pt = rc.maxDist;
                    dst2.Circle(pt, vbc.task.DotSize, vbc.task.HighlightColor, -1, LineTypes.AntiAlias);
                    labels[3] = "maxDist Is at (" + pt.X + ", " + pt.Y + ")";
                    break;
                case 1:
                    dst3[rc.rect].SetTo(vbNearFar((float)((rc.depthMean[2]) / vbc.task.MaxZmeters)), rc.mask);
                    labels[3] = "rc.depthMean(2) Is highlighted in dst2";
                    labels[3] = "Mean depth for the cell Is " + rc.depthMean[2].ToString("F3");
                    break;
                case 2:
                    Cv2.MatchTemplate(vbc.task.pcSplit[0][rc.rect], vbc.task.pcSplit[2][rc.rect], correlationMat, TemplateMatchModes.CCoeffNormed, rc.mask);
                    correlationXtoZ = correlationMat.Get<float>(0, 0);
                    labels[3] = "High correlation X to Z Is yellow, low correlation X to Z Is blue";
                    break;
                case 3:
                    Cv2.MatchTemplate(vbc.task.pcSplit[1][rc.rect], vbc.task.pcSplit[2][rc.rect], correlationMat, TemplateMatchModes.CCoeffNormed, rc.mask);
                    correlationYtoZ = correlationMat.Get<float>(0, 0);
                    labels[3] = "High correlation Y to Z Is yellow, low correlation Y to Z Is blue";
                    break;
            }
            if (options.selection == 2 || options.selection == 3)
            {
                dst3[rc.rect].SetTo(vbNearFar((options.selection == 2 ? correlationXtoZ : correlationYtoZ) + 1), rc.mask);
                SetTrueText("(" + correlationXtoZ.ToString("F3") + ", " + correlationYtoZ.ToString("F3") + ")", new cv.Point(rc.rect.X, rc.rect.Y), 3);
            }
            DrawContour(dst0[rc.rect], rc.contour, Scalar.Yellow);
            SetTrueText(labels[3], 3);
            labels[2] = "Highlighted feature = " + options.labelName;
        }
    }




    public class RedTrack_Basics_CS : VB_Parent
    {
        Cell_Basics stats = new Cell_Basics();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public RedTrack_Basics_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height) != new cv.Size(168, 94)) vbc.task.frameHistoryCount = 1;
            desc = "Get stats on each RedCloud cell.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            stats.Run(src);
            labels = stats.labels;
            dst2.SetTo(0);
            foreach (rcData rc in vbc.task.redCells)
            {
                DrawContour(dst2[rc.rect], rc.contour, vecToScalar(rc.color), -1);
                if (rc.index == vbc.task.rc.index) DrawContour(dst2[rc.rect], rc.contour, Scalar.White, -1);
            }
            strOut = stats.strOut;
            SetTrueText(strOut, 3);
        }
    }




    public class RedTrack_Lines_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        RedTrack_Basics track = new RedTrack_Basics();
        public RedTrack_Lines_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Identify and track the lines in an image as RedCloud Cells";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            if (vbc.task.heartBeat || vbc.task.motionFlag) dst3.SetTo(0);
            int index = 0;
            foreach (var lp in lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, cv.Scalar.All(255));
                index++;
                if (index > 10) break;
            }
            track.Run(dst3.Clone());
            dst0 = track.redC.dst0;
            dst1 = track.redC.dst1;
            dst2 = track.dst2;
        }
    }




    public class RedTrack_LineSingle_CS : VB_Parent
    {
        RedTrack_Basics track = new RedTrack_Basics();
        int leftMost, rightmost;
        cv.Point leftCenter, rightCenter;
        public RedTrack_LineSingle_CS()
        {
            desc = "Create a line between the rightmost and leftmost good feature to show camera motion";
        }
        int findNearest(cv.Point pt)
        {
            float bestDistance = float.MaxValue;
            int bestIndex = 0;
            foreach (var rc in vbc.task.redCells)
            {
                float d = (float)pt.DistanceTo(rc.maxDist);
                if (d < bestDistance)
                {
                    bestDistance = d;
                    bestIndex = rc.index;
                }
            }
            return bestIndex;
        }
        public void RunAlg(Mat src)
        {
            track.Run(src);
            dst0 = track.redC.dst0;
            dst1 = track.redC.dst1;
            dst2 = track.dst2;
            if (vbc.task.redCells.Count() == 0)
            {
                SetTrueText("No lines found to track.", 3);
                return;
            }
            var xList = new SortedList<int, int>(new CompareAllowIdenticalIntegerInverted());
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.index == 0) continue;
                xList.Add(rc.rect.X, rc.index);
            }
            int minLeft = xList.Count() / 4;
            int minRight = (xList.Count() - minLeft);
            if (leftMost == 0 || rightmost == 0 || leftMost == rightmost)
            {
                leftCenter = rightCenter; // force iteration...
                int iterations = 0;
                while (leftCenter.DistanceTo(rightCenter) < dst2.Width / 4)
                {
                    leftMost = msRNG.Next(minLeft, minRight);
                    rightmost = msRNG.Next(minLeft, minRight);
                    leftCenter = vbc.task.redCells[leftMost].maxDist;
                    rightCenter = vbc.task.redCells[rightmost].maxDist;
                    iterations++;
                    if (iterations > 10) return;
                }
            }
            leftMost = findNearest(leftCenter);
            leftCenter = vbc.task.redCells[leftMost].maxDist;
            rightmost = findNearest(rightCenter);
            rightCenter = vbc.task.redCells[rightmost].maxDist;
            DrawLine(dst2, leftCenter, rightCenter, Scalar.White);
            labels[2] = track.redC.labels[2];
        }
    }




    public class RedTrack_FeaturesKNN_CS : VB_Parent
    {
        public KNN_Basics knn = new KNN_Basics();
        public Feature_Stable feat = new Feature_Stable();
        public RedTrack_FeaturesKNN_CS()
        {
            labels = new string[] { "", "", "Output of Feature_Stable", "Grid of points to measure motion." };
            desc = "Use KNN with the good features in the image to create a grid of points";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            knn.queries = new List<cv.Point2f>(vbc.task.features);
            knn.Run(empty);
            dst3 = src.Clone();
            for (int i = 0; i < knn.neighbors.Count(); i++)
            {
                Point2f p1 = knn.queries[i];
                int index = knn.neighbors[i][knn.neighbors[i].Count() - 1];
                Point2f p2 = knn.trainInput[index];
                DrawCircle(dst3, p1, vbc.task.DotSize, Scalar.Yellow);
                DrawCircle(dst3, p2, vbc.task.DotSize, Scalar.Yellow);
                DrawLine(dst3, p1, p2, Scalar.White);
            }
            knn.trainInput = new List<cv.Point2f>(knn.queries);
        }
    }




    public class RedTrack_GoodCell_CS : VB_Parent
    {
        RedTrack_GoodCellInput good = new RedTrack_GoodCellInput();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public RedTrack_GoodCell_CS()
        {
            FindSlider("Feature Sample Size").Value = 100;
            desc = "Track the cells that have good features";
        }
        public void RunAlg(Mat src)
        {
            hulls.Run(src);
            dst2 = hulls.dst2;
            good.Run(src);
            dst3.SetTo(0);
            foreach (var pt in good.featureList)
            {
                DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.White);
            }
        }
    }




    public class RedTrack_GoodCells_CS : VB_Parent
    {
        RedTrack_GoodCellInput good = new RedTrack_GoodCellInput();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public RedTrack_GoodCells_CS()
        {
            desc = "Track the cells that have good features";
        }
        public void RunAlg(Mat src)
        {
            hulls.Run(src);
            dst2 = hulls.dst2.Clone();
            good.Run(src);
            dst3.SetTo(0);
            dst0 = src;
            var trackCells = new List<rcData>();
            var trackIndex = new List<int>();
            foreach (var pt in good.featureList)
            {
                int index = vbc.task.cellMap.Get<byte>((int)pt.Y, (int)pt.X);
                if (!trackIndex.Contains(index))
                {
                    var rc = vbc.task.redCells[index];
                    if (rc.hull == null) continue;
                    DrawContour(dst2[rc.rect], rc.hull, Scalar.White, -1);
                    trackIndex.Add(index);
                    DrawCircle(dst0, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                    DrawCircle(dst3, pt, vbc.task.DotSize, Scalar.White);
                    trackCells.Add(rc);
                }
            }
            labels[3] = "There were " + trackCells.Count() + " cells that could be tracked.";
        }
    }




    public class RedTrack_GoodCellInput_CS : VB_Parent
    {
        public KNN_Basics knn = new KNN_Basics();
        public Feature_Stable feat = new Feature_Stable();
        public List<cv.Point2f> featureList = new List<cv.Point2f>();
        Options_RedTrack options = new Options_RedTrack();
        public RedTrack_GoodCellInput_CS()
        {
            desc = "Use KNN to find good features to track";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            feat.Run(src);
            dst2 = feat.dst2;
            knn.queries = new List<cv.Point2f>(vbc.task.features);
            knn.Run(empty);
            featureList.Clear();
            for (int i = 0; i < knn.neighbors.Count(); i++)
            {
                var p1 = knn.queries[i];
                var index = knn.neighbors[i][0]; // find nearest
                var p2 = knn.trainInput[index];
                if (p1.DistanceTo(p2) < options.maxDistance) featureList.Add(p1);
            }
            knn.trainInput = new List<cv.Point2f>(knn.queries);
        }
    }




    public class RedTrack_Points_CS : VB_Parent
    {
        Line_Basics lines = new Line_Basics();
        RedTrack_Basics track = new RedTrack_Basics();
        public RedTrack_Points_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "RedCloudX_Track output", "Input to RedCloudX_Track" };
            desc = "Identify and track the end points of lines in an image of RedCloud Cells";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst3.SetTo(0);
            int index = 0;
            foreach (var lp in lines.lpList)
            {
                DrawCircle(dst3, lp.p1, vbc.task.DotSize, cv.Scalar.All(255));
                DrawCircle(dst3, lp.p2, vbc.task.DotSize, cv.Scalar.All(255));
                index++;
                if (index >= 10) break;
            }
            track.Run(dst3);
            dst0 = track.redC.dst0;
            dst1 = track.redC.dst1;
            dst2 = track.dst2;
        }
    }




    public class RedTrack_Features_CS : VB_Parent
    {
        Options_Flood options = new Options_Flood();
        Feature_Stable feat = new Feature_Stable();
        RedCloud_Basics redC = new RedCloud_Basics();
        public RedTrack_Features_CS()
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new string[] { "", "", "Output of Feature_Stable - input to RedCloud",
                            "Value Is correlation of x to y in contour points (0 indicates circular.)" };
            desc = "Similar to RedTrack_KNNPoints";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            if (vbc.task.heartBeat) dst2.SetTo(0);
            foreach (var pt in vbc.task.features)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, cv.Scalar.All(255));
            }
            redC.Run(dst2);
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.rect.X == 0 && rc.rect.Y == 0) continue;
                DrawContour(dst3[rc.rect], rc.contour, vecToScalar(rc.color), -1);
                if (rc.contour.Count() > 0) SetTrueText(shapeCorrelation(rc.contour).ToString(vbc.fmt3), new cv.Point(rc.rect.X, rc.rect.Y), 3);
            }
            SetTrueText("Move camera to see the value of this algorithm", 2);
            SetTrueText("Values are correlation of x to y.  Leans left (negative) or right (positive) or circular (neutral correlation.)", 3);
        }
    }




    public class Reduction_Basics_CS : VB_Parent
    {
        public int classCount;
        public Reduction_Basics_CS()
        {
            vbc.task.redOptions.enableReductionTypeGroup(true);
            vbc.task.redOptions.enableReductionSliders(true);
            desc = "Reduction: a simpler way to KMeans by reducing color resolution";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (vbc.task.redOptions.reductionType == "Use Bitwise Reduction")
            {
                var bits = vbc.task.redOptions.getBitReductionBar();
                classCount = (int)(255 / Math.Pow(2, bits));
                var zeroBits = Math.Pow(2, bits) - 1;
                dst2 = src & new Mat(src.Size(), src.Type(), Scalar.All(255 - zeroBits));
                dst2 = dst2 / zeroBits;
            }
            else if (vbc.task.redOptions.reductionType == "Use Simple Reduction")
            {
                var reductionVal = vbc.task.redOptions.getSimpleReductionBar();
                classCount = (int)Math.Ceiling((double)(255 / reductionVal));
                dst2 = src / reductionVal;
                labels[2] = "Reduced image - factor = " + vbc.task.redOptions.getSimpleReductionBar().ToString();
            }
            else
            {
                dst2 = src;
                labels[2] = "No reduction requested";
            }
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = classCount.ToString() + " colors after reduction";
        }
    }




    public class Reduction_Floodfill_CS : VB_Parent
    {
        public Reduction_Basics reduction = new Reduction_Basics();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Reduction_Floodfill_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            vbc.task.redOptions.setUseColorOnly(true);
            labels[2] = "Reduced input to floodfill";
            vbc.task.redOptions.setBitReductionBar(32);
            desc = "Use the reduction output as input to floodfill to get masks of cells.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = ShowPalette(reduction.dst2 * 255 / reduction.classCount);
            redC.Run(reduction.dst2);
            dst3 = redC.dst2;
            labels[3] = redC.labels[3];
        }
    }




    public class Reduction_HeatMapLines_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        public Line_Basics lines = new Line_Basics();
        public PointCloud_SetupSide setupSide = new PointCloud_SetupSide();
        public PointCloud_SetupTop setupTop = new PointCloud_SetupTop();
        Reduction_PointCloud reduction = new Reduction_PointCloud();
        public Reduction_HeatMapLines_CS()
        {
            labels[2] = "Gravity rotated Side View with detected lines";
            labels[3] = "Gravity rotated Top View width detected lines";
            desc = "Present both the top and side view to minimize pixel counts.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            heat.Run(src);
            lines.Run(heat.dst2);
            setupTop.Run(heat.dst2);
            dst2 = setupTop.dst2;
            dst2.SetTo(Scalar.White, lines.dst3);
            lines.Run(heat.dst3);
            setupSide.Run(heat.dst3);
            dst3 = setupSide.dst2;
            dst3.SetTo(Scalar.White, lines.dst3);
        }
    }




    public class Reduction_PointCloud_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        public Reduction_PointCloud_CS()
        {
            vbc.task.redOptions.checkSimpleReduction(true); ;
            vbc.task.redOptions.setBitReductionBar(20);
            labels = new string[] { "", "", "8-bit reduced depth", "Palettized output of the different depth levels found" };
            desc = "Use reduction to smooth depth data";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pcSplit[2];
            src *= 255 / vbc.task.MaxZmeters;
            src.ConvertTo(dst0, MatType.CV_32S);
            reduction.Run(dst0);
            reduction.dst2.ConvertTo(dst2, MatType.CV_32F);
            dst2.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2 * 255 / reduction.classCount);
        }
    }




    public class Reduction_XYZ_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Options_Reduction options = new Options_Reduction();
        public Reduction_XYZ_CS()
        {
            vbc.task.redOptions.setSimpleReductionBarMax(1000);
            vbc.task.redOptions.setBitReductionBar(400);
            desc = "Use reduction to slice the point cloud in 3 dimensions";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            Mat[] split = src.Split();
            for (int i = 0; i < split.Length; i++)
            {
                if (options.reduceXYZ[i])
                {
                    split[i] *= 1000;
                    split[i].ConvertTo(dst0, MatType.CV_32S);
                    reduction.Run(dst0);
                    mmData mm = GetMinMax(reduction.dst2);
                    reduction.dst2.ConvertTo(split[i], MatType.CV_32F);
                }
            }
            Cv2.Merge(split, dst3);
            dst3.SetTo(0, vbc.task.noDepthMask);
            SetTrueText("vbc.task.PointCloud (or 32fc3 input) has been reduced and is in dst3");
        }
    }




    public class Reduction_Edges_CS : VB_Parent
    {
        Edge_Laplacian edges = new Edge_Laplacian();
        Reduction_Basics reduction = new Reduction_Basics();
        public Reduction_Edges_CS()
        {
            vbc.task.redOptions.checkSimpleReduction(true); ;
            desc = "Get the edges after reducing the image.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2 * 255 / reduction.classCount;
            bool reductionRequested = true;
            if (vbc.task.redOptions.reductionType == "No Reduction") reductionRequested = false;
            labels[2] = reductionRequested ? "Reduced image" : "Original image";
            labels[3] = reductionRequested ? "Laplacian edges of reduced image" : "Laplacian edges of original image";
            edges.Run(dst2);
            dst3 = edges.dst2;
        }
    }




    public class Reduction_Histogram_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        public Reduction_Histogram_CS()
        {
            plot.createHistogram = true;
            plot.removeZeroEntry = false;
            labels = new string[] { "", "", "Reduction image", "Histogram of the reduction" };
            desc = "Visualize a reduction with a histogram";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2 * 255 / reduction.classCount;
            plot.Run(dst2);
            dst3 = plot.dst2;
            labels[2] = "ClassCount = " + reduction.classCount.ToString();
        }
    }




    public class Reduction_BGR_CS : VB_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Mat_4Click mats = new Mat_4Click();
        public Reduction_BGR_CS()
        {
            desc = "Reduce BGR image in parallel";
        }
        public void RunAlg(Mat src)
        {
            Mat[] split = src.Split();
            for (int i = 0; i <= 2; i++)
            {
                reduction.Run(split[i]);
                if (standaloneTest()) mats.mat[i] = ShowPalette(reduction.dst2 * 255 / reduction.classCount);
                split[0] = reduction.dst2.Clone();
            }
            if (standaloneTest())
            {
                mats.mat[3] = (mats.mat[0] + mats.mat[1] + mats.mat[2]);
                mats.Run(empty);
                dst3 = mats.dst2;
            }
            Cv2.Merge(split, dst2);
        }
    }




    public class Remap_Basics_CS : VB_Parent
    {
        public int direction = 3; // default to remap horizontally and vertically
        Mat mapx1, mapx2, mapx3;
        Mat mapy1, mapy2, mapy3;
        public Remap_Basics_CS()
        {
            mapx1 = new Mat(dst2.Size(), MatType.CV_32F);
            mapy1 = new Mat(dst2.Size(), MatType.CV_32F);
            mapx2 = new Mat(dst2.Size(), MatType.CV_32F);
            mapy2 = new Mat(dst2.Size(), MatType.CV_32F);
            mapx3 = new Mat(dst2.Size(), MatType.CV_32F);
            mapy3 = new Mat(dst2.Size(), MatType.CV_32F);
            for (int j = 0; j < mapx1.Rows; j++)
            {
                for (int i = 0; i < mapx1.Cols; i++)
                {
                    mapx1.Set<float>(j, i, i);
                    mapy1.Set<float>(j, i, dst2.Rows - j);
                    mapx2.Set<float>(j, i, dst2.Cols - i);
                    mapy2.Set<float>(j, i, j);
                    mapx3.Set<float>(j, i, dst2.Cols - i);
                    mapy3.Set<float>(j, i, dst2.Rows - j);
                }
            }
            desc = "Use remap to reflect an image in 4 directions.";
        }
        public void RunAlg(Mat src)
        {
            labels[2] = new[] { "Remap_Basics_CS - original", "Remap vertically", "Remap horizontally", "Remap horizontally and vertically" }[direction];
            switch (direction)
            {
                case 0:
                    dst2 = src;
                    break;
                case 1:
                    Cv2.Remap(src, dst2, mapx1, mapy1, InterpolationFlags.Nearest);
                    break;
                case 2:
                    Cv2.Remap(src, dst2, mapx2, mapy2, InterpolationFlags.Nearest);
                    break;
                case 3:
                    Cv2.Remap(src, dst2, mapx3, mapy3, InterpolationFlags.Nearest);
                    break;
            }
            if (vbc.task.heartBeat)
            {
                direction += 1;
                direction %= 4;
            }
        }
    }




    public class Remap_Flip_CS : VB_Parent
    {
        public int direction = 0;
        public Remap_Flip_CS()
        {
            desc = "Use flip to remap an image.";
        }
        public void RunAlg(Mat src)
        {
            labels[2] = new[] { "Remap_Flip_CS - original", "Remap_Flip_CS - flip horizontal", "Remap_Flip_CS - flip vertical", "Remap_Flip_CS - flip horizontal and vertical" }[direction];
            switch (direction)
            {
                case 0: // do nothing!
                    src.CopyTo(dst2);
                    break;
                case 1: // flip vertically
                    Cv2.Flip(src, dst2, FlipMode.Y);
                    break;
                case 2: // flip horizontally
                    Cv2.Flip(src, dst2, FlipMode.X);
                    break;
                case 3: // flip horizontally and vertically
                    Cv2.Flip(src, dst2, FlipMode.XY);
                    break;
            }
            if (vbc.task.heartBeat)
            {
                direction += 1;
                direction %= 4;
            }
        }
    }




    public class Flip_Basics_CS : VB_Parent
    {
        Remap_Flip flip = new Remap_Flip();
        public Flip_Basics_CS()
        {
            desc = "Placeholder to make it easy to remember 'Remap'.";
        }
        public void RunAlg(Mat src)
        {
            flip.RunAlg(src);
            dst2 = flip.dst2;
            labels = flip.labels;
        }
    }




    public class Resize_Basics_CS : VB_Parent
    {
        public cv.Size newSize;
        public Options_Resize options = new Options_Resize();
        public Resize_Basics_CS()
        {
            if (standaloneTest())
                vbc.task.drawRect = new cv.Rect(dst2.Width / 4, dst2.Height / 4, dst2.Width / 2, dst2.Height / 2);
            desc = "Resize with different options and compare them";
            labels[2] = "Rectangle highlight above resized";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.drawRect.Width != 0)
            {
                src = src[vbc.task.drawRect];
                newSize = vbc.task.drawRect.Size;
            }
            dst2 = src.Resize(newSize, 0, 0, options.warpFlag);
        }
    }




    public class Resize_Smaller_CS : VB_Parent
    {
        public Options_Resize options = new Options_Resize();
        public cv.Size newSize;
        public Options_GridFromResize optGrid = new Options_GridFromResize();
        public Resize_Smaller_CS()
        {
            desc = "Resize by a percentage of the image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            newSize = new cv.Size((int)Math.Ceiling(src.Width * optGrid.lowResPercent), 
                                  (int)Math.Ceiling(src.Height * optGrid.lowResPercent));
            dst2 = src.Resize(newSize, 0, 0, options.warpFlag);
            labels[2] = "Image after resizing to: " + newSize.Width + "X" + newSize.Height;
        }
    }




    public class Resize_Proportional_CS : VB_Parent
    {
        Options_Spectrum options = new Options_Spectrum();
        public Resize_Proportional_CS()
        {
            desc = "Resize the input but keep the results proportional to the original.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                options.RunOpt();
                dst2 = options.runRedCloud(ref labels[2]);
                src = src[vbc.task.rc.rect];
            }
            cv.Size newSize;
            if (dst0.Width / (double)dst0.Height < src.Width / (double)src.Height)
            {
                newSize = new cv.Size(dst2.Width, dst2.Height * dst0.Height / dst0.Width);
            }
            else
            {
                newSize = new cv.Size(dst2.Width * dst0.Height / dst0.Width, dst2.Height);
            }
            src = src.Resize(newSize, 0, 0, InterpolationFlags.Nearest);
            var newRect = new cv.Rect(0, 0, newSize.Width, newSize.Height);
            dst3.SetTo(0);
            src.CopyTo(dst3[newRect]);
        }
    }




    public class Retina_Basics_CPP_CS : VB_Parent
    {
        ProcessStartInfo startInfo = new ProcessStartInfo();
        byte[] magnoData = new byte[1];
        byte[] dataSrc = new byte[1];
        float samplingFactor = -1; // force open
        Options_Retina options = new Options_Retina();
        bool saveUseLogSampling;
        public Retina_Basics_CPP_CS()
        {
            labels[2] = "Retina Parvo";
            labels[3] = "Retina Magno";
            desc = "Use the bio-inspired retina algorithm to adjust color and monitor motion.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.xmlCheck)
            {
                var fileinfo = new FileInfo(Path.Combine(Directory.GetCurrentDirectory(), "RetinaDefaultParameters.xml"));
                if (fileinfo.Exists)
                {
                    File.Copy(Path.Combine(Directory.GetCurrentDirectory(), "RetinaDefaultParameters.xml"), Path.Combine(vbc.task.HomeDir, "data/RetinaDefaultParameters.xml"), true);
                    startInfo.FileName = "wordpad.exe";
                    startInfo.Arguments = Path.Combine(vbc.task.HomeDir, "Data/RetinaDefaultParameters.xml");
                    Process.Start(startInfo);
                }
                else
                {
                    MessageBox.Show("RetinaDefaultParameters.xml should have been created but was not found.  OpenCV error?");
                }
            }
            if (saveUseLogSampling != options.useLogSampling || samplingFactor != options.sampleFactor)
            {
                if (cPtr != (IntPtr)0) Retina_Basics_Close(cPtr);
                Array.Resize(ref magnoData, (int)(src.Total() - 1));
                Array.Resize(ref dataSrc, (int)(src.Total() * src.ElemSize() - 1));
                saveUseLogSampling = options.useLogSampling;
                samplingFactor = options.sampleFactor;
                if (!vbc.task.testAllRunning) cPtr = Retina_Basics_Open(src.Rows, src.Cols, options.useLogSampling, samplingFactor);
            }
            GCHandle handleMagno = GCHandle.Alloc(magnoData, GCHandleType.Pinned);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = IntPtr.Zero;
            if (!vbc.task.testAllRunning)
            {
                Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
                int logSampling = options.useLogSampling ? 1 : 0;
                imagePtr = Retina_Basics_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols,
                                                handleMagno.AddrOfPinnedObject(), logSampling);
            }
            else
            {
                SetTrueText("Retina_Basics_CS runs fine but during 'Test All' it is not run because it can oversubscribe OpenCL memory.");
                dst3= new cv.Mat(dst2.Rows, dst2.Cols, MatType.CV_8UC1, cv.Scalar.All(0));
            }
            handleSrc.Free();
            handleMagno.Free();
            if (imagePtr != IntPtr.Zero)
            {
                float nextFactor = samplingFactor;
                if (!options.useLogSampling) nextFactor = 1;
                dst2 = cv.Mat.FromPixelData(src.Rows / (int)nextFactor, src.Cols / (int)nextFactor, MatType.CV_8UC3, imagePtr).Resize(src.Size()).Clone();
                dst3 = cv.Mat.FromPixelData(src.Rows / (int)nextFactor, src.Cols / (int)nextFactor, MatType.CV_8U, magnoData).Resize(src.Size());
            }
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = Retina_Basics_Close(cPtr);
        }
    }




    public class Retina_Depth_CS : VB_Parent
    {
        Retina_Basics_CPP_VB retina = new Retina_Basics_CPP_VB();
        Mat lastMotion = new Mat();
        public Retina_Depth_CS()
        {
            desc = "Use the bio-inspired retina algorithm with the depth data.";
            labels[2] = "Last result || current result";
            labels[3] = "Current depth motion result";
        }
        public void RunAlg(Mat src)
        {
            retina.Run(vbc.task.depthRGB);
            dst3 = retina.dst3;
            if (lastMotion.Width == 0) lastMotion = retina.dst3;
            dst2 = lastMotion | retina.dst3;
            lastMotion = retina.dst3;
        }
    }




    public class ROI_Basics_CS : VB_Parent
    {
        public Diff_Basics diff = new Diff_Basics();
        public cv.Rect aoiRect;
        public ROI_Basics_CS()
        {
            labels = new string[] { "", "", "Enclosing rectangle of all pixels that have changed", "" };
            dst1 = new Mat(dst2.Size(), MatType.CV_8UC1, cv.Scalar.All(0));
            vbc.task.gOptions.pixelDiffThreshold = 30;
            desc = "Find the motion ROI in the latest image.";
        }
        public void RunAlg(Mat src)
        {
            diff.Run(src);
            dst2 = diff.dst2;
            var split = diff.dst2.FindNonZero().Split();
            if (split.Length == 0) return;
            var mm0 = GetMinMax(split[0]);
            var mm1 = GetMinMax(split[1]);
            aoiRect = new cv.Rect((int)mm0.minVal, (int)mm1.minVal, (int)(mm0.maxVal - mm0.minVal), (int)(mm1.maxVal - mm1.minVal));
            if (aoiRect.Width > 0 && aoiRect.Height > 0)
            {
                vbc.task.color.Rectangle(aoiRect, Scalar.Yellow, vbc.task.lineWidth);
                dst2.Rectangle(aoiRect, Scalar.White, vbc.task.lineWidth);
            }
        }
    }




    public class ROI_FindNonZeroNoSingle_CS : VB_Parent
    {
        public Diff_Basics diff = new Diff_Basics();
        public cv.Rect aoiRect;
        public ROI_FindNonZeroNoSingle_CS()
        {
            labels = new string[] { "", "", "Enclosing rectangle of all changed pixels (after removing single pixels)", "" };
            dst1 = new Mat(dst2.Size(), MatType.CV_8UC1, cv.Scalar.All(0));
            vbc.task.gOptions.pixelDiffThreshold = 30;
            desc = "Find the motion ROI in just the latest image - eliminate single pixels";
        }
        public void RunAlg(Mat src)
        {
            diff.Run(src);
            dst2 = diff.dst2;
            var tmp = diff.dst2.FindNonZero();
            if (tmp.Rows == 0) return;
            int minX = int.MaxValue, maxX = int.MinValue, minY = int.MaxValue, maxY = int.MinValue;
            for (int i = 0; i < tmp.Rows; i++)
            {
                var pt = tmp.Get<cv.Point>(i, 0);
                // eliminate single pixel differences.
                var r = new cv.Rect(pt.X - 1, pt.Y - 1, 3, 3);
                if (r.X < 0) r.X = 0;
                if (r.Y < 0) r.Y = 0;
                if (r.X + r.Width < dst2.Width && r.Y + r.Height < dst2.Height)
                {
                    if (dst2[r].CountNonZero() > 1)
                    {
                        if (minX > pt.X) minX = pt.X;
                        if (maxX < pt.X) maxX = pt.X;
                        if (minY > pt.Y) minY = pt.Y;
                        if (maxY < pt.Y) maxY = pt.Y;
                    }
                }
            }
            if (minX != int.MaxValue)
            {
                aoiRect = new cv.Rect(minX, minY, maxX - minX + 1, maxY - minY + 1);
                vbc.task.color.Rectangle(aoiRect, Scalar.Yellow, vbc.task.lineWidth);
                dst2.Rectangle(aoiRect, Scalar.White, vbc.task.lineWidth);
            }
        }
    }




    public class ROI_AccumulateOld_CS : VB_Parent
    {
        public Diff_Basics diff = new Diff_Basics();
        public cv.Rect aoiRect;
        public int minX = int.MaxValue, maxX = int.MinValue, minY = int.MaxValue, maxY = int.MinValue;
        Options_ROI options = new Options_ROI();
        public ROI_AccumulateOld_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Area of Interest", "" };
            dst1 = new Mat(dst2.Size(), MatType.CV_8UC1, cv.Scalar.All(0));
            vbc.task.gOptions.pixelDiffThreshold = 30;
            desc = "Accumulate pixels in a motion ROI - all pixels that are different by X";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (aoiRect.Width * aoiRect.Height > src.Total() * options.roiPercent || vbc.task.optionsChanged)
            {
                dst0 = vbc.task.color;
                dst1.SetTo(0);
                aoiRect = new cv.Rect();
                minX = int.MaxValue;
                maxX = int.MinValue;
                minY = int.MaxValue;
                maxY = int.MinValue;
            }
            diff.Run(src);
            dst3 = diff.dst2;
            Cv2.BitwiseOr(dst3, dst1, dst1);
            var tmp = dst3.FindNonZero();
            if (aoiRect != new cv.Rect())
            {
                vbc.task.color[aoiRect].CopyTo(dst0[aoiRect]);
                dst0.Rectangle(aoiRect, Scalar.Yellow, vbc.task.lineWidth);
                dst2.Rectangle(aoiRect, Scalar.White, vbc.task.lineWidth);
            }
            if (tmp.Rows == 0) return;
            for (int i = 0; i < tmp.Rows; i++)
            {
                var pt = tmp.Get<cv.Point>(i, 0);
                if (minX > pt.X) minX = pt.X;
                if (maxX < pt.X) maxX = pt.X;
                if (minY > pt.Y) minY = pt.Y;
                if (maxY < pt.Y) maxY = pt.Y;
            }
            aoiRect = new cv.Rect(minX, minY, maxX - minX + 1, maxY - minY + 1);
            dst1.CopyTo(dst2);
            dst2.Rectangle(aoiRect, Scalar.White, vbc.task.lineWidth);
        }
    }




    public class ROI_Accumulate_CS : VB_Parent
    {
        public Diff_Basics diff = new Diff_Basics();
        cv.Rect roiRect;
        Options_ROI options = new Options_ROI();
        public ROI_Accumulate_CS()
        {
            labels = new string[] { "", "", "Area of Interest", "" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8UC1, cv.Scalar.All(0));
            vbc.task.gOptions.pixelDiffThreshold = 30;
            desc = "Accumulate pixels in a motion ROI until the size is x% of the total image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            SetTrueText(traceName + " is the same as ROI_AccumulateOld_CS but simpler.", 3);
            if (roiRect.Width * roiRect.Height > src.Total() * options.roiPercent || vbc.task.optionsChanged)
            {
                dst2.SetTo(0);
                roiRect = new cv.Rect();
            }
            diff.Run(src);
            var split = diff.dst2.FindNonZero().Split();
            if (split.Length > 0)
            {
                var mm0 = GetMinMax(split[0]);
                var mm1 = GetMinMax(split[1]);
                var motionRect = new cv.Rect((int)mm0.minVal, (int)mm1.minVal, (int)(mm0.maxVal - mm0.minVal),
                                                (int)(mm1.maxVal - mm1.minVal));
                if (motionRect.Width != 0 && motionRect.Height != 0)
                {
                    if (roiRect.X > 0 || roiRect.Y > 0) roiRect = motionRect.Union(roiRect);
                    else roiRect = motionRect;
                    Cv2.BitwiseOr(diff.dst2, dst2, dst2);
                }
            }
            dst2.Rectangle(roiRect, Scalar.White, vbc.task.lineWidth);
            vbc.task.color.Rectangle(roiRect, vbc.task.HighlightColor, vbc.task.lineWidth);
        }
    }




    public class Rotate_Basics_CS : VB_Parent
    {
        public Mat M;
        public Mat Mflip;
        public Options_Resize options = new Options_Resize();
        public double rotateAngle = 1000;
        public Point2f rotateCenter;
        Options_Rotate optionsRotate = new Options_Rotate();
        public Rotate_Basics_CS()
        {
            rotateCenter = new Point2f(dst2.Width / 2, dst2.Height / 2);
            desc = "Rotate a rectangle by a specified angle";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsRotate.RunOpt();
            rotateAngle = optionsRotate.rotateAngle;
            M = Cv2.GetRotationMatrix2D(rotateCenter, -rotateAngle, 1);
            dst2 = src.WarpAffine(M, src.Size(), options.warpFlag);
            if (options.warpFlag == InterpolationFlags.WarpInverseMap)
            {
                Mflip = Cv2.GetRotationMatrix2D(rotateCenter, rotateAngle, 1);
            }
        }
    }





    public class Rotate_BasicsQT_CS : VB_Parent
    {
        public float rotateAngle = 24;
        public Point2f rotateCenter;
        public Rotate_BasicsQT_CS()
        {
            rotateCenter = new Point2f(dst2.Width / 2, dst2.Height / 2);
            desc = "Rotate a rectangle by a specified angle";
        }
        public void RunAlg(Mat src)
        {
            var M = Cv2.GetRotationMatrix2D(rotateCenter, -rotateAngle, 1);
            dst2 = src.WarpAffine(M, src.Size(), InterpolationFlags.Nearest);
        }
    }




    public class Rotate_Box_CS : VB_Parent
    {
        readonly Rotate_Basics rotation = new Rotate_Basics();
        public Rotate_Box_CS()
        {
            vbc.task.drawRect = new cv.Rect(100, 100, 100, 100);
            labels[2] = "Original Rectangle in the original perspective";
            labels[3] = "Same Rectangle in the new warped perspective";
            desc = "Track a rectangle no matter how the perspective is warped.  Draw a rectangle anywhere.";
        }
        public void RunAlg(Mat src)
        {
            rotation.Run(src);
            dst3 = dst2.Clone();
            var r = vbc.task.drawRect;
            dst2 = src.Clone();
            dst2.Rectangle(r, Scalar.White, 1);
            var center = new Point2f(r.X + r.Width / 2, r.Y + r.Height / 2);
            var drawBox = new RotatedRect(center, new Size2f(r.Width, r.Height), 0);
            var boxPoints = Cv2.BoxPoints(drawBox);
            var srcPoints = cv.Mat.FromPixelData(1, 4, MatType.CV_32FC2, boxPoints);
            var dstpoints = new Mat();
            if (rotation.options.warpFlag != InterpolationFlags.WarpInverseMap)
            {
                Cv2.Transform(srcPoints, dstpoints, rotation.M);
            }
            else
            {
                Cv2.Transform(srcPoints, dstpoints, rotation.Mflip);
            }
            for (int i = 0; i < dstpoints.Width - 1; i++)
            {
                var p1 = dstpoints.Get<cv.Point2f>(0, i);
                var p2 = dstpoints.Get<cv.Point2f>(0, (i + 1) % 4);
                DrawLine(dst3, p1, p2, Scalar.White, vbc.task.lineWidth + 1);
            }
        }
    }




    public class Rotate_Poly_CS : VB_Parent
    {
        Options_FPoly optionsFPoly = new Options_FPoly();
        public Options_RotatePoly options = new Options_RotatePoly();
        public Rotate_PolyQT rotateQT = new Rotate_PolyQT();
        List<cv.Point2f> rPoly = new List<cv.Point2f>();
        public Rotate_Poly_CS()
        {
            labels = new[] { "", "", "Triangle before rotation", "Triangle after rotation" };
            desc = "Rotate a triangle around a center of rotation";
        }
        public void RunAlg(Mat src)
        {
            optionsFPoly.RunOpt();
            if (options.changeCheck.Checked || vbc.task.FirstPass)
            {
                rPoly.Clear();
                for (int i = 0; i < vbc.task.polyCount; i++)
                {
                    rPoly.Add(new Point2f(msRNG.Next(dst2.Width / 4, dst2.Width * 3 / 4), msRNG.Next(dst2.Height / 4, dst2.Height * 3 / 4)));
                }
                rotateQT.rotateCenter = new Point2f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                options.changeCheck.Checked = false;
            }
            rotateQT.poly = new List<cv.Point2f>(rPoly);
            rotateQT.rotateAngle = options.angleSlider.Value;
            rotateQT.Run(src);
            dst2 = rotateQT.dst3;
            DrawCircle(dst2, rotateQT.rotateCenter, vbc.task.DotSize + 2, Scalar.Yellow);
            SetTrueText("center of rotation", new cv.Point(rotateQT.rotateCenter.X, rotateQT.rotateCenter.Y));
            labels[3] = rotateQT.labels[3];
        }
    }




    public class Rotate_PolyQT_CS : VB_Parent
    {
        public List<cv.Point2f> poly = new List<cv.Point2f>();
        public Point2f rotateCenter;
        public float rotateAngle;
        public Rotate_PolyQT_CS()
        {
            labels = new string[] { "", "", "Polygon before rotation", "" };
            desc = "Rotate a triangle around a center of rotation";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(0);
                dst3.SetTo(0);
            }
            if (standaloneTest())
            {
                SetTrueText(traceName + " has no output when run standaloneTest().");
                return;
            }
            DrawFPoly(ref dst2, poly, Scalar.Red);
            labels[3] = "White is the original polygon, yellow has been rotated " + (rotateAngle * 57.2958).ToString() + " degrees";
            // translate so the center of rotation is 0,0
            List<cv.Point2f> translated = new List<cv.Point2f>();
            for (int i = 0; i < poly.Count(); i++)
            {
                Point2f pt = poly[i];
                translated.Add(new Point2f(poly[i].X - rotateCenter.X, poly[i].Y - rotateCenter.Y));
            }
            List<cv.Point2f> rotated = new List<cv.Point2f>();
            for (int i = 0; i < poly.Count(); i++)
            {
                Point2f pt = translated[i];
                float x = pt.X * (float)Math.Cos(rotateAngle) - pt.Y * (float)Math.Sin(rotateAngle);
                float y = pt.Y * (float)Math.Cos(rotateAngle) + pt.X * (float)Math.Sin(rotateAngle);
                rotated.Add(new Point2f(x, y));
            }
            DrawFPoly(ref dst3, poly, Scalar.White);
            poly.Clear();
            foreach (Point2f pt in rotated)
            {
                poly.Add(new Point2f(pt.X + rotateCenter.X, pt.Y + rotateCenter.Y));
            }
            DrawFPoly(ref dst3, poly, Scalar.Yellow);
        }
    }




    public class Rotate_Example_CS : VB_Parent
    {
        Rotate_Basics rotate = new Rotate_Basics();
        public Rotate_Example_CS()
        {
            rotate.rotateCenter = new cv.Point(dst2.Height / 2, dst2.Height / 2);
            rotate.rotateAngle = -90;
            desc = "Reminder on how to rotate an image and keep all the pixels.";
        }
        public void RunAlg(Mat src)
        {
            cv.Rect r = new cv.Rect(0, 0, src.Height, src.Height);
            dst2[r] = src.Resize(new cv.Size(src.Height, src.Height));
            rotate.Run(dst2);
            dst3[r] = rotate.dst2[new cv.Rect(0, 0, src.Height, src.Height)];
        }
    }




    public class Rotate_Horizon_CS : VB_Parent
    {
        Rotate_Basics rotate = new Rotate_Basics();
        CameraMotion_WithRotation edges = new CameraMotion_WithRotation();
        public Rotate_Horizon_CS()
        {
            FindSlider("Rotation Angle in degrees").Value = 3;
            labels[2] = "White is the current horizon vector of the camera.  Highlighted color is the rotated horizon vector.";
            desc = "Rotate the horizon independently from the rotation of the image to validate the Edge_CameraMotion algorithm.";
        }
        Point2f RotatePoint(Point2f point, Point2f center, double angle)
        {
            double radians = angle * (Math.PI / 180.0);
            double sinAngle = Math.Sin(radians);
            double cosAngle = Math.Cos(radians);
            double x = point.X - center.X;
            double y = point.Y - center.Y;
            double xNew = x * cosAngle - y * sinAngle;
            double yNew = x * sinAngle + y * cosAngle;
            xNew += center.X;
            yNew += center.Y;
            return new Point2f((float)xNew, (float)yNew);
        }
        public void RunAlg(Mat src)
        {
            rotate.Run(src);
            dst2 = rotate.dst2.Clone();
            dst1 = dst2.Clone();
            PointPair horizonVec = new PointPair(vbc.task.horizonVec.p1, vbc.task.horizonVec.p2);
            horizonVec.p1 = RotatePoint(vbc.task.horizonVec.p1, rotate.rotateCenter, -rotate.rotateAngle);
            horizonVec.p2 = RotatePoint(vbc.task.horizonVec.p2, rotate.rotateCenter, -rotate.rotateAngle);
            DrawLine(dst2, horizonVec.p1, horizonVec.p2, vbc.task.HighlightColor);
            DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, Scalar.White);
            double y1 = horizonVec.p1.Y - vbc.task.horizonVec.p1.Y;
            double y2 = horizonVec.p2.Y - vbc.task.horizonVec.p2.Y;
            edges.translateRotateY((int)y1, (int)y2);
            rotate.rotateAngle = edges.rotationY;
            rotate.rotateCenter = new cv.Point(edges.centerY.X, edges.centerY.Y);
            rotate.Run(dst1);
            dst3 = rotate.dst2.Clone();
            strOut = edges.strOut;
        }
    }




    public class Salience_Basics_CPP_CS : VB_Parent
    {
        byte[] grayData = new byte[1];
        public Options_Salience options = new Options_Salience();
        public Salience_Basics_CPP_CS()
        {
            cPtr = Salience_Open();
            desc = "Show results of Salience algorithm when using C++";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (src.Total() != grayData.Length) Array.Resize(ref grayData, (int)src.Total());
            GCHandle grayHandle = GCHandle.Alloc(grayData, GCHandleType.Pinned);
            Marshal.Copy(src.Data, grayData, 0, grayData.Length);
            IntPtr imagePtr = Salience_Run(cPtr, options.numScales, grayHandle.AddrOfPinnedObject(), src.Height, src.Width);
            grayHandle.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Salience_Close(cPtr);
        }
    }




    public class Salience_Basics_MT_CPP_CS : VB_Parent
    {
        Salience_Basics_CPP_VB salience = new Salience_Basics_CPP_VB();
        public Salience_Basics_MT_CPP_CS()
        {
            FindSlider("Salience numScales").Value = 2;
            desc = "Show results of multi-threaded Salience algorithm when using C++.  NOTE: salience is relative.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            int threads = 32;
            int h = src.Height / threads;
            dst2 = new Mat(dst2.Rows, dst2.Cols, MatType.CV_8U, new cv.Scalar(0));
            Parallel.For(0, threads, i =>
            {
                cv.Rect roi = new cv.Rect(0, i * h, src.Width, Math.Min(h, src.Height - i * h));
                if (roi.Height <= 0) return;
                IntPtr cPtr = Salience_Open();
                Mat input = src[roi].Clone();
                byte[] grayData = new byte[input.Total()];
                GCHandle grayHandle = GCHandle.Alloc(grayData, GCHandleType.Pinned);
                Marshal.Copy(input.Data, grayData, 0, grayData.Length);
                IntPtr imagePtr = Salience_Run(cPtr, salience.options.numScales, grayHandle.AddrOfPinnedObject(), roi.Height, roi.Width);
                grayHandle.Free();
                dst2[roi] = cv.Mat.FromPixelData(roi.Height, roi.Width, cv.MatType.CV_8U, imagePtr).Clone();
                if (cPtr != IntPtr.Zero) cPtr = Salience_Close(cPtr);
            });
        }
    }




    public class Sides_Basics_CS : VB_Parent
    {
        public Profile_Basics sides = new Profile_Basics();
        public Contour_RedCloudCorners corners = new Contour_RedCloudCorners();
        public Sides_Basics_CS()
        {
            labels = new string[] { "", "", "RedCloud output", "Selected Cell showing the various extrema." };
            desc = "Find the 6 extrema and the 4 farthest points in each quadrant for the selected RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            sides.Run(src);
            dst2 = sides.dst2;
            dst3 = sides.dst3;
            var cornersList = sides.corners.ToList();
            for (int i = 0; i < cornersList.Count(); i++)
            {
                var nextColor = sides.cornerColors[i];
                var nextLabel = sides.cornerNames[i];
                DrawLine(dst3, vbc.task.rc.maxDist, cornersList[i], Scalar.White);
                SetTrueText(nextLabel, new cv.Point(cornersList[i].X, cornersList[i].Y), 3);
            }
            if (cornersList.Count() > 0)
                SetTrueText(sides.strOut, 3);
            else
                SetTrueText(strOut, 3);
        }
    }




    public class Sides_Profile_CS : VB_Parent
    {
        Contour_SidePoints sides = new Contour_SidePoints();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Sides_Profile_CS()
        {
            labels = new string[] { "", "", "RedCloud_Basics Output", "Selected Cell" };
            desc = "Find the 6 corners - left/right, top/bottom, front/back - of a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            sides.Run(src);
            dst3 = sides.dst3;
            SetTrueText(sides.strOut, 3);
        }
    }




    public class Sides_Corner_CS : VB_Parent
    {
        Contour_RedCloudCorners sides = new Contour_RedCloudCorners();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Sides_Corner_CS()
        {
            labels = new string[] { "", "", "RedCloud_Basics output", "" };
            desc = "Find the 4 points farthest from the center in each quadrant of the selected RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            sides.Run(src);
            dst3 = sides.dst3;
            SetTrueText("Center point is rcSelect.maxDist", 3);
        }
    }




    public class Sides_ColorC_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Sides_Basics sides = new Sides_Basics();
        public Sides_ColorC_CS()
        {
            labels = new string[] { "", "", "RedColor Output", "Cell Extrema" };
            desc = "Find the extrema - top/bottom, left/right, near/far - points for a RedColor Cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            sides.Run(src);
            dst3 = sides.dst3;
        }
    }




    public class Sieve_Image_CS : VB_Parent
    {
        Pixel_Zoom zoom = new Pixel_Zoom();
        byte[] numArray;
        Dictionary<int, int> referenceResults = new Dictionary<int, int>
    {
        {10, 4}, {100, 25}, {1000, 168}, {10000, 1229}, {100000, 9592}, {1000000, 78498},
        {10000000, 664579}, {100000000, 5761455}
    };
        public Sieve_Image_CS()
        {
            numArray = new byte[dst2.Total() - 1];
            labels[2] = "NonZero pixels are primes";
            labels[3] = "Zoom output";
            desc = "Create an image marking primes";
        }
        public void RunAlg(Mat src)
        {
            int numCeiling = numArray.Length - 1;
            Array.Resize(ref numArray, numCeiling + 1);
            numArray[0] = 255;
            numArray[1] = 255;
            for (int i = 2; i <= numCeiling / 2 - 1; i++)
            {
                for (int j = i + i; j <= numCeiling; j += i)
                {
                    if (numArray[j] != 255) numArray[j] = 255;
                }
            }
            int countPrimes = 0;
            for (int i = 2; i <= numCeiling; i++)
            {
                if (numArray[i] == 0) countPrimes++;
            }
            if (referenceResults.ContainsKey(numCeiling))
            {
                if (referenceResults[numCeiling] != countPrimes) SetTrueText("Invalid prime count - check this...");
            }
            dst2 = cv.Mat.FromPixelData(dst2.Rows, dst2.Cols, MatType.CV_8U, numArray);
            dst2 = ~dst2;
            zoom.Run(dst2);
            dst3 = zoom.dst2;
        }
    }




    public class SLR_PlotData_CS : VB_Parent
    {
        Plot_Basics_CPP_VB plot = new Plot_Basics_CPP_VB();
        public List<double> dataX = new List<double>();
        public List<double> dataY = new List<double>();
        public SLR_PlotData_CS()
        {
            using (var sr = new StreamReader(vbc.task.HomeDir + "/Data/real_data.txt"))
            {
                string code = sr.ReadToEnd();
                var lines = code.Split('\n');
                foreach (var line in lines)
                {
                    var split = line.Split(' ');
                    if (split.Length > 1)
                    {
                        dataX.Add(double.Parse(split[0]));
                        dataY.Add(double.Parse(split[1]));
                    }
                }
            }
            desc = "Plot the data used in SLR_Basics";
        }
        public void RunAlg(Mat src)
        {
            plot.srcX = dataX;
            plot.srcY = dataY;
            plot.Run(src);
            dst2 = plot.dst2;
        }
    }




    public class SLR_SurfaceH_CS : VB_Parent
    {
        PointCloud_SurfaceH surface = new PointCloud_SurfaceH();
        public SLR_SurfaceH_CS()
        {
            desc = "Use the PointCloud_SurfaceH data to indicate valleys and peaks.";
        }
        public void RunAlg(Mat src)
        {
            surface.Run(src);
            dst2 = surface.dst3;
        }
    }




    public class SLR_Trends_CS : VB_Parent
    {
        public Hist_KalmanAuto hist = new Hist_KalmanAuto();
        List<float> valList = new List<float>();
        float barMidPoint;
        Point2f lastPoint;
        public List<cv.Point2f> resultingPoints = new List<cv.Point2f>();
        public List<float> resultingValues = new List<float>();
        public SLR_Trends_CS()
        {
            desc = "Find trends by filling in short histogram gaps in the given image's histogram.";
        }
        public void connectLine(int i, cv.Mat dst)
        {
            float x = barMidPoint + dst.Width * i / valList.Count();
            float y = dst.Height - dst.Height * valList[i] / hist.plot.maxRange;
            Point2f p1 = new Point2f(x, y);
            resultingPoints.Add(p1);
            resultingValues.Add(p1.Y);
            DrawLine(dst, lastPoint, p1, Scalar.Yellow, vbc.task.lineWidth + 1);
            lastPoint = p1;
        }
        public void RunAlg(Mat src)
        {
            labels[2] = "Grayscale histogram - yellow line shows trend";
            hist.plot.backColor = Scalar.Red;
            hist.Run(src);
            dst2 = hist.dst2;
            var indexer = hist.histogram.GetGenericIndexer<float>();
            valList = new List<float>();
            for (int i = 0; i < hist.histogram.Rows; i++)
            {
                valList.Add(indexer[i]);
            }
            barMidPoint = dst2.Width / valList.Count() / 2;
            if (valList.Count() < 2) return;
            hist.plot.maxRange = valList.Max();
            lastPoint = new Point2f(barMidPoint, dst2.Height - dst2.Height * valList[0] / hist.plot.maxRange);
            resultingPoints.Clear();
            resultingValues.Clear();
            resultingPoints.Add(lastPoint);
            resultingValues.Add(lastPoint.Y);
            for (int i = 1; i < valList.Count() - 1; i++)
            {
                if (valList[i - 1] > valList[i] && valList[i + 1] > valList[i])
                {
                    valList[i] = (valList[i - 1] + valList[i + 1]) / 2;
                }
                connectLine(i, dst2);
            }
            connectLine(valList.Count() - 1, dst2);
        }
    }




    public class SLR_TrendImages_CS : VB_Parent
    {
        SLR_Trends trends = new SLR_Trends();
        Options_SLRImages options = new Options_SLRImages();
        public SLR_TrendImages_CS()
        {
            desc = "Find trends by filling in short histogram gaps for depth or 1-channel images";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat[] split = src.Split();
            trends.hist.plot.maxRange = 255;
            trends.hist.plot.removeZeroEntry = false; // default is to look at element 0....
            int splitIndex = 0;
            switch (options.radioText)
            {
                case "pcSplit(2) input":
                    trends.hist.plot.maxRange = vbc.task.MaxZmeters;
                    trends.hist.plot.removeZeroEntry = true; // not interested in the undefined depth areas...
                    trends.Run(vbc.task.pcSplit[2]);
                    labels[2] = "SLR_TrendImages_CS - pcSplit(2)";
                    break;
                case "Grayscale input":
                    trends.Run(src.CvtColor(cv.ColorConversionCodes.BGR2GRAY));
                    labels[2] = "SLR_TrendImages_CS - grayscale";
                    break;
                case "Blue input":
                    labels[2] = "SLR_TrendImages_CS - Blue channel";
                    splitIndex = 0;
                    break;
                case "Green input":
                    labels[2] = "SLR_TrendImages_CS - Green channel";
                    splitIndex = 1;
                    break;
                case "Red input":
                    labels[2] = "SLR_TrendImages_CS - Red channel";
                    splitIndex = 2;
                    break;
            }
            trends.Run(split[splitIndex]);
            dst2 = trends.dst2;
        }
    }




    public class Smoothing_Exterior_CS : VB_Parent
    {
        Convex_Basics hull = new Convex_Basics();
        public List<cv.Point> inputPoints { get; set; }
        public List<cv.Point> smoothPoints { get; set; }
        public Scalar plotColor = Scalar.Yellow;
        Options_Smoothing smOptions = new Options_Smoothing();
        List<cv.Point> getSplineInterpolationCatmullRom(List<cv.Point> points, int nrOfInterpolatedPoints)
        {
            List<cv.Point> spline = new List<cv.Point>();
            List<cv.Point> spoints = new List<cv.Point>(points);
            cv.Point startPt = (spoints[1] + spoints[0]) * 0.5;
            spoints.Insert(0, startPt);
            cv.Point endPt = (spoints[spoints.Count() - 1] + spoints[spoints.Count() - 2]) * 0.5;
            spoints.Add(endPt);
            double t;
            cv.Point spoint;
            for (int i = 0; i <= spoints.Count() - 4; i++)
            {
                spoint = new cv.Point();
                for (int j = 0; j < nrOfInterpolatedPoints; j++)
                {
                    cv.Point x0 = spoints[i % spoints.Count()];
                    cv.Point x1 = spoints[(i + 1) % spoints.Count()];
                    cv.Point x2 = spoints[(i + 2) % spoints.Count()];
                    cv.Point x3 = spoints[(i + 3) % spoints.Count()];
                    t = 1.0 / nrOfInterpolatedPoints * j;
                    spoint.X = (int)(0.5 * (2 * x1.X + (-1 * x0.X + x2.X) * t + (2 * x0.X - 5 * x1.X + 4 * x2.X - x3.X) * t * t +
                                        (-1 * x0.X + 3 * x1.X - 3 * x2.X + x3.X) * t * t * t));
                    spoint.Y = (int)(0.5 * (2 * x1.Y + (-1 * x0.Y + x2.Y) * t + (2 * x0.Y - 5 * x1.Y + 4 * x2.Y - x3.Y) * t * t +
                                        (-1 * x0.Y + 3 * x1.Y - 3 * x2.Y + x3.Y) * t * t * t));
                    spline.Add(spoint);
                }
            }
            spline.Add(spoints[spoints.Count() - 2]);
            return spline;
        }
        public Smoothing_Exterior_CS()
        {
            labels[2] = "Original Points (white) Smoothed (yellow)";
            labels[3] = "";
            desc = "Smoothing the line connecting a series of points.";
        }
        public void RunAlg(Mat src)
        {
            smOptions.RunOpt();
            if (standaloneTest())
            {
                if (vbc.task.heartBeat && !vbc.task.paused)
                {
                    List<cv.Point> hullList = hull.buildRandomHullPoints();
                    dst2.SetTo(0);
                    hull.Run(src);
                    cv.Point[] nextHull = Cv2.ConvexHull(hullList.ToArray(), true);
                    inputPoints = new List<cv.Point>(nextHull);
                    DrawPoly(dst2, inputPoints, Scalar.White);
                }
                else
                {
                    return;
                }
            }
            else
            {
                dst2.SetTo(0);
            }
            if (inputPoints.Count() > 1)
            {
                smoothPoints = getSplineInterpolationCatmullRom(inputPoints, smOptions.iterations);
                DrawPoly(dst2, smoothPoints, plotColor);
            }
        }
    }




    public class Smoothing_Interior_CS : VB_Parent
    {
        Convex_Basics hull = new Convex_Basics();
        public List<cv.Point> inputPoints { get; set; }
        public List<cv.Point> smoothPoints { get; set; }
        public Scalar plotColor = Scalar.Yellow;
        Options_Smoothing smOptions = new Options_Smoothing();
        List<cv.Point2d> getCurveSmoothingChaikin(List<cv.Point> points, double tension, int nrOfIterations)
        {
            double cutdist = 0.05 + (tension * 0.4);
            List<cv.Point2d> nl = new List<cv.Point2d>();
            for (int i = 0; i < points.Count(); i++)
            {
                nl.Add(new Point2d(points[i].X, points[i].Y));
            }
            for (int i = 1; i <= nrOfIterations; i++)
            {
                if (nl.Count() > 0) nl = getSmootherChaikin(nl, cutdist);
            }
            return nl;
        }
        List<cv.Point2d> getSmootherChaikin(List<cv.Point2d> points, double cuttingDist)
        {
            List<cv.Point2d> nl = new List<cv.Point2d>();
            nl.Add(points[0]);
            for (int i = 0; i < points.Count() - 1; i++)
            {
                Point2d pt1 = new Point2d((1 - cuttingDist) * points[i].X, (1 - cuttingDist) * points[i].Y);
                Point2d pt2 = new Point2d(cuttingDist * points[i + 1].X, cuttingDist * points[i + 1].Y);
                nl.Add(pt1 + pt2);
                pt1 = new Point2d(cuttingDist * points[i].X, cuttingDist * points[i].Y);
                pt2 = new Point2d((1 - cuttingDist) * points[i + 1].X, (1 - cuttingDist) * points[i + 1].Y);
                nl.Add(pt1 + pt2);
            }
            nl.Add(points[points.Count() - 1]);
            return nl;
        }
        public Smoothing_Interior_CS()
        {
            if (standaloneTest()) FindSlider("Hull random points").Value = 16;
            labels[2] = "Original Points (white) Smoothed (yellow)";
            labels[3] = "";
            desc = "Smoothing the line connecting a series of points staying inside the outline.";
        }
        public void RunAlg(Mat src)
        {
            smOptions.RunOpt();
            if (standaloneTest())
            {
                if (vbc.task.heartBeat && !vbc.task.paused)
                {
                    List<cv.Point> hullList = hull.buildRandomHullPoints();
                    dst2.SetTo(0);
                    hull.Run(src);
                    cv.Point[] nextHull = Cv2.ConvexHull(hullList.ToArray(), true);
                    inputPoints = new List<cv.Point>(nextHull);
                    DrawPoly(dst2, nextHull.ToList(), Scalar.White);
                }
                else
                {
                    return;
                }
            }
            else
            {
                dst2.SetTo(0);
            }
            List<cv.Point2d> smoothPoints2d = getCurveSmoothingChaikin(inputPoints, smOptions.interiorTension, smOptions.iterations);
            smoothPoints = new List<cv.Point>();
            for (int i = 0; i < smoothPoints2d.Count(); i += smOptions.stepSize)
            {
                smoothPoints.Add(new cv.Point((int)smoothPoints2d[i].X, (int)smoothPoints2d[i].Y));
            }
            if (smoothPoints.Count() > 0) DrawPoly(dst2, smoothPoints, plotColor);
        }
    }





    public class Solve_ByMat_CS : VB_Parent
    {
        public Solve_ByMat_CS()
        {
            desc = "Solve a set of equations with OpenCV's Solve API.";
        }
        public void RunAlg(Mat src)
        {
            // x + y = 10
            // 2x + 3y = 26
            // (x=4, y=6)
            double[,] av = { { 1, 1 }, { 2, 3 } };
            double[] yv = { 10, 26 };
            Mat a = cv.Mat.FromPixelData(2, 2, MatType.CV_64FC1, av);
            Mat y = cv.Mat.FromPixelData(2, 1, MatType.CV_64FC1, yv);
            Mat x = new Mat();
            Cv2.Solve(a, y, x, DecompTypes.LU);
            SetTrueText("Solution ByMat: X1 = " + x.At<double>(0, 0) + "\tX2 = " + x.At<double>(0, 1), new cv.Point(10, 125));
        }
    }




    public class Solve_ByArray_CS : VB_Parent
    {
        public Solve_ByArray_CS()
        {
            desc = "Solve a set of equations with OpenCV's Solve API with a normal array as input  ";
        }
        public void RunAlg(Mat src)
        {
            // x + y = 10
            // 2x + 3y = 26
            // (x=4, y=6)
            double[,] av = { { 1, 1 }, { 2, 3 } };
            double[] yv = { 10, 26 };
            Mat x = new Mat();
            Cv2.Solve(InputArray.Create(av), InputArray.Create(yv), x, DecompTypes.LU);
            SetTrueText("Solution ByArray: X1 = " + x.At<double>(0, 0) + "\tX2 = " + x.At<double>(0, 1), new cv.Point(10, 125));
        }
    }




    public class Sort_Basics_CS : VB_Parent
    {
        Options_Sort options = new Options_Sort();
        public Sort_Basics_CS()
        {
            desc = "Sort the pixels of a grayscale image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (options.radio5.Checked)
            {
                src = src.Reshape(1, src.Rows * src.Cols);
                options.sortOption = SortFlags.EveryColumn | SortFlags.Descending;
            }
            if (options.radio4.Checked)
            {
                src = src.Reshape(1, src.Rows * src.Cols);
                options.sortOption = SortFlags.EveryColumn | SortFlags.Ascending;
            }
            if (src.Channels() == 3) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            dst2 = src.Sort(options.sortOption);
            if (options.radio4.Checked || options.radio5.Checked) dst2 = dst2.Reshape(1, dst0.Rows);
        }
    }




    public class Sort_RectAndMask_CS : VB_Parent
    {
        Sort_Basics sort = new Sort_Basics();
        public Mat mask;
        public cv.Rect rect;
        public Sort_RectAndMask_CS()
        {
            labels[3] = "Original input to sort";
            if (standaloneTest()) vbc.task.drawRect = new cv.Rect(10, 10, 50, 5);
            desc = "Sort the grayscale image portion in a rect while allowing for a mask.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            var tmpRect = rect == new cv.Rect() ? vbc.task.drawRect : rect;
            dst1 = src[tmpRect].Clone();
            if (mask != null)
            {
                mask = mask.Threshold(0, 255, ThresholdTypes.BinaryInv);
                dst1.SetTo(0, mask);
            }
            sort.Run(dst1);
            dst2 = sort.dst2.Reshape(1, dst1.Rows);
            dst2 = dst2.Resize(dst3.Size());
            if (standaloneTest()) dst3 = src[tmpRect].Resize(dst3.Size());
        }
    }




    public class Sort_MLPrepTest_CPP_CS : VB_Parent
    {
        public Reduction_Basics reduction = new Reduction_Basics();
        public Mat MLTestData = new Mat();
        public Sort_MLPrepTest_CPP_CS()
        {
            cPtr = Sort_MLPrepTest_Open();
            desc = "Prepare the grayscale image and row to predict depth";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            reduction.Run(src);
            byte[] dataSrc = new byte[reduction.dst2.Total() * reduction.dst2.ElemSize()];
            Marshal.Copy(reduction.dst2.Data, dataSrc, 0, dataSrc.Length);
            var handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            var imagePtr = Sort_MLPrepTest_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();
            MLTestData = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_32FC2, imagePtr).Clone();
            var split = MLTestData.Split();
            dst2 = split[0];
            dst3 = split[1];
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = Sort_MLPrepTest_Close(cPtr);
        }
    }




    public class Sort_1Channel_CS : VB_Parent
    {
        Sort_Basics sort = new Sort_Basics();
        ML_RemoveDups_CPP_VB dups = new ML_RemoveDups_CPP_VB();
        public List<int> rangeStart = new List<int>();
        public List<int> rangeEnd = new List<int>();
        TrackBar thresholdSlider;
        public Sort_1Channel_CS()
        {
            thresholdSlider = FindSlider("Threshold for sort input");
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            FindRadio("Sort all pixels descending").Checked = true;
            if (standaloneTest()) vbc.task.gOptions.setGridSize(10);
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels = new[] { "", "Mask used to isolate the gray scale input to sort", "Sorted thresholded data", "Output of sort - no duplicates" };
            desc = "Take some 1-channel input, sort it, and provide the list of unique elements";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            dst1 = src.Threshold(thresholdSlider.Value, 255, ThresholdTypes.Binary);
            dst2.SetTo(0);
            src.CopyTo(dst2, dst1);
            sort.Run(dst2);
            var pixelsPerBlock = (int)(dst3.Total() / dst2.Rows);
            var sq = Math.Sqrt(pixelsPerBlock);
            vbc.task.gOptions.setGridSize((int)Math.Min(sq, 10));
            dst0 = sort.dst2.Reshape(1, dst2.Rows);
            dups.Run(dst0);
            dst3.SetTo(255);
            var inputCount = dups.dst3.CountNonZero();
            var testVals = new List<int>();
            for (int i = 0; i < Math.Min(inputCount, vbc.task.gridRects.Count()); i++)
            {
                var roi = vbc.task.gridRects[i];
                var val = (int)dups.dst3.Get<byte>(0, i);
                testVals.Add(val);
                dst3[roi].SetTo(val);
            }
            if (testVals.Count() == 0) return;
            rangeStart.Clear();
            rangeEnd.Clear();
            rangeStart.Add(testVals[0]);
            for (int i = 0; i < testVals.Count() - 1; i++)
            {
                if (Math.Abs(testVals[i] - testVals[i + 1]) > 1)
                {
                    rangeEnd.Add(testVals[i]);
                    rangeStart.Add(testVals[i + 1]);
                }
            }
            rangeEnd.Add(testVals[testVals.Count() - 1]);
            labels[3] = " The number of unique entries = " + inputCount + " were spread across " + rangeStart.Count() + " ranges";
        }
    }




    public class Sort_3Channel_CS : VB_Parent
    {
        Sort_Basics sort = new Sort_Basics();
        ML_RemoveDups_CPP_VB dups = new ML_RemoveDups_CPP_VB();
        Mat bgra;
        TrackBar thresholdSlider;
        public Sort_3Channel_CS()
        {
            thresholdSlider = FindSlider("Threshold for sort input");
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            FindRadio("Sort all pixels descending").Checked = true;
            labels = new[] { "", "The BGRA input to sort - shown here as 1-channel CV_32S format", "Output of sort - no duplicates", "Input before removing the dups - use slider to increase/decrease the amount of data" };
            desc = "Take some 3-channel input, convert it to BGRA, sort it as integers, and provide the list of unique elements";
        }
        public void RunAlg(Mat src)
        {
            var inputMask = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (standaloneTest()) inputMask = inputMask.Threshold(thresholdSlider.Value, 255, ThresholdTypes.Binary);
            bgra = src.CvtColor(cv.ColorConversionCodes.BGR2BGRA);
            dst1 = cv.Mat.FromPixelData(dst1.Rows, dst1.Cols, MatType.CV_32S, bgra.Data);
            dst0 = new Mat(dst0.Size(), MatType.CV_32S, cv.Scalar.All(0));
            dst1.CopyTo(dst0, inputMask);
            sort.Run(dst0);
            dst2 = sort.dst2.Reshape(1, dst2.Rows);
            var tmp = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC4, dst2.Data);
            dst3 = tmp.CvtColor(cv.ColorConversionCodes.BGRA2BGR);
            //dups.Run(dst2);
            //dst2 = dups.dst2;
        }
    }




    public class Sort_FeatureLess_CS : VB_Parent
    {
        public FeatureROI_Basics devGrid = new FeatureROI_Basics();
        public Sort_Basics sort = new Sort_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        public Sort_FeatureLess_CS()
        {
            plot.createHistogram = true;
            vbc.task.gOptions.setHistogramBins(256);
            vbc.task.gOptions.setGridSize(8);
            desc = "Sort all the featureless grayscale pixels.";
        }
        public void RunAlg(Mat src)
        {
            devGrid.Run(src);
            dst2 = devGrid.dst2;
            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst1.SetTo(0, ~devGrid.dst3);
            sort.Run(dst1);
            // dst3 = sort.dst2;
            byte[] samples = new byte[sort.dst2.Total()];
            Marshal.Copy(sort.dst2.Data, samples, 0, samples.Length);
            plot.Run(sort.dst2);
            dst3 = plot.dst2;
        }
    }




    public class Sort_Integer_CS : VB_Parent
    {
        Sort_Basics sort = new Sort_Basics();
        public int[] data;
        public List<int> vecList = new List<int>();
        public Sort_Integer_CS()
        {
            data = new int[dst2.Total()];
            FindRadio("Sort all pixels ascending").Checked = true;
            labels = new string[] { "", "Mask used to isolate the gray scale input to sort", "Sorted thresholded data", "Output of sort - no duplicates" };
            desc = "Take some 1-channel input, sort it, and provide the list of unique elements";
        }
        public void RunAlg(Mat src)
        {
            if (standalone)
            {
                Mat[] split = src.Split();
                Mat zero = new Mat(split[0].Size(), MatType.CV_8U, cv.Scalar.All(0));
                Cv2.Merge(new Mat[] { split[0], split[1], split[2], zero }, src);
                Marshal.Copy(src.Data, data, 0, data.Length);
                src = new Mat(src.Size(), MatType.CV_32S, cv.Scalar.All(0));
                Marshal.Copy(data, 0, src.Data, data.Length);
            }
            sort.Run(src);
            Marshal.Copy(sort.dst2.Data, data, 0, data.Length);
            vecList.Clear();
            vecList.Add(data[0]);
            for (int i = 1; i < data.Length; i++)
            {
                if (data[i - 1] != data[i]) vecList.Add(data[i]);
            }
            labels[2] = "There were " + vecList.Count().ToString() + " unique 8UC3 pixels in the input.";
        }
    }




    public class Sort_GrayScale1_CS : VB_Parent
    {
        Sort_Integer sort = new Sort_Integer();
        byte[][] pixels = new byte[3][];
        public Sort_GrayScale1_CS()
        {
            desc = "Sort the grayscale image but keep the 8uc3 pixels with each gray entry.";
        }
        public void RunAlg(Mat src)
        {
            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] gray = new byte[dst1.Total()];
            Marshal.Copy(dst1.Data, gray, 0, gray.Length);
            Mat[] split = src.Split();
            for (int i = 0; i < 3; i++)
            {
                if (vbc.task.FirstPass) pixels[i] = new byte[src.Total()];
                Marshal.Copy(split[i].Data, pixels[i], 0, pixels[i].Length);
            }
            uint[] input = new uint[gray.Length];
            for (int i = 0; i < gray.Length; i++)
            {
                input[i] = (uint)(pixels[0][i] * 65536 + pixels[1][i] * 256 + pixels[2][i]);
            }
            sort.Run(cv.Mat.FromPixelData(gray.Length, 1, MatType.CV_32S, input));
            List<uint> unique = new List<uint>();
            unique.Add((uint)sort.data[0]);
            for (int i = 1; i < sort.data.Length; i++)
            {
                if (sort.data[i - 1] != sort.data[i]) unique.Add((uint)sort.data[i]);
            }
            labels[2] = "There were " + unique.Count().ToString() + " distinct pixels in the image.";
        }
    }




    public class Sort_GrayScale_CS : VB_Parent
    {
        Plot_Histogram plot = new Plot_Histogram();
        byte[][] pixels = new byte[3][];
        public Sort_GrayScale_CS()
        {
            desc = "Sort the grayscale image but keep the 8uc3 pixels with each gray entry.";
        }
        public void RunAlg(Mat src)
        {
            Mat[] split = src.Split();
            for (int i = 0; i < 3; i++)
            {
                if (vbc.task.FirstPass) pixels[i] = new byte[src.Total()];
                Marshal.Copy(split[i].Data, pixels[i], 0, pixels[i].Length);
            }
            float[] totals = new float[256];
            Vec3b[] lut = new Vec3b[256];
            for (int i = 0; i < src.Total(); i++)
            {
                int index = (int)(0.299 * pixels[2][i] + 0.587 * pixels[1][i] + 0.114 * pixels[0][i]);
                totals[index] += 1;
                if (totals[index] == 1) lut[index] = new Vec3b(pixels[0][i], pixels[1][i], pixels[2][i]);
            }
            Mat histogram = cv.Mat.FromPixelData(256, 1, MatType.CV_32F, totals);
            plot.Run(histogram);
            dst2 = plot.dst2;
        }
    }




    public class Spectrum_Basics_CS : VB_Parent
    {
        Spectrum_Z dSpec = new Spectrum_Z();
        Spectrum_Gray gSpec = new Spectrum_Gray();
        public Options_Spectrum options = new Options_Spectrum();
        public Spectrum_Basics_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the ranges of the depth and color.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = options.runRedCloud(ref labels[2]);
            dSpec.Run(src);
            gSpec.Run(src);
            if (vbc.task.heartBeat && vbc.task.rc.index > 0)
            {
                strOut = dSpec.strOut + "\n\n" + gSpec.strOut;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_X_CS : VB_Parent
    {
        public Options_Spectrum options = new Options_Spectrum();
        public Spectrum_X_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the depth ranges.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            if (vbc.task.heartBeat && vbc.task.rc.index > 0)
            {
                var ranges = options.buildDepthRanges(vbc.task.pcSplit[0][vbc.task.rc.rect].Clone(), " pointcloud X ");
                strOut = options.strOut;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_Y_CS : VB_Parent
    {
        public Options_Spectrum options = new Options_Spectrum();
        public Spectrum_Y_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the depth ranges.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            if (vbc.task.heartBeat && vbc.task.rc.index > 0)
            {
                var ranges = options.buildDepthRanges(vbc.task.pcSplit[1][vbc.task.rc.rect].Clone(), " pointcloud Y ");
                strOut = options.strOut;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_Z_CS : VB_Parent
    {
        public Options_Spectrum options = new Options_Spectrum();
        public Spectrum_Z_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the depth ranges.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            if (vbc.task.heartBeat && vbc.task.rc.index > 0)
            {
                var ranges = options.buildDepthRanges(vbc.task.pcSplit[2][vbc.task.rc.rect].Clone(), " pointcloud Z ");
                strOut = options.strOut;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_Cloud_CS : VB_Parent
    {
        public Options_Spectrum options = new Options_Spectrum();
        Spectrum_X specX = new Spectrum_X();
        Spectrum_Y specY = new Spectrum_Y();
        Spectrum_Z specZ = new Spectrum_Z();
        public Spectrum_Cloud_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the ranges for X, Y, and Z in the point cloud.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            if (vbc.task.heartBeat)
            {
                specX.Run(src);
                strOut = specX.strOut + "\n";
                specY.Run(src);
                strOut += specY.strOut + "\n";
                specZ.Run(src);
                strOut += specZ.strOut;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_GrayAndCloud_CS : VB_Parent
    {
        Options_Spectrum options = new Options_Spectrum();
        Spectrum_Gray gSpec = new Spectrum_Gray();
        Spectrum_Cloud sCloud = new Spectrum_Cloud();
        public Spectrum_GrayAndCloud_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the ranges for X, Y, and Z in the point cloud.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            if (vbc.task.heartBeat)
            {
                sCloud.Run(src);
                strOut = sCloud.strOut + "\n";
                gSpec.Run(src);
                strOut += gSpec.strOut;
            }
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_RGB_CS : VB_Parent
    {
        Options_Spectrum options = new Options_Spectrum();
        Spectrum_Gray gSpec = new Spectrum_Gray();
        public Spectrum_RGB_CS()
        {
            desc = "Create a spectrum of the RGB values for a given RedCloud cell.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            var split = src.Split();
            gSpec.typeSpec = " blue ";
            gSpec.Run(split[0]);
            if (vbc.task.heartBeat) strOut = gSpec.strOut + "\n";
            gSpec.typeSpec = " green ";
            gSpec.Run(split[1]);
            if (vbc.task.heartBeat) strOut += gSpec.strOut + "\n";
            gSpec.typeSpec = " red ";
            gSpec.Run(split[2]);
            if (vbc.task.heartBeat) strOut += gSpec.strOut;
            SetTrueText(strOut, 3);
        }
    }




    public class Spectrum_CellZoom_CS : VB_Parent
    {
        Resize_Proportional proportion = new Resize_Proportional();
        Spectrum_Breakdown breakdown = new Spectrum_Breakdown();
        public Spectrum_CellZoom_CS()
        {
            labels = new string[] { "", "Cell trimming information", "", "White is after trimming, gray is before trim, black is outside the cell mask." };
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Zoom in on the selected RedCloud cell before and after Spectrum filtering.";
        }
        public void RunAlg(Mat src)
        {
            breakdown.options.RunOpt();
            dst2 = breakdown.options.runRedCloud(ref labels[2]);
            if (vbc.task.heartBeat)
            {
                breakdown.Run(src);
                SetTrueText(breakdown.strOut, 1);
                proportion.Run(breakdown.dst3);
                dst3 = proportion.dst2;
                strOut = breakdown.options.strOut;
            }
            SetTrueText(strOut, 1);
        }
    }




    public class Spectrum_Breakdown_CS : VB_Parent
    {
        public Options_Spectrum options = new Options_Spectrum();
        public bool buildMaskOnly;
        Resize_Proportional proportion = new Resize_Proportional();
        public Spectrum_Breakdown_CS()
        {
            desc = "Breakdown a cell if possible.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                options.RunOpt();
                dst2 = options.runRedCloud(ref labels[2]);
            }
            var rc = vbc.task.rc;
            List<rangeData> ranges;
            Mat input;
            if (rc.pixels == 0) return;
            if (rc.depthPixels / rc.pixels < 0.5)
            {
                input = new Mat(rc.mask.Size(), MatType.CV_8U, cv.Scalar.All(0));
                src[rc.rect].CopyTo(input, rc.mask);
                input = input.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            }
            else
            {
                input = new Mat(rc.mask.Size(), MatType.CV_32F, cv.Scalar.All(0));
                vbc.task.pcSplit[2][rc.rect].CopyTo(input, rc.mask);
            }
            ranges = options.buildColorRanges(input, "GrayScale");
            if (ranges.Count() == 0) return; // all the counts were too small - rare but it happens.
            rangeData maxRange = null;
            int maxPixels = 0;
            foreach (var r in ranges)
            {
                if (r.pixels > maxPixels)
                {
                    maxPixels = r.pixels;
                    maxRange = r;
                }
            }
            Mat rangeClip = new Mat(input.Size(), MatType.CV_8U, cv.Scalar.All(0));
            if (input.Type() == MatType.CV_8U)
            {
                rangeClip = input.InRange(maxRange.start, maxRange.ending);
                rangeClip = rangeClip.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            }
            else
            {
                rangeClip = new Mat(rc.mask.Size(), MatType.CV_32F, cv.Scalar.All(0));
                input.CopyTo(rangeClip, rc.mask);
                rangeClip = rangeClip.InRange(maxRange.start / 100, maxRange.ending / 100);
                rangeClip = rangeClip.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            }
            if (!buildMaskOnly)
            {
                dst3 = rc.mask.Threshold(0, 128, ThresholdTypes.Binary);
                dst3.SetTo(255, rangeClip);
            }
            if (standaloneTest())
            {
                proportion.Run(dst3);
                dst3 = proportion.dst2;
            }
            rc.mask = rc.mask.Threshold(0, 255, ThresholdTypes.Binary);
            vbc.task.rc = rc;
        }
    }




    public class Spectrum_RedCloud_CS : VB_Parent
    {
        Spectrum_Breakdown breakdown = new Spectrum_Breakdown();
        public List<rcData> redCells = new List<rcData>();
        public Spectrum_RedCloud_CS()
        {
            desc = "Breakdown each cell in redCells.";
        }
        public void RunAlg(Mat src)
        {
            breakdown.options.RunOpt();
            dst2 = breakdown.options.runRedCloud(ref labels[2]);
            redCells.Clear();
            dst3.SetTo(0);
            foreach (var rc in vbc.task.redCells)
            {
                vbc.task.rc = rc;
                breakdown.Run(src);
                var rcNew = vbc.task.rc;
                redCells.Add(rcNew);
                dst3[rcNew.rect].SetTo(rcNew.color, rcNew.mask);
            }
            breakdown.Run(src);
        }
    }




    public class Spectrum_Mask_CS : VB_Parent
    {
        Spectrum_Gray gSpec = new Spectrum_Gray();
        public Spectrum_Mask_CS()
        {
            if (standaloneTest()) strOut = "Select a cell to see its depth spectrum";
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Create a mask from the Spectrum ranges";
        }
        public void RunAlg(Mat src)
        {
            gSpec.Run(src);
            dst1 = gSpec.dst2;
            labels[2] = gSpec.labels[2];
            if (vbc.task.heartBeat) strOut = gSpec.strOut;
        }
    }




    public class Spectrum_Gray_CS : VB_Parent
    {
        Options_Spectrum options = new Options_Spectrum();
        public string typeSpec = "GrayScale";
        public Spectrum_Gray_CS()
        {
            desc = "Given a RedCloud cell, create a spectrum that contains the color ranges.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) dst2 = options.runRedCloud(ref labels[2]);
            var input = src[vbc.task.rc.rect];
            if (input.Type() != MatType.CV_8U) input = input.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            var ranges = options.buildColorRanges(input, typeSpec);
            strOut = options.strOut;
            SetTrueText(strOut, 3);
        }
    }




    public class Stabilizer_Basics_CS : VB_Parent
    {
        Match_Basics match = new Match_Basics();
        public int shiftX;
        public int shiftY;
        public cv.Rect templateRect;
        public cv.Rect searchRect;
        public cv.Rect stableRect;
        Options_Stabilizer options = new Options_Stabilizer();
        Mat lastFrame;
        public Stabilizer_Basics_CS()
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, cv.Scalar.All(0));
            labels[2] = "Current frame - rectangle input to matchTemplate";
            desc = "if reasonable stdev and no motion in correlation rectangle, stabilize image across frames";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            bool resetImage = false;
            templateRect = new cv.Rect(src.Width / 2 - options.width / 2, src.Height / 2 - options.height / 2,
                                        options.width, options.height);
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) lastFrame = src.Clone();
            dst2 = src.Clone();
            Scalar mean;
            Scalar stdev;
            Cv2.MeanStdDev(dst2[templateRect], out mean, out stdev);
            if (stdev[0] > options.minStdev)
            {
                var t = templateRect;
                int w = t.Width + options.pad * 2;
                int h = t.Height + options.pad * 2;
                int x = Math.Abs(t.X - options.pad);
                int y = Math.Abs(t.Y - options.pad);
                searchRect = new cv.Rect(x, y, Math.Min(w, lastFrame.Width - x - 1), Math.Min(h, lastFrame.Height - y - 1));
                match.template = lastFrame[searchRect];
                match.Run(src[templateRect]);
                if (match.correlation > options.corrThreshold)
                {
                    var maxLoc = new cv.Point(match.matchCenter.X, match.matchCenter.Y);
                    shiftX = templateRect.X - maxLoc.X - searchRect.X;
                    shiftY = templateRect.Y - maxLoc.Y - searchRect.Y;
                    int x1 = shiftX < 0 ? Math.Abs(shiftX) : 0;
                    int y1 = shiftY < 0 ? Math.Abs(shiftY) : 0;
                    dst3.SetTo(0);
                    int x2 = shiftX < 0 ? 0 : shiftX;
                    int y2 = shiftY < 0 ? 0 : shiftY;
                    stableRect = new cv.Rect(x1, y1, src.Width - Math.Abs(shiftX), src.Height - Math.Abs(shiftY));
                    var srcRect = new cv.Rect(x2, y2, stableRect.Width, stableRect.Height);
                    stableRect = new cv.Rect(x1, y1, src.Width - Math.Abs(shiftX), src.Height - Math.Abs(shiftY));
                    src[srcRect].CopyTo(dst3[stableRect]);
                    double nonZero = Cv2.CountNonZero(dst3) / (dst3.Width * dst3.Height);
                    if (nonZero < (1 - options.lostMax))
                    {
                        labels[3] = "Lost pixels = " + string.Format("{0:00%}", 1 - nonZero);
                        resetImage = true;
                    }
                    labels[3] = "Offset (x, y) = (" + shiftX + "," + shiftY + "), " + string.Format("{0:00%}", nonZero) + " preserved, cc=" + string.Format("{0}", match.correlation);
                }
                else
                {
                    labels[3] = "Below correlation threshold " + string.Format("{0}", options.corrThreshold) + " with " +
                                string.Format("{0}", match.correlation);
                    resetImage = true;
                }
            }
            else
            {
                labels[3] = "Correlation rectangle stdev is " + string.Format("{0:00}", stdev[0]) + " - too low";
                resetImage = true;
            }
            if (resetImage)
            {
                src.CopyTo(lastFrame);
                dst3 = lastFrame.Clone();
            }
            if (standaloneTest()) dst3.Rectangle(templateRect, Scalar.White, 1); // when not standaloneTest(), traceName doesn't want artificial rectangle.
        }
    }






    public class Stabilizer_BasicsTest_CS : VB_Parent
    {
        Stabilizer_BasicsRandomInput random = new Stabilizer_BasicsRandomInput();
        Stabilizer_Basics stable = new Stabilizer_Basics();
        public Stabilizer_BasicsTest_CS()
        {
            labels[2] = "Unstable input to Stabilizer_Basics";
            desc = "Test the Stabilizer_Basics with random movement";
        }
        public void RunAlg(Mat src)
        {
            random.Run(src);
            stable.Run(random.dst3.Clone());
            dst2 = stable.dst2;
            dst3 = stable.dst3;
            if (standaloneTest()) dst3.Rectangle(stable.templateRect, Scalar.White, 1);
            labels[3] = stable.labels[3];
        }
    }




    public class Stabilizer_OpticalFlow_CS : VB_Parent
    {
        public Feature_Stable feat = new Feature_Stable();
        public List<cv.Point2f> inputFeat = new List<cv.Point2f>();
        public int borderCrop = 30;
        Mat sumScale, sScale, features1;
        Mat errScale, qScale, rScale;
        Mat lastFrame;

        public Stabilizer_OpticalFlow_CS()
        {
            desc = "Stabilize video with a Kalman filter.  Shake camera to see image edges appear.  This is not really working!";
            labels[2] = "Stabilized Image";
        }
        public void RunAlg(Mat src)
        {
            double vert_Border = borderCrop * src.Rows / src.Cols;
            if (vbc.task.optionsChanged)
            {
                errScale = new Mat(new cv.Size(1, 5), MatType.CV_64F, cv.Scalar.All(1));
                qScale = new Mat(new cv.Size(1, 5), MatType.CV_64F, cv.Scalar.All(0.004));
                rScale = new Mat(new cv.Size(1, 5), MatType.CV_64F, cv.Scalar.All(0.5));
                sumScale = new Mat(new cv.Size(1, 5), MatType.CV_64F, cv.Scalar.All(0));
                sScale = new Mat(new cv.Size(1, 5), MatType.CV_64F, cv.Scalar.All(0));
            }
            dst2 = src;
            if (src.Channels() == 3) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (vbc.task.FirstPass) lastFrame = src.Clone();
            feat.Run(src);
            inputFeat = new List<cv.Point2f>(vbc.task.features);
            features1 = cv.Mat.FromPixelData(inputFeat.Count(), 1, MatType.CV_32FC2, inputFeat.ToArray());
            if (vbc.task.frameCount > 0)
            {
                Mat features2 = new Mat();
                Mat status = new Mat();
                Mat err = new Mat();
                cv.Size winSize = new cv.Size(3, 3);
                TermCriteria term = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 10, 1.0);
                Cv2.CalcOpticalFlowPyrLK(src, lastFrame, features1, features2, status, err, winSize, 3, term, OpticalFlowFlags.None);
                lastFrame = src.Clone();
                List<cv.Point2f> commonPoints = new List<cv.Point2f>();
                List<cv.Point2f> lastFeatures = new List<cv.Point2f>();
                for (int i = 0; i < status.Rows; i++)
                {
                    if (status.Get<byte>(i, 0) != 0)
                    {
                        Point2f pt1 = features1.Get<cv.Point2f>(i, 0);
                        Point2f pt2 = features2.Get<cv.Point2f>(i, 0);
                        double length = Math.Sqrt((pt1.X - pt2.X) * (pt1.X - pt2.X) + (pt1.Y - pt2.Y) * (pt1.Y - pt2.Y));
                        if (length < 10)
                        {
                            commonPoints.Add(pt1);
                            lastFeatures.Add(pt2);
                        }
                    }
                }
                Mat affine = Cv2.GetAffineTransform(commonPoints.ToArray(), lastFeatures.ToArray());
                double dx = affine.Get<double>(0, 2);
                double dy = affine.Get<double>(1, 2);
                double da = Math.Atan2(affine.Get<double>(1, 0), affine.Get<double>(0, 0));
                double ds_x = affine.Get<double>(0, 0) / Math.Cos(da);
                double ds_y = affine.Get<double>(1, 1) / Math.Cos(da);
                double saveDX = dx, saveDY = dy, saveDA = da;
                string text = "Original dx = " + dx.ToString(vbc.fmt2) + "\n" + " dy = " + dy.ToString(vbc.fmt2) + "\n" + " da = " + da.ToString(vbc.fmt2);
                SetTrueText(text);
                double sx = ds_x, sy = ds_y;
                Mat delta = cv.Mat.FromPixelData(5, 1, MatType.CV_64F, new double[] { ds_x, ds_y, da, dx, dy });
                Cv2.Add(sumScale, delta, sumScale);
                Mat diff = new Mat();
                Cv2.Subtract(sScale, sumScale, diff);
                da += diff.Get<double>(2, 0);
                dx += diff.Get<double>(3, 0);
                dy += diff.Get<double>(4, 0);
                if (Math.Abs(dx) > 50) dx = saveDX;
                if (Math.Abs(dy) > 50) dy = saveDY;
                if (Math.Abs(da) > 50) da = saveDA;
                text = "dx = " + dx.ToString(vbc.fmt2) + "\n" + " dy = " + dy.ToString(vbc.fmt2) + "\n" + " da = " + da.ToString(vbc.fmt2);
                SetTrueText(text, new cv.Point(10, 100));
                Mat smoothedMat = new Mat(2, 3, MatType.CV_64F);
                smoothedMat.Set<double>(0, 0, sx * Math.Cos(da));
                smoothedMat.Set<double>(0, 1, sx * -Math.Sin(da));
                smoothedMat.Set<double>(1, 0, sy * Math.Sin(da));
                smoothedMat.Set<double>(1, 1, sy * Math.Cos(da));
                smoothedMat.Set<double>(0, 2, dx);
                smoothedMat.Set<double>(1, 2, dy);
                Mat smoothedFrame = vbc.task.color.WarpAffine(smoothedMat, src.Size());
                smoothedFrame = smoothedFrame[new cv.Range((int)vert_Border, (int)(smoothedFrame.Rows - vert_Border)),
                                                new cv.Range(borderCrop, smoothedFrame.Cols - borderCrop)];
                dst3 = smoothedFrame.Resize(src.Size());
                for (int i = 0; i < commonPoints.Count(); i++)
                {
                    DrawCircle(dst2, commonPoints[i], vbc.task.DotSize + 3, Scalar.Red);
                    DrawCircle(dst2, lastFeatures[i], vbc.task.DotSize + 1, Scalar.Blue);
                }
            }
            inputFeat = null; // show that we consumed the current set of features.
        }
    }




    public class Stabilizer_VerticalIMU_CS : VB_Parent
    {
        public bool stableTest;
        public string stableStr;
        List<float> angleXValue = new List<float>();
        List<float> angleYValue = new List<float>();
        List<int> stableCount = new List<int>();
        float lastAngleX, lastAngleY;
        public Stabilizer_VerticalIMU_CS()
        {
            desc = "Use the IMU angular velocity to determine if the camera is moving or stable.";
        }
        public void RunAlg(Mat src)
        {
            angleXValue.Add(vbc.task.accRadians.X);
            angleYValue.Add(vbc.task.accRadians.Y);
            strOut = "IMU X" + "\t" + "IMU Y" + "\t" + "IMU Z" + "\n";
            strOut += (vbc.task.accRadians.X * 57.2958).ToString(vbc.fmt3) + "\t" + (vbc.task.accRadians.Y * 57.2958).ToString(vbc.fmt3) + "\t" +
                        (vbc.task.accRadians.Z * 57.2958).ToString(vbc.fmt3) + "\n";
            float avgX = angleXValue.Average();
            float avgY = angleYValue.Average();
            if (vbc.task.FirstPass)
            {
                lastAngleX = avgX;
                lastAngleY = avgY;
            }
            strOut += "Angle X" + "\t" + "Angle Y" + "\n";
            strOut += avgX.ToString(vbc.fmt3) + "\t" + avgY.ToString(vbc.fmt3) + "\n";
            float angle = 90 - avgY * 57.2958f;
            if (avgX < 0) angle *= -1;
            labels[2] = "stabilizer_Vertical Angle = " + angle.ToString(vbc.fmt1);
            stableTest = Math.Abs(lastAngleX - avgX) < 0.001f && Math.Abs(lastAngleY - avgY) < 0.01f;
            stableCount.Add(stableTest ? 1 : 0);
            if (vbc.task.heartBeat)
            {
                float avgStable = (float)stableCount.Average();
                stableStr = "IMU stable = " + avgStable.ToString("0.0%") + " of the time";
                stableCount.Clear();
            }
            SetTrueText(strOut + "\n" + stableStr, 2);
            lastAngleX = avgX;
            lastAngleY = avgY;
            if (angleXValue.Count() >= vbc.task.frameHistoryCount) angleXValue.RemoveAt(0);
            if (angleYValue.Count() >= vbc.task.frameHistoryCount) angleYValue.RemoveAt(0);
        }
    }




    public class Stabilizer_CornerPoints_CS : VB_Parent
    {
        public Stable_Basics basics = new Stable_Basics();
        public List<cv.Point2f> features = new List<cv.Point2f>();
        cv.Rect ul, ur, ll, lr;
        Options_StabilizerOther options = new Options_StabilizerOther();
        public Stabilizer_CornerPoints_CS()
        {
            desc = "Track the FAST feature points found in the corners of the BGR image.";
        }
        void getKeyPoints(Mat src, cv.Rect r)
        {
            KeyPoint[] kpoints = Cv2.FAST(src[r], options.fastThreshold, true);
            foreach (var kp in kpoints)
            {
                features.Add(new Point2f(kp.Pt.X + r.X, kp.Pt.Y + r.Y));
            }
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            if (vbc.task.optionsChanged)
            {
                int size = vbc.task.gridSize;
                ul = new cv.Rect(0, 0, size, size);
                ur = new cv.Rect(dst2.Width - size, 0, size, size);
                ll = new cv.Rect(0, dst2.Height - size, size, size);
                lr = new cv.Rect(dst2.Width - size, dst2.Height - size, size, size);
            }
            src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            features.Clear();
            getKeyPoints(src, ul);
            getKeyPoints(src, ur);
            getKeyPoints(src, ll);
            getKeyPoints(src, lr);
            dst2.SetTo(0);
            foreach (var pt in features)
            {
                DrawCircle(dst2, pt, vbc.task.DotSize, Scalar.Yellow);
            }
            labels[2] = "There were " + features.Count().ToString() + " key points detected";
        }
    }




    public class Stabilizer_BasicsRandomInput_CS : VB_Parent
    {
        Options_StabilizerOther options = new Options_StabilizerOther();
        int lastShiftX;
        int lastShiftY;
        public Stabilizer_BasicsRandomInput_CS()
        {
            labels[2] = "Current frame (before)";
            labels[3] = "Image after shift";
            desc = "Generate images that have been arbitrarily shifted";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat input = src;
            if (input.Channels() != 1) input = input.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            int shiftX = msRNG.Next(-options.range, options.range);
            int shiftY = msRNG.Next(-options.range, options.range);
            if (vbc.task.FirstPass)
            {
                lastShiftX = shiftX;
                lastShiftY = shiftY;
            }
            if (vbc.task.frameCount % 2 == 0)
            {
                shiftX = lastShiftX;
                shiftY = lastShiftY;
            }
            lastShiftX = shiftX;
            lastShiftY = shiftY;
            dst2 = input.Clone();
            if (shiftX != 0 || shiftY != 0)
            {
                int x = shiftX < 0 ? Math.Abs(shiftX) : 0;
                int y = shiftY < 0 ? Math.Abs(shiftY) : 0;
                int x2 = shiftX < 0 ? 0 : shiftX;
                int y2 = shiftY < 0 ? 0 : shiftY;
                cv.Rect srcRect = new cv.Rect(x, y, src.Width - Math.Abs(shiftX), src.Height - Math.Abs(shiftY));
                cv.Rect dstRect = new cv.Rect(x2, y2, srcRect.Width, srcRect.Height);
                dst2[srcRect].CopyTo(input[dstRect]);
            }
            dst3 = input;
        }
    }




    public class Stable_Basics_CS : VB_Parent
    {
        public Delaunay_Generations facetGen = new Delaunay_Generations();
        public List<cv.Point2f> ptList = new List<cv.Point2f>();
        public Point2f anchorPoint;
        Feature_KNN good = new Feature_KNN();
        public Stable_Basics_CS()
        {
            desc = "Maintain the generation counts around the feature points.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                good.Run(src);
                facetGen.inputPoints = new List<cv.Point2f>(good.featurePoints);
            }
            facetGen.Run(src);
            if (facetGen.inputPoints.Count() == 0) return; // nothing to work on ...
            ptList.Clear();
            List<int> generations = new List<int>();
            foreach (var ptf in facetGen.inputPoints)
            {
                cv.Point pt = new cv.Point(ptf.X, ptf.Y);
                int fIndex = facetGen.facet.facet32s.Get<int>((int)pt.Y, (int)pt.X);
                if (fIndex >= facetGen.facet.facetList.Count()) continue; // new point
                int g = facetGen.dst0.Get<int>((int)pt.Y, (int)pt.X);
                generations.Add(g);
                ptList.Add(pt);
                SetTrueText(g.ToString(), pt);
            }
            int maxGens = generations.Max();
            int index = generations.IndexOf(maxGens);
            anchorPoint = ptList[index];
            if (index < facetGen.facet.facetList.Count())
            {
                var bestFacet = facetGen.facet.facetList[index];
                dst2.FillConvexPoly(bestFacet, Scalar.Black, vbc.task.lineType);
                DrawContour(dst2, bestFacet, vbc.task.HighlightColor);
            }
            dst2 = facetGen.dst2;
            dst3 = src.Clone();
            for (int i = 0; i < ptList.Count(); i++)
            {
                var pt = ptList[i];
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                DrawCircle(dst3, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = $"{ptList.Count()} stable points were identified with {maxGens} generations at the anchor point";
        }
    }




    public class Stable_BasicsCount_CS : VB_Parent
    {
        public Stable_Basics basics = new Stable_Basics();
        public Feature_Stable feat = new Feature_Stable();
        public SortedList<int, int> goodCounts = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
        public Stable_BasicsCount_CS()
        {
            desc = "Track the stable good features found in the BGR image.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            basics.facetGen.inputPoints = new List<cv.Point2f>(vbc.task.features);
            basics.Run(src);
            dst2 = basics.dst2;
            dst3 = basics.dst3;
            goodCounts.Clear();
            int g;
            for (int i = 0; i < basics.ptList.Count(); i++)
            {
                cv.Point pt = new cv.Point(basics.ptList[i].X, basics.ptList[i].Y);
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
                g = basics.facetGen.dst0.Get<int>((int)pt.Y, (int)pt.X);
                goodCounts.Add(g, i);
                SetTrueText(g.ToString(), pt);
            }
            labels[2] = $"{vbc.task.features.Count()} good features were found and {basics.ptList.Count()} were stable";
        }
    }




    public class Stable_Lines_CS : VB_Parent
    {
        public Stable_Basics basics = new Stable_Basics();
        Line_Basics lines = new Line_Basics();
        public Stable_Lines_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Track the line end points found in the BGR image and keep those that are stable.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            basics.facetGen.inputPoints.Clear();
            dst1 = src.Clone();
            foreach (var lp in lines.lpList)
            {
                basics.facetGen.inputPoints.Add(lp.p1);
                basics.facetGen.inputPoints.Add(lp.p2);
                DrawLine(dst1, lp.p1, lp.p2, vbc.task.HighlightColor);
            }
            basics.Run(src);
            dst2 = basics.dst2;
            dst3 = basics.dst3;
            foreach (var ptf in basics.ptList)
            {
                cv.Point pt = new cv.Point(ptf.X, ptf.Y);
                DrawCircle(dst2, pt, vbc.task.DotSize + 1, vbc.task.HighlightColor);
                if (standaloneTest())
                {
                    int g = basics.facetGen.dst0.Get<int>((int)pt.Y, (int)pt.X);
                    SetTrueText(g.ToString(), pt);
                }
            }
            labels[2] = basics.labels[2];
            labels[3] = $"{lines.lpList.Count()} line end points were found and {basics.ptList.Count()} were stable";
        }
    }




    public class Stable_FAST_CS : VB_Parent
    {
        public Stable_Basics basics = new Stable_Basics();
        readonly Corners_Basics fast = new Corners_Basics();
        public Stable_FAST_CS()
        {
            FindSlider("FAST Threshold").Value = 100;
            desc = "Track the FAST feature points found in the BGR image and track those that appear stable.";
        }
        public void RunAlg(Mat src)
        {
            fast.Run(src);
            basics.facetGen.inputPoints.Clear();
            basics.facetGen.inputPoints = new List<cv.Point2f>(fast.features);
            basics.Run(src);
            dst3 = basics.dst3;
            dst2 = basics.dst2;
            foreach (var ptf in basics.ptList)
            {
                cv.Point pt = new cv.Point(ptf.X, ptf.Y);
                DrawCircle(dst2, pt, vbc.task.DotSize + 1, vbc.task.HighlightColor);
                if (standaloneTest())
                {
                    int g = basics.facetGen.dst0.Get<int>((int)pt.Y, (int)pt.X);
                    SetTrueText(g.ToString(), pt);
                }
            }
            labels[2] = basics.labels[2];
            labels[3] = $"{fast.features.Count()} features were found and {basics.ptList.Count()} were stable";
        }
    }




    public class Stable_GoodFeatures_CS : VB_Parent
    {
        public Stable_Basics basics = new Stable_Basics();
        public Feature_Stable feat = new Feature_Stable();
        public SortedList<int, int> genSorted = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
        public Stable_GoodFeatures_CS()
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Track the stable good features found in the BGR image.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(src);
            dst3 = basics.dst3;
            if (vbc.task.features.Count() == 0) return; // nothing to work on...
            basics.facetGen.inputPoints = new List<cv.Point2f>(vbc.task.features);
            basics.Run(src);
            dst2 = basics.dst2;
            dst1.SetTo(0);
            genSorted.Clear();
            for (int i = 0; i < basics.ptList.Count(); i++)
            {
                cv.Point pt = new cv.Point(basics.ptList[i].X, basics.ptList[i].Y);
                if (standaloneTest()) DrawCircle(dst2, pt, vbc.task.DotSize + 1, Scalar.Yellow);
                dst1.Set<byte>((int)pt.Y, (int)pt.X, 255);
                int g = basics.facetGen.dst0.Get<int>((int)pt.Y, (int)pt.X);
                genSorted.Add(g, i);
                SetTrueText(g.ToString(), pt);
                DrawCircle(dst2, pt, vbc.task.DotSize, vbc.task.HighlightColor);
            }
            labels[2] = basics.labels[2];
            labels[3] = $"{vbc.task.features.Count()} good features were found and {basics.ptList.Count()} were stable";
        }
    }




    public class Stitch_Basics_CS : VB_Parent
    {
        Options_Stitch options = new Options_Stitch();
        public Stitch_Basics_CS()
        {
            desc = "Stitch together random parts of a color image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            List<Mat> mats = new List<Mat>();
            dst2 = src.Clone();
            for (int i = 0; i < options.imageCount; i++)
            {
                int x1 = (int)msRNG.Next(0, src.Width - options.width);
                int x2 = (int)msRNG.Next(0, src.Height - options.height);
                cv.Rect rect = new cv.Rect(x1, x2, options.width, options.height);
                dst2.Rectangle(rect, Scalar.Red, 2);
                mats.Add(src[rect].Clone());
            }
            if (vbc.task.testAllRunning)
            {
                // It runs fine but after several runs during 'Test All', it will fail with an external exception.  Only happens on 'Test All' runs.
                SetTrueText("Stitch_Basics_CS only fails when running 'Test All'.\n" +
                            "Skipping it during a 'Test All' just so all the other tests can be exercised.", new cv.Point(10, 100), 3);
                return;
            }
            var stitcher = Stitcher.Create(Stitcher.Mode.Scans);
            Mat pano = new Mat();
            // stitcher may fail with an external exception if you make width and height too small.
            if (pano.Cols == 0) return;
            var status = stitcher.Stitch(mats, pano);
            dst3.SetTo(0);
            if (status == Stitcher.Status.OK)
            {
                int w = pano.Width, h = pano.Height;
                if (w > dst2.Width) w = dst2.Width;
                if (h > dst2.Height) h = dst2.Height;
                pano.CopyTo(dst3[new cv.Rect(0, 0, w, h)]);
            }
            else
            {
                if (status == Stitcher.Status.ErrorNeedMoreImgs) SetTrueText("Need more images", 3);
            }
        }
    }




    public class Structured_LinearizeFloor_CS : VB_Parent
    {
        public Structured_FloorCeiling floor = new Structured_FloorCeiling();
        Kalman_VB_Basics kalman = new Kalman_VB_Basics();
        public Mat sliceMask;
        public float floorYPlane;
        Options_StructuredFloor options = new Options_StructuredFloor();
        public Structured_LinearizeFloor_CS()
        {
            desc = "Using the mask for the floor create a better representation of the floor plane";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            floor.Run(src);
            dst2 = floor.dst2;
            dst3 = floor.dst3;
            sliceMask = floor.slice.sliceMask;
            Mat imuPC = vbc.task.pointCloud.Clone();
            imuPC.SetTo(0, ~sliceMask);
            if (Cv2.CountNonZero(sliceMask) > 0)
            {
                Mat[] split = imuPC.Split();
                if (options.xCheck)
                {
                    mmData mm = GetMinMax(split[0], sliceMask);
                    int firstCol = 0, lastCol = 0;
                    for (firstCol = 0; firstCol < sliceMask.Width; firstCol++)
                    {
                        if (Cv2.CountNonZero(sliceMask.Col(firstCol)) > 0) break;
                    }
                    for (lastCol = sliceMask.Width - 1; lastCol >= 0; lastCol--)
                    {
                        if (Cv2.CountNonZero(sliceMask.Col(lastCol)) > 0) break;
                    }
                    float xIncr = (float)((mm.maxVal - mm.minVal) / (lastCol - firstCol));
                    for (int i = firstCol; i <= lastCol; i++)
                    {
                        Mat maskCol = sliceMask.Col(i);
                        if (Cv2.CountNonZero(maskCol) > 0)
                            split[0].Col(i).SetTo(mm.minVal + xIncr * i, maskCol);
                    }
                }
                if (options.yCheck)
                {
                    mmData mm = GetMinMax(split[1], sliceMask);
                    kalman.kInput = (float)((mm.minVal + mm.maxVal) / 2);
                    kalman.Run(src);
                    floorYPlane = kalman.kAverage;
                    split[1].SetTo(floorYPlane, sliceMask);
                }
                if (options.zCheck)
                {
                    int firstRow = 0, lastRow = 0;
                    for (firstRow = 0; firstRow < sliceMask.Height; firstRow++)
                    {
                        if (Cv2.CountNonZero(sliceMask.Row(firstRow)) > 20) break;
                    }
                    for (lastRow = sliceMask.Height - 1; lastRow >= 0; lastRow--)
                    {
                        if (Cv2.CountNonZero(sliceMask.Row(lastRow)) > 20) break;
                    }
                    if (lastRow >= 0 && firstRow < sliceMask.Height)
                    {
                        Scalar meanMin = split[2].Row(lastRow).Mean(sliceMask.Row(lastRow));
                        Scalar meanMax = split[2].Row(firstRow).Mean(sliceMask.Row(firstRow));
                        float zIncr = (float)(meanMax[0] - meanMin[0]) / Math.Abs(lastRow - firstRow);
                        for (int i = firstRow; i <= lastRow; i++)
                        {
                            Mat maskRow = sliceMask.Row(i);
                            Scalar mean = split[2].Row(i).Mean(maskRow);
                            if (Cv2.CountNonZero(maskRow) > 0)
                            {
                                split[2].Row(i).SetTo(mean[0]);
                            }
                        }
                        DrawLine(dst2, new cv.Point(0, firstRow), new cv.Point(dst2.Width, firstRow), Scalar.Yellow, vbc.task.lineWidth + 1);
                        DrawLine(dst2, new cv.Point(0, lastRow), new cv.Point(dst2.Width, lastRow), Scalar.Yellow, vbc.task.lineWidth + 1);
                    }
                }
                Cv2.Merge(split, imuPC);
                imuPC.CopyTo(vbc.task.pointCloud, sliceMask);
            }
        }
    }




    public class Structured_MultiSlice_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public Mat sliceMask;
        public Mat[] split;
        public Options_Structured options = new Options_Structured();
        public Structured_MultiSlice_CS()
        {
            desc = "Use slices through the point cloud to find straight lines indicating planes present in the depth data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int stepSize = options.stepSize;
            heat.Run(src);
            split = vbc.task.pointCloud.Split();
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            for (int xCoordinate = 0; xCoordinate < src.Width; xCoordinate += stepSize)
            {
                float planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - xCoordinate) / vbc.task.topCameraPoint.X;
                if (xCoordinate > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (xCoordinate - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
                Mat depthMask = new Mat();
                double minVal, maxVal;
                minVal = planeX - vbc.task.metersPerPixel;
                maxVal = planeX + vbc.task.metersPerPixel;
                Cv2.InRange(split[0].Clone(), minVal, maxVal, depthMask);
                sliceMask = depthMask;
                if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
                dst3.SetTo(255, sliceMask);
            }
            for (int yCoordinate = 0; yCoordinate < src.Height; yCoordinate += stepSize)
            {
                float planeY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - yCoordinate) / vbc.task.sideCameraPoint.Y;
                if (yCoordinate > vbc.task.sideCameraPoint.Y) planeY = vbc.task.yRange * (yCoordinate - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
                Mat depthMask = new Mat();
                double minVal, maxVal;
                minVal = planeY - vbc.task.metersPerPixel;
                maxVal = planeY + vbc.task.metersPerPixel;
                Cv2.InRange(split[1].Clone(), minVal, maxVal, depthMask);
                Mat tmp = depthMask;
                sliceMask = tmp | sliceMask;
                dst3.SetTo(255, sliceMask);
            }
            dst2 = vbc.task.color.Clone();
            dst2.SetTo(Scalar.White, dst3);
        }
    }




    public class Structured_MultiSliceLines_CS : VB_Parent
    {
        Structured_MultiSlice multi = new Structured_MultiSlice();
        public Line_Basics lines = new Line_Basics();
        public Structured_MultiSliceLines_CS()
        {
            desc = "Detect lines in the multiSlice output";
        }
        public void RunAlg(Mat src)
        {
            multi.Run(src);
            dst3 = multi.dst3;
            lines.Run(dst3);
            dst2 = lines.dst2;
        }
    }




    public class Structured_Depth_CS : VB_Parent
    {
        Structured_SliceH sliceH = new Structured_SliceH();
        public Structured_Depth_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Use mouse to explore slices", "Top down view of the highlighted slice (at left)" };
            desc = "Use the structured depth to enhance the depth away from the centerline.";
        }
        public void RunAlg(Mat src)
        {
            sliceH.Run(src);
            dst0 = sliceH.dst3;
            dst2 = sliceH.dst2;
            Mat mask = sliceH.sliceMask;
            float perMeter = dst3.Height / vbc.task.MaxZmeters;
            dst3.SetTo(0);
            Vec3b white = new Vec3b(255, 255, 255);
            for (int y = 0; y < mask.Height; y++)
            {
                for (int x = 0; x < mask.Width; x++)
                {
                    byte val = mask.Get<byte>(y, x);
                    if (val > 0)
                    {
                        float depth = vbc.task.pcSplit[2].Get<float>(y, x);
                        int row = dst1.Height - (int)(depth * perMeter);
                        dst3.Set<Vec3b>(row < 0 ? 0 : row, x, white);
                    }
                }
            }
        }
    }




    public class Structured_Rebuild_CS : VB_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        Options_Structured options = new Options_Structured();
        float thickness;
        public Mat pointcloud = new Mat();
        public Structured_Rebuild_CS()
        {
            labels = new string[] { "", "", "X values in point cloud", "Y values in point cloud" };
            desc = "Rebuild the point cloud using inrange - not useful yet";
        }
        Mat rebuildX(Mat viewX)
        {
            Mat output = new Mat(vbc.task.pcSplit[1].Size(), MatType.CV_32F, cv.Scalar.All(0));
            int firstCol;
            for (firstCol = 0; firstCol < viewX.Width; firstCol++)
            {
                if (viewX.Col(firstCol).CountNonZero() > 0) break;
            }
            int lastCol;
            for (lastCol = viewX.Height - 1; lastCol >= 0; lastCol--)
            {
                if (viewX.Row(lastCol).CountNonZero() > 0) break;
            }
            Mat sliceMask = new Mat();
            for (int i = firstCol; i <= lastCol; i++)
            {
                float planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - i) / vbc.task.topCameraPoint.X;
                if (i > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (i - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
                Cv2.InRange(vbc.task.pcSplit[0], planeX - thickness, planeX + thickness, sliceMask);
                output.SetTo(planeX, sliceMask);
            }
            return output;
        }
        Mat rebuildY(Mat viewY)
        {
            Mat output = new Mat(vbc.task.pcSplit[1].Size(), MatType.CV_32F, cv.Scalar.All(0));
            int firstLine;
            for (firstLine = 0; firstLine < viewY.Height; firstLine++)
            {
                if (viewY.Row(firstLine).CountNonZero() > 0) break;
            }
            int lastLine;
            for (lastLine = viewY.Height - 1; lastLine >= 0; lastLine--)
            {
                if (viewY.Row(lastLine).CountNonZero() > 0) break;
            }
            Mat sliceMask = new Mat();
            for (int i = firstLine; i <= lastLine; i++)
            {
                float planeY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - i) / vbc.task.sideCameraPoint.Y;
                if (i > vbc.task.sideCameraPoint.Y) planeY = vbc.task.yRange * (i - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
                Cv2.InRange(vbc.task.pcSplit[1], planeY - thickness, planeY + thickness, sliceMask);
                output.SetTo(planeY, sliceMask);
            }
            return output;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            float metersPerPixel = vbc.task.MaxZmeters / dst3.Height;
            thickness = options.sliceSize * metersPerPixel;
            heat.Run(src);
            if (options.rebuilt)
            {
                vbc.task.pcSplit[0] = rebuildX(heat.dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
                vbc.task.pcSplit[1] = rebuildY(heat.dst2.CvtColor(ColorConversionCodes.BGR2GRAY));
                Cv2.Merge(vbc.task.pcSplit, pointcloud);
            }
            else
            {
                vbc.task.pcSplit = vbc.task.pointCloud.Split();
                pointcloud = vbc.task.pointCloud;
            }
            dst2 = Convert32f_To_8UC3(vbc.task.pcSplit[0]);
            dst3 = Convert32f_To_8UC3(vbc.task.pcSplit[1]);
            dst2.SetTo(0, vbc.task.noDepthMask);
            dst3.SetTo(0, vbc.task.noDepthMask);
        }
    }




    public class Structured_Cloud2_CS : VB_Parent
    {
        Pixel_Measure mmPixel = new Pixel_Measure();
        Options_StructuredCloud options = new Options_StructuredCloud();
        public Structured_Cloud2_CS()
        {
            desc = "Attempt to impose a structure on the point cloud data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Mat input = src;
            if (input.Type() != MatType.CV_32F) input = vbc.task.pcSplit[2];
            float stepX = dst2.Width / options.xLines;
            float stepY = dst2.Height / options.yLines;
            dst3 = new Mat(dst2.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            float midX = dst2.Width / 2;
            float midY = dst2.Height / 2;
            float halfStepX = stepX / 2;
            float halfStepy = stepY / 2;
            for (int y = 1; y < options.yLines - 1; y++)
            {
                for (int x = 1; x < options.xLines - 1; x++)
                {
                    Point2f p1 = new Point2f(x * stepX, y * stepY);
                    Point2f p2 = new Point2f((x + 1) * stepX, y * stepY);
                    float d1 = vbc.task.pcSplit[2].Get<float>((int)p1.Y, (int)p1.X);
                    float d2 = vbc.task.pcSplit[2].Get<float>((int)p2.Y, (int)p2.X);
                    if (stepX * options.threshold > Math.Abs(d1 - d2) && d1 > 0 && d2 > 0)
                    {
                        Vec3f p = vbc.task.pointCloud.Get<Vec3f>((int)p1.Y, (int)p1.X);
                        float mmPP = mmPixel.Compute(d1);
                        if (options.xConstraint)
                        {
                            p[0] = (p1.X - midX) * mmPP;
                            if (p1.X == midX) p[0] = mmPP;
                        }
                        if (options.yConstraint)
                        {
                            p[1] = (p1.Y - midY) * mmPP;
                            if (p1.Y == midY) p[1] = mmPP;
                        }
                        cv.Rect r = new cv.Rect((int)(p1.X - halfStepX), (int)(p1.Y - halfStepy), (int)stepX, (int)stepY);
                        Scalar meanVal = Cv2.Mean(vbc.task.pcSplit[2][r], vbc.task.depthMask[r]);
                        p[2] = (d1 + d2) / 2;
                        dst3.Set<Vec3f>(y, x, p);
                    }
                }
            }
            dst2 = dst3[new cv.Rect(0, 0, options.xLines, options.yLines)].Resize(dst2.Size(), 0, 0, InterpolationFlags.Nearest);
        }
    }




    public class Structured_Cloud_CS : VB_Parent
    {
        public Options_StructuredCloud options = new Options_StructuredCloud();
        public Structured_Cloud_CS()
        {
            vbc.task.gOptions.setGridSize(10);
            desc = "Attempt to impose a linear structure on the pointcloud.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int yLines = (int)(options.xLines * dst2.Height / dst2.Width);
            float stepX = dst3.Width / options.xLines;
            float stepY = dst3.Height / yLines;
            dst2 = new Mat(dst3.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            for (int y = 0; y < yLines; y++)
            {
                for (int x = 0; x < options.xLines; x++)
                {
                    cv.Rect r = new cv.Rect((int)(x * stepX), (int)(y * stepY), (int)(stepX - 1), (int)(stepY - 1));
                    cv.Point p1 = new cv.Point(r.X, r.Y);
                    cv.Point p2 = new cv.Point(r.X + r.Width, r.Y + r.Height);
                    Vec3f vec1 = vbc.task.pointCloud.Get<Vec3f>(p1.Y, p1.X);
                    Vec3f vec2 = vbc.task.pointCloud.Get<Vec3f>(p2.Y, p2.X);
                    if (vec1[2] > 0 && vec2[2] > 0) dst2[r].SetTo(vec1);
                }
            }
            labels[2] = "Structured_Cloud_CS with " + yLines.ToString() + " rows " + options.xLines.ToString() + " columns";
        }
    }




    public class Structured_ROI_CS : VB_Parent
    {
        public Mat data = new Mat();
        public List<cv.Point3f> oglData = new List<cv.Point3f>();
        public Structured_ROI_CS()
        {
            vbc.task.gOptions.setGridSize(10);
            desc = "Simplify the point cloud so it can be represented as quads in OpenGL";
        }
        public void RunAlg(Mat src)
        {
            dst2 = new Mat(dst3.Size(), MatType.CV_32FC3, cv.Scalar.All(0));
            foreach (var roi in vbc.task.gridRects)
            {
                Scalar d = vbc.task.pointCloud[roi].Mean(vbc.task.depthMask[roi]);
                Vec3f depth = new Vec3f((float)d.Val0, (float)d.Val1, (float)d.Val2);
                cv.Point pt = new cv.Point(roi.X + roi.Width / 2, roi.Y + roi.Height / 2);
                Vec3f vec = vbc.task.pointCloud.Get<Vec3f>(pt.Y, pt.X);
                if (vec[2] > 0) dst2[roi].SetTo(depth);
            }
            labels[2] = traceName + " with " + vbc.task.gridRects.Count().ToString() + " regions was created";
        }
    }




    public class Structured_Tiles_CS : VB_Parent
    {
        public List<Vec3f> oglData = new List<Vec3f>();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public Structured_Tiles_CS()
        {
            vbc.task.gOptions.setGridSize(10);
            desc = "Use the OpenGL point size to represent the point cloud as data";
        }
        public void RunAlg(Mat src)
        {
            hulls.Run(src);
            dst2 = hulls.dst3;
            dst3.SetTo(0);
            oglData.Clear();
            foreach (var roi in vbc.task.gridRects)
            {
                Vec3b c = dst2.Get<Vec3b>(roi.Y, roi.X);
                if (c == black) continue;
                oglData.Add(new Vec3f(c[2] / 255f, c[1] / 255f, c[0] / 255f));
                Scalar v = vbc.task.pointCloud[roi].Mean(vbc.task.depthMask[roi]);
                oglData.Add(new Vec3f((float)v.Val0, (float)v.Val1, (float)v.Val2));
                dst3[roi].SetTo(c);
            }
            labels[2] = traceName + " with " + vbc.task.gridRects.Count().ToString() + " regions was created";
        }
    }




    public class Structured_CountTop_CS : VB_Parent
    {
        Structured_SliceV slice = new Structured_SliceV();
        Plot_Histogram plot = new Plot_Histogram();
        List<float> counts = new List<float>();
        public Structured_CountTop_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Structured Slice heatmap input - red line is max", "Max Slice output - likely vertical surface", "Histogram of pixel counts in each slice" };
            desc = "Count the number of pixels found in each slice of the point cloud data.";
        }
        Mat makeXSlice(int index)
        {
            Mat sliceMask = new Mat();
            double planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - index) / vbc.task.topCameraPoint.X;
            if (index > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (index - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
            double minVal = planeX - vbc.task.metersPerPixel;
            double maxVal = planeX + vbc.task.metersPerPixel;
            Cv2.InRange(vbc.task.pcSplit[0].Clone(), minVal, maxVal, sliceMask);
            if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask); // don't include zero depth locations
            counts.Add(sliceMask.CountNonZero());
            return sliceMask;
        }
        public void RunAlg(Mat src)
        {
            slice.Run(src);
            dst1 = slice.dst3.Clone();
            counts.Clear();
            for (int i = 0; i <= dst2.Width - 1; i++)
            {
                makeXSlice(i);
            }
            float max = counts.Max();
            int index = counts.IndexOf(max);
            dst0 = makeXSlice(index);
            dst2 = vbc.task.color.Clone();
            dst2.SetTo(Scalar.White, dst0);
            dst1.Line(new cv.Point(index, 0), new cv.Point(index, dst1.Height), Scalar.Red, slice.options.sliceSize);
            Mat hist = cv.Mat.FromPixelData(dst0.Width, 1, MatType.CV_32F, counts.ToArray());
            plot.Run(hist);
            dst3 = plot.dst2;
        }
    }





    public class Structured_FeatureLines_CS : VB_Parent
    {
        Structured_MultiSlice mStruct = new Structured_MultiSlice();
        FeatureLine_Finder lines = new FeatureLine_Finder();
        public Structured_FeatureLines_CS()
        {
            desc = "Find the lines in the Structured_MultiSlice algorithm output";
        }
        public void RunAlg(Mat src)
        {
            mStruct.Run(src);
            dst2 = mStruct.dst2;
            lines.Run(mStruct.dst2);
            dst3 = src.Clone();
            for (int i = 0; i <= lines.lines2D.Count() - 1; i += 2)
            {
                cv.Point2f p1 = lines.lines2D[i];
                cv.Point2f p2 = lines.lines2D[i + 1];
                DrawLine(dst3, p1, p2, Scalar.Yellow, vbc.task.lineWidth);
            }
        }
    }




    public class Structured_FloorCeiling_CS : VB_Parent
    {
        public Structured_SliceEither slice = new Structured_SliceEither();
        Kalman_Basics kalman = new Kalman_Basics();
        public Structured_FloorCeiling_CS()
        {
            Array.Resize(ref kalman.kInput, 2);
            FindCheckBox("Top View (Unchecked Side View)").Checked = false;
            desc = "Find the floor or ceiling plane";
        }
        public void RunAlg(Mat src)
        {
            slice.Run(src);
            dst2 = slice.heat.dst3;
            double floorMax = 0;
            int floorY = 0;
            int floorBuffer = dst2.Height / 4;
            for (int i = dst2.Height - 1; i >= 0; i--)
            {
                double nextSum = slice.heat.dst3.Row(i).Sum()[0];
                if (nextSum > 0) floorBuffer -= 1;
                if (floorBuffer == 0) break;
                if (nextSum > floorMax)
                {
                    floorMax = nextSum;
                    floorY = i;
                }
            }
            double ceilingMax = 0;
            int ceilingY = 0;
            int ceilingBuffer = dst2.Height / 4;
            for (int i = 0; i < dst3.Height; i++)
            {
                double nextSum = slice.heat.dst3.Row(i).Sum()[0];
                if (nextSum > 0) ceilingBuffer -= 1;
                if (ceilingBuffer == 0) break;
                if (nextSum > ceilingMax)
                {
                    ceilingMax = nextSum;
                    ceilingY = i;
                }
            }
            kalman.kInput[0] = floorY;
            kalman.kInput[1] = ceilingY;
            kalman.Run(src);
            labels[2] = "Current slice is at row =" + vbc.task.mouseMovePoint.Y.ToString();
            labels[3] = "Ceiling is at row =" + ((int)kalman.kOutput[1]).ToString() + " floor at y=" + ((int)kalman.kOutput[0]).ToString();
            DrawLine(dst2, new cv.Point(0, floorY), new cv.Point(dst2.Width, floorY), Scalar.Yellow);
            SetTrueText("floor", new cv.Point(10, floorY + vbc.task.DotSize), 3);
            cv.Rect rect = new cv.Rect(0, Math.Max(ceilingY - 5, 0), dst2.Width, 10);
            Mat mask = slice.heat.dst3[rect];
            Scalar mean, stdev;
            Cv2.MeanStdDev(mask, out mean, out stdev);
            if (mean[0] < mean[2])
            {
                DrawLine(dst2, new cv.Point(0, ceilingY), new cv.Point(dst2.Width, ceilingY), Scalar.Yellow);
                SetTrueText("ceiling", new cv.Point(10, ceilingY + vbc.task.DotSize), 3);
            }
            else
            {
                SetTrueText("Ceiling does not appear to be present", 3);
            }
        }
    }




    public class Structured_MultiSliceH_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public Mat sliceMask;
        Options_Structured options = new Options_Structured();
        public Structured_MultiSliceH_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = false;
            desc = "Use slices through the point cloud to find straight lines indicating planes present in the depth data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int stepsize = options.stepSize;
            heat.Run(src);
            dst3 = heat.dst3;
            sliceMask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            for (int yCoordinate = 0; yCoordinate <= src.Height - 1; yCoordinate += stepsize)
            {
                double planeY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - yCoordinate) / vbc.task.sideCameraPoint.Y;
                if (yCoordinate > vbc.task.sideCameraPoint.Y) planeY = vbc.task.yRange * (yCoordinate - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
                Mat depthMask = new Mat();
                double minVal, maxVal;
                minVal = planeY - vbc.task.metersPerPixel;
                maxVal = planeY + vbc.task.metersPerPixel;
                Cv2.InRange(vbc.task.pcSplit[1].Clone(), minVal, maxVal, depthMask);
                sliceMask.SetTo(255, depthMask);
                if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            }
            dst2 = vbc.task.color.Clone();
            dst2.SetTo(Scalar.White, sliceMask);
            labels[3] = heat.labels[3];
        }
    }




    public class Structured_MultiSliceV_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        Options_Structured options = new Options_Structured();
        public Structured_MultiSliceV_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = true;
            desc = "Use slices through the point cloud to find straight lines indicating planes present in the depth data.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int stepsize = options.stepSize;
            heat.Run(src);
            dst3 = heat.dst2;
            Mat sliceMask = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            for (int xCoordinate = 0; xCoordinate <= src.Width - 1; xCoordinate += stepsize)
            {
                double planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - xCoordinate) / vbc.task.topCameraPoint.X;
                if (xCoordinate > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (xCoordinate - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
                Mat depthMask = new Mat();
                double minVal, maxVal;
                minVal = planeX - vbc.task.metersPerPixel;
                maxVal = planeX + vbc.task.metersPerPixel;
                Cv2.InRange(vbc.task.pcSplit[0].Clone(), minVal, maxVal, depthMask);
                sliceMask.SetTo(255, depthMask);
                if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            }
            dst2 = vbc.task.color.Clone();
            dst2.SetTo(Scalar.White, sliceMask);
            labels[3] = heat.labels[3];
        }
    }




    public class Structured_SliceXPlot_CS : VB_Parent
    {
        Structured_MultiSlice multi = new Structured_MultiSlice();
        Options_Structured options = new Options_Structured();
        public Structured_SliceXPlot_CS()
        {
            desc = "Find any plane around a peak value in the top-down histogram";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            multi.Run(src);
            dst3 = multi.heat.dst2;
            int col = (vbc.task.mouseMovePoint.X == 0) ? dst2.Width / 2 : vbc.task.mouseMovePoint.X;
            cv.Rect rect = new cv.Rect(col, 0, (col + options.sliceSize >= dst3.Width) ? dst3.Width - col : options.sliceSize, dst3.Height - 1);
            mmData mm = GetMinMax(multi.heat.topframes.dst2[rect]);
            DrawCircle(dst3, new cv.Point(col, mm.maxLoc.Y), vbc.task.DotSize + 3, Scalar.Yellow);
            dst2 = vbc.task.color.Clone();
            double filterZ = (dst3.Height - mm.maxLoc.Y) / dst3.Height * vbc.task.MaxZmeters;
            if (filterZ > 0)
            {
                Mat depthMask = vbc.task.pcSplit[2].InRange(filterZ - 0.05, filterZ + 0.05); // a 10 cm buffer surrounding the z value
                depthMask = multi.sliceMask & depthMask;
                dst2.SetTo(Scalar.White, depthMask);
            }
            labels[3] = "Peak histogram count (" + mm.maxVal.ToString("F0") + ") at " + filterZ.ToString("F2") + " meters +-" + (5 / dst2.Height / vbc.task.MaxZmeters).ToString("F2") + " m";
            SetTrueText("Use the mouse to move the yellow dot above.", new cv.Point(10, dst2.Height * 7 / 8), 3);
        }
    }




    public class Structured_SliceYPlot_CS : VB_Parent
    {
        Structured_MultiSlice multi = new Structured_MultiSlice();
        Options_Structured options = new Options_Structured();
        public Structured_SliceYPlot_CS()
        {
            desc = "Find any plane around a peak value in the side view histogram";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            multi.Run(src);
            dst3 = multi.heat.dst3;
            int row = vbc.task.mouseMovePoint.Y == 0 ? dst2.Height / 2 : vbc.task.mouseMovePoint.Y;
            cv.Rect rect = new cv.Rect(0, row, dst3.Width - 1, row + options.sliceSize >= dst3.Height ? dst3.Height - row : options.sliceSize);
            mmData mm = GetMinMax(multi.heat.sideframes.dst2[rect]);
            if (mm.maxVal > 0)
            {
                DrawCircle(dst3, new cv.Point(mm.maxLoc.X, row), vbc.task.DotSize + 3, Scalar.Yellow);
                // dst3.Line(new cv.Point(mm.maxLoc.X, 0), new cv.Point(mm.maxLoc.X, dst3.Height), vbc.task.HighlightColor, vbc.task.lineWidth, vbc.task.lineType);
                double filterZ = mm.maxLoc.X / (double)dst3.Width * vbc.task.MaxZmeters;
                Mat depthMask = vbc.task.pcSplit[2].InRange(filterZ - 0.05, filterZ + 0.05); // a 10 cm buffer surrounding the z value
                dst2 = vbc.task.color.Clone();
                dst2.SetTo(Scalar.White, depthMask);
                double pixelsPerMeter = (double)dst2.Width / vbc.task.MaxZmeters;
                labels[3] = $"Peak histogram count ({mm.maxVal.ToString(vbc.fmt0)}) at {filterZ.ToString(vbc.fmt2)} meters ±{(5 / pixelsPerMeter).ToString(vbc.fmt2)} m";
            }
            SetTrueText("Use the mouse to move the yellow dot above.", new cv.Point(10, dst2.Height * 7 / 8), 3);
        }
    }




    public class Structured_MouseSlice_CS : VB_Parent
    {
        Structured_SliceEither slice = new Structured_SliceEither();
        Line_Basics lines = new Line_Basics();
        public Structured_MouseSlice_CS()
        {
            labels[2] = "Center Slice in yellow";
            labels[3] = "White = SliceV output, Red Dot is avgPt";
            desc = "Find the vertical center line with accurate depth data.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.mouseMovePoint == new cv.Point()) vbc.task.mouseMovePoint = new cv.Point(dst2.Width / 2, dst2.Height);
            slice.Run(src);
            lines.Run(slice.sliceMask);
            List<int> tops = new List<int>();
            List<int> bots = new List<int>();
            List<cv.Point> topsList = new List<cv.Point>();
            List<cv.Point> botsList = new List<cv.Point>();
            if (lines.lpList.Count() > 0)
            {
                dst3 = lines.dst2;
                foreach (var lp in lines.lpList)
                {
                    DrawLine(dst3, lp.p1, lp.p2, vbc.task.HighlightColor, vbc.task.lineWidth + 3);
                    if (lp.p1.Y < lp.p2.Y) tops.Add((int)lp.p1.Y); else tops.Add((int)lp.p2.Y);
                    if (lp.p1.Y > lp.p2.Y) bots.Add((int)lp.p1.Y); else bots.Add((int)lp.p2.Y);
                    topsList.Add(new cv.Point(lp.p1.X, lp.p1.Y));
                    botsList.Add(new cv.Point(lp.p2.X, lp.p2.Y));
                }
            }
            if (standaloneTest())
            {
                dst2 = src;
                dst2.SetTo(Scalar.White, dst3);
            }
        }
    }




    public class Structured_SliceEither_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public Mat sliceMask = new Mat();
        Options_Structured options = new Options_Structured();
        public Structured_SliceEither_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = false;
            desc = "Create slices in top and side views";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            bool topView = FindCheckBox("Top View (Unchecked Side View)").Checked;
            int sliceVal = topView ? vbc.task.mouseMovePoint.X : vbc.task.mouseMovePoint.Y;
            heat.Run(src);
            double minVal, maxVal;
            if (topView)
            {
                double planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - sliceVal) / vbc.task.topCameraPoint.X;
                if (sliceVal > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (sliceVal - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
                minVal = planeX - vbc.task.metersPerPixel;
                maxVal = planeX + vbc.task.metersPerPixel;
                sliceMask = vbc.task.pcSplit[0].InRange(minVal, maxVal);
            }
            else
            {
                double planeY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - sliceVal) / vbc.task.sideCameraPoint.Y;
                if (sliceVal > vbc.task.sideCameraPoint.Y) planeY = vbc.task.yRange * (sliceVal - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
                minVal = planeY - vbc.task.metersPerPixel;
                maxVal = planeY + vbc.task.metersPerPixel;
                sliceMask = vbc.task.pcSplit[1].InRange(minVal, maxVal);
            }
            if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            double w = Math.Abs(maxVal - minVal) * 100;
            labels[2] = $"At offset {sliceVal} x = {((maxVal + minVal) / 2).ToString(vbc.fmt2)} with {w.ToString(vbc.fmt2)} cm width";
            labels[3] = heat.labels[3];
            dst3 = heat.dst3;
            DrawCircle(dst3, new cv.Point(vbc.task.topCameraPoint.X, dst3.Height), vbc.task.DotSize, Scalar.Yellow);
            if (topView)
            {
                dst3.Line(new cv.Point(sliceVal, 0), new cv.Point(sliceVal, dst3.Height), Scalar.Yellow, vbc.task.lineWidth);
            }
            else
            {
                int yPlaneOffset = sliceVal < dst3.Height - options.sliceSize ? sliceVal : dst3.Height - options.sliceSize - 1;
                dst3.Line(new cv.Point(0, yPlaneOffset), new cv.Point(dst3.Width, yPlaneOffset), Scalar.Yellow, options.sliceSize);
            }
            if (standaloneTest())
            {
                dst2 = src;
                dst2.SetTo(Scalar.White, sliceMask);
            }
        }
    }




    public class Structured_TransformH_CS : VB_Parent
    {
        Options_Structured options = new Options_Structured();
        Projection_HistTop histTop = new Projection_HistTop();
        public Structured_TransformH_CS()
        {
            labels[3] = "Top down view of the slice of the point cloud";
            desc = "Find and isolate planes (floor and ceiling) in a TopView or SideView histogram.";
        }
        public Mat createSliceMaskH()
        {
            options.RunOpt();
            Mat sliceMask = new Mat();
            int ycoordinate = vbc.task.mouseMovePoint.Y == 0 ? dst2.Height / 2 : vbc.task.mouseMovePoint.Y;
            double planeY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - ycoordinate) / vbc.task.sideCameraPoint.Y;
            if (ycoordinate > vbc.task.sideCameraPoint.Y) planeY = vbc.task.yRange * (ycoordinate - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
            double thicknessMeters = options.sliceSize * vbc.task.metersPerPixel;
            double minVal = planeY - thicknessMeters;
            double maxVal = planeY + thicknessMeters;
            Cv2.InRange(vbc.task.pcSplit[1], minVal, maxVal, sliceMask);
            double w = Math.Abs(maxVal - minVal) * 100;
            labels[2] = $"At offset {ycoordinate} y = {((maxVal + minVal) / 2).ToString(vbc.fmt2)} with {w.ToString(vbc.fmt2)} cm width";
            if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            return sliceMask;
        }
        public void RunAlg(Mat src)
        {
            Mat sliceMask = createSliceMaskH();
            histTop.Run(vbc.task.pointCloud.SetTo(0, ~sliceMask));
            dst3 = histTop.dst2;
            if (standaloneTest())
            {
                dst2 = src;
                dst2.SetTo(Scalar.White, sliceMask);
            }
        }
    }




    public class Structured_TransformV_CS : VB_Parent
    {
        Options_Structured options = new Options_Structured();
        Projection_HistSide histSide = new Projection_HistSide();
        public Structured_TransformV_CS()
        {
            labels[3] = "Side view of the slice of the point cloud";
            desc = "Find and isolate planes using the top view histogram data";
        }
        public Mat createSliceMaskV()
        {
            options.RunOpt();
            Mat sliceMask = new Mat();
            if (vbc.task.mouseMovePoint == new cv.Point()) vbc.task.mouseMovePoint = new cv.Point(dst2.Width / 2, dst2.Height);
            int xCoordinate = vbc.task.mouseMovePoint.X == 0 ? dst2.Width / 2 : vbc.task.mouseMovePoint.X;
            double planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - xCoordinate) / vbc.task.topCameraPoint.X;
            if (xCoordinate > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (xCoordinate - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
            double thicknessMeters = options.sliceSize * vbc.task.metersPerPixel;
            double minVal = planeX - thicknessMeters;
            double maxVal = planeX + thicknessMeters;
            Cv2.InRange(vbc.task.pcSplit[0], minVal, maxVal, sliceMask);
            double w = Math.Abs(maxVal - minVal) * 100;
            labels[2] = $"At offset {xCoordinate} x = {((maxVal + minVal) / 2).ToString(vbc.fmt2)} with {w.ToString(vbc.fmt2)} cm width";
            if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            return sliceMask;
        }
        public void RunAlg(Mat src)
        {
            Mat sliceMask = createSliceMaskV();
            histSide.Run(vbc.task.pointCloud.SetTo(0, ~sliceMask));
            dst3 = histSide.dst2;
            if (standaloneTest())
            {
                dst2 = src;
                dst2.SetTo(Scalar.White, sliceMask);
            }
        }
    }




    public class Structured_CountSide_CS : VB_Parent
    {
        Structured_SliceH slice = new Structured_SliceH();
        Plot_Histogram plot = new Plot_Histogram();
        Rotate_Basics rotate = new Rotate_Basics();
        public List<float> counts = new List<float>();
        public int maxCountIndex;
        public List<float> yValues = new List<float>();
        public Structured_CountSide_CS()
        {
            rotate.rotateCenter = new cv.Point((int)(dst2.Width / 2), (int)(dst2.Width / 2));
            rotate.rotateAngle = -90;
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Max Slice output - likely flat surface", "Structured Slice heatmap input - red line is max", "Histogram of pixel counts in each slice" };
            desc = "Count the number of pixels found in each slice of the point cloud data.";
        }
        public void RunAlg(Mat src)
        {
            slice.Run(src);
            dst2 = slice.dst3;
            counts.Clear();
            yValues.Clear();
            for (int i = 0; i <= dst2.Height - 1; i++)
            {
                float planeY = vbc.task.yRange * (i - vbc.task.sideCameraPoint.Y) / vbc.task.sideCameraPoint.Y;
                float minVal = planeY - vbc.task.metersPerPixel, maxVal = planeY + vbc.task.metersPerPixel;
                Mat sliceMask = vbc.task.pcSplit[1].InRange(minVal, maxVal);
                if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask); // don't include zero depth locations
                counts.Add(sliceMask.CountNonZero());
                yValues.Add(planeY);
            }
            float max = counts.Max();
            maxCountIndex = counts.IndexOf(max);
            dst2.Line(new cv.Point(0, maxCountIndex), new cv.Point(dst2.Width, maxCountIndex), Scalar.Red, slice.options.sliceSize);
            Mat hist = cv.Mat.FromPixelData(dst0.Height, 1, MatType.CV_32F, counts.ToArray());
            plot.dst2 = new Mat(dst2.Height, dst2.Height, MatType.CV_8UC3, cv.Scalar.All(0));
            plot.Run(hist);
            dst3 = plot.dst2;
            dst3 = dst3.Resize(new cv.Size(dst2.Width, dst2.Width));
            rotate.Run(dst3);
            dst3 = rotate.dst2;
            SetTrueText("Max flat surface at: " + "\n" + string.Format(vbc.fmt3, yValues[maxCountIndex]), 2);
        }
    }




    public class Structured_CountSideSum_CS : VB_Parent
    {
        public List<float> counts = new List<float>();
        public int maxCountIndex;
        public List<float> yValues = new List<float>();
        public Structured_CountSideSum_CS()
        {
            vbc.task.redOptions.setProjection(vbc.task.redOptions.getProjection() + 50); // to get the point cloud into the histogram.
            labels = new string[] { "", "Max Slice output - likely flat surface", "Structured Slice heatmap input - red line is max", "Histogram of pixel counts in each slice" };
            desc = "Count the number of points found in each slice of the point cloud data.";
        }
        public void RunAlg(Mat src)
        {
            Cv2.CalcHist(new Mat[] { vbc.task.pointCloud }, vbc.task.channelsSide, new Mat(), dst2, 2, vbc.task.bins2D, vbc.task.rangesSide);
            dst2.Col(0).SetTo(0);
            counts.Clear();
            yValues.Clear();
            float ratio = vbc.task.yRange / vbc.task.yRangeDefault;
            for (int i = 0; i <= dst2.Height - 1; i++)
            {
                float planeY = vbc.task.yRange * (i - vbc.task.sideCameraPoint.Y) / vbc.task.sideCameraPoint.Y;
                counts.Add((float)dst2.Row(i).Sum()[0]);
                yValues.Add(planeY * ratio);
            }
            dst2 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
            float max = counts.Max();
            if (max == 0) return;
            List<float> surfaces = new List<float>();
            for (int i = 0; i < counts.Count(); i++)
            {
                if (counts[i] >= max / 2)
                {
                    DrawLine(dst2, new cv.Point(0, i), new cv.Point(dst2.Width, i), Scalar.White);
                    surfaces.Add(yValues[i]);
                }
            }
            if (vbc.task.heartBeat)
            {
                strOut = "Flat surface at: ";
                for (int i = 0; i < surfaces.Count(); i++)
                {
                    strOut += string.Format(vbc.fmt3, surfaces[i]) + ", ";
                    if (i % 10 == 0 && i > 0) strOut += "\n";
                }
            }
            SetTrueText(strOut, 2);
            dst3.SetTo(Scalar.Red);
            float barHeight = dst2.Height / counts.Count();
            for (int i = 0; i < counts.Count(); i++)
            {
                float w = dst2.Width * counts[i] / max;
                Cv2.Rectangle(dst3, new cv.Rect(0, (int)(i * barHeight), (int)w, (int)barHeight), Scalar.Black, -1);
            }
        }
    }




    public class Structured_SliceV_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public Mat sliceMask = new Mat();
        public Options_Structured options = new Options_Structured();
        public Structured_SliceV_CS()
        {
            FindCheckBox("Top View (Unchecked Side View)").Checked = true;
            desc = "Find and isolate planes using the top view histogram data";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.mouseMovePoint == new cv.Point()) vbc.task.mouseMovePoint = new cv.Point(dst2.Width / 2, dst2.Height);
            int xCoordinate = (vbc.task.mouseMovePoint.X == 0) ? dst2.Width / 2 : vbc.task.mouseMovePoint.X;
            heat.Run(src);
            float planeX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - xCoordinate) / vbc.task.topCameraPoint.X;
            if (xCoordinate > vbc.task.topCameraPoint.X) planeX = vbc.task.xRange * (xCoordinate - vbc.task.topCameraPoint.X) / (dst3.Width - vbc.task.topCameraPoint.X);
            float thicknessMeters = options.sliceSize * vbc.task.metersPerPixel;
            float minVal = planeX - thicknessMeters;
            float maxVal = planeX + thicknessMeters;
            Cv2.InRange(vbc.task.pcSplit[0], minVal, maxVal, sliceMask);
            if (minVal < 0 && maxVal > 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            labels[2] = "At offset " + xCoordinate + " x = " + string.Format(vbc.fmt2, (maxVal + minVal) / 2) +
                        " with " + string.Format(vbc.fmt2, Math.Abs(maxVal - minVal) * 100) + " cm width";
            labels[3] = heat.labels[3];
            dst3 = heat.dst2;
            DrawCircle(dst3, new cv.Point(vbc.task.topCameraPoint.X, 0), vbc.task.DotSize, vbc.task.HighlightColor);
            dst3.Line(new cv.Point(xCoordinate, 0), new cv.Point(xCoordinate, dst3.Height), vbc.task.HighlightColor, options.sliceSize);
            if (standaloneTest())
            {
                dst2 = src;
                dst2.SetTo(Scalar.White, sliceMask);
            }
        }
    }




    public class Structured_SliceH_CS : VB_Parent
    {
        public HeatMap_Basics heat = new HeatMap_Basics();
        public Mat sliceMask = new Mat();
        public Options_Structured options = new Options_Structured();
        public int ycoordinate;
        public Structured_SliceH_CS()
        {
            desc = "Find and isolate planes (floor and ceiling) in a TopView or SideView histogram.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            heat.Run(src);
            if (standaloneTest()) ycoordinate = (vbc.task.mouseMovePoint.Y == 0) ? dst2.Height / 2 : vbc.task.mouseMovePoint.Y;
            float sliceY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - ycoordinate) / vbc.task.sideCameraPoint.Y;
            if (ycoordinate > vbc.task.sideCameraPoint.Y) sliceY = vbc.task.yRange * (ycoordinate - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
            float thicknessMeters = options.sliceSize * vbc.task.metersPerPixel;
            float minVal = sliceY - thicknessMeters;
            float maxVal = sliceY + thicknessMeters;
            Cv2.InRange(vbc.task.pcSplit[1], minVal, maxVal, sliceMask);
            labels[2] = "At offset " + ycoordinate + " y = " + string.Format(vbc.fmt2, (maxVal + minVal) / 2) +
                        " with " + string.Format(vbc.fmt2, Math.Abs(maxVal - minVal) * 100) + " cm width";
            if (minVal <= 0 && maxVal >= 0) sliceMask.SetTo(0, vbc.task.noDepthMask);
            labels[3] = heat.labels[2];
            dst3 = heat.dst3;
            int yPlaneOffset = (ycoordinate < dst3.Height - options.sliceSize) ? ycoordinate : dst3.Height - options.sliceSize - 1;
            DrawCircle(dst3, new cv.Point(0, vbc.task.sideCameraPoint.Y), vbc.task.DotSize, vbc.task.HighlightColor);
            dst3.Line(new cv.Point(0, yPlaneOffset), new cv.Point(dst3.Width, yPlaneOffset), vbc.task.HighlightColor, options.sliceSize);
            if (standaloneTest())
            {
                dst2 = src;
                dst2.SetTo(Scalar.White, sliceMask);
            }
        }
    }




    public class Structured_SurveyH_CS : VB_Parent
    {
        public Structured_SurveyH_CS()
        {
            vbc.task.redOptions.setYRangeSlider(300);
            UpdateAdvice(traceName + ": use Y-Range slider in RedCloud options.");
            labels[2] = "Each slice represents point cloud pixels with the same Y-Range";
            labels[3] = "Y-Range - compressed to increase the size of each slice.  Use Y-range slider to adjust the size of each slice.";
            desc = "Mark each horizontal slice with a separate color.  Y-Range determines how thick the slice is.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsSide, new Mat(), dst3, 2, vbc.task.bins2D, vbc.task.rangesSide);
            dst3.Col(0).SetTo(0);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary);
            dst3.ConvertTo(dst3, MatType.CV_8U);
            int topRow;
            for (topRow = 0; topRow <= dst2.Height - 1; topRow++)
            {
                if (dst3.Row(topRow).CountNonZero() > 0) break;
            }
            int botRow;
            for (botRow = dst2.Height - 1; botRow >= 0; botRow--)
            {
                if (dst3.Row(botRow).CountNonZero() > 0) break;
            }
            int index = 0;
            dst2.SetTo(0);
            for (int y = topRow; y <= botRow; y++)
            {
                float sliceY = -vbc.task.yRange * (vbc.task.sideCameraPoint.Y - y) / vbc.task.sideCameraPoint.Y;
                if (y > vbc.task.sideCameraPoint.Y) sliceY = vbc.task.yRange * (y - vbc.task.sideCameraPoint.Y) / (dst3.Height - vbc.task.sideCameraPoint.Y);
                float minVal = sliceY - vbc.task.metersPerPixel;
                float maxVal = sliceY + vbc.task.metersPerPixel;
                if (minVal < 0 && maxVal > 0) continue;
                dst0 = vbc.task.pcSplit[1].InRange(minVal, maxVal);
                dst2.SetTo(vbc.task.scalarColors[index % 256], dst0);
                index++;
            }
        }
    }




    public class Structured_SurveyV_CS : VB_Parent
    {
        public Structured_SurveyV_CS()
        {
            vbc.task.redOptions.setXRangeSlider(250);
            UpdateAdvice(traceName + ": use X-Range slider in RedCloud options.");
            labels[2] = "Each slice represents point cloud pixels with the same X-Range";
            labels[3] = "X-Range - compressed to increase the size of each slice.  Use X-range slider to adjust the size of each slice.";
            desc = "Mark each vertical slice with a separate color.  X-Range determines how thick the slice is.";
        }
        public void RunAlg(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = vbc.task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, vbc.task.channelsTop, new Mat(), dst3, 2, vbc.task.bins2D, vbc.task.rangesTop);
            dst3.Row(0).SetTo(0);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary);
            dst3.ConvertTo(dst3, MatType.CV_8U);
            int column;
            for (column = 0; column < dst2.Width; column++)
            {
                if (dst3.Col(column).CountNonZero() > 0) break;
            }
            int lastColumn;
            for (lastColumn = dst2.Width - 1; lastColumn >= 0; lastColumn--)
            {
                if (dst3.Col(lastColumn).CountNonZero() > 0) break;
            }
            int index = 0;
            dst2.SetTo(0);
            for (int x = column; x <= lastColumn; x++)
            {
                float sliceX = -vbc.task.xRange * (vbc.task.topCameraPoint.X - x) / vbc.task.topCameraPoint.X;
                if (x > vbc.task.topCameraPoint.X) sliceX = vbc.task.xRange * (x - vbc.task.topCameraPoint.X) / (dst3.Height - vbc.task.topCameraPoint.X);
                float minVal = sliceX - vbc.task.metersPerPixel;
                float maxVal = sliceX + vbc.task.metersPerPixel;
                if (minVal < 0 && maxVal > 0) continue;
                dst0 = vbc.task.pcSplit[0].InRange(minVal, maxVal);
                dst2.SetTo(vbc.task.scalarColors[index % 256], dst0);
                index++;
            }
        }
    }




    public class Structured_MultiSlicePolygon_CS : VB_Parent
    {
        Structured_MultiSlice multi = new Structured_MultiSlice();
        Options_StructuredMulti options = new Options_StructuredMulti();
        public Structured_MultiSlicePolygon_CS()
        {
            labels[2] = "Input to FindContours";
            labels[3] = "ApproxPolyDP 4-corner object from FindContours input";
            desc = "Detect polygons in the multiSlice output";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            multi.Run(src);
            dst2 = ~multi.dst3;
            cv.Point[][] rawContours = Cv2.FindContoursAsArray(dst2, RetrievalModes.Tree, 
                                                               ContourApproximationModes.ApproxSimple);
            cv.Point[][] contours = new cv.Point[rawContours.Length][];
            for (int j = 0; j < rawContours.Length; j++)
            {
                contours[j] = Cv2.ApproxPolyDP(rawContours[j], 3, true);
            }
            dst3.SetTo(0);
            for (int i = 0; i < contours.Length; i++)
            {
                if (contours[i].Length == 2) continue;
                if (contours[i].Length <= options.maxSides)
                {
                    Cv2.DrawContours(dst3, contours, i, new Scalar(0, 255, 255), vbc.task.lineWidth + 1, vbc.task.lineType);
                }
            }
        }
    }




    public class Structured_Crosshairs_CS : VB_Parent
    {
        Structured_Cloud sCloud = new Structured_Cloud();
        double minX, maxX, minY, maxY;
        public Structured_Crosshairs_CS()
        {
            desc = "Connect vertical and horizontal dots that are in the same column and row.";
        }
        public void RunAlg(Mat src)
        {
            int xLines = sCloud.options.indexX;
            int yLines = (int)(xLines * dst2.Width / dst2.Height);
            if (sCloud.options.indexX > xLines) sCloud.options.indexX = xLines - 1;
            if (sCloud.options.indexY > yLines) sCloud.options.indexY = yLines - 1;
            sCloud.Run(src);
            Mat[] split = Cv2.Split(sCloud.dst2);
            var mmX = GetMinMax(split[0]);
            var mmY = GetMinMax(split[1]);
            minX = Math.Min(minX, mmX.minVal);
            minY = Math.Min(minY, mmY.minVal);
            maxX = Math.Max(maxX, mmX.maxVal);
            maxY = Math.Max(maxY, mmY.maxVal);
            SetTrueText("mmx min/max = " + minX.ToString("0.00") + "/" + maxX.ToString("0.00") + " mmy min/max " + minY.ToString("0.00") +
                        "/" + maxY.ToString("0.00"), 3);
            dst2.SetTo(0);
            Vec3b white = new Vec3b(255, 255, 255);
            Mat pointX = new Mat(sCloud.dst2.Size(), MatType.CV_32S, cv.Scalar.All(0));
            Mat pointY = new Mat(sCloud.dst2.Size(), MatType.CV_32S, cv.Scalar.All(0));
            int yy, xx;
            for (int y = 1; y < sCloud.dst2.Height - 1; y++)
            {
                for (int x = 1; x < sCloud.dst2.Width - 1; x++)
                {
                    Vec3f p = sCloud.dst2.Get<Vec3f>(y, x);
                    if (p[2] > 0)
                    {
                        if (float.IsNaN(p[0]) || float.IsNaN(p[1]) || float.IsNaN(p[2])) continue;
                        xx = (int)(dst2.Width * (maxX - p[0]) / (maxX - minX));
                        yy = (int)(dst2.Height * (maxY - p[1]) / (maxY - minY));
                        if (xx < 0) xx = 0;
                        if (yy < 0) yy = 0;
                        if (xx >= dst2.Width) xx = dst2.Width - 1;
                        if (yy >= dst2.Height) yy = dst2.Height - 1;
                        yy = dst2.Height - yy - 1;
                        xx = dst2.Width - xx - 1;
                        dst2.Set<Vec3b>(yy, xx, white);
                        pointX.Set<int>(y, x, xx);
                        pointY.Set<int>(y, x, yy);
                        if (x == sCloud.options.indexX)
                        {
                            cv.Point p1 = new cv.Point(pointX.Get<int>(y - 1, x), pointY.Get<int>(y - 1, x));
                            if (p1.X > 0)
                            {
                                cv.Point p2 = new cv.Point(xx, yy);
                                dst2.Line(p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth + 1, vbc.task.lineType);
                            }
                        }
                        if (y == sCloud.options.indexY)
                        {
                            cv.Point p1 = new cv.Point(pointX.Get<int>(y, x - 1), pointY.Get<int>(y, x - 1));
                            if (p1.X > 0)
                            {
                                cv.Point p2 = new cv.Point(xx, yy);
                                dst2.Line(p1, p2, vbc.task.HighlightColor, vbc.task.lineWidth + 1, vbc.task.lineType);
                            }
                        }
                    }
                }
            }
        }
    }




    public class SuperPixel_Basics_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public SuperPixel_Basics_CS()
        {
            labels[2] = "Super Pixel cells";
            desc = "A Better superpixel algorithm";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3 = src;
            foreach (var rc in vbc.task.redCells)
            {
                DrawContour(dst3[rc.rect], rc.contour, Scalar.White, vbc.task.lineWidth);
            }
        }
    }




    public class SuperPixel_Basics_CPP_CS : VB_Parent
    {
        public Mat wireGrid;
        public Scalar gridColor = Scalar.White;
        Options_SuperPixels options = new Options_SuperPixels();
        public SuperPixel_Basics_CPP_CS()
        {
            labels[3] = "Superpixel label data (0-255)";
            desc = "Sub-divide the image into super pixels.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.optionsChanged)
            {
                if (cPtr != (IntPtr)0) SuperPixel_Close(cPtr);
                cPtr = SuperPixel_Open(src.Width, src.Height, options.numSuperPixels, options.numIterations, options.prior);
            }
            var input = src;
            if (input.Channels() == 1) input = input.CvtColor(ColorConversionCodes.GRAY2BGR);
            var dataSrc = new byte[input.Total() * input.ElemSize()];
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            var handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            var imagePtr = SuperPixel_Run(cPtr, handleSrc.AddrOfPinnedObject());
            handleSrc.Free();
            dst2 = input;
            dst2.SetTo(gridColor, cv.Mat.FromPixelData(input.Rows, input.Cols, MatType.CV_8UC1, imagePtr));
            var labelData = new byte[input.Total() * 4]; // labels are 32-bit integers.
            var labelPtr = SuperPixel_GetLabels(cPtr);
            Marshal.Copy(labelPtr, labelData, 0, labelData.Length);
            var labels = cv.Mat.FromPixelData(input.Rows, input.Cols, MatType.CV_32S, labelData);
            if (options.numSuperPixels < 255) labels *= 255 / options.numSuperPixels;
            labels.ConvertTo(dst3, MatType.CV_8U);
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = SuperPixel_Close(cPtr);
        }
    }




    public class SuperPixel_BinarizedImage_CS : VB_Parent
    {
        SuperPixel_Basics_CPP_VB pixels = new SuperPixel_Basics_CPP_VB();
        Binarize_Basics binarize;
        public SuperPixel_BinarizedImage_CS()
        {
            binarize = new Binarize_Basics();
            pixels.gridColor = Scalar.Red;
            FindSlider("Number of SuperPixels").Value = 20; // find the top 20 super pixels.
            desc = "Create SuperPixels from a binary image.";
        }
        public void RunAlg(Mat src)
        {
            binarize.Run(src);
            pixels.Run(binarize.dst2);
            dst2 = pixels.dst2;
            dst3 = pixels.dst3;
            dst3.SetTo(Scalar.White, pixels.wireGrid);
        }
    }




    public class SuperPixel_Depth_CS : VB_Parent
    {
        SuperPixel_Basics_CPP_VB pixels = new SuperPixel_Basics_CPP_VB();
        public SuperPixel_Depth_CS()
        {
            desc = "Create SuperPixels using RGBDepth image.";
        }
        public void RunAlg(Mat src)
        {
            pixels.Run(vbc.task.depthRGB);
            dst2 = pixels.dst2;
            dst3 = pixels.dst3;
        }
    }




    public class SuperPixel_WithCanny_CS : VB_Parent
    {
        SuperPixel_Basics_CPP_VB pixels = new SuperPixel_Basics_CPP_VB();
        Edge_Canny edges = new Edge_Canny();
        public SuperPixel_WithCanny_CS()
        {
            desc = "Create SuperPixels using RGBDepth image.";
        }
        public void RunAlg(Mat src)
        {
            edges.Run(src);
            src = vbc.task.color.Clone();
            src.SetTo(Scalar.White, edges.dst2);
            pixels.Run(src);
            dst2 = pixels.dst2;
            dst3 = pixels.dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3.SetTo(Scalar.Red, edges.dst2);
            labels[3] = "Edges provided by Canny in red";
        }
    }




    public class SuperPixel_WithLineDetector_CS : VB_Parent
    {
        SuperPixel_Basics_CPP_VB pixels = new SuperPixel_Basics_CPP_VB();
        Line_Basics lines = new Line_Basics();
        public SuperPixel_WithLineDetector_CS()
        {
            labels[3] = "Input to superpixel basics.";
            desc = "Create SuperPixels using RGBDepth image.";
        }
        public void RunAlg(Mat src)
        {
            lines.Run(src);
            dst3 = lines.dst2;
            pixels.Run(dst3);
            dst2 = pixels.dst2;
        }
    }




    public class SuperRes_Basics_CS : VB_Parent
    {
        SuperRes_Input video = new SuperRes_Input();
        Options_SuperRes options = new Options_SuperRes();
        DenseOpticalFlowExt optFlow;
        SuperResolution superres;
        int warningMessage = 10;
        public SuperRes_Basics_CS()
        {
            labels[2] = "Original Input video";
            labels[3] = "SuperRes output";
            desc = "Create superres version of the video input";
        }
        public void RunAlg(Mat src)
        {
            if (warningMessage > 0)
            {
                SetTrueText("The first frame takes a while when iterations are over 50 or so");
                warningMessage -= 1;
                return;
            }
            options.RunOpt();
            if (options.restartWithNewOptions)
            {
                warningMessage = 10;
                optFlow = null; // start over...
                video = new SuperRes_Input();
                return;
            }
            video.Run(empty);
            dst2 = video.dst2;
            if (optFlow == null)
            {
                switch (options.method) // only one method available with OpenCVSharp...
                {
                    case "farneback":
                        optFlow = FarnebackOpticalFlow.CreateFarneback();
                        break;
                    case "brox":
                        optFlow = BroxOpticalFlow.CreateFarneback();
                        break;
                    case "tvl1":
                        optFlow = DualTVL1OpticalFlow.CreateDualTVL1();
                        break;
                    case "pyrlk":
                        optFlow = PyrLKOpticalFlow.CreateFarneback();
                        break;
                }
                if (optFlow == null) return;
                superres = SuperResolution.CreateBTVL1();
                superres.Iterations = options.iterations;
                superres.Scale = 4;
                superres.TemporalAreaRadius = 4;
                superres.SetInput(FrameSource.CreateFrameSource_Video(video.inputFileName));
            }
            superres.NextFrame(dst3);
            if (dst3.Width == 0)
            {
                dst3 = dst2.Clone();
                optFlow = null; // start over...
            }
        }
    }




    public class SuperRes_Input_CS : VB_Parent
    {
        public Video_Basics video = new Video_Basics();
        public string inputFileName;
        public SuperRes_Input_CS()
        {
            video.options.fileInfo = new FileInfo(vbc.task.HomeDir + "Data/testdata_superres_car.avi");
            inputFileName = video.options.fileInfo.FullName;
            desc = "Input data for the superres testing";
        }
        public void RunAlg(Mat src)
        {
            video.Run(empty);
            dst2 = video.dst2;
        }
    }




    public class SuperRes_SubPixelZoom_CS : VB_Parent
    {
        Pixel_SubPixel zoom = new Pixel_SubPixel();
        SuperRes_Input video = new SuperRes_Input();
        public SuperRes_SubPixelZoom_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            desc = "Is SuperRes better than just zoom with sub-pixel accuracy?";
        }
        public void RunAlg(Mat src)
        {
            vbc.task.mouseMovePoint = new cv.Point(45, 60);
            video.Run(empty);
            if (video.video.captureVideo.PosFrames > 30) return;
            dst1 = video.dst2;
            zoom.Run(video.dst2);
            dst2 = zoom.dst2;
            dst3 = zoom.dst3;
            labels = zoom.labels;
        }
    }




    public class SVD_Example_CS : VB_Parent
    {
        public SVD_Example_CS()
        {
            desc = "SVD example";
        }
        public void RunAlg(Mat src)
        {
            float[] inputData = {
        1, 2, 3, 4, 5,
        1, 2, 3, 4, 5,
        1, 2, 3, 4, 5,
        1, 2, 3, 4, 5,
        1, 2, 3, 4, 5
    };
            src = cv.Mat.FromPixelData(5, 5, MatType.CV_32F, inputData);
            Mat W = new Mat(), U = new Mat(), VT = new Mat();
            Cv2.SVDecomp(src, W, U, VT, SVD.Flags.FullUV);
            Mat WD = new Mat(5, 5, MatType.CV_32F, cv.Scalar.All(0));
            W.CopyTo(WD.Diag());
            Mat rec = VT.Transpose() * WD * U.Transpose();
            strOut = "";
            for (int i = 0; i < rec.Rows; i++)
            {
                for (int j = 0; j < rec.Cols; j++)
                {
                    strOut += string.Format("{0}, ", rec.Get<float>(i, j));
                }
                strOut += "\n";
            }
            SetTrueText(strOut);
        }
    }




    public class SVD_Example2_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public SVD_Example2_CS()
        {
            desc = "Compute the mean and tangent of a RedCloud Cell";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            var rc = vbc.task.rc;
            if (vbc.task.heartBeat)
            {
                var m = Cv2.Moments(rc.mask, true);
                var center = new Point2f((float)(m.M10 / rc.pixels), (float)(m.M01 / rc.pixels));
                DrawCircle(vbc.task.color[rc.rect], center, vbc.task.DotSize, vbc.task.HighlightColor);
                Mat mArea = cv.Mat.FromPixelData(4, 1, MatType.CV_32F, new float[]
                            { (float)(m.M20 / rc.pixels), (float)(m.Mu11 / rc.pixels),
                            (float)(m.Mu11 / rc.pixels), (float)(m.Mu02 / rc.pixels) });
                Mat U = new Mat();
                Cv2.SVDecomp(mArea, new Mat(), U, new Mat(), SVD.Flags.FullUV);
                strOut = "The U Mat: \n";
                for (int j = 0; j < U.Rows; j++)
                {
                    for (int i = 0; i < U.Cols; i++)
                    {
                        strOut += string.Format("{0}, ", U.Get<float>(j, i));
                    }
                    strOut += "\n";
                }
                strOut += "\n";
                strOut += "The tangent: \n";
                for (int i = 0; i < U.Cols; i++)
                {
                    strOut += string.Format("{0}, ", U.Get<float>(0, i));
                }
                strOut += "\n";
                double angle = Math.Atan2(U.Get<float>(0, 1), U.Get<float>(0, 0));
                strOut += "Angle = " + string.Format("{0} radians\n", angle);
                strOut += "Center.X = " + string.Format("{0} Center.Y = {1}\n", center.X, center.Y);
                strOut += "Rect is at (" + rc.rect.X + ", " + rc.rect.Y + ") with width/height = " + rc.rect.Width + "/" + rc.rect.Height + "\n";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class SVD_Gaussian_CS : VB_Parent
    {
        Covariance_Images covar = new Covariance_Images();
        public SVD_Gaussian_CS()
        {
            desc = "Compute the SVD for the covariance of 2 images - only close to working...";
        }
        public void RunAlg(Mat src)
        {
            covar.Run(src);
            dst2 = src;
            Mat U = new Mat(), W = new Mat(), VT = new Mat();
            Cv2.SVDecomp(covar.covariance, W, U, VT, SVD.Flags.FullUV);
            strOut = "The Covariance Mat: \n";
            for (int j = 0; j < covar.covariance.Rows; j++)
            {
                for (int i = 0; i < covar.covariance.Cols; i++)
                {
                    strOut += string.Format("{0}, ", covar.covariance.Get<double>(j, i));
                }
                strOut += "\n";
            }
            strOut += "\n";
            strOut += "The W Mat: \n";
            for (int j = 0; j < W.Rows; j++)
            {
                for (int i = 0; i < W.Cols; i++)
                {
                    strOut += string.Format("{0}, ", W.Get<double>(j, i));
                }
                strOut += "\n";
            }
            strOut += "\n";
            strOut += "The U Mat: \n";
            for (int j = 0; j < U.Rows; j++)
            {
                for (int i = 0; i < U.Cols; i++)
                {
                    strOut += string.Format("{0}, ", U.Get<double>(j, i));
                }
                strOut += "\n";
            }
            strOut += "\n";
            double angle = -Math.Atan2(U.Get<double>(0, 1), U.Get<double>(0, 0)) * (180 / Cv2.PI);
            strOut += "Angle = " + string.Format("{0} radians\n", angle);
            W = W.Sqrt() * 3;
            Size2f size = new Size2f(10, 100);
            Point2f pt = new Point2f((float)covar.mean.Get<double>(0, 0), (float)covar.mean.Get<double>(0, 1));
            RotatedRect rrect = new RotatedRect(pt, size, (float)angle);
            dst2.Ellipse(rrect, vbc.task.HighlightColor, vbc.task.lineWidth, vbc.task.lineType);
            SetTrueText(strOut, 3);
        }
    }




    public class SVM_Basics_CS : VB_Parent
    {
        public Options_SVM options = new Options_SVM();
        SVM_SampleData sampleData = new SVM_SampleData();
        public List<cv.Point2f> points = new List<cv.Point2f>();
        public List<int> response = new List<int>();
        cv.ML.SVM svm;
        public SVM_Basics_CS()
        {
            desc = "Use SVM to classify random points.  Increase the sample count to see the value of more data.";
            if (standaloneTest()) vbc.task.gOptions.setGridSize(8);
            labels = new string[] { "", "", "SVM_Basics_CS input data", "Results - white line is ground truth" };
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt(); // update any options specified in the interface.
            if (standaloneTest())
            {
                sampleData.Run(src);
                dst2 = sampleData.dst2;
                points = sampleData.points;
                response = sampleData.responses;
            }
            var dataMat = cv.Mat.FromPixelData(options.sampleCount, 2, MatType.CV_32FC1, points.ToArray());
            var resMat = cv.Mat.FromPixelData(options.sampleCount, 1, MatType.CV_32SC1, response.ToArray());
            dataMat *= 1 / src.Height;
            if (vbc.task.optionsChanged) svm = options.createSVM();
            svm.Train(dataMat, cv.ML.SampleTypes.RowSample, resMat);
            dst3.SetTo(0);
            foreach (var roi in vbc.task.gridRects)
            {
                if (roi.X > src.Height) continue; // working only with square - not rectangles.
                float[] samples = { roi.X / src.Height, roi.Y / src.Height };
                if (svm.Predict(cv.Mat.FromPixelData(1, 2, MatType.CV_32F, samples)) == 1)
                {
                    dst3[roi].SetTo(Scalar.Red);
                }
                else
                {
                    dst3[roi].SetTo(Scalar.GreenYellow);
                }
            }
            if (standaloneTest())
            {
                // draw the function in both plots to show ground truth.
                for (int x = 1; x < src.Height; x++)
                {
                    int y1 = (int)sampleData.inputFunction(x - 1);
                    int y2 = (int)sampleData.inputFunction(x);
                    DrawLine(dst3, new Point2f(x - 1, y1), new Point2f(x, y2), Scalar.White);
                }
            }
        }
    }




    public class SVM_SampleData_CS : VB_Parent
    {
        readonly Options_SVM options = new Options_SVM();
        public List<cv.Point2f> points = new List<cv.Point2f>();
        public List<int> responses = new List<int>();
        public SVM_SampleData_CS()
        {
            desc = "Create sample data for a sample SVM application.";
        }
        public double inputFunction(double x)
        {
            return x + 50 * Math.Sin(x / 15.0);
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2.SetTo(0);
            points.Clear();
            responses.Clear();
            for (int i = 0; i < options.sampleCount; i++)
            {
                int x = msRNG.Next(0, src.Height - 1);
                int y = msRNG.Next(0, src.Height - 1);
                points.Add(new Point2f(x, y));
                if (y > inputFunction(x))
                {
                    responses.Add(1);
                    DrawCircle(dst2, new cv.Point(x, y), 2, Scalar.Red);
                }
                else
                {
                    responses.Add(-1);
                    DrawCircle(dst2, new cv.Point(x, y), 3, Scalar.GreenYellow);
                }
            }
        }
    }




    public class SVM_TestCase_CS : VB_Parent
    {
        Options_SVM options = new Options_SVM();
        List<cv.Point2f> points = new List<cv.Point2f>();
        List<int> responses = new List<int>();
        cv.ML.SVM svm;
        public SVM_TestCase_CS()
        {
            FindSlider("Granularity").Value = 15;
            labels = new string[] { "", "", "Input points - color is the category label", "Predictions" };
            desc = "Text book example on SVM";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2.SetTo(Scalar.White);
            dst3.SetTo(0);
            int labeled = 1;
            int nonlabel = -1;
            if (vbc.task.heartBeat)
            {
                points.Clear();
                responses.Clear();
                int[] choices = new int[] { labeled, nonlabel, nonlabel, nonlabel };
                for (int i = 0; i < 4; i++)
                {
                    points.Add(new Point2f(msRNG.Next(0, src.Width - 1), msRNG.Next(0, src.Height - 1)));
                    responses.Add(choices[i]);
                }
            }
            var trainMat = cv.Mat.FromPixelData(4, 2, MatType.CV_32F, points.ToArray());
            var labelsMat = cv.Mat.FromPixelData(4, 1, MatType.CV_32SC1, responses.ToArray());
            var dataMat = trainMat * 1 / src.Height;
            if (vbc.task.optionsChanged) svm = options.createSVM();
            svm.Train(dataMat, cv.ML.SampleTypes.RowSample, labelsMat);
            var sampleMat = new Mat(1, 2, MatType.CV_32F);
            for (int y = 0; y < dst2.Height; y += options.granularity)
            {
                for (int x = 0; x < dst2.Width; x += options.granularity)
                {
                    sampleMat.Set<float>(0, 0, x / src.Height);
                    sampleMat.Set<float>(0, 1, y / src.Height);
                    var response = svm.Predict(sampleMat);
                    var color = response >= 0 ? Scalar.Blue : Scalar.Red;
                    DrawCircle(dst3, new cv.Point((int)x, (int)y), vbc.task.DotSize + 1, color);
                }
            }
            for (int i = 0; i < trainMat.Rows; i++)
            {
                var color = labelsMat.Get<int>(i) == 1 ? Scalar.Blue : Scalar.Red;
                var pt = new cv.Point(trainMat.Get<float>(i, 0), trainMat.Get<float>(i, 1));
                DrawCircle(dst2, pt, vbc.task.DotSize + 2, color);
                DrawCircle(dst3, pt, vbc.task.DotSize + 2, color);
            }
        }
    }




    public class SVM_ReuseBasics_CS : VB_Parent
    {
        SVM_Basics svm = new SVM_Basics();
        List<cv.Point2f> points = new List<cv.Point2f>();
        List<int> responses = new List<int>();
        public SVM_ReuseBasics_CS()
        {
            FindSlider("Granularity").Value = 15;
            FindSlider("SVM Sample Count").Value = 4;
            labels = new string[] { "", "", "Input points", "Predictions" };
            desc = "Text book example on SVM";
        }
        public void RunAlg(Mat src)
        {
            int labeled = 1;
            int nonlabel = -1;
            int[] choices = new int[] { labeled, nonlabel, nonlabel, nonlabel };
            if (vbc.task.heartBeat)
            {
                points.Clear();
                responses.Clear();
                for (int i = 0; i < 4; i++)
                {
                    points.Add(new Point2f(msRNG.Next(0, src.Height - 1), msRNG.Next(0, src.Height - 1))); // note: working with a square, not a rectangle
                    responses.Add(choices[i]);
                }
            }
            svm.points.Clear();
            svm.response.Clear();
            for (int i = 0; i < points.Count(); i++)
            {
                svm.points.Add(points[i]);
                svm.response.Add(choices[i]);
            }
            svm.Run(src);
            dst3 = svm.dst3;
            dst2.SetTo(Scalar.White);
            for (int i = 0; i < svm.points.Count(); i++)
            {
                var color = svm.response[i] == 1 ? Scalar.Blue : Scalar.Red;
                DrawCircle(dst2, svm.points[i], vbc.task.DotSize, color);
                DrawCircle(dst3, svm.points[i], vbc.task.DotSize, color);
            }
        }
    }




    public class SVM_ReuseRandom_CS : VB_Parent
    {
        readonly SVM_Basics svm = new SVM_Basics();
        int blueCount;
        public SVM_ReuseRandom_CS()
        {
            FindSlider("Granularity").Value = 15;
            vbc.task.drawRect = new cv.Rect(dst2.Cols / 4, dst2.Rows / 4, dst2.Cols / 2, dst2.Rows / 2);
            labels[2] = "SVM Training data - draw a rectangle anywhere to test further.";
            desc = "Use SVM to classify random points - testing if height must equal width - needs more work";
        }
        public void RunAlg(Mat src)
        {
            svm.options.RunOpt();
            var rect = vbc.task.drawRect;
            var contour = new List<cv.Point>();
            contour.Clear();
            contour.Add(new cv.Point(rect.X, rect.Y));
            contour.Add(new cv.Point(rect.X, rect.Y + rect.Height));
            contour.Add(new cv.Point(rect.X + rect.Width, rect.Y + rect.Height));
            contour.Add(new cv.Point(rect.X + rect.Width, rect.Y));
            int width = src.Width;
            if (svm.options.kernelType == cv.ML.SVM.KernelTypes.Linear)
            {
                width = src.Height;
                rect.X = 0;
                rect.Y = src.Height - rect.Height;
                rect.Width = width;
            }
            if (vbc.task.heartBeat)
            {
                dst2.SetTo(0);
                blueCount = 0;
                svm.points.Clear();
                svm.response.Clear();
                for (int i = 0; i < svm.options.sampleCount; i++)
                {
                    var pt = new Point2f(msRNG.Next(0, width - 1), msRNG.Next(0, src.Height - 1));
                    svm.points.Add(pt);
                    int res = 0;
                    if (svm.options.kernelType == cv.ML.SVM.KernelTypes.Linear)
                    {
                        res = pt.X >= pt.Y ? 1 : -1;
                    }
                    else
                    {
                        res = Cv2.PointPolygonTest(contour, pt, false) >= 0 ? 1 : -1;
                    }
                    svm.response.Add(res);
                    if (res > 0) blueCount++;
                    DrawCircle(dst2, pt, vbc.task.DotSize, res == 1 ? Scalar.Blue : Scalar.Green);
                }
                svm.Run(src);
                dst3 = svm.dst3;
            }
            labels[3] = "There were " + blueCount + " blue points out of " + svm.options.sampleCount;
            if (svm.options.kernelType != cv.ML.SVM.KernelTypes.Linear)
            {
                dst2.Rectangle(rect, Scalar.Black, 2);
                dst3.Rectangle(rect, Scalar.Black, 2);
            }
        }
    }




    public class Swarm_Basics_CS : VB_Parent
    {
        public KNN_Basics knn = new KNN_Basics();
        Feature_Stable feat = new Feature_Stable();
        public List<PointPair> mpList = new List<PointPair>();
        public float distanceAvg;
        public float directionAvg;
        public float distanceMax;
        public Options_Swarm options = new Options_Swarm();
        List<List<cv.Point2f>> cornerHistory = new List<List<cv.Point2f>>();
        public Swarm_Basics_CS()
        {
            FindSlider("Feature Sample Size").Value = 1000;
            FindSlider("Blocksize").Value = 1;
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, cv.Scalar.All(0));
            desc = "Track the GoodFeatures across a frame history and connect the first and last good.corners in the history.";
        }
        public void DrawLines(ref Mat dst)
        {
            var queries = knn.queries;
            var trainInput = knn.trainInput;
            var neighbors = knn.neighbors;
            for (int i = 0; i < queries.Count(); i++)
            {
                var nabList = neighbors[i];
                var pt = queries[i];
                for (int j = 0; j < Math.Min(nabList.Count(), options.ptCount); j++)
                {
                    var ptNew = trainInput[nabList[j]];
                    DrawLine(dst, pt, ptNew, Scalar.White, vbc.task.lineWidth);
                    if (ptNew.X < options.border) DrawLine(dst, new Point2f(0, ptNew.Y), ptNew, Scalar.White, vbc.task.lineWidth);
                    if (ptNew.Y < options.border) DrawLine(dst, new Point2f(ptNew.X, 0), ptNew, Scalar.White, vbc.task.lineWidth);
                    if (ptNew.X > dst.Width - options.border) DrawLine(dst, new Point2f(dst.Width, ptNew.Y), ptNew, Scalar.White, vbc.task.lineWidth);
                    if (ptNew.Y > dst.Height - options.border) DrawLine(dst, new Point2f(ptNew.X, dst.Height), ptNew, Scalar.White, vbc.task.lineWidth);
                }
            }
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            feat.Run(src);
            dst3 = feat.dst2;
            if (vbc.task.optionsChanged) cornerHistory.Clear();
            int histCount = vbc.task.frameHistoryCount;
            cornerHistory.Add(new List<cv.Point2f>(vbc.task.features));
            int lastIndex = cornerHistory.Count() - 1;
            knn.trainInput = new List<cv.Point2f>(cornerHistory.ElementAt(0));
            knn.queries = new List<cv.Point2f>(cornerHistory.ElementAt(lastIndex));
            knn.Run(empty);
            dst2.SetTo(0);
            mpList.Clear();
            var disList = new List<float>();
            var dirList = new List<float>(); // angle in radians
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                var nabList = knn.neighbors[i];
                int trainIndex = nabList[0]; // index of the matched train input
                var pt = knn.queries[i];
                var ptNew = knn.trainInput[trainIndex];
                double nextDist = pt.DistanceTo(ptNew);
                DrawLine(dst2, pt, ptNew, Scalar.White);
                disList.Add((float)nextDist);
                mpList.Add(new PointPair(pt, ptNew));
                if (nextDist > 0)
                {
                    if (pt.Y != ptNew.Y)
                    {
                        float nextDirection = (float)Math.Atan((pt.X - ptNew.X) / (pt.Y - ptNew.Y));
                        dirList.Add(nextDirection);
                    }
                }
            }
            DrawLines(ref dst2);
            labels[3] = $"{mpList.Count()} points were matched to the previous set of features.";
            distanceAvg = 0;
            if (vbc.task.heartBeat) distanceMax = 0;
            if (disList.Count() > 10)
            {
                distanceAvg = disList.Average();
                distanceMax = Math.Max(distanceMax, disList.Max());
                labels[2] = $"Avg distance = {distanceAvg:F1}\nMax Distance = {distanceMax:F1} (all units in pixels) ";
            }
            if (dirList.Count() > 0)
            {
                directionAvg = dirList.Average();
                labels[3] = $"{directionAvg:F1} average direction (radians)";
            }
            if (cornerHistory.Count() >= histCount) cornerHistory.RemoveAt(0);
        }
    }




    public class Swarm_LeftRightFeatures_CS : VB_Parent
    {
        public List<cv.Point2f> leftList = new List<cv.Point2f>();
        public List<cv.Point2f> rightList = new List<cv.Point2f>();
        Feature_Stable feat = new Feature_Stable();
        public Swarm_LeftRightFeatures_CS()
        {
            labels = new[] { "", "", "Left view feature points", "Right view feature points" };
            desc = "Double the votes on motion by collecting features for both left and right images.";
        }
        public void RunAlg(Mat src)
        {
            feat.Run(vbc.task.leftView);
            leftList = new List<cv.Point2f>(vbc.task.features);
            dst2 = feat.dst2.Clone();
            feat.Run(vbc.task.rightView);
            rightList = new List<cv.Point2f>(vbc.task.features);
            dst3 = feat.dst2.Clone();
        }
    }




    public class Swarm_LeftRight_CS : VB_Parent
    {
        public float leftDistance;
        public float leftDirection;
        public float leftMax;
        public float rightDistance;
        public float rightDirection;
        public float rightMax;
        Swarm_Basics swarm = new Swarm_Basics();
        public Swarm_LeftRight_CS()
        {
            if (standalone) vbc.task.gOptions.setDisplay1();
            labels = new[] { "", "", "Left view feature points", "Right view feature points" };
            desc = "Get direction and distance from the left and right images.";
        }
        public void RunAlg(Mat src)
        {
            swarm.Run(vbc.task.leftView);
            leftDistance = swarm.distanceAvg;
            leftDirection = swarm.directionAvg;
            leftMax = swarm.distanceMax;
            dst2 = vbc.task.leftView;
            swarm.DrawLines(dst2);
            swarm.Run(vbc.task.rightView);
            rightDistance = swarm.distanceAvg;
            rightDirection = swarm.directionAvg;
            rightMax = swarm.distanceMax;
            dst3 = vbc.task.rightView;
            swarm.DrawLines(dst3);
            strOut = swarm.labels[2] + "\n" + swarm.labels[3];
            SetTrueText(strOut, 1);
        }
    }





    public class Swarm_Flood_CS : VB_Parent
    {
        Swarm_Basics swarm = new Swarm_Basics();
        public Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics cvt = new Color8U_Basics();
        public Swarm_Flood_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            desc = "Floodfill the color image using the swarm outline as a mask";
        }
        public void RunAlg(Mat src)
        {
            swarm.Run(src);
            cvt.Run(src);
            flood.genCells.removeContour = false;
            flood.inputMask = swarm.dst2;
            flood.Run(cvt.dst2);
            dst2 = flood.dst2;
            vbc.task.setSelectedContour();
            labels[2] = flood.genCells.labels[2];
        }
    }




    public class Swarm_Percentage_CS : VB_Parent
    {
        Swarm_Flood swarm = new Swarm_Flood();
        Options_SwarmPercent options = new Options_SwarmPercent();
        public Swarm_Percentage_CS()
        {
            desc = "Use features to segment a percentage of the image then use RedCloud with a mask for the rest of the image.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            swarm.Run(src);
            dst2 = swarm.dst2;
            dst3.SetTo(0);
            int pixels = 0;
            int count = 0;
            foreach (var rc in vbc.task.redCells)
            {
                if (vbc.task.redOptions.getNaturalColor())
                    dst3[rc.rect].SetTo(rc.naturalColor, rc.mask);
                else
                    dst3[rc.rect].SetTo(rc.color, rc.mask);

                pixels += rc.pixels;
                count++;
                if ((double)pixels / src.Total() >= options.percent) break;
            }
            labels[3] = "The top " + count.ToString() + " cells by size = " + options.percent.ToString("0%") + " of the pixels";
        }
    }





    public class Swarm_Flood2_CS : VB_Parent
    {
        public Line_KNN lines = new Line_KNN();
        public Flood_BasicsMask flood = new Flood_BasicsMask();
        public Color8U_Basics cvt = new Color8U_Basics();
        public Swarm_Flood2_CS()
        {
            vbc.task.redOptions.setIdentifyCells(true);
            flood.genCells.removeContour = false;
            desc = "Floodfill the color image using the swarm outline as a mask";
        }
        public Mat runRedCloud(Mat src)
        {
            lines.Run(src);
            cvt.Run(src);
            flood.inputMask = lines.dst3;
            flood.Run(cvt.dst2);
            return flood.dst2;
        }
        public void RunAlg(Mat src)
        {
            if (!vbc.task.heartBeat) return;
            dst2 = runRedCloud(src).Clone();
            dst3 = lines.dst3.Clone();
            vbc.task.setSelectedContour();
            labels[2] = flood.genCells.labels[2];
            labels[3] = lines.labels[2];
        }
    }




    public class Swarm_Flood3_CS : VB_Parent
    {
        Swarm_Flood2 swarm = new Swarm_Flood2();
        public Swarm_Flood3_CS()
        {
            desc = "Create RedCloud cells every heartbeat and compare the results against RedCloud cells created with the current frame.";
        }
        public void RunAlg(Mat src)
        {
            swarm.Run(src);
            dst2 = swarm.dst2;
            labels[2] = swarm.labels[2];
            dst3 = swarm.runRedCloud(src);
            labels[3] = swarm.labels[2];
        }
    }




    public class Tessallate_Basics_CS : VB_Parent
    {
        public List<cv.Point3f> points = new List<cv.Point3f>();
        public List<Scalar> colors = new List<Scalar>();
        public Options_OpenGLFunctions oglOptions = new Options_OpenGLFunctions();
        public RedCloud_Hulls hulls = new RedCloud_Hulls();
        public Tessallate_Basics_CS()
        {
            vbc.task.gOptions.setGridSize(30);
            desc = "Prepare the list of 2D triangles";
        }
        List<cv.Point> addTriangle(cv.Point c1, cv.Point c2, cv.Point center, rcData rc, Point3f shift)
        {
            var pt1 = getWorldCoordinates(new Point3f(c1.X, c1.Y, (float)rc.depthMean[2]));
            var ptCenter = getWorldCoordinates(new Point3f(center.X, center.Y, (float)rc.depthMean[2]));
            var pt2 = getWorldCoordinates(new Point3f(c2.X, c2.Y, (float)rc.depthMean[2]));
            colors.Add(vecToScalar(rc.color));
            points.Add(new Point3f(pt1.X + shift.X, pt1.Y + shift.Y, pt1.Z + shift.Z));
            points.Add(new Point3f(ptCenter.X + shift.X, ptCenter.Y + shift.Y, ptCenter.Z + shift.Z));
            points.Add(new Point3f(pt2.X + shift.X, pt2.Y + shift.Y, pt2.Z + shift.Z));
            var points2d = new List<cv.Point> { c1, center, c2 };
            return points2d;
        }
        public void RunAlg(Mat src)
        {
            oglOptions.RunOpt();
            var ptM = oglOptions.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            hulls.Run(src);
            dst2 = hulls.dst2;
            points.Clear();
            colors.Clear();
            var listOfPoints = new List<List<cv.Point>>();
            foreach (var rc in vbc.task.redCells)
            {
                if (rc.contour == null || rc.contour.Count() < 5) continue;
                cv.Point[] corners = new cv.Point[4];
                for (int i = 0; i < corners.Length; i++)
                {
                    var pt = rc.contour[i * rc.contour.Count() / 4];
                    corners[i] = new cv.Point(rc.rect.X + pt.X, rc.rect.Y + pt.Y);
                }
                var center = new cv.Point(rc.rect.X + rc.rect.Width / 2, rc.rect.Y + rc.rect.Height / 2);
                DrawLine(dst2, corners[0], center, Scalar.White);
                DrawLine(dst2, corners[1], center, Scalar.White);
                DrawLine(dst2, corners[2], center, Scalar.White);
                DrawLine(dst2, corners[3], center, Scalar.White);
                listOfPoints.Add(addTriangle(corners[0], corners[3], center, rc, shift));
                listOfPoints.Add(addTriangle(corners[1], corners[0], center, rc, shift));
                listOfPoints.Add(addTriangle(corners[2], corners[1], center, rc, shift));
                listOfPoints.Add(addTriangle(corners[3], corners[2], center, rc, shift));
            }
            dst3.SetTo(0);
            for (int i = 0; i < colors.Count(); i++)
            {
                Cv2.DrawContours(dst3, listOfPoints, i, colors[i], -1);
            }
            labels[2] = colors.Count().ToString() + " triangles from " + vbc.task.redCells.Count().ToString() + " RedCloud cells";
        }
    }




    public class Tessallate_Triangles_CS : VB_Parent
    {
        public Tessallate_Basics basics = new Tessallate_Basics();
        public List<cv.Point3f> oglData = new List<cv.Point3f>();
        public Tessallate_Triangles_CS()
        {
            labels = new string[] { "", "", "", "" };
            desc = "Prepare colors and triangles for use in OpenGL Triangle presentation.";
        }
        public void RunAlg(Mat src)
        {
            basics.Run(src);
            dst2 = basics.dst2;
            dst3 = basics.dst3;
            oglData.Clear();
            for (int i = 0; i < basics.colors.Count(); i++)
            {
                oglData.Add(new Point3f((float)(basics.colors[i][2] / 255),
                                        (float)(basics.colors[i][1] / 255),
                                        (float)(basics.colors[i][0] / 255))); // BGR to RGB
                for (int j = 0; j < 3; j++)
                {
                    oglData.Add(basics.points[i * 3 + j]);
                }
            }
            labels = basics.labels;
        }
    }




    public class Tessallate_QuadSimple_CS : VB_Parent
    {
        public List<cv.Point3f> oglData = new List<cv.Point3f>();
        public Options_OpenGLFunctions oglOptions = new Options_OpenGLFunctions();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Tessallate_QuadSimple_CS()
        {
            vbc.task.gOptions.setGridSize(20);
            desc = "Prepare to tessellate the point cloud with RedCloud data";
        }
        public void RunAlg(Mat src)
        {
            oglOptions.RunOpt();
            var ptM = oglOptions.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            redC.Run(src);
            dst2 = redC.dst2;
            oglData.Clear();
            dst3.SetTo(0);
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                var center = new cv.Point((int)(roi.X + roi.Width / 2), (int)(roi.Y + roi.Height / 2));
                var index = vbc.task.cellMap.Get<byte>(center.Y, center.X);
                if (index <= 0) continue;
                var rc = vbc.task.redCells[index];
                dst3[roi].SetTo(rc.color);
                SetTrueText(rc.depthMean[2].ToString(vbc.fmt1), new cv.Point(roi.X, roi.Y));
                var topLeft = getWorldCoordinates(new Point3f(roi.X, roi.Y, (float)rc.depthMean[2]));
                var botRight = getWorldCoordinates(new Point3f(roi.X + roi.Width, roi.Y + roi.Height, (float)rc.depthMean[2]));
                oglData.Add(new Point3f(rc.color[2] / 255, rc.color[1] / 255, rc.color[0] / 255));
                oglData.Add(new Point3f(topLeft.X + shift.X, topLeft.Y + shift.Y, (float)(rc.depthMean[2] + shift.Z)));
                oglData.Add(new Point3f(botRight.X + shift.X, topLeft.Y + shift.Y, (float)(rc.depthMean[2] + shift.Z)));
                oglData.Add(new Point3f(botRight.X + shift.X, botRight.Y + shift.Y, (float)(rc.depthMean[2] + shift.Z)));
                oglData.Add(new Point3f(topLeft.X + shift.X, botRight.Y + shift.Y, (float)(rc.depthMean[2] + shift.Z)));
            }
            labels = new string[] { "", "", traceName + " completed with " + (oglData.Count() / 5).ToString(vbc.fmt0) + " quad sets (with a 5th element for color)", "Output of Tessallate_QuadSimple_CS" };
        }
    }




    public class Tessallate_QuadHulls_CS : VB_Parent
    {
        public List<cv.Point3f> oglData = new List<cv.Point3f>();
        public List<List<double>> depthList = new List<List<double>>();
        public List<Vec3b> colorList = new List<Vec3b>();
        public Options_OpenGLFunctions oglOptions = new Options_OpenGLFunctions();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public Tessallate_QuadHulls_CS()
        {
            vbc.task.gOptions.setGridSize(20);
            desc = "Prepare to tessellate the point cloud with RedCloud data";
        }
        public void RunAlg(Mat src)
        {
            oglOptions.RunOpt();
            var ptM = oglOptions.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            hulls.Run(src);
            dst2 = hulls.dst2;
            if (vbc.task.optionsChanged)
            {
                depthList = new List<List<double>>();
                for (int i = 0; i < vbc.task.gridRects.Count(); i++)
                {
                    depthList.Add(new List<double>());
                    colorList.Add(black);
                }
            }
            oglData.Clear();
            dst3.SetTo(0);
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                var center = new cv.Point((int)(roi.X + roi.Width / 2), (int)(roi.Y + roi.Height / 2));
                var index = vbc.task.cellMap.Get<byte>(center.Y, center.X);
                if (index <= 0)
                {
                    depthList[i].Clear();
                    colorList[i] = black;
                    continue;
                }
                var rc = vbc.task.redCells[index];
                if (rc.depthMean[2] == 0) continue;
                if (colorList[i] != rc.color) depthList[i].Clear();
                depthList[i].Add(rc.depthMean[2]);
                colorList[i] = rc.color;
                if (depthList[i].Count() > 0)
                {
                    dst3[roi].SetTo(colorList[i]);
                    var depth = depthList[i].Average();
                    var topLeft = getWorldCoordinates(new Point3f(roi.X, roi.Y, (float)depth));
                    var botRight = getWorldCoordinates(new Point3f(roi.X + roi.Width, roi.Y + roi.Height, (float)depth));
                    oglData.Add(new Point3f(rc.color[2] / 255, rc.color[1] / 255, rc.color[0] / 255));
                    oglData.Add(new Point3f(topLeft.X + shift.X, topLeft.Y + shift.Y, (float)(depth + shift.Z)));
                    oglData.Add(new Point3f(botRight.X + shift.X, topLeft.Y + shift.Y, (float)(depth + shift.Z)));
                    oglData.Add(new Point3f(botRight.X + shift.X, botRight.Y + shift.Y, (float)(depth + shift.Z)));
                    oglData.Add(new Point3f(topLeft.X + shift.X, botRight.Y + shift.Y, (float)(depth + shift.Z)));
                    if (depthList[i].Count() >= depthListMaxCount) depthList[i].RemoveAt(0);
                }
            }
            labels[2] = traceName + " completed with " + (oglData.Count() / 5).ToString(vbc.fmt0) + " quad sets (with a 5th element for color)";
        }
    }




    public class Tessallate_QuadMinMax_CS : VB_Parent
    {
        public List<cv.Point3f> oglData = new List<cv.Point3f>();
        public List<List<double>> depthList1 = new List<List<double>>();
        public List<List<double>> depthList2 = new List<List<double>>();
        public List<Vec3b> colorList = new List<Vec3b>();
        public Options_OpenGLFunctions oglOptions = new Options_OpenGLFunctions();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Tessallate_QuadMinMax_CS()
        {
            vbc.task.gOptions.setGridSize(20);
            desc = "Prepare to tessellate the point cloud with RedCloud data";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            oglOptions.RunOpt();
            var ptM = oglOptions.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            if (vbc.task.optionsChanged)
            {
                depthList1 = new List<List<double>>();
                depthList2 = new List<List<double>>();
                for (int i = 0; i <= vbc.task.gridRects.Count(); i++)
                {
                    depthList1.Add(new List<double>());
                    depthList2.Add(new List<double>());
                    colorList.Add(black);
                }
            }
            oglData.Clear();
            dst3.SetTo(0);
            Mat depth32f = vbc.task.pcSplit[2] * 1000, depth32s = new Mat();
            depth32f.ConvertTo(depth32s, MatType.CV_32S);
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                var center = new cv.Point((int)(roi.X + roi.Width / 2), (int)(roi.Y + roi.Height / 2));
                var index = vbc.task.cellMap.Get<byte>(center.Y, center.X);
                if (index <= 0)
                {
                    depthList1[i].Clear();
                    depthList2[i].Clear();
                    colorList[i] = black;
                    continue;
                }
                var rc = vbc.task.redCells[index];
                if (rc.depthMean[2] == 0) continue;
                if (colorList[i] != rc.color)
                {
                    depthList1[i].Clear();
                    depthList2[i].Clear();
                }
                double depthMin, depthMax;
                cv.Point minLoc, maxLoc;
                Cv2.MinMaxLoc(depth32s[roi], out depthMin, out depthMax, out minLoc, out maxLoc, vbc.task.depthMask[roi]);
                depthMax /= 1000;
                depthMin /= 1000;
                if (depthMax > rc.depthMean[2] + rc.depthStdev[2] * 3) depthMax = rc.depthMean[2] + 3 * rc.depthStdev[2];
                depthList1[i].Add(depthMin);
                depthList2[i].Add(depthMax);
                colorList[i] = rc.color;
                var d1 = depthList1[i].Average();
                var d2 = depthList2[i].Average();
                int depthCount = (d1 == d2) ? 1 : 2;
                for (int j = 0; j < depthCount; j++)
                {
                    var depth = (j == 0) ? d1 : d2;
                    var topLeft = getWorldCoordinates(new Point3f(roi.X, roi.Y, (float)depth));
                    var botRight = getWorldCoordinates(new Point3f(roi.X + roi.Width, roi.Y + roi.Height, (float)depth));
                    var color = rc.color;
                    dst3[roi].SetTo(color);
                    oglData.Add(new Point3f(color[2] / 255f, color[1] / 255f, color[0] / 255f));
                    oglData.Add(new Point3f(topLeft.X + shift.X, topLeft.Y + shift.Y, (float)(depth + shift.Z)));
                    oglData.Add(new Point3f(botRight.X + shift.X, topLeft.Y + shift.Y, (float)(depth + shift.Z)));
                    oglData.Add(new Point3f(botRight.X + shift.X, botRight.Y + shift.Y, (float)(depth + shift.Z)));
                    oglData.Add(new Point3f(topLeft.X + shift.X, botRight.Y + shift.Y, (float)(depth + shift.Z)));
                }
                SetTrueText(string.Format("{0}\n{1}", d1.ToString(vbc.fmt1), d2.ToString(vbc.fmt1)), new cv.Point(roi.X, roi.Y), 3);
                if (depthList1[i].Count() >= depthListMaxCount) depthList1[i].RemoveAt(0);
                if (depthList2[i].Count() >= depthListMaxCount) depthList2[i].RemoveAt(0);
            }
            labels[2] = traceName + " completed with " + (oglData.Count() / 5).ToString(vbc.fmt0) + " quad sets (with a 5th element for color)";
        }
    }




    public class Tessallate_Bricks_CS : VB_Parent
    {
        public List<cv.Point3f> oglData = new List<cv.Point3f>();
        public List<double> depths = new List<double>();
        public Options_OpenGLFunctions options = new Options_OpenGLFunctions();
        public RedCloud_Hulls hulls = new RedCloud_Hulls();
        List<List<double>> depthMinList = new List<List<double>>();
        List<List<double>> depthMaxList = new List<List<double>>();
        int myListMax = 10;
        public Tessallate_Bricks_CS()
        {
            vbc.task.gOptions.setGridSize(20);
            desc = "Tessellate each quad in point cloud";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.optionsChanged)
            {
                depthMinList.Clear();
                depthMaxList.Clear();
                for (int i = 0; i < vbc.task.gridRects.Count(); i++)
                {
                    depthMinList.Add(new List<double>());
                    depthMaxList.Add(new List<double>());
                }
            }
            options.RunOpt();
            var ptM = options.moveAmount;
            var shift = new Point3f((float)ptM[0], (float)ptM[1], (float)ptM[2]);
            oglData.Clear();
            hulls.Run(src);
            dst2 = hulls.dst2;
            Point3f[] min = new Point3f[4];
            Point3f[] max = new Point3f[4];
            depths.Clear();
            for (int i = 0; i < vbc.task.gridRects.Count(); i++)
            {
                var roi = vbc.task.gridRects[i];
                var center = new cv.Point(roi.X + roi.Width / 2, roi.Y + roi.Height / 2);
                var index = vbc.task.cellMap.Get<byte>(center.Y, center.X);
                double depthMin = 0, depthMax = 0;
                cv.Point minLoc, maxLoc;
                if (index >= 0)
                {
                    Cv2.MinMaxLoc(vbc.task.pcSplit[2][roi], out depthMin, out depthMax, out minLoc, out maxLoc, vbc.task.depthMask[roi]);
                    var rc = vbc.task.redCells[index];
                    depthMin = (depthMax > rc.depthMean[2]) ? rc.depthMean[2] : depthMin;
                    var test = depthMin + rc.depthStdev[2] * 3;
                    if (test < depthMax) depthMax = test;
                    if (depthMin > 0 && depthMax > 0 && depthMax < vbc.task.MaxZmeters)
                    {
                        depthMinList[i].Add(depthMin);
                        depthMaxList[i].Add(depthMax);
                        depthMin = depthMinList[i].Average();
                        var avg = depthMaxList[i].Average() - depthMin;
                        depthMax = depthMin + (avg < 0.2 ? avg : 0.2); // trim the max depth - often unreliable 
                        var color = rc.color;
                        oglData.Add(new Point3f(color[2] / 255f, color[1] / 255f, color[0] / 255f));
                        for (int j = 0; j < 4; j++)
                        {
                            var x = (j == 0) ? roi.X : (j == 1) ? roi.X + roi.Width : (j == 2) ? roi.X + roi.Width : roi.X;
                            var y = (j == 0) ? roi.Y : (j == 1) ? roi.Y : (j == 2) ? roi.Y + roi.Height : roi.Y + roi.Height;
                            min[j] = getWorldCoordinates(new Point3f(x, y, (float)depthMin));
                            min[j] += shift;
                            oglData.Add(min[j]);
                        }
                        for (int j = 0; j < 4; j++)
                        {
                            max[j] += shift;
                            oglData.Add(max[j]);
                        }
                        oglData.Add(max[0]);
                        oglData.Add(min[0]);
                        oglData.Add(min[1]);
                        oglData.Add(max[1]);
                        oglData.Add(max[0]);
                        oglData.Add(min[0]);
                        oglData.Add(min[3]);
                        oglData.Add(max[3]);
                        oglData.Add(max[1]);
                        oglData.Add(min[1]);
                        oglData.Add(min[2]);
                        oglData.Add(max[2]);
                        oglData.Add(max[2]);
                        oglData.Add(min[2]);
                        oglData.Add(min[3]);
                        oglData.Add(max[3]);
                        SetTrueText(string.Format("{0}\n{1}", depthMin.ToString(vbc.fmt1), depthMax.ToString(vbc.fmt1)), new cv.Point(roi.X, roi.Y));
                        if (depthMinList[i].Count() >= myListMax) depthMinList[i].RemoveAt(0);
                        if (depthMaxList[i].Count() >= myListMax) depthMaxList[i].RemoveAt(0);
                    }
                }
                depths.Add(depthMin);
                depths.Add(depthMax);
            }
            labels[2] = traceName + " completed: " + vbc.task.gridRects.Count().ToString(vbc.fmt0) + " ROI's produced " + (oglData.Count() / 25).ToString(vbc.fmt0) + " six sided bricks with color";
            SetTrueText("There should be no 0.0 values in the list of min and max depths in the dst2 image.", 3);
        }
    }




    public class Texture_Basics_CS : VB_Parent
    {
        Draw_Ellipses ellipse = new Draw_Ellipses();
        public Mat texture = new Mat();
        public cv.Rect tRect;
        int texturePop;
        public bool tChange; // if the texture hasn't changed this will be false.
        public Texture_Basics_CS()
        {
            vbc.task.gOptions.setGridSize((int)(dst2.Width / 8));
            desc = "find the best sample 256x256 texture of a mask";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() || src.Channels() != 1)
            {
                ellipse.Run(src);
                dst2 = ellipse.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
                dst2 = dst2.ConvertScaleAbs(255);
                dst3 = ellipse.dst2.Clone();
                dst3.SetTo(Scalar.Yellow, vbc.task.gridMask);
            }
            else
            {
                dst2 = src;
            }
            tChange = true;
            if (texturePop > 0)
            {
                var nextCount = dst2[tRect].CountNonZero();
                if (nextCount >= texturePop * 0.95) tChange = false;
            }
            if (tChange)
            {
                var sortcounts = new SortedList<int, cv.Rect>(new compareAllowIdenticalIntegerInverted());
                foreach (var roi in vbc.task.gridRects)
                {
                    sortcounts.Add(dst2[roi].CountNonZero(), roi);
                }
                if (standaloneTest()) dst3.Rectangle(sortcounts.Values[0], Scalar.White, 2);
                tRect = sortcounts.Values[0];
                texture = vbc.task.color[tRect];
                texturePop = dst2[tRect].CountNonZero();
            }
            if (standaloneTest()) dst3.Rectangle(tRect, Scalar.White, 2);
        }
    }




    public class Texture_Flow_CS : VB_Parent
    {
        Options_Texture options = new Options_Texture();
        public Texture_Flow_CS()
        {
            desc = "Find and mark the texture flow in an image - see texture_flow.py";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.Clone();
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var eigen = src.CornerEigenValsAndVecs(options.TFblockSize, options.TFksize);
            var split = eigen.Split();
            float d2 = options.TFdelta / 2;
            for (int y = (int)d2; y < dst2.Height - 1; y += (int)d2)
            {
                for (int x = (int)d2; x < dst2.Width - 1; x += (int)d2)
                {
                    var delta = new Point2f(split[4].Get<float>(y, x), split[5].Get<float>(y, x)) * options.TFdelta;
                    var p1 = new cv.Point((int)(x - delta.X), (int)(y - delta.Y));
                    var p2 = new cv.Point((int)(x + delta.X), (int)(y + delta.Y));
                    DrawLine(dst2, p1, p2, vbc.task.HighlightColor);
                }
            }
        }
    }





    public class Texture_Flow_Depth_CS : VB_Parent
    {
        TextureFlow_Basics texture;
        public Texture_Flow_Depth_CS()
        {
            texture = new TextureFlow_Basics();
            desc = "Display texture flow in the depth data";
        }
        public void RunAlg(Mat src)
        {
            texture.Run(vbc.task.depthRGB);
            dst2 = texture.dst2;
        }
    }




    public class Texture_Flow_Reduction_CS : VB_Parent
    {
        TextureFlow_Basics texture;
        Reduction_Basics reduction = new Reduction_Basics();
        public Texture_Flow_Reduction_CS()
        {
            texture = new TextureFlow_Basics();
            desc = "Display texture flow in the reduced color image";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2;
            texture.Run(reduction.dst2.CvtColor(ColorConversionCodes.GRAY2BGR));
            dst3 = texture.dst2;
        }
    }




    public class OpenGL_TextureShuffle_CS : VB_Parent
    {
        Random_Shuffle shuffle = new Random_Shuffle();
        OpenGL_FlatStudy2 floor = new OpenGL_FlatStudy2();
        Texture_Basics texture;
        public cv.Rect tRect;
        public Mat rgbaTexture = new Mat();
        public OpenGL_TextureShuffle_CS()
        {
            texture = new Texture_Basics();
            desc = "Use random shuffling to homogenize a texture sample of what the floor looks like.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                if (dst2.Width == 320)
                {
                    SetTrueText("Texture_Shuffle is not supported at the 320x240 resolution.  It needs at least 256 rows in the output.");
                    return;
                }
                floor.plane.Run(src);
                dst3.SetTo(0);
                src.CopyTo(dst3, floor.plane.sliceMask);
                dst2 = floor.plane.dst2;
                src = floor.plane.sliceMask;
            }
            texture.Run(src);
            dst2 = texture.dst3;
            dst3.Rectangle(texture.tRect, Scalar.White, vbc.task.lineWidth);
            shuffle.Run(texture.texture);
            tRect = new cv.Rect(0, 0, texture.tRect.Width * 4, texture.tRect.Height * 4);
            dst2[tRect] = shuffle.dst2.Repeat(4, 4);
            var split = dst2[tRect].Split();
            var alpha = new Mat(split[0].Size(), MatType.CV_8U, cv.Scalar.All(1));
            var merged = new Mat[] { split[2], split[1], split[0], alpha };
            Cv2.Merge(merged, rgbaTexture);
            SetTrueText("Use mouse movement over the image to display results.", 3);
        }
    }




    public class Thickness_Basics_CS : VB_Parent
    {
        public rcData rc = new rcData();
        public Volume_Basics volZ = new Volume_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public Thickness_Basics_CS()
        {
            desc = "Determine the thickness of a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                rc = vbc.task.rc;
            }
            volZ.rc = rc;
            volZ.Run(src);
            dst3 = volZ.dst3;
            SetTrueText(volZ.strOut, 3);
        }
    }




    public class Threading_Test_CS : VB_Parent
    {
        Thread thread1;
        Thread thread2;
        Horizon_Basics horizon = new Horizon_Basics();
        Gravity_Basics gravity = new Gravity_Basics();
        public Threading_Test_CS()
        {
            vbc.task.recordTimings = false;
            labels = new string[] { "", "", "Output of thread 1 - horizon thread", "Output of thread 2 - gravity thread" };
            desc = "Test using the threading in C#";
        }
        void runThread(int id)
        {
            while (true)
            {
                if (vbc.task.frameCount < 0) break;
                if (vbc.task.srcThread != null)
                {
                    if (id == 1)
                    {
                        horizon.autoDisplay = true;
                        horizon.Run(vbc.task.srcThread);
                        dst2 = horizon.dst2;
                    }
                    else
                    {
                        gravity.autoDisplay = true;
                        gravity.Run(vbc.task.srcThread);
                        dst3 = gravity.dst2;
                    }
                    vbc.task.srcThread = null;
                }
                else
                {
                    Thread.Sleep(10);
                }
            }
        }
        public void RunAlg(Mat src)
        {
            if (thread1 == null)
            {
                thread1 = new Thread(() => runThread(1));
                thread1.Name = "Threading_Test_CS1";
                thread1.Start();
            }
            if (thread2 == null)
            {
                thread2 = new Thread(() => runThread(2));
                thread2.Name = "Threading_Test_CS2";
                thread2.Start();
            }
            if (vbc.task.srcThread == null) vbc.task.srcThread = src.Clone();
        }
        public void Close()
        {
            thread1.Abort();
            thread2.Abort();
        }
    }




    public class Threading_Test1_CS : VB_Parent
    {
        Gravity_Basics gravity = new Gravity_Basics();
        Thread thread;
        public Threading_Test1_CS()
        {
            desc = "Test using the threading in C# - this test works because there are no options with Gravity_Basics.";
        }
        void runThread()
        {
            while (true)
            {
                if (vbc.task.frameCount < 0) break;
                if (vbc.task.srcThread != null)
                {
                    gravity.autoDisplay = true;
                    gravity.Run(vbc.task.srcThread);
                    dst2 = gravity.dst2;
                    vbc.task.srcThread = null;
                }
                else
                {
                    Thread.Sleep(10);
                }
            }
        }
        public void RunAlg(Mat src)
        {
            if (thread == null)
            {
                thread = new Thread(runThread);
                thread.Name = "Threading_Test";
                thread.Start();
            }
            if (vbc.task.srcThread == null) vbc.task.srcThread = src.Clone();
        }
        public void Close()
        {
            thread.Abort();
        }
    }




    public class Threshold_Basics_CS : VB_Parent
    {
        public Options_Threshold options = new Options_Threshold();
        public Threshold_Basics_CS()
        {
            labels[2] = "Original image";
            desc = "Demonstrate the use of OpenCV's threshold and all its options";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            labels[3] = "Image after thresholding with threshold = " + options.threshold.ToString();
            dst2 = src;
            if (options.inputGray) dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (options.otsuOption) options.thresholdMethod |= ThresholdTypes.Otsu;
            if ((options.otsuOption || options.thresholdMethod == ThresholdTypes.Triangle) && dst2.Channels() != 1)
            {
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            dst3 = dst2.Threshold(options.threshold, 255, options.thresholdMethod);
        }
    }




    public class Threshold_Adaptive_CS : VB_Parent
    {
        Options_Threshold options = new Options_Threshold();
        Options_AdaptiveThreshold options1 = new Options_AdaptiveThreshold();
        public Threshold_Adaptive_CS()
        {
            labels = new string[] { "", "", "Original input", "Output of AdaptiveThreshold" };
            desc = "Explore what adaptive threshold can do.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            options1.RunOpt();
            dst2 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
            dst3 = dst2.AdaptiveThreshold(255, options1.method, options.thresholdMethod,
                                               options1.blockSize, options1.constantVal);
        }
    }




    public class Threshold_Definitions_CS : VB_Parent
    {
        Gradient_Color gradient = new Gradient_Color();
        Mat_4Click mats = new Mat_4Click();
        Options_ThresholdDef options = new Options_ThresholdDef();
        public Threshold_Definitions_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new string[] { "Gradient input (from Gradient_Basics)", "Binary threshold output of Gradient input at left", "Clockwise: binaryInv, Trunc, ToZero, ToZeroInv", "Current selection" };
            desc = "Demonstrate BinaryInv, Trunc, ToZero, and ToZero_Inv threshold methods";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();

            gradient.Run(empty);
            dst0 = gradient.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst1 = dst0.Threshold(options.threshold, 255, ThresholdTypes.Binary);
            mats.mat[0] = dst0.Threshold(options.threshold, 255, ThresholdTypes.BinaryInv);
            mats.mat[1] = dst0.Threshold(options.threshold, 255, ThresholdTypes.Trunc);
            mats.mat[2] = dst0.Threshold(options.threshold, 255, ThresholdTypes.Tozero);
            mats.mat[3] = dst0.Threshold(options.threshold, 255, ThresholdTypes.TozeroInv);
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            SetTrueText("Input Gradient Image", 0);
            SetTrueText("Binary", new cv.Point(dst2.Width / 2 + 5, 10), 1);
            SetTrueText("BinaryInv", 2);
            SetTrueText("Trunc", new cv.Point(dst2.Width / 2 + 5, 10), 2);
            SetTrueText("ToZero", new cv.Point(10, dst2.Height / 2 + 10), 2);
            SetTrueText("ToZeroInv", new cv.Point(dst2.Width / 2 + 5, dst2.Height / 2 + 10), 2);
            SetTrueText("Current selection from grid at left", 3);
        }
    }




    public class Threshold_ByChannels_CS : VB_Parent
    {
        Options_Colors optionsColor = new Options_Colors();
        Options_Threshold options = new Options_Threshold();
        public Threshold_ByChannels_CS()
        {
            labels[3] = "Threshold Inverse";
            UpdateAdvice(traceName + ": see local options.");
            desc = "Threshold by channel - use red threshold slider to impact grayscale results.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsColor.RunOpt();
            if (options.inputGray)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                dst2 = src.Threshold(optionsColor.redS, 255, options.thresholdMethod);
            }
            else
            {
                Mat[] split = src.Split();
                split[0] = split[0].Threshold(optionsColor.blueS, 255, options.thresholdMethod);
                split[1] = split[1].Threshold(optionsColor.greenS, 255, options.thresholdMethod);
                split[2] = split[2].Threshold(optionsColor.redS, 255, options.thresholdMethod);
                Cv2.Merge(split, dst2);
            }
            dst3 = ~dst2;
            labels[2] = "Threshold method: " + options.thresholdName;
        }
    }




    public class Threshold_ColorSource_CS : VB_Parent
    {
        Color8U_Basics colorClass = new Color8U_Basics();
        Threshold_ByChannels byChan = new Threshold_ByChannels();
        public Threshold_ColorSource_CS()
        {
            UpdateAdvice(traceName + ": Use redOptions color source to change the input.  Also, see local options.");
            desc = "Use all the alternative color sources as input to Threshold_ByChannels.";
        }
        public void RunAlg(Mat src)
        {
            colorClass.Run(src);
            byChan.Run(colorClass.dst3);
            dst2 = byChan.dst2;
            dst3 = byChan.dst3;
            labels = byChan.labels;
        }
    }




    public class Tracker_Basics_CPP_CS : VB_Parent
    {
        public cv.Rect tRect;
        cv.Rect saveRect = new cv.Rect();
        Options_Tracker options = new Options_Tracker();
        public Tracker_Basics_CPP_CS()
        {
            if (vbc.task.testAllRunning) vbc.task.drawRect = new cv.Rect(25, 25, 25, 25);
            desc = "Use C++ to track objects.  Results are poor compared to Match_DrawRect";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (vbc.task.drawRect != saveRect || vbc.task.optionsChanged)
            {
                if (cPtr != (IntPtr)0) Tracker_Basics_Close(cPtr);
                cPtr = Tracker_Basics_Open(options.trackType);
                saveRect = vbc.task.drawRect;
            }
            if (saveRect.Width != 0)
            {
                byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
                Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
                GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
                cv.Rect r = saveRect;
                IntPtr imagePtr = Tracker_Basics_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, r.X, r.Y, r.Width, r.Height);
                handleSrc.Free();
                dst2 = src;
                int[] rectData = new int[4];
                Marshal.Copy(imagePtr, rectData, 0, rectData.Length);
                tRect = new cv.Rect(rectData[0], rectData[1], rectData[2], rectData[3]);
                dst2.Rectangle(tRect, Scalar.White, vbc.task.lineWidth);
            }
            else
            {
                SetTrueText("Draw a rectangle around any object to be tracked in the BGR image above.", new cv.Point(10, 140));
            }
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0) cPtr = Tracker_Basics_Close(cPtr);
        }
    }




    public class Transform_Resize_CS : VB_Parent
    {
        Options_Transform options = new Options_Transform();
        public Transform_Resize_CS()
        {
            desc = "Resize an image based on the slider value.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            int w = (int)(options.resizeFactor * src.Width);
            int h = (int)(options.resizeFactor * src.Height);
            if (options.resizeFactor > 1)
            {
                Mat tmp = new Mat();
                tmp = src.Resize(new cv.Size(w, h), 0);
                cv.Rect roi = new cv.Rect((w - src.Width) / 2, (h - src.Height) / 2, src.Width, src.Height);
                tmp[roi].CopyTo(dst2);
            }
            else
            {
                dst2.SetTo(0);
                cv.Rect roi = new cv.Rect((src.Width - w) / 2, (src.Height - h) / 2, w, h);
                dst2[roi] = src.Resize(new cv.Size(w, h), 0);
            }
        }
    }




    public class Transform_Affine3D_CS : VB_Parent
    {
        Mat pc1;
        Mat pc2;
        Mat affineTransform;
        Options_Transform options = new Options_Transform();
        public Transform_Affine3D_CS()
        {
            desc = "Using 2 point clouds compute the 3D affine transform between them";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            string output = "Use the check boxes to snapshot the different point clouds" + "\n";
            if (vbc.task.testAllRunning)
            {
                if (vbc.task.frameCount == 30) options.firstCheck = true;
                if (vbc.task.frameCount == 60) options.secondCheck = true;
            }
            if (options.firstCheck)
            {
                pc1 = vbc.task.pointCloud.Clone();
                options.firstCheck = false;
                output += "First point cloud captured" + "\n";
            }
            if (options.secondCheck)
            {
                pc2 = vbc.task.pointCloud.Clone();
                options.secondCheck = false;
                output += "Second point cloud captured" + "\n";
            }
            if (pc1 != null)
            {
                if (pc2 != null)
                {
                    Mat inliers = new Mat();
                    affineTransform = new Mat(3, 4, MatType.CV_64F);
                    pc1 = pc1.Reshape(3, pc1.Rows * pc1.Cols);
                    pc2 = pc2.Reshape(3, pc2.Rows * pc2.Cols);
                    Cv2.EstimateAffine3D(pc1, pc2, affineTransform, inliers);
                    pc1 = null;
                    pc2 = null;
                }
            }
            if (affineTransform != null)
            {
                output += "Affine Transform 3D results:" + "\n";
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 4; j++)
                    {
                        output += string.Format("{0}\t", affineTransform.At<double>(i, j));
                    }
                    output += "\n";
                }
                output += "0\t0\t0\t1" + "\n";
            }
            SetTrueText(output);
        }
    }




    public class Transform_Rotate_CS : VB_Parent
    {
        public Point2f imageCenter;
        Options_Transform options = new Options_Transform();
        public Transform_Rotate_CS()
        {
            desc = "Rotate and scale and image based on the slider values.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            imageCenter = new Point2f(options.centerX, options.centerY);
            Mat rotationMat = Cv2.GetRotationMatrix2D(imageCenter, options.angle, options.scale);
            Cv2.WarpAffine(src, dst2, rotationMat, new cv.Size());
            DrawCircle(dst2, imageCenter, vbc.task.DotSize * 2, Scalar.Yellow);
            DrawCircle(dst2, imageCenter, vbc.task.DotSize, Scalar.Blue);
        }
    }




    public class TransformationMatrix_Basics_CS : VB_Parent
    {
        List<cv.Point3d> topLocations = new List<cv.Point3d>();
        Options_TransformationMatrix options = new Options_TransformationMatrix();
        public TransformationMatrix_Basics_CS()
        {
            if (vbc.task.cameraName == "StereoLabs ZED 2/2i")
            {
                FindSlider("TMatrix Top View multiplier").Value = 1; // need a smaller multiplier for this camera...
            }
            labels = new string[] { "", "", "View from above the camera", "View from side of the camera" };
            desc = "Show the contents of the transformation matrix";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.transformationMatrix != null)
            {
                var t = vbc.task.transformationMatrix;
                topLocations.Add(new Point3d(-t[12] * options.mul + dst2.Width / 2,
                                                -t[13] * options.mul + dst2.Height / 2,
                                                t[14] * options.mul + dst2.Height / 2));
                for (int i = 0; i < topLocations.Count(); i++)
                {
                    var pt = topLocations[i];
                    if (pt.X > 0 && pt.X < dst2.Width && pt.Z > 0 && pt.Z < src.Height)
                    {
                        DrawCircle(dst2, new cv.Point(pt.X, pt.Z), vbc.task.DotSize + 2, Scalar.Yellow);
                    }
                    if (pt.Z > 0 && pt.Z < dst2.Width && pt.Y > 0 && pt.Y < src.Height)
                    {
                        DrawCircle(dst3, new cv.Point(pt.Z, pt.Y), vbc.task.DotSize + 2, Scalar.Yellow);
                    }
                }
                if (topLocations.Count() > 20) topLocations.RemoveAt(0); // just show the last x points
            }
            else
            {
                SetTrueText("The transformation matrix for the current camera has not been set", new cv.Point(10, 125));
            }
        }
    }




    public class Triangle_Basics_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public List<cv.Point3f> triangles = new List<cv.Point3f>();
        public Triangle_Basics_CS()
        {
            labels = new string[] { "", "", "RedCloud_Hulls output", "Selected contour - each pixel has depth" };
            desc = "Given a contour, convert that contour to a series of triangles";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            if (vbc.task.redCells.Count() <= 1) return;
            var rc = vbc.task.rc;
            if (rc.index == 0) return;
            dst3.SetTo(0);
            var pt3D = new List<cv.Point3f>();
            foreach (var pt in rc.contour)
            {
                var point = new cv.Point(pt.X + rc.rect.X, pt.Y + rc.rect.Y);
                var vec = vbc.task.pointCloud.Get<cv.Point3f>(point.Y, point.X);
                DrawCircle(dst3, point, vbc.task.DotSize, Scalar.Yellow);
                pt3D.Add(vec);
            }
            var c3D = vbc.task.pointCloud.Get<cv.Point3f>(rc.maxDist.Y, rc.maxDist.X);
            triangles.Clear();
            var color3D = new Point3f(rc.color.Item2 / 255f, rc.color.Item1 / 255f, rc.color.Item0 / 255f);
            for (int i = 0; i < pt3D.Count(); i++)
            {
                triangles.Add(color3D);
                triangles.Add(c3D);
                triangles.Add(pt3D[i]);
                triangles.Add(pt3D[(i + 1) % pt3D.Count()]);
            }
        }
    }




    public class Triangle_HullContour_CS : VB_Parent
    {
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public Triangle_HullContour_CS()
        {
            vbc.task.gOptions.setDisplay1();
            labels = new string[] { "", "Selected cell", "RedCloud_Basics output", "Selected contour" };
            desc = "Given a contour, convert that contour to a series of triangles";
        }
        public void RunAlg(Mat src)
        {
            hulls.Run(src);
            dst2 = hulls.dst2;
            if (vbc.task.redCells.Count() <= 1) return;
            var rc = vbc.task.rc;
            rc.contour = ContourBuild(rc.mask, ContourApproximationModes.ApproxTC89L1);
            dst3.SetTo(0);
            foreach (var pt in rc.contour)
            {
                var point = new cv.Point(pt.X + rc.rect.X, pt.Y + rc.rect.Y);
                DrawCircle(dst3, point, vbc.task.DotSize, Scalar.Yellow);
            }
            dst1.SetTo(0);
            foreach (var pt in rc.hull)
            {
                var point = new cv.Point(pt.X + rc.rect.X, pt.Y + rc.rect.Y);
                DrawCircle(dst1, point, vbc.task.DotSize, Scalar.Yellow);
            }
        }
    }




    public class Triangle_RedCloud_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public List<cv.Point3f> triangles = new List<cv.Point3f>();
        public Triangle_RedCloud_CS()
        {
            labels = new string[] { "", "", "RedCloud_Basics output", "Selected contour - each pixel has depth" };
            desc = "Given a contour, convert that contour to a series of triangles";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst0 = redC.dst0;
            dst1 = redC.dst1;
            dst2 = redC.dst2;
            if (vbc.task.redCells.Count() <= 1) return;
            if (vbc.task.rc.index == 0) return;
            triangles.Clear();
            foreach (rcData rc in vbc.task.redCells)
            {
                var pt3D = new List<cv.Point3f>();
                foreach (var pt in rc.contour)
                {
                    var point = new cv.Point(pt.X + rc.rect.X, pt.Y + rc.rect.Y);
                    var vec = vbc.task.pointCloud.Get<cv.Point3f>(point.Y, point.X);
                    if (vec.Z > 0) pt3D.Add(vec);
                }
                var c3D = vbc.task.pointCloud.Get<cv.Point3f>(rc.maxDist.Y, rc.maxDist.X);
                var color3D = new Point3f(rc.color.Item2 / 255f, rc.color.Item1 / 255f, rc.color.Item0 / 255f);
                for (int i = 0; i < pt3D.Count(); i++)
                {
                    triangles.Add(color3D);
                    triangles.Add(c3D);
                    triangles.Add(pt3D[i]);
                    triangles.Add(pt3D[(i + 1) % pt3D.Count()]);
                }
            }
        }
    }




    public class Triangle_Cell_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public List<cv.Point3f> triangles = new List<cv.Point3f>();
        public Triangle_Cell_CS()
        {
            labels = new string[] { "", "", "RedCloud_Basics output", "Selected contour - each pixel has depth" };
            desc = "Given a contour, convert that contour to a series of triangles";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            if (vbc.task.redCells.Count() <= 1) return;
            var rc = vbc.task.rc;
            if (rc.index == 0) return;
            dst3.SetTo(0);
            var pt3D = new List<cv.Point3f>();
            float aspectRect = (float)rc.rect.Width / rc.rect.Height, aspect = (float)dst2.Width / dst2.Height;
            cv.Rect cellRect;
            float xFactor, yFactor;
            if (aspectRect > aspect)
            {
                cellRect = new cv.Rect(0, 0, dst2.Width, (int)(rc.rect.Height * dst2.Width / rc.rect.Width));
                xFactor = dst2.Width;
                yFactor = (float)(rc.rect.Height * dst2.Width / rc.rect.Width);
            }
            else
            {
                cellRect = new cv.Rect(0, 0, (int)(rc.rect.Width * dst2.Height / rc.rect.Height), dst2.Height);
                xFactor = (float)(rc.rect.Width * dst2.Height / rc.rect.Height);
                yFactor = dst2.Height;
            }
            dst3.Rectangle(cellRect, Scalar.White, vbc.task.lineWidth);
            foreach (var pt in rc.contour)
            {
                var vec = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(pt.Y, pt.X);
                var point = new cv.Point(xFactor * pt.X / rc.rect.Width, yFactor * pt.Y / rc.rect.Height);
                DrawCircle(dst3, point, vbc.task.DotSize, Scalar.Yellow);
                pt3D.Add(vec);
            }
            var c3D = vbc.task.pointCloud.Get<cv.Point3f>(rc.maxDist.Y, rc.maxDist.X);
            triangles.Clear();
            var color3D = new Point3f(rc.color.Item2 / 255f, rc.color.Item1 / 255f, rc.color.Item0 / 255f);
            for (int i = 0; i < pt3D.Count(); i++)
            {
                triangles.Add(color3D);
                triangles.Add(c3D);
                triangles.Add(pt3D[i]);
                triangles.Add(pt3D[(i + 1) % pt3D.Count()]);
            }
        }
    }




    public class Triangle_Mask_CS : VB_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public List<cv.Point3f> triangles = new List<cv.Point3f>();
        public Triangle_Mask_CS()
        {
            labels = new string[] { "", "", "RedCloud_Basics output", "Selected rc.mask - each pixel has depth. Red dot is maxDist." };
            desc = "Given a RedCloud cell, resize it and show the points with depth.";
        }
        public void RunAlg(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            if (vbc.task.redCells.Count() <= 1) return;
            var rc = vbc.task.rc;
            if (rc.index == 0) return;
            dst3.SetTo(0);
            var pt3D = new List<cv.Point3f>();
            float aspectRect = (float)rc.rect.Width / rc.rect.Height, aspect = (float)dst2.Width / dst2.Height;
            cv.Rect cellRect;
            float xFactor, yFactor;
            if (aspectRect > aspect)
            {
                cellRect = new cv.Rect(0, 0, dst2.Width, (int)(rc.rect.Height * dst2.Width / rc.rect.Width));
                xFactor = dst2.Width;
                yFactor = (float)(rc.rect.Height * dst2.Width / rc.rect.Width);
            }
            else
            {
                cellRect = new cv.Rect(0, 0, (int)(rc.rect.Width * dst2.Height / rc.rect.Height), dst2.Height);
                xFactor = (float)(rc.rect.Width * dst2.Height / rc.rect.Height);
                yFactor = dst2.Height;
            }
            dst3.Rectangle(cellRect, Scalar.White, vbc.task.lineWidth);
            triangles.Clear();
            for (int y = 0; y < rc.rect.Height; y++)
            {
                for (int x = 0; x < rc.rect.Width; x++)
                {
                    if (rc.mask.Get<byte>(y, x) == 0) continue;
                    var vec = vbc.task.pointCloud[rc.rect].Get<cv.Point3f>(y, x);
                    var point = new Point2f(xFactor * x / rc.rect.Width, yFactor * y / rc.rect.Height);
                    DrawCircle(dst3, point, vbc.task.DotSize, Scalar.Yellow);
                    pt3D.Add(vec);
                }
            }
            var newMaxDist = new Point2f(xFactor * (rc.maxDist.X - rc.rect.X) / rc.rect.Width,
                                            yFactor * (rc.maxDist.Y - rc.rect.Y) / rc.rect.Height);
            DrawCircle(dst3, newMaxDist, vbc.task.DotSize + 2, Scalar.Red);
            labels[2] = redC.labels[2];
        }
    }




    public class VectorMagnitude_CS : VB_Parent
    {
        public VectorMagnitude_CS()
        {
            desc = "Compute Euclidian and Manhattan Distance on a single vector.";
            labels[2] = "Vector Magnitude";
        }
        public void RunAlg(Mat src)
        {
            float[] cVector = { 1, 4, 4, 8 };
            strOut = $"p1 = ({cVector[0]}, {cVector[1]})\t p2 = ({cVector[2]}, {cVector[3]})\n\n";
            Mat coordinates = cv.Mat.FromPixelData(1, 4, MatType.CV_32F, cVector);
            Mat diff_x = coordinates.Col(0) - coordinates.Col(2);
            Mat diff_y = coordinates.Col(1) - coordinates.Col(3);
            // sqrt((x2 - x1)^2 + (y2 - y1)^2)
            Mat euclidean_distance = new Mat();
            Cv2.Magnitude(diff_x, diff_y, euclidean_distance);
            strOut += $"euclidean_distance = {euclidean_distance.At<float>(0, 0)}\n\n";
            Mat manhattan_distance = Cv2.Abs(diff_x) + Cv2.Abs(diff_y);
            strOut += $"manhattan_distance = {manhattan_distance.At<float>(0, 0)}\n\n";
            // Another way to compute L1 distance, with Absdiff
            // abs(x2 - x1) + abs(y2 - y1)
            Mat points1 = coordinates[new cv.Range(0, 1), new cv.Range(0, 2)];
            Mat points2 = coordinates[new cv.Range(0, 1), new cv.Range(2, 4)];
            Mat other_manhattan_distance = new Mat();
            Cv2.Absdiff(points1, points2, other_manhattan_distance);
            other_manhattan_distance = other_manhattan_distance.Col(0) + other_manhattan_distance.Col(1);
            strOut += $"other_manhattan_distance = {other_manhattan_distance.At<float>(0, 0)}";
            SetTrueText(strOut);
        }
    }




    public class Video_Basics_CS : VB_Parent
    {
        public VideoCapture captureVideo = new VideoCapture();
        public Options_Video options = new Options_Video();
        public Video_Basics_CS()
        {
            captureVideo = new VideoCapture(options.fileInfo.FullName);
            labels[2] = options.fileInfo.Name;
            desc = "Show a video file";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.optionsChanged)
            {
                captureVideo = new VideoCapture(options.fileInfo.FullName);
            }
            captureVideo.Read(dst1);
            if (dst1.Empty())
            {
                captureVideo.Dispose();
                captureVideo = new VideoCapture(options.fileInfo.FullName);
                captureVideo.Read(dst1);
            }
            options.maxFrames = captureVideo.FrameCount;
            options.currFrame = captureVideo.PosFrames;
            dst2 = dst1.Resize(dst1.Size());
        }
    }




    public class Video_CarCounting_CS : VB_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        Video_Basics video = new Video_Basics();
        BGSubtract_MOG bgSub = new BGSubtract_MOG();
        bool[] activeState = new bool[6];
        int carCount = 0;
        public Video_CarCounting_CS()
        {
            flow.parentData = this;
            desc = "Count cars in a video file";
        }
        public void RunAlg(Mat src)
        {
            video.Run(src);
            dst2.SetTo(0);
            bgSub.Run(video.dst1);
            var videoImage = bgSub.dst2;
            dst3 = video.dst2;
            int activeHeight = 30;
            int finishLine = bgSub.dst2.Height - activeHeight * 8;
            int[] choices = { 230, 460, 680, 900, 1110 };
            for (int i = 0; i < choices.Length; i++)
            {
                var lane = new cv.Rect(choices[i], finishLine, 40, activeHeight);
                int cellCount = videoImage[lane].CountNonZero();
                if (cellCount > 0)
                {
                    activeState[i] = true;
                    videoImage.Rectangle(lane, Scalar.Red, -1);
                    dst3.Rectangle(lane, Scalar.Red, -1);
                }
                if (cellCount == 0 && activeState[i])
                {
                    activeState[i] = false;
                    carCount++;
                }
                dst3.Rectangle(lane, Scalar.White, 2);
            }
            var tmp = videoImage.Resize(src.Size());
            if (tmp.Channels() != dst2.Channels()) tmp = tmp.CvtColor(ColorConversionCodes.GRAY2BGR);
            flow.nextMsg = "  Cars " + carCount.ToString();
            flow.Run(empty);
            dst2 = dst2 | tmp;
        }
    }




    public class Video_CarCComp_CS : VB_Parent
    {
        CComp_Both cc = new CComp_Both();
        Video_Basics video = new Video_Basics();
        BGSubtract_MOG bgSub = new BGSubtract_MOG();
        public Video_CarCComp_CS()
        {
            desc = "Outline cars with a rectangle";
        }
        public void RunAlg(Mat src)
        {
            video.Run(src);
            if (!video.dst2.Empty())
            {
                bgSub.Run(video.dst2);
                cc.Run(bgSub.dst2);
                dst2 = cc.dst3;
                dst3 = cc.dst2;
            }
        }
    }




    public class Video_MinRect_CS : VB_Parent
    {
        public Video_Basics video = new Video_Basics();
        public BGSubtract_MOG bgSub = new BGSubtract_MOG();
        public cv.Point[][] contours;
        public Video_MinRect_CS()
        {
            video.options.fileInfo = new FileInfo(vbc.task.HomeDir + "Data/CarsDrivingUnderBridge.mp4");
            video.Run(dst2);
            desc = "Find area of car outline - example of using minAreaRect";
        }
        public void RunAlg(Mat src)
        {
            video.Run(src);
            if (!video.dst2.Empty())
            {
                bgSub.Run(video.dst2);
                contours = Cv2.FindContoursAsArray(bgSub.dst2, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);
                dst2 = bgSub.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
                if (standaloneTest())
                {
                    for (int i = 0; i < contours.Length; i++)
                    {
                        var minRect = Cv2.MinAreaRect(contours[i]);
                        DrawRotatedRect(minRect, dst2, Scalar.Red);
                    }
                }
                dst3 = video.dst2;
            }
        }
    }




    public class Video_MinCircle_CS : VB_Parent
    {
        Video_MinRect video = new Video_MinRect();
        public Video_MinCircle_CS()
        {
            desc = "Find area of car outline - example of using MinEnclosingCircle";
        }
        public void RunAlg(Mat src)
        {
            video.Run(src);
            dst2 = video.dst2;
            dst3 = video.dst3;
            Point2f center = new Point2f();
            float radius = 10;
            if (video.contours != null)
            {
                for (int i = 0; i < video.contours.Length; i++)
                {
                    Cv2.MinEnclosingCircle(video.contours[i], out center, out radius);
                    DrawCircle(dst2, center, (int)radius, Scalar.White);
                }
            }
        }
    }





    public class Vignetting_Basics_CPP_CS : VB_Parent
    {
        public bool removeVig;
        cv.Point center;
        Options_Vignetting options = new Options_Vignetting();
        public Vignetting_Basics_CPP_CS()
        {
            center = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            cPtr = Vignetting_Open();
            desc = "C++ version of vignetting for comparison with the VB version.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.ClickPoint != new cv.Point())
                center = vbc.task.ClickPoint;
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Vignetting_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.radius, center.X, center.Y, removeVig);
            handleSrc.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr);
        }
        public void Close()
        {
            if (cPtr != (IntPtr)0)
                cPtr = Vignetting_Close(cPtr);
        }
    }




    public class Vignetting_VB_CS : VB_Parent
    {
        public bool removeVig;
        cv.Point center;
        Options_Vignetting options = new Options_Vignetting();
        public Vignetting_VB_CS()
        {
            center = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            labels = new string[] { "", "", "Resulting vignetting.  Click where the center should be located for vignetting", "" };
            desc = "Create a stream of images that have been vignetted.";
        }
        public double fastCos(double x)
        {
            x += Cv2.PI / 2;
            if (x > Cv2.PI) x -= 2 * Cv2.PI;
            if (x < 0) return 1.27323954 * x + 0.405284735 * x * x;
            return 1.27323954 * x - 0.405284735 * x * x;
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (vbc.task.ClickPoint != new cv.Point())
                center = vbc.task.ClickPoint;
            double maxDist = new cv.Point(0, 0).DistanceTo(center) * options.radius;
            double tmp;
            for (int y = 0; y < src.Height; y++)
            {
                for (int x = 0; x < src.Width; x++)
                {
                    cv.Point pt = new cv.Point(x, y);
                    double cos = fastCos(pt.DistanceTo(center) / maxDist);
                    cos *= cos;
                    Vec3b val = src.Get<Vec3b>(y, x);
                    for (int i = 0; i <= 2; i++)
                    {
                        if (removeVig)
                            tmp = Math.Floor(val[i] / cos);
                        else
                            tmp = Math.Floor(val[i] * cos);
                        val[i] = (byte)(tmp > 255 ? 255 : tmp);
                    }
                    dst2.Set<Vec3b>(y, x, val);
                }
            }
        }
    }




    public class Vignetting_Removal_CS : VB_Parent
    {
        Vignetting_Basics basics = new Vignetting_Basics();
        Mat defaultImage;
        public Vignetting_Removal_CS()
        {
            basics.removeVig = true;
            labels = new string[] { "", "", "Vignetted input - click anywhere to adjust the center of the vignetting.", "The devignetted output - brighter, more vivid colors." };
            desc = "Demonstrate devignetting";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() && defaultImage == null)
            {
                FileInfo fileInfo = new FileInfo(vbc.task.HomeDir + "data/nature.jpg");
                if (fileInfo.Exists)
                    defaultImage = Cv2.ImRead(fileInfo.FullName);
                defaultImage = defaultImage.Resize(dst3.Size());
                dst2 = defaultImage.Clone();
            }
            if (standaloneTest())
                basics.Run(defaultImage);
            else
                basics.Run(src);
            dst3 = basics.dst2;
        }
    }




    public class Vignetting_Devignetting_CS : VB_Parent
    {
        Vignetting_Removal devignet = new Vignetting_Removal();
        Vignetting_Basics basics = new Vignetting_Basics();
        public Vignetting_Devignetting_CS()
        {
            labels = new string[] { "", "", "Vignetted image", "Devignetted image" };
            desc = "Inject vignetting into the image and then remove it to test devignetting.  Click to relocate the center";
        }
        public void RunAlg(Mat src)
        {
            basics.Run(src);
            dst2 = basics.dst2;
            devignet.Run(dst2);
            dst3 = devignet.dst3;
        }
    }




    public class Volume_Basics_CS : VB_Parent
    {
        public rcData rc = new rcData();
        public float volume;
        RedCloud_Basics redC = new RedCloud_Basics();
        public Volume_Basics_CS()
        {
            desc = "Build a box containing all the 3D points of a RedCloud cell";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                rc = vbc.task.rc;
            }
            List<float> xList = new List<float>();
            List<float> yList = new List<float>();
            List<float> zList = new List<float>();
            foreach (var pt in rc.contour)
            {
                var vec = vbc.task.pointCloud.Get<Vec3f>(pt.Y, pt.X);
                if (vec.Item0 != 0) xList.Add(vec.Item0);
                if (vec.Item1 != 0) yList.Add(vec.Item1);
                if (vec.Item2 != 0) zList.Add(vec.Item2);
            }
            float minX = 0, maxX = 0, minY = 0, maxY = 0, minZ = 0, maxZ = 0;
            if (xList.Count() > 0) minX = xList.Min();
            if (yList.Count() > 0) minY = yList.Min();
            if (zList.Count() > 0) minZ = zList.Min();
            if (xList.Count() > 0) maxX = xList.Max();
            if (yList.Count() > 0) maxY = yList.Max();
            if (zList.Count() > 0) maxZ = zList.Max();
            int meterFactor = 100;
            string mString = meterFactor == 100 ? "centimeters" : (meterFactor == 1 ? "meters" : "decimeters");
            volume = (maxX - minX) * (maxY - minY) * (maxZ - minZ) * meterFactor * meterFactor * meterFactor;
            if (vbc.task.heartBeat)
            {
                strOut = "Volume = " + volume.ToString("F0") + " cubic " + mString + "\n" + "\n";
                strOut += "Min " + "\t" + "Max " + "\t" + "Range " + "\t" + " units=" + mString + "\n";
                strOut += (minX * meterFactor).ToString("F0") + "\t" + (maxX * meterFactor).ToString("F0") + "\t" + ((maxX - minX) * meterFactor).ToString("F0") + "\t" + " X dimension" + "\n";
                strOut += (minY * meterFactor).ToString("F0") + "\t" + (maxY * meterFactor).ToString("F0") + "\t" + ((maxY - minY) * meterFactor).ToString("F0") + "\t" + " Y dimension" + "\n";
                strOut += (minZ * meterFactor).ToString("F0") + "\t" + (maxZ * meterFactor).ToString("F0") + "\t" + ((maxZ - minZ) * meterFactor).ToString("F0") + "\t" + " Z dimension" + "\n";
            }
            SetTrueText(strOut, 3);
        }
    }




    public class WarpAffine_Basics_CS : VB_Parent
    {
        public Options_Resize options = new Options_Resize();
        Options_WarpAffine optionsWarp = new Options_WarpAffine();
        public Point2f rotateCenter;
        public float rotateAngle; // in degrees
        WarpAffine_BasicsQT_CS warpQT;
        public WarpAffine_Basics_CS()
        {
            warpQT = new WarpAffine_BasicsQT_CS();
            desc = "Use WarpAffine to transform input images.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            optionsWarp.RunOpt();

            if (standaloneTest() && vbc.task.heartBeat)
            {
                rotateAngle = optionsWarp.angle;
                rotateCenter.X = msRNG.Next(0, dst2.Width);
                rotateCenter.Y = msRNG.Next(0, dst2.Height);
            }
            warpQT.rotateCenter = rotateCenter;
            warpQT.rotateAngle = rotateAngle;
            warpQT.RunAlg(src);
            labels = warpQT.labels;
            dst2 = warpQT.dst2;
        }
    }




    public class WarpAffine_BasicsQT_CS : VB_Parent
    {
        public Point2f rotateCenter;
        public float rotateAngle; // in degrees
        public WarpAffine_BasicsQT_CS()
        {
            desc = "Use WarpAffine to transform input images with no options.";
        }
        public void RunAlg(Mat src)
        {
            if (standaloneTest() && vbc.task.heartBeat)
            {
                SetTrueText("There is no output for the " + traceName + " algorithm.  Use WarpAffine_Basics to test.", 3);
                return;
            }
            var rotationMatrix = Cv2.GetRotationMatrix2D(rotateCenter, rotateAngle, 1.0);
            Cv2.WarpAffine(src, dst2, rotationMatrix, src.Size(), InterpolationFlags.Nearest);
            labels[2] = "Rotated around yellow point " + rotateCenter.X.ToString(vbc.fmt0) + ", " + rotateCenter.Y.ToString(vbc.fmt0) +
                        " with Warpaffine with angle: " + rotateAngle.ToString();
        }
    }




    public class WarpAffine_Captcha_CS : VB_Parent
    {
        const int charHeight = 40;
        const int charWidth = 30;
        const int captchaLength = 8;
        Random rng = new Random();
        public WarpAffine_Captcha_CS()
        {
            desc = "Use OpenCV to build a captcha Turing test.";
        }
        void addNoise(Mat image)
        {
            for (int n = 0; n <= 100; n++)
            {
                int i = rng.Next(0, image.Cols - 1);
                int j = rng.Next(0, image.Rows - 1);
                var center = new cv.Point(i, j);
                var c = new Scalar(rng.Next(0, 255), rng.Next(0, 255), rng.Next(0, 255));
                DrawCircle(image, center, rng.Next(1, 3), c);
            }
        }
        void addLines(ref Mat image)
        {
            for (int i = 0; i < captchaLength; i++)
            {
                int startX = rng.Next(0, image.Cols - 1);
                int endX = rng.Next(0, image.Cols - 1);
                int startY = rng.Next(0, image.Rows - 1);
                int endY = rng.Next(0, image.Rows - 1);
                var c = new Scalar(rng.Next(0, 255), rng.Next(0, 255), rng.Next(0, 255));
                image.Line(new cv.Point(startX, startY), new cv.Point(endX, endY), c, rng.Next(1, 3), vbc.task.lineType);
            }
        }
        void scaleImg(Mat input, ref Mat output)
        {
            int height = rng.Next(0, 19) * -1 + charHeight;
            int width = rng.Next(0, 19) * -1 + charWidth;
            var s = new cv.Size(width, height);
            output = input.Resize(s);
        }
        void rotateImg(Mat input, ref Mat output)
        {
            int sign = (int)rng.NextDouble();
            if (sign == 0) sign = -1;
            int angle = rng.Next(0, 29) * sign; // between -30 and 30
            var center = new Point2f(input.Cols / 2, input.Rows / 2);
            var rotationMatrix = Cv2.GetRotationMatrix2D(center, angle, 1);
            Cv2.WarpAffine(input, output, rotationMatrix, input.Size(), InterpolationFlags.Linear, BorderTypes.Constant, Scalar.White);
        }
        void transformPerspective(ref Mat charImage)
        {
            Point2f[] srcPt = { new Point2f(0, 0), new Point2f(0, charHeight), new Point2f(charWidth, 0), new Point2f(charWidth, charHeight) };
            float varWidth = charWidth / 2;
            float varHeight = charHeight / 2.0f;
            float widthWarp = charHeight - varWidth + (float)(rng.NextDouble() * varWidth);
            float heightWarp = charHeight - varHeight + (float)(rng.NextDouble() * varHeight);
            Point2f[] dstPt = { new Point2f(0, 0), new Point2f(0, charHeight), new Point2f(charWidth, 0), new Point2f(widthWarp, heightWarp) };
            var perspectiveTranx = Cv2.GetPerspectiveTransform(srcPt, dstPt);
            Cv2.WarpPerspective(charImage, charImage, perspectiveTranx, new cv.Size(charImage.Cols, charImage.Rows), InterpolationFlags.Cubic,
                                    BorderTypes.Constant, Scalar.White);
        }
        public void RunAlg(Mat src)
        {
            string[] characters = { "a", "A", "b", "B", "c", "C", "D", "d", "e", "E", "f", "F", "g", "G", "h", "H", "j", "J", "k", "K", "m", "M", "n", "N", "q", "Q", "R", "t", "T", "w", "W", "x", "X", "y", "Y", "1", "2", "3", "4", "5", "6", "7", "8", "9" };
            int charactersSize = characters.Length / characters[0].Length;
            Mat outImage = new Mat(charHeight, charWidth * captchaLength, MatType.CV_8UC3, Scalar.White);
            for (int i = 0; i < captchaLength; i++)
            {
                Mat charImage = new Mat(charHeight, charWidth, MatType.CV_8UC3, Scalar.White);
                string c = characters[rng.Next(0, characters.Length - 1)];
                Cv2.PutText(charImage, c, new cv.Point(10, charHeight - 10), (cv.HersheyFonts)msRNG.Next(1, 6), msRNG.Next(3, 4),
                            vbc.task.scalarColors[i], msRNG.Next(1, 5), LineTypes.AntiAlias);
                transformPerspective(ref charImage);
                rotateImg(charImage, ref charImage);
                scaleImg(charImage, ref charImage);
                charImage.CopyTo(outImage[new cv.Rect(charWidth * i, 0, charImage.Cols, charImage.Rows)]);
            }
            addLines(ref outImage);
            addNoise(outImage);
            var roi = new cv.Rect(0, src.Height / 2 - charHeight / 2, dst2.Cols, charHeight);
            dst2[roi] = outImage.Resize(new cv.Size(dst2.Cols, charHeight));
        }
    }




    public class WarpAffine_3Points_CS : VB_Parent
    {
        Area_MinTriangle_CPP_VB triangle = new Area_MinTriangle_CPP_VB();
        Mat M = new Mat();
        public WarpAffine_3Points_CS()
        {
            desc = "Use 3 non-colinear points to build an affine transform and apply it to the color image.";
            labels[2] = "Triangles define the affine transform";
            labels[3] = "Image with affine transform applied";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                Mat[] triangles = new Mat[2];
                triangle.Run(src);
                triangles[0] = triangle.triangle.Clone();
                var srcPoints1 = new List<cv.Point2f>(triangle.options.srcPoints);
                triangle.Run(src);
                triangles[1] = triangle.triangle.Clone();
                var srcPoints2 = new List<cv.Point2f>(triangle.options.srcPoints);
                var tOriginal = cv.Mat.FromPixelData(3, 1, MatType.CV_32FC2, new float[] { 0, 0, 0, src.Height, src.Width, src.Height });
                M = Cv2.GetAffineTransform(tOriginal, triangles[1]);
                Mat wideMat = new Mat(src.Rows, src.Cols * 2, MatType.CV_8UC3, cv.Scalar.All(0));
                cv.Scalar[] choices = { Scalar.Red, Scalar.White, Scalar.Yellow };
                for (int j = 0; j <= 1; j++)
                {
                    for (int i = 0; i < triangles[j].Rows; i++)
                    {
                        var p1 = triangles[j].Get<cv.Point2f>(i) + new Point2f(j * src.Width, 0);
                        var p2 = triangles[j].Get<cv.Point2f>((i + 1) % 3) + new Point2f(j * src.Width, 0);
                        var color = choices[i];
                        DrawLine(wideMat, p1, p2, color, vbc.task.lineWidth + 3);
                        if (j == 0)
                        {
                            var p3 = triangles[j + 1].Get<cv.Point2f>(i) + new Point2f(src.Width, 0);
                            DrawLine(wideMat, p1, p3, Scalar.White);
                        }
                    }
                }
                var corner = triangles[0].Get<cv.Point2f>(0);
                DrawCircle(wideMat, corner, vbc.task.DotSize + 5, Scalar.Yellow);
                corner = new Point2f((float)M.Get<double>(0, 2) + src.Width, (float)M.Get<double>(1, 2));
                DrawCircle(wideMat, corner, vbc.task.DotSize + 5, Scalar.Yellow);
                dst2 = wideMat[new cv.Rect(0, 0, src.Width, src.Height)];
                dst3 = wideMat[new cv.Rect(src.Width, 0, src.Width, src.Height)];
                cv.Point pt;
                for (int i = 0; i < srcPoints1.Count(); i++)
                {
                    pt = new cv.Point((int)srcPoints1[i].X, (int)srcPoints1[i].Y);
                    DrawCircle(dst2, pt, vbc.task.DotSize + 2, Scalar.White);
                    pt = new cv.Point((int)srcPoints2[i].X, (int)srcPoints2[i].Y);
                    DrawCircle(dst3, pt, vbc.task.DotSize + 2, Scalar.White);
                }
            }
            SetTrueText("M defined as: " + "\n" +
                            M.Get<double>(0, 0).ToString(vbc.fmt2) + "\t" +
                            M.Get<double>(0, 1).ToString(vbc.fmt2) + "\t" +
                            M.Get<double>(0, 2).ToString(vbc.fmt2) + "\n" +
                            M.Get<double>(1, 0).ToString(vbc.fmt2) + "\t" +
                            M.Get<double>(1, 1).ToString(vbc.fmt2) + "\t" +
                            M.Get<double>(1, 2).ToString(vbc.fmt2));
        }
    }




    public class WarpAffine_4Points_CS : VB_Parent
    {
        Area_MinRect mRect = new Area_MinRect();
        Options_MinArea options = new Options_MinArea();
        Mat M = new Mat();
        public WarpAffine_4Points_CS()
        {
            desc = "Use 4 non-colinear points to build a perspective transform and apply it to the color image.";
            labels[2] = "Color image with perspective transform applied";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.heartBeat)
            {
                options.RunOpt();
                mRect.inputPoints = options.srcPoints;
                var roi = new cv.Rect(50, src.Height / 2, src.Width / 6, src.Height / 6);
                var smallImage = src.Resize(new cv.Size(roi.Width, roi.Height));
                RotatedRect[] rectangles = new RotatedRect[2];
                mRect.Run(src);
                rectangles[1] = mRect.minRect;
                rectangles[1].Center.X = src.Width - rectangles[0].Center.X - roi.Width;
                rectangles[0] = new RotatedRect(new Point2f(src.Width / 2, src.Height / 2), new Size2f(src.Width, src.Height), 0);
                M = Cv2.GetPerspectiveTransform(rectangles[0].Points(), rectangles[1].Points());
                Cv2.WarpPerspective(src, dst2, M, src.Size());
                dst2[roi] = smallImage;
                cv.Scalar[] choices = { Scalar.Red, Scalar.White, Scalar.Yellow, Scalar.Green, Scalar.White };
                for (int j = 0; j <= 1; j++)
                {
                    for (int i = 0; i < rectangles[j].Points().Length; i++)
                    {
                        var p1 = rectangles[j].Points()[i];
                        var p2 = rectangles[j].Points()[(i + 1) % rectangles[j].Points().Length];
                        if (j == 0)
                        {
                            var p3 = rectangles[1].Points()[i];
                            DrawLine(dst2, p1, p3, Scalar.White);
                        }
                        cv.Scalar color = choices[i];
                        DrawLine(dst2, p1, p2, color, vbc.task.lineWidth + 3);
                    }
                }
            }
            SetTrueText("M defined as: " + "\n" +
                            $"{M.At<double>(0, 0)}\t{M.At<double>(0, 1)}\t{M.At<double>(0, 2)}" + "\n" +
                            $"{M.At<double>(1, 0)}\t{M.At<double>(1, 1)}\t{M.At<double>(1, 2)}" + "\n" +
                            $"{M.At<double>(2, 0)}\t{M.At<double>(2, 1)}\t{M.At<double>(2, 2)}" + "\n");
            var center = new Point2f((float)M.At<double>(0, 2), (float)M.At<double>(1, 2));
            DrawCircle(dst2, center, vbc.task.DotSize + 5, Scalar.Yellow);
            center = new Point2f(50, src.Height / 2);
            DrawCircle(dst2, center, vbc.task.DotSize + 5, Scalar.Yellow);
        }
    }




    public class WarpAffine_Repeated_CS : VB_Parent
    {
        public WarpAffine_Repeated_CS()
        {
            labels = new[] { "", "", "Rotated repeatedly 45 degrees - note the blur", "Rotated repeatedly 90 degrees" };
            desc = "Compare an image before and after repeated and equivalent in degrees rotations.";
        }
        public void RunAlg(Mat src)
        {
            var rect = new cv.Rect(0, 0, dst2.Height, dst2.Height);
            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = dst1.Clone();
            dst3 = dst1.Clone();
            var center = new cv.Point(rect.Width / 2, rect.Height / 2);
            int angle45 = 45, angle90 = 90;
            double scale = 1.0;
            int h = rect.Height, w = rect.Width;
            var m1 = Cv2.GetRotationMatrix2D(center, angle45, scale);
            var m2 = Cv2.GetRotationMatrix2D(center, angle90, scale);
            double abs_cos = Math.Abs(m2.At<double>(0, 0));
            double abs_sin = Math.Abs(m2.At<double>(0, 1));
            int bound_w = (int)(h * abs_sin + w * abs_cos);
            int bound_h = (int)(h * abs_cos + w * abs_sin);
            double val = m1.At<double>(0, 2);
            m1.Set<double>(0, 2, val + bound_w / 2 - center.X);
            val = m1.At<double>(1, 2);
            m1.Set<double>(1, 2, val + bound_h / 2 - center.Y);
            val = m2.At<double>(0, 2);
            m2.Set<double>(0, 2, val + bound_w / 2 - center.X);
            val = m2.At<double>(1, 2);
            m2.Set<double>(1, 2, val + bound_h / 2 - center.Y);
            Cv2.WarpAffine(dst1[rect], dst2[rect], m1, new cv.Size(bound_w, bound_h));
            for (int i = 0; i <= 6; i++)
            {
                Cv2.WarpAffine(dst2[rect], dst2[rect], m1, new cv.Size(bound_w, bound_h));
            }
            Cv2.WarpAffine(dst1[rect], dst3[rect], m2, new cv.Size(bound_w, bound_h));
            for (int i = 0; i <= 2; i++)
            {
                Cv2.WarpAffine(dst3[rect], dst3[rect], m2, new cv.Size(bound_w, bound_h));
            }
            dst2.Rectangle(rect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
            dst3.Rectangle(rect, Scalar.White, vbc.task.lineWidth, vbc.task.lineType);
        }
    }




    public class WarpAffine_RepeatedExample8_CS : VB_Parent
    {
        public WarpAffine_RepeatedExample8_CS()
        {
            labels = new[] { "", "", "Rotated repeatedly 45 degrees", "Rotated repeatedly 90 degrees" };
            desc = "Compare an image before and after repeated rotations.";
        }
        public void RunAlg(Mat src)
        {
            var input = Cv2.ImRead(vbc.task.HomeDir + "Data/8.jpg", ImreadModes.Color);
            var center = new cv.Point(input.Width / 2, input.Height / 2);
            int angle45 = 45, angle90 = 90;
            double scale = 1.0;
            int h = input.Height, w = input.Width;
            var m1 = Cv2.GetRotationMatrix2D(center, angle45, scale);
            var m2 = Cv2.GetRotationMatrix2D(center, angle90, scale);
            double abs_cos = Math.Abs(m2.At<double>(0, 0));
            double abs_sin = Math.Abs(m2.At<double>(0, 1));
            int bound_w = (int)(h * abs_sin + w * abs_cos);
            int bound_h = (int)(h * abs_cos + w * abs_sin);
            double val = m1.At<double>(0, 2);
            m1.Set<double>(0, 2, val + bound_w / 2 - center.X);
            val = m1.At<double>(1, 2);
            m1.Set<double>(1, 2, val + bound_h / 2 - center.Y);
            val = m2.At<double>(0, 2);
            m2.Set<double>(0, 2, val + bound_w / 2 - center.X);
            val = m2.At<double>(1, 2);
            m2.Set<double>(1, 2, val + bound_h / 2 - center.Y);
            Cv2.WarpAffine(input, dst2, m1, new cv.Size(bound_w, bound_h));
            for (int i = 0; i <= 6; i++)
            {
                Cv2.WarpAffine(dst2, dst2, m1, new cv.Size(bound_w, bound_h));
            }
            Cv2.WarpAffine(input, dst3, m2, new cv.Size(bound_w, bound_h));
            for (int i = 0; i <= 2; i++)
            {
                Cv2.WarpAffine(dst3, dst3, m2, new cv.Size(bound_w, bound_h));
            }
        }
    }




    public class WarpModel_Basics_CS : VB_Parent
    {
        readonly WarpModel_ECC ecc = new WarpModel_ECC();
        Options_WarpModel options = new Options_WarpModel();
        public WarpModel_Basics_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new[] { "Original Blue plane", "Original Green plane", "Original Red plane", "ECC Aligned image" };
            desc = "Align the BGR inputs raw images from the Prokudin examples.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest()) ecc.warpInput.Run(src);
            dst0 = ecc.warpInput.rgb[0].Clone();
            dst1 = ecc.warpInput.rgb[1].Clone();
            dst2 = ecc.warpInput.rgb[2].Clone();
            Mat[] aligned = { new Mat(), new Mat() };
            for (int i = 0; i <= 1; i++)
            {
                if (options.useGradient)
                {
                    src = ecc.warpInput.gradient[0];
                    ecc.src2 = (i + 1 == 1) ? ecc.warpInput.gradient[1] : ecc.warpInput.gradient[2];
                }
                else
                {
                    src = ecc.warpInput.rgb[0];
                    ecc.src2 = (i + 1 == 1) ? ecc.warpInput.rgb[1] : ecc.warpInput.rgb[2];
                }
                ecc.Run(src);
                aligned[i] = ecc.aligned.Clone();
            }
            Mat[] mergeInput = { src, aligned[0], aligned[1] };
            Mat merged = new Mat();
            Cv2.Merge(mergeInput, merged);
            dst3.SetTo(0);
            dst3[new cv.Rect(0, 0, merged.Width, merged.Height)] = merged;
            SetTrueText("Note small displacement of" + "\n" + "the image when gradient is used." + "\n" +
                            "Other than that, images look the same." + "\n" +
                            "Displacement increases with Sobel" + "\n" + "kernel size", new cv.Point(merged.Width + 10, 40), 3);
        }
    }




    public class WarpModel_ECC_CPP_CS : VB_Parent
    {
        public WarpModel_Input warpInput = new WarpModel_Input();
        public float[] warpMatrix;
        public Mat src2 = new Mat();
        public Mat aligned = new Mat();
        public cv.Rect outputRect;
        readonly Options_WarpModel options = new Options_WarpModel();
        public WarpModel_ECC_CPP_CS()
        {
            cPtr = WarpModel_Open();
            labels[2] = "Src image (align to this image)";
            labels[3] = "Src2 image aligned to src image";
            desc = "Use FindTransformECC to align 2 images";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            if (standaloneTest())
            {
                warpInput.Run(src);
                if (options.useGradient)
                {
                    src = warpInput.gradient[0];
                    src2 = warpInput.gradient[1];
                }
                else
                {
                    src = warpInput.rgb[0];
                    src2 = warpInput.rgb[1];
                }
            }
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            byte[] src2Data = new byte[src2.Total() * src2.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            Marshal.Copy(src2.Data, src2Data, 0, src2Data.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            GCHandle handleSrc2 = GCHandle.Alloc(src2Data, GCHandleType.Pinned);
            IntPtr imagePtr = WarpModel_Run(cPtr, handleSrc.AddrOfPinnedObject(), handleSrc2.AddrOfPinnedObject(), src.Rows, src.Cols, 1, options.warpMode);
            handleSrc.Free();
            handleSrc2.Free();
            if (options.warpMode != 3)
            {
                warpMatrix = new float[2 * 3];
            }
            else
            {
                warpMatrix = new float[3 * 3];
            }
            Marshal.Copy(imagePtr, warpMatrix, 0, warpMatrix.Length);
            if (options.warpMode != 3)
            {
                Mat warpMat = cv.Mat.FromPixelData(2, 3, MatType.CV_32F, warpMatrix);
                Cv2.WarpAffine(src2, aligned, warpMat, src.Size(), InterpolationFlags.Linear | InterpolationFlags.WarpInverseMap);
            }
            else
            {
                Mat warpMat = cv.Mat.FromPixelData(3, 3, MatType.CV_32F, warpMatrix);
                Cv2.WarpPerspective(src2, aligned, warpMat, src.Size(), InterpolationFlags.Linear | InterpolationFlags.WarpInverseMap);
            }
            dst2 = new Mat(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height), MatType.CV_8U, cv.Scalar.All(0));
            dst3 = new Mat(new cv.Size(vbc.task.dst2.Width, vbc.task.dst2.Height), MatType.CV_8U, cv.Scalar.All(0));
            outputRect = new cv.Rect(0, 0, src.Width, src.Height);
            dst2[outputRect] = src;
            dst3[outputRect] = src2;
            string outStr = "The warp matrix is:" + "\n";
            for (int i = 0; i < warpMatrix.Length; i++)
            {
                if (i % 3 == 0) outStr += "\n";
                outStr += string.Format("{0:#0.000}", warpMatrix[i]) + "\t";
            }
            if (options.useWarpAffine || options.useWarpHomography)
            {
                outStr += "\nNOTE: Gradients may give better results.";
            }
            SetTrueText(outStr, new cv.Point(aligned.Width + 10, 220));
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = WarpModel_Close(cPtr);
        }
    }




    public class WarpModel_Input_CS : VB_Parent
    {
        public Mat[] rgb = new Mat[3];
        public Mat[] gradient = new Mat[3];
        Edge_Sobel sobel = new Edge_Sobel();
        Options_WarpModel options = new Options_WarpModel();
        public WarpModel_Input_CS()
        {
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            if (standaloneTest()) vbc.task.gOptions.setDisplay1();
            labels = new[] { "Original Blue plane", "Original Green plane", "Original Red plane", "Naively Aligned image" };
            desc = "Import the misaligned input.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            cv.Rect[] r = {
        new cv.Rect(0, 0, options.pkImage.Width, options.pkImage.Height / 3),
        new cv.Rect(0, options.pkImage.Height / 3, options.pkImage.Width, options.pkImage.Height / 3),
        new cv.Rect(0, 2 * options.pkImage.Height / 3, options.pkImage.Width, options.pkImage.Height / 3)
    };
            for (int i = 0; i < r.Length; i++)
            {
                if (options.useGradient)
                {
                    sobel.Run(options.pkImage[r[i]]);
                    gradient[i] = sobel.dst2.Clone();
                }
                rgb[i] = options.pkImage[r[i]];
            }
            if (src.Width < rgb[0].Width || src.Height < rgb[0].Height)
            {
                for (int i = 0; i < rgb.Length; i++)
                {
                    cv.Size sz = new cv.Size(src.Width * rgb[i].Height / rgb[i].Width, src.Height);
                    r[i] = new cv.Rect(0, 0, sz.Width, sz.Height);
                    rgb[i] = rgb[i].Resize(sz);
                }
            }
            dst0 = rgb[0];
            dst1 = rgb[1];
            dst2 = rgb[2];
            Mat merged = new Mat();
            Cv2.Merge(rgb, merged);
            dst3.SetTo(0);
            dst3[r[0]] = merged;
        }
    }




    public class WarpPerspective_Basics_CS : VB_Parent
    {
        public Options_Warp options = new Options_Warp();
        public WarpPerspective_Basics_CS()
        {
            desc = "Essentials of the rotation matrix of WarpPerspective";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src.EmptyClone();
            Cv2.WarpPerspective(src, dst2, options.transformMatrix, dst2.Size(), InterpolationFlags.Cubic | InterpolationFlags.WarpInverseMap);
            SetTrueText("Use sliders to understand impact of WarpPerspective", 3);
        }
    }




    public class WarpPerspective_WidthHeight_CS : VB_Parent
    {
        Options_WarpPerspective options = new Options_WarpPerspective();
        public WarpPerspective_WidthHeight_CS()
        {
            desc = "Use WarpPerspective to transform input images.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            Point2f[] srcPt = { new Point2f(0, 0), new Point2f(0, src.Height), new Point2f(src.Width, 0), new Point2f(src.Width, src.Height) };
            Point2f[] pts = { new Point2f(0, 0), new Point2f(0, src.Height), new Point2f(src.Width, 0),
                        new Point2f(options.width, options.height) };
            Mat perpectiveTranx = Cv2.GetPerspectiveTransform(srcPt, pts);
            Cv2.WarpPerspective(src, dst2, perpectiveTranx, new cv.Size(src.Cols, src.Rows), InterpolationFlags.Cubic, BorderTypes.Constant, Scalar.White);
            Point2f center = new Point2f(src.Cols / 2, src.Rows / 2);
            Mat rotationMatrix = Cv2.GetRotationMatrix2D(center, options.angle, 1.0);
            Cv2.WarpAffine(dst2, dst3, rotationMatrix, src.Size(), InterpolationFlags.Nearest);
        }
    }




    public class Watershed_Basics_CS : VB_Parent
    {
        AddWeighted_Basics addW = new AddWeighted_Basics();
        List<cv.Rect> rects = new List<cv.Rect>();
        public bool UseCorners { get; set; }
        public Watershed_Basics_CS()
        {
            labels[2] = "Draw rectangle to add another marker";
            labels[3] = "Mask for watershed (selected regions).";
            desc = "Watershed API experiment.  Draw on the image to test.";
        }
        public void RunAlg(Mat src)
        {
            if (vbc.task.drawRect.Width > 0 && vbc.task.drawRect.Height > 0)
                rects.Add(vbc.task.drawRect);
            if ((standaloneTest() || UseCorners) && vbc.task.optionsChanged)
            {
                for (int i = 0; i < 4; i++)
                {
                    cv.Rect r = new cv.Rect(0, 0, src.Width / 10, src.Height / 10);
                    switch (i)
                    {
                        case 1:
                            r.X = src.Width - src.Width / 10;
                            break;
                        case 2:
                            r.X = src.Width - src.Width / 10;
                            r.Y = src.Height - src.Height / 10;
                            break;
                        case 3:
                            r.Y = src.Height - src.Height / 10;
                            break;
                    }
                    rects.Add(r);
                }
            }
            if (rects.Count() > 0)
            {
                Mat markers = new Mat(src.Size(), MatType.CV_32S, cv.Scalar.All(0));
                for (int i = 0; i < rects.Count(); i++)
                {
                    markers.Rectangle(rects[i], Scalar.All(i + 1), -1);
                }
                Cv2.Watershed(src, markers);
                markers *= (int)(255 / rects.Count());
                Mat tmp = new Mat();
                markers.ConvertTo(tmp, MatType.CV_8U);
                dst3 = ShowPalette(tmp);
                addW.src2 = vbc.task.palette.dst2;
                addW.Run(src);
                dst2 = addW.dst2;
            }
            else
            {
                dst2 = src;
            }
            vbc.task.drawRect = new cv.Rect();
            labels[2] = "There were " + rects.Count().ToString() + " regions defined as input";
        }
    }




    public class Watershed_DepthReduction_CS : VB_Parent
    {
        Watershed_Basics watershed = new Watershed_Basics();
        Reduction_Basics reduction = new Reduction_Basics();
        public Watershed_DepthReduction_CS()
        {
            watershed.UseCorners = true;
            labels[3] = "Reduction input to WaterShed";
            desc = "Watershed the depth image using shadow, close, and far points.";
        }
        public void RunAlg(Mat src)
        {
            reduction.Run(vbc.task.depthRGB);
            dst3 = reduction.dst3;
            watershed.Run(dst3);
            dst2 = watershed.dst2;
            labels[2] = watershed.labels[2];
            SetTrueText("Draw anywhere in dst2 to add regions.", 3);
        }
    }




    public class Watershed_DepthAuto_CS : VB_Parent
    {
        Watershed_Basics watershed = new Watershed_Basics();
        public Watershed_DepthAuto_CS()
        {
            watershed.UseCorners = true;
            desc = "Watershed the four corners of the depth image.";
        }
        public void RunAlg(Mat src)
        {
            watershed.Run(vbc.task.depthRGB);
            dst2 = watershed.dst2;
            labels[2] = watershed.labels[2];
        }
    }




    public class XFeatures2D_StarDetector_CS : VB_Parent
    {
        public XFeatures2D_StarDetector_CS()
        {
            desc = "Basics of the StarDetector - a 2D feature detector.  FAILS IN COMPUTE.  Uncomment to investigate further.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src.Clone();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var detector = StarDetector.Create();
            KeyPoint[] keypoints = detector.Detect(src);
            if (keypoints != null)
            {
                foreach (KeyPoint kpt in keypoints)
                {
                    float r = kpt.Size / 2;
                    DrawCircle(dst2, kpt.Pt, (int)Math.Truncate(r), new Scalar(0, 255, 0));
                    dst2.Line(new cv.Point(kpt.Pt.X + r, kpt.Pt.Y + r), new cv.Point(kpt.Pt.X - r, kpt.Pt.Y - r), new Scalar(0, 255, 0), vbc.task.lineWidth, LineTypes.Link8, 0);
                    dst2.Line(new cv.Point(kpt.Pt.X - r, kpt.Pt.Y + r), new cv.Point(kpt.Pt.X + r, kpt.Pt.Y - r), new Scalar(0, 255, 0), vbc.task.lineWidth, LineTypes.Link8, 0);
                }
            }
        }
    }




    public class XPhoto_Bm3dDenoise_CS : VB_Parent
    {
        public XPhoto_Bm3dDenoise_CS()
        {
            desc = "Denoise image with block matching and filtering.";
            labels[2] = "Bm3dDenoising";
            labels[3] = "Difference from Input";
        }
        public void RunAlg(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Cv2.EqualizeHist(src, src);
            CvXPhoto.Bm3dDenoising(src, dst2);
            Cv2.Subtract(dst2, src, dst3);
            mmData mm = GetMinMax(dst3);
            labels[3] = "Diff from input - max change=" + mm.maxVal.ToString();
            dst3 = dst3.Normalize(0, 255, NormTypes.MinMax);
        }
    }




    public class XPhoto_Bm3dDenoiseDepthImage_CS : VB_Parent
    {
        public XPhoto_Bm3dDenoiseDepthImage_CS()
        {
            desc = "Denoise the depth image with block matching and filtering.";
            labels[3] = "Difference from Input";
        }
        public void RunAlg(Mat src)
        {
            Mat test = new Mat(src.Size(), MatType.CV_8U);
            Mat gray = vbc.task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            Cv2.EqualizeHist(gray, gray);
            CvXPhoto.Bm3dDenoising(gray, dst2);
            Cv2.Subtract(dst2, gray, dst3);
            mmData mm = GetMinMax(dst3);
            labels[3] = "Diff from input - max change=" + mm.maxVal.ToString();
            dst3 = dst3.Normalize(0, 255, NormTypes.MinMax);
        }
    }




    public class XPhoto_OilPaint_CPP_CS : VB_Parent
    {
        readonly Options_XPhoto options = new Options_XPhoto();
        public XPhoto_OilPaint_CPP_CS()
        {
            cPtr = xPhoto_OilPaint_Open();
            desc = "Use the xPhoto Oil Painting transform";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = xPhoto_OilPaint_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols,
                                                    options.blockSize, options.dynamicRatio, options.colorCode);
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero) dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = xPhoto_OilPaint_Close(cPtr);
        }
    }




    public class XPhoto_Inpaint_CS : VB_Parent
    {
        public InPaint_Basics basics = new InPaint_Basics();
        public Options_XPhotoInpaint options = new Options_XPhotoInpaint();
        public XPhoto_Inpaint_CS()
        {
            labels[2] = "RGB input to xPhoto Inpaint";
            labels[3] = "Repaired result...";
            desc = "Use the xPhoto inpaint to fill in the depth holes";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            dst2 = src;
            Mat mask = basics.drawRandomLine(dst2);
            //InpaintTypes iType = InpaintTypes.FSR_BEST;
            //if (radioFast.Checked) iType = InpaintTypes.FSR_FAST;
            //if (radioSMap.Checked) iType = InpaintTypes.SHIFTMAP;
            //CvXPhoto.Inpaint(dst2, mask, dst3, InpaintTypes.FSR_BEST);
            SetTrueText("This C# interface for xPhoto Inpaint does not work...  Uncomment the lines above this msg to test.", 3);
        }
    }




    public class XPhoto_Inpaint_CPP_CS : VB_Parent
    {
        readonly XPhoto_Inpaint inpVB = new XPhoto_Inpaint();
        public XPhoto_Inpaint_CPP_CS()
        {
            cPtr = xPhoto_Inpaint_Open();
            labels = new string[] { "", "Mask for inpainted repair", "output with inpainted data repaired", "Input to the inpaint C++ algorithm - not working!!!" };
            desc = "Use the xPhoto Oil Painting transform";
        }
        public void RunAlg(Mat src)
        {
            inpVB.options.RunOpt();
            InpaintTypes iType = InpaintTypes.FSR_BEST;
            if (inpVB.options.FSRFast) iType = InpaintTypes.FSR_FAST;
            if (inpVB.options.shiftMap) iType = InpaintTypes.SHIFTMAP;
            dst1 = inpVB.basics.drawRandomLine(src);
            dst3 = src.Clone();
            dst3.SetTo(0, dst1);
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            byte[] maskData = new byte[dst1.Total() * dst1.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            Marshal.Copy(dst1.Data, maskData, 0, maskData.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            GCHandle handleMask = GCHandle.Alloc(maskData, GCHandleType.Pinned);
            IntPtr imagePtr = xPhoto_Inpaint_Run(cPtr, handleSrc.AddrOfPinnedObject(), handleMask.AddrOfPinnedObject(), src.Rows, src.Cols, (int)iType);
            handleSrc.Free();
            handleMask.Free();
            dst2 = cv.Mat.FromPixelData(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
            SetTrueText("The xPhoto Inpaint call hangs." + "\n" + "Uncomment the C++ line - see XPhoto.cpp - to test", 1);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = xPhoto_Inpaint_Close(cPtr);
        }
    }



    public class Horizon_Perpendicular_CS : VB_Parent
    {
        Line_Perpendicular perp = new Line_Perpendicular();
        public Horizon_Perpendicular_CS()
        {
            labels[2] = "Yellow line is the perpendicular to the horizon.  White is gravity vector from the IMU.";
            desc = "Find the gravity vector using the perpendicular to the horizon.";
        }
        public void RunAlg(Mat src)
        {
            dst2 = src;
            DrawLine(dst2, vbc.task.horizonVec.p1, vbc.task.horizonVec.p2, Scalar.White);
            perp.p1 = vbc.task.horizonVec.p1;
            perp.p2 = vbc.task.horizonVec.p2;
            perp.Run(src);
            DrawLine(dst2, perp.r1, perp.r2, Scalar.Yellow);
            var gVec = vbc.task.gravityVec;
            gVec.p1.X += 10;
            gVec.p2.X += 10;
            DrawLine(dst2, gVec.p1, gVec.p2, Scalar.White);
        }
    }


    public class Feature_Agast_CS : VB_Parent
    {
        private List<Point2f> stablePoints;
        private AgastFeatureDetector agastFD;
        private List<Point2f> lastPoints;
        public Feature_Agast_CS()
        {
            agastFD = AgastFeatureDetector.Create(10, true, AgastFeatureDetector.DetectorType.OAST_9_16);
            desc = "Use the Agast Feature Detector in the OpenCV Contrib.";
            stablePoints = new List<Point2f>();
            lastPoints = new List<Point2f>();
        }
        public void RunAlg(Mat src)
        {
            int resizeFactor = 1;
            Mat input = new cv.Mat();
            if (src.Cols >= 1280)
            {
                Cv2.Resize(src, input, new cv.Size(src.Cols / 4, src.Rows / 4));
                resizeFactor = 4;
            }
            else
            {
                input = src;
            }
            KeyPoint[] keypoints = agastFD.Detect(input);

            if (vbc.task.heartBeat || lastPoints.Count < 10)
            {
                lastPoints.Clear();
                foreach (KeyPoint kpt in keypoints)
                {
                    lastPoints.Add(new Point2f((float)Math.Round(kpt.Pt.X) * resizeFactor, (float)Math.Round(kpt.Pt.Y) * resizeFactor));
                }
            }
            stablePoints.Clear();
            dst2 = src.Clone();
            foreach (KeyPoint pt in keypoints)
            {
                Point2f p1 = new Point2f((float)Math.Round(pt.Pt.X * resizeFactor), (float)Math.Round(pt.Pt.Y * resizeFactor));
                if (lastPoints.Contains(p1))
                {
                    stablePoints.Add(p1);
                    DrawCircle(dst2, p1, vbc.task.DotSize, new Scalar(0, 0, 255), -1);
                }
            }
            lastPoints = new List<Point2f>(stablePoints);
            if (vbc.task.midHeartBeat)
            {
                labels[2] = $"{keypoints.Count()} features found and {stablePoints.Count} of them were stable";
            }
            labels[2] = $"Found {keypoints.Count()} features";
        }
    }







    public class Edge_Basics_CS : VB_Parent
    {
        Edge_Canny canny;
        Edge_Scharr scharr;
        Edge_BinarizedReduction binRed;
        Bin4Way_Sobel binSobel;
        Edge_ColorGap_CPP_VB colorGap;
        Edge_Deriche_CPP_VB deriche;
        Edge_Laplacian Laplacian;
        Edge_ResizeAdd resizeAdd;
        Edge_Regions regions;
        public Options_Edge_Basics options = new Options_Edge_Basics();
        public Edge_Basics_CS()
        {
            desc = "Use Radio Buttons to select the different edge algorithms.";
        }
        public void RunAlg(Mat src)
        {
            options.RunOpt();
            switch (options.edgeSelection)
            {
                case "Canny":
                    if (canny == null) canny = new Edge_Canny();
                    canny.Run(src);
                    dst2 = canny.dst2;
                    break;
                case "Scharr":
                    if (scharr == null) scharr = new Edge_Scharr();
                    scharr.Run(src);
                    dst2 = scharr.dst3;
                    break;
                case "Binarized Reduction":
                    if (binRed == null) binRed = new Edge_BinarizedReduction();
                    binRed.Run(src);
                    dst2 = binRed.dst2;
                    break;
                case "Binarized Sobel":
                    if (binSobel == null) binSobel = new Bin4Way_Sobel();
                    binSobel.Run(src);
                    dst2 = binSobel.dst2;
                    break;
                case "Color Gap":
                    if (colorGap == null) colorGap = new Edge_ColorGap_CPP_VB();
                    colorGap.Run(src);
                    dst2 = colorGap.dst2;
                    break;
                case "Deriche":
                    if (deriche == null) deriche = new Edge_Deriche_CPP_VB();
                    deriche.Run(src);
                    dst2 = deriche.dst2;
                    break;
                case "Laplacian":
                    if (Laplacian == null) Laplacian = new Edge_Laplacian();
                    Laplacian.Run(src);
                    dst2 = Laplacian.dst2;
                    break;
                case "Resize And Add":
                    if (resizeAdd == null) resizeAdd = new Edge_ResizeAdd();
                    resizeAdd.Run(src);
                    dst2 = resizeAdd.dst2;
                    break;
                case "Depth Region Boundaries":
                    if (regions == null) regions = new Edge_Regions();
                    regions.Run(src);
                    dst2 = regions.dst2;
                    break;
            }
            if (dst2.Channels() != 1) dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            labels[2] = traceName + " - selection = " + options.edgeSelection;
        }
    }


}



