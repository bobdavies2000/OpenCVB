using cv = OpenCvSharp;
using System;
using System.Windows.Forms;
using VB_Classes;
using OpenCvSharp;
using OpenCvSharp.Extensions;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using static CS_Classes.CS_Externs;
using OpenCvSharp.XImgProc;
using System.IO;
using System.Security.Cryptography;
using System.Numerics;
using System.Windows.Controls;
using System.Diagnostics;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using NAudio.Gui;
using OpenCvSharp.Internal.Vectors;
using CS_Classes;
using OpenCvSharp.ML;

namespace CS_Classes
{
    public class CompareAllowIdenticalDoubleInverted : IComparer<double>
    {
        public int Compare(double a, double b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a <= b) return 1;
            return -1;
        }
    }

    public class CompareAllowIdenticalDouble : IComparer<double>
    {
        public int Compare(double a, double b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a >= b) return 1;
            return -1;
        }
    }

    public class CompareAllowIdenticalSingleInverted : IComparer<float>
    {
        public int Compare(float a, float b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a <= b) return 1;
            return -1;
        }
    }

    public class CompareAllowIdenticalSingle : IComparer<float>
    {
        public int Compare(float a, float b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a >= b) return 1;
            return -1;
        }
    }

    public class CompareAllowIdenticalIntegerInverted : IComparer<int>
    {
        public int Compare(int a, int b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a <= b) return 1;
            return -1;
        }
    }

    public class CompareByte : IComparer<byte>
    {
        public int Compare(byte a, byte b)
        {
            if (a <= b) return -1;
            return 1;
        }
    }

    public class CompareAllowIdenticalInteger : IComparer<int>
    {
        public int Compare(int a, int b)
        {
            // why have compare for just unequal?  So we can get duplicates.  Nothing below returns a zero (equal)
            if (a >= b) return 1;
            return -1;
        }
    }

    public class CompareMaskSize : IComparer<int>
    {
        public int Compare(int a, int b)
        {
            if (a <= b) return 1;
            return -1;
        }
    }

    public class CS_AddWeighted_Basics : CS_Parent
    {
        public Single weight;
        public Mat src2;
        public Options_AddWeighted options = new Options_AddWeighted();

        public CS_AddWeighted_Basics(VBtask task) : base(task) 
        {
            UpdateAdvice(traceName + ": use the local option slider 'Add Weighted %'");
            desc = "Add 2 images with specified weights.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            weight = options.addWeighted;

            Mat srcPlus = src2;
            // algorithm user normally provides src2! 
            if (standaloneTest() || src2 == null) srcPlus = task.depthRGB;
            if (srcPlus.Type() != src.Type())
            {
                if (src.Type() != MatType.CV_8UC3 || srcPlus.Type() != MatType.CV_8UC3)
                {
                    if (src.Type() == MatType.CV_32FC1) src = GetNormalize32f(src);
                    if (srcPlus.Type() == MatType.CV_32FC1) srcPlus = GetNormalize32f(srcPlus);
                    if (src.Type() != MatType.CV_8UC3) src = src.CvtColor(ColorConversionCodes.GRAY2BGR);
                    if (srcPlus.Type() != MatType.CV_8UC3) srcPlus = srcPlus.CvtColor(ColorConversionCodes.GRAY2BGR);
                }
            }
            Cv2.AddWeighted(src, weight, srcPlus, 1.0 - weight, 0, dst2);
            labels[2] = $"Depth %: {100 - weight * 100} BGR %: {(int)(weight * 100)}";
        }
    }







    public class CS_AddWeighted_Edges : CS_Parent
    {
        Edge_All edges = new Edge_All();
        CS_AddWeighted_Basics addw;

        public CS_AddWeighted_Edges(VBtask task) : base(task)
        {
            addw = new CS_AddWeighted_Basics(task);
            labels = new string[] { "", "", "Edges_BinarizedSobel output", "AddWeighted edges and BGR image" };
            desc = "Add in the edges separating light and dark to the color image";
        }

        public void RunCS(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2;
            labels[2] = edges.labels[2];

            addw.src2 = edges.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.RunAndMeasure(src, addw);
            dst3 = addw.dst2;
        }
    }






    public class CS_AddWeighted_ImageAccumulate : CS_Parent
    {
        Options_AddWeightedAccum options = new Options_AddWeightedAccum();
        public CS_AddWeighted_ImageAccumulate(VBtask task) : base(task)
        {
            desc = "Update a running average of the image";
        }
        public void RunCS(cv.Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                dst2 = task.pcSplit[2] * 1000;
            }
            cv.Cv2.AccumulateWeighted(task.pcSplit[2] * 1000, dst2, options.addWeighted, new cv.Mat());
        }
    }







    public class CS_AddWeighted_InfraRed : CS_Parent
    {
        CS_AddWeighted_Basics addw;
        Mat src2 = new Mat();

        public CS_AddWeighted_InfraRed(VBtask task) : base(task)
        {
            addw = new CS_AddWeighted_Basics(task);
            desc = "Align the depth data with the left or right view. Oak-D is aligned with the right image. Some cameras are not close to aligned.";
        }

        public void RunCS(Mat src)
        {
            if (task.toggleOnOff)
            {
                dst1 = task.leftView;
                labels[2] = "Left view combined with depthRGB";
            }
            else
            {
                dst1 = task.rightView;
                labels[2] = "Right view combined with depthRGB";
            }

            addw.src2 = dst1;
            addw.RunAndMeasure(task.depthRGB, addw);
            dst2 = addw.dst2.Clone();
        }
    }





    public class CS_AlphaChannel_Basics : CS_Parent
    {
        Form alpha = new Form();

        public CS_AlphaChannel_Basics(VBtask task) : base(task)
        {
            alpha.Show();
            alpha.Width = dst2.Width + 10;
            alpha.Height = dst2.Height + 10;
            desc = "Use the Windows alpha channel to separate foreground and background";
        }

        public void RunCS(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2BGRA);
            Mat[] split = Cv2.Split(src);
            split[3] = task.depthMask;
            Cv2.Merge(split, src);
            alpha.BackgroundImage = BitmapConverter.ToBitmap(src, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
        }
    }






// https://stackoverflow.com/questions/22132510/opencv-approxpolydp-for-edge-maps-Not-contours
// https://docs.opencv.org/4.x/js_contour_features_approxPolyDP.html
public class CS_ApproxPoly_Basics : CS_Parent
    {
        Contour_Largest contour = new Contour_Largest();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        Options_ApproxPoly options = new Options_ApproxPoly();

        public CS_ApproxPoly_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Input to the ApproxPolyDP", "Output of ApproxPolyDP" };
            desc = "Using the input contours, create ApproxPoly output";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest())
            {
                if (task.heartBeat)
                    rotatedRect.Run(src);
                dst2 = rotatedRect.dst2;
            }

            contour.Run(dst2);
            dst2 = contour.dst2;

            if (contour.allContours.Count() > 0)
            {
                cv.Point[] nextContour;
                nextContour = Cv2.ApproxPolyDP(contour.bestContour, options.epsilon, options.closedPoly);
                dst3.SetTo(Scalar.Black);
                DrawContour(dst3, new List<cv.Point>(nextContour), Scalar.Yellow);
            }
            else
            {
                labels[2] = "No contours found";
            }
        }
    }







    public class CS_ApproxPoly_FindandDraw : CS_Parent
    {
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        public cv.Point[][] allContours;
        public CS_ApproxPoly_FindandDraw(VBtask task) : base(task)
        {
            labels[2] = "FindandDraw input";
            labels[3] = "FindandDraw output - note the change in line width where ApproxPoly differs from DrawContours";
            desc = "Demo the use of FindContours, ApproxPolyDP, and DrawContours.";
        }

        public void RunCS(Mat src)
        {
            rotatedRect.Run(src);
            dst2 = rotatedRect.dst2;
            dst0 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst0 = dst0.Threshold(1, 255, ThresholdTypes.Binary);

            dst0.ConvertTo(dst1, MatType.CV_32SC1);
            Cv2.FindContours(dst1, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxSimple);
            dst3.SetTo(Scalar.Black);

            List<cv.Point[]> contours = new List<cv.Point[]>();
            for (int i = 0; i < allContours.Length; i++)
            {
                cv.Point[] nextContour = Cv2.ApproxPolyDP(allContours[i], 3, true);
                if (nextContour.Length > 2)
                {
                    contours.Add(nextContour);
                }
            }
            Cv2.DrawContours(dst3, contours, -1, new Scalar(0, 255, 255), task.lineWidth, task.lineType);
        }
    }




    public class CS_ApproxPoly_Hull : CS_Parent
    {
        Hull_Basics hull = new Hull_Basics();
        ApproxPoly_Basics aPoly = new ApproxPoly_Basics();
        public CS_ApproxPoly_Hull(VBtask task) : base(task)
        {
            hull.useRandomPoints = true;
            labels = new string[] { "", "", "Original Hull", "Hull after ApproxPoly" };
            desc = "Use ApproxPolyDP on a hull to show impact of options (which appears to be minimal - what is wrong?)";
        }
        public void RunCS(Mat src)
        {
            hull.Run(src);
            dst2 = hull.dst2;

            aPoly.Run(dst2);
            dst3 = aPoly.dst2;
        }
    }




    public class CS_Area_MinTriangle_CPP : CS_Parent
    {
        public Mat triangle;
        public Options_MinArea options = new Options_MinArea();
        public List<Point2f> srcPoints;

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void MinTriangle_Run(IntPtr inputPtr, int numberOfPoints, IntPtr outputTriangle);

        public CS_Area_MinTriangle_CPP(VBtask task) : base(task)
        {
            desc = "Find minimum containing triangle for a set of points.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.heartBeat)
            {
                srcPoints = new List<Point2f>(options.srcPoints);
            }
            else
            {
                if (srcPoints.Count < 3) return; // not enough points
            }

            float[] dataSrc = new float[srcPoints.Count * Marshal.SizeOf<int>() * 2];
            float[] dstData = new float[3 * Marshal.SizeOf<int>() * 2];

            dst2.SetTo(Scalar.White);

            Mat input = new Mat(srcPoints.Count, 1, MatType.CV_32FC2, srcPoints.ToArray());
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            GCHandle srcHandle = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            GCHandle dstHandle = GCHandle.Alloc(dstData, GCHandleType.Pinned);
            MinTriangle_Run(srcHandle.AddrOfPinnedObject(), srcPoints.Count, dstHandle.AddrOfPinnedObject());
            srcHandle.Free();
            dstHandle.Free();
            triangle = new Mat(3, 1, MatType.CV_32FC2, dstData);

            for (int i = 0; i <= 2; i++)
            {
                cv.Point2f pt = triangle.At<Point2f>(i);
                cv.Point p1 = new cv.Point(pt.X, pt.Y);
                pt = triangle.At<cv.Point2f>((i + 1) % 3);
                cv.Point p2 = new cv.Point(pt.X, pt.Y);
                DrawLine(dst2, p1, p2, Scalar.Black, task.lineWidth);
            }

            foreach (var ptSrc in srcPoints)
            {
                var pt = new cv.Point(ptSrc.X, ptSrc.Y);
                DrawCircle(dst2, pt, task.DotSize + 1, Scalar.Red);
            }
        }
    }





    public class CS_Annealing_Basics_CPP : CS_Parent
    {
        public int numberOfCities = 25;
        public Point2f[] cityPositions;
        public int[] cityOrder;
        public float energy;
        public float energyLast;
        public bool circularPattern = true;

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Annealing_Basics_Open(IntPtr cityPositions, int numberOfCities);

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Annealing_Basics_Close(IntPtr saPtr);

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Annealing_Basics_Run(IntPtr saPtr, IntPtr cityOrder, int numberOfCities);
        public void drawMap()
        {
            dst2.SetTo(Scalar.Black);
            for (int i = 0; i < cityOrder.Length; i++)
            {
                DrawCircle(dst2, cityPositions[i], task.DotSize, Scalar.White);
                DrawLine(dst2, cityPositions[i], cityPositions[cityOrder[i]], Scalar.White, task.lineWidth);
            }
            SetTrueText("Energy" + "\n" + energy.ToString(fmt0), new cv.Point(10, 100), 2);
        }

        public void setup()
        {
            cityOrder = new int[numberOfCities];

            double radius = dst2.Rows * 0.45;
            cv.Point center = new cv.Point(dst2.Cols / 2, dst2.Rows / 2);
            if (circularPattern)
            {
                cityPositions = new cv.Point2f[numberOfCities];
                for (int i = 0; i < cityPositions.Length; i++)
                {
                    double theta = msRNG.Next(0, 360);
                    cityPositions[i].X = (float)(radius * Math.Cos(theta) + center.X);
                    cityPositions[i].Y = (float)(radius * Math.Sin(theta) + center.Y);
                    cityOrder[i] = (i + 1) % numberOfCities;
                }
            }
            for (int i = 0; i < cityOrder.Length; i++)
            {
                cityOrder[i] = (i + 1) % numberOfCities;
            }
            dst2 = new Mat(dst2.Size(), MatType.CV_8UC3, Scalar.Black);
        }

        public void Open()
        {
            GCHandle hCityPosition = GCHandle.Alloc(cityPositions, GCHandleType.Pinned);
            cPtr = Annealing_Basics_Open(hCityPosition.AddrOfPinnedObject(), numberOfCities);
            hCityPosition.Free();
        }

        public CS_Annealing_Basics_CPP(VBtask task) : base(task)
        {
            energy = -1;
            setup();
            Open();
            desc = "Simulated annealing with traveling salesman.  NOTE: No guarantee simulated annealing will find the optimal solution.";
        }

        public void RunCS(Mat src)
        {
            var saveCityOrder = (int[])cityOrder.Clone();
            GCHandle hCityOrder = GCHandle.Alloc(cityOrder, GCHandleType.Pinned);
            IntPtr outPtr = Annealing_Basics_Run(cPtr, hCityOrder.AddrOfPinnedObject(), cityPositions.Length);
            hCityOrder.Free();

            string msg = Marshal.PtrToStringAnsi(outPtr);
            string[] split = Regex.Split(msg, @"\W+");
            energy = float.Parse(split[split.Length - 2] + "." + split[split.Length - 1]);
            if (standaloneTest())
            {
                if (energyLast == energy || task.optionsChanged)
                {
                    Annealing_Basics_Close(cPtr);
                    setup();
                    Open();
                }
                energyLast = energy;
            }

            drawMap();
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Annealing_Basics_Close(cPtr);
        }
    }





    public class CS_Random_Basics : CS_Parent
    {
        public List<cv.Point2f> PointList = new List<cv.Point2f>();
        public Rect range;
        public Options_Random options = new Options_Random();

        public CS_Random_Basics(VBtask task) : base(task)
        {
            range = new Rect(0, 0, dst2.Cols, dst2.Rows);
            desc = "Create a uniform random mask with a specified number of pixels.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            int sizeRequest = options.count;
            if (!task.paused)
            {
                PointList.Clear();
                Random msRNG = new Random();
                while (PointList.Count < sizeRequest)
                {
                    PointList.Add(new cv.Point2f(msRNG.Next(range.X, range.X + range.Width),
                                              msRNG.Next(range.Y, range.Y + range.Height)));
                }
                if (standaloneTest())
                {
                    dst2.SetTo(0);
                    foreach (var pt in PointList)
                    {
                        DrawCircle(dst2, pt, task.DotSize, Scalar.Yellow);
                    }
                }
            }
        }
    }







    public class CS_Annealing_MultiThreaded_CPP : CS_Parent
    {
        Options_Annealing options = new Options_Annealing();
        CS_Random_Basics random;
        CS_Annealing_Basics_CPP[] anneal;
        CS_Mat_4to1 mats;
        DateTime startTime;
        void setup()
        {
            random.options.count = options.cityCount;
            random.RunAndMeasure(empty, random); // get the city positions (may or may not be used below.)

            for (int i = 0; i < anneal.Length; i++)
            {
                anneal[i] = new CS_Annealing_Basics_CPP(task);
                anneal[i].numberOfCities = options.cityCount;
                anneal[i].cityPositions = random.PointList.ToArray();
                anneal[i].circularPattern = options.circularFlag;
                anneal[i].setup();
                anneal[i].Open(); // this will initialize the C++ copy of the city positions.
            }

            TimeSpan timeSpent = DateTime.Now.Subtract(startTime);
            if (timeSpent.TotalSeconds < 10000)
            {
                Console.WriteLine("time spent on last problem = " + timeSpent.TotalSeconds.ToString("0.00") + " seconds.");
            }
            startTime = DateTime.Now;
        }

        public CS_Annealing_MultiThreaded_CPP(VBtask task) : base(task)
        {
            mats = new CS_Mat_4to1(task);
            random = new CS_Random_Basics(task);
            anneal = new CS_Annealing_Basics_CPP[Environment.ProcessorCount / 2];
            labels = new string[] { "", "", "Top 2 are best solutions, bottom 2 are worst.", "Log of Annealing progress" };
            desc = "Setup and control finding the optimal route for a traveling salesman";
        }

        public void RunCS(cv.Mat src)
        {
            options.RunVB();

            if (task.optionsChanged) setup();

            Parallel.For(0, anneal.Length, i =>
            {
                anneal[i].RunAndMeasure(src, anneal[i]);
            });

            // find the best result and start all the others with it.
            SortedList<float, int> bestList = new SortedList<float, int>(new compareAllowIdenticalSingle());
            strOut = "";
            for (int i = 0; i < anneal.Length; i++)
            {
                bestList.Add(anneal[i].energy, i);
                if (i % 2 == 0)
                {
                    strOut += "CPU=" + i.ToString("00") + " energy=" + anneal[i].energy.ToString("0") + "\t";
                }
                else
                {
                    strOut += "CPU=" + i.ToString("00") + " energy=" + anneal[i].energy.ToString("0") + "\n";
                }
            }
            SetTrueText(strOut, new cv.Point(10, 10), 3);

            mats.mat[0] = anneal[bestList.ElementAt(0).Value].dst2;
            if (bestList.Count >= 2)
            {
                mats.mat[1] = anneal[bestList.ElementAt(1).Value].dst2;
                mats.mat[2] = anneal[bestList.ElementAt(bestList.Count - 2).Value].dst2;
                mats.mat[3] = anneal[bestList.ElementAt(bestList.Count - 1).Value].dst2;
            }
            mats.RunAndMeasure(empty, mats);
            dst2 = mats.dst2;

            // copy the top half of the solutions to the bottom half (worst solutions)
            if (options.copyBestFlag)
            {
                for (int i = 0; i < anneal.Length / 2; i++)
                {
                    anneal[bestList.ElementAt(bestList.Count - 1 - i).Value].cityOrder = anneal[bestList.ElementAt(i).Value].cityOrder;
                }
            }

            // if the top X are all the same energy, then we are done.
            int workingCount = 0, successCounter = 0;
            for (int i = 0; i < anneal.Length; i++)
            {
                int index = bestList.ElementAt(i).Value;
                if (anneal[index].energy != anneal[index].energyLast)
                {
                    anneal[index].energyLast = anneal[index].energy;
                    workingCount++;
                }
                else
                {
                    successCounter++;
                }
            }
            labels[3] = $"There are {workingCount} threads working in parallel.";
            if (successCounter >= options.successCount) setup();
        }
    }




    public class CS_Area_MinMotionRect : CS_Parent
    {
        BGSubtract_Basics bgSub = new BGSubtract_Basics();

        public CS_Area_MinMotionRect(VBtask task) : base(task)
        {
            desc = "Use minRectArea to encompass detected motion";
            labels[2] = "MinRectArea of MOG motion";
        }

        Mat motionRectangles(Mat gray, Vec3b[] colors)
        {
            cv.Point[][] contours;
            contours = Cv2.FindContoursAsArray(gray, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);

            for (int i = 0; i < contours.Length; i++)
            {
                RotatedRect minRect = Cv2.MinAreaRect(contours[i]);
                Scalar nextColor = new Scalar(colors[i % 256].Item0, colors[i % 256].Item1, colors[i % 256].Item2);
                DrawRotatedRectangle(minRect, gray, nextColor);
            }
            return gray;
        }

        public void RunCS(Mat src)
        {
            bgSub.Run(src);
            Mat gray;
            if (bgSub.dst2.Channels() == 1)
                gray = bgSub.dst2;
            else
                gray = bgSub.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            dst2 = motionRectangles(gray, task.vecColors);
            dst2.SetTo(Scalar.All(255), gray);
        }
    }





    public class CS_Area_FindNonZero : CS_Parent
    {
        public Mat nonZero;
        public CS_Area_FindNonZero(VBtask task) : base(task)
        {
            labels[2] = "Coordinates of non-zero points";
            labels[3] = "Non-zero original points";
            desc = "Use FindNonZero API to get coordinates of non-zero points.";
        }

        public void RunCS(Mat src)
        {
            if (standalone)
            {
                src = new Mat(src.Size(), MatType.CV_8U, Scalar.All(0));
                cv.Point[] srcPoints = new cv.Point[100]; // doesn't really matter how many there are.
                Random msRNG = new Random();
                for (int i = 0; i < srcPoints.Length; i++)
                {
                    srcPoints[i].X = msRNG.Next(0, src.Width);
                    srcPoints[i].Y = msRNG.Next(0, src.Height);
                    src.Set<byte>(srcPoints[i].Y, srcPoints[i].X, 255);
                }
            }
            if (src.Channels() != 1) src = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            nonZero = src.FindNonZero();

            dst3 = new Mat(src.Size(), MatType.CV_8U, Scalar.All(0));
            // mark the points so they are visible...
            for (int i = 0; i < nonZero.Rows; i++)
            {
                cv.Point pt = nonZero.At<cv.Point>(i);
                Cv2.Circle(dst3, pt, task.DotSize, Scalar.White);
            }

            string outstr = "Coordinates of the non-zero points (ordered by row - top to bottom): \n\n";
            for (int i = 0; i < nonZero.Rows; i++)
            {
                cv.Point pt = nonZero.At<cv.Point>(i);
                outstr += "X = \t" + pt.X + "\t y = \t" + pt.Y + "\n";
                if (i > 100) break; // for when there are way too many points found...
            }
            SetTrueText(outstr);
        }
    }





    public class CS_Area_SoloPoints : CS_Parent
    {
        BackProject_SoloTop hotTop = new BackProject_SoloTop();
        BackProject_SoloSide hotSide = new BackProject_SoloSide();
        Area_FindNonZero nZero = new Area_FindNonZero();
        public List<cv.Point> soloPoints = new List<cv.Point>();

        public CS_Area_SoloPoints(VBtask task) : base(task)
        {
            desc = "Find the solo points in the pointcloud histograms for top and side views.";
        }

        public void RunCS(Mat src)
        {
            hotTop.Run(src);
            dst2 = hotTop.dst3;

            hotSide.Run(src);
            dst2 = dst2 | hotSide.dst3;

            nZero.Run(dst2);
            soloPoints.Clear();
            for (int i = 0; i < nZero.nonZero.Rows; i++)
            {
                soloPoints.Add(nZero.nonZero.At<cv.Point>(i, 0));
            }

            if (task.heartBeat)
            {
                labels[2] = $"There were {soloPoints.Count} points found";
            }
        }
    }




    public class CS_Area_MinRect : CS_Parent
    {
        public RotatedRect minRect;
        Options_MinArea options = new Options_MinArea();
        public List<Point2f> inputPoints = new List<Point2f>();

        public CS_Area_MinRect(VBtask task) : base(task)
        {
            desc = "Find minimum containing rectangle for a set of points.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (!task.heartBeat) return;
                options.RunVB();
                inputPoints = QuickRandomPoints(options.numPoints);
            }

            minRect = Cv2.MinAreaRect(inputPoints.ToArray());

            if (standaloneTest())
            {
                dst2.SetTo(Scalar.Black);
                foreach (var pt in inputPoints)
                {
                    DrawCircle(dst2, pt, task.DotSize + 2, Scalar.Red);
                }
                DrawRotatedOutline(minRect, dst2, Scalar.Yellow);
            }
        }
    }




    public class CS_AsciiArt_Basics : CS_Parent
    {
        string[] asciiChars = { "@", "%", "#", "*", "+", "=", "-", ":", ",", ".", " " };
        Options_AsciiArt options = new Options_AsciiArt();

        public CS_AsciiArt_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": use the local options for height and width.");
            labels = new string[] { "", "", "Ascii version", "Grayscale input to ascii art" };
            desc = "Build an ascii art representation of the input stream.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst3 = src.CvtColor(ColorConversionCodes.BGR2GRAY).Resize(options.size, 0, 0, InterpolationFlags.Nearest); 
            for (int y = 0; y < dst3.Height; y++)
            {
                for (int x = 0; x < dst3.Width; x++)
                {
                    byte grayValue = dst3.At<byte>(y, x);
                    string asciiChar = asciiChars[grayValue * (asciiChars.Length - 1) / 255];
                    SetTrueText(asciiChar, new cv.Point(x * options.wStep, y * options.hStep), 2);
                }
            }
            labels[2] = "Ascii version using " + (dst3.Height * dst3.Width).ToString("N0") + " characters";
        }
    }




    public class CS_AsciiArt_Color : CS_Parent
    {
        public CS_AsciiArt_Color(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "A palette'd version of the ascii art data";
        }

        public void RunCS(Mat src)
        {
            int hStep = src.Height / 31 - 1;
            int wStep = src.Width / 55 - 1;
            cv.Size size = new cv.Size(55, 31);
            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY).Resize(size, 0, 0, InterpolationFlags.Nearest);
            double grayRatio = 12.0 / 255;

            for (int y = 0; y < dst1.Height; y++)
            {
                for (int x = 0; x < dst1.Width; x++)
                {
                    Rect r = new Rect(x * wStep, y * hStep, wStep - 1, hStep - 1);
                    int asciiChar = (int)(dst1.At<byte>(y, x) * grayRatio);
                    dst3[r].SetTo(asciiChar);
                }
            }

            dst2 = ShowPalette(dst3 / grayRatio);
        }
    }




    public class CS_AsciiArt_Diff : CS_Parent
    {
        CS_AsciiArt_Color colorAA;
        CS_Diff_Basics diff;

        public CS_AsciiArt_Diff(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Ascii Art colorized", "Difference from previous frame"};
            diff = new CS_Diff_Basics(task);
            colorAA = new CS_AsciiArt_Color(task);
            desc = "Display the instability in image pixels.";
        }

        public void RunCS(Mat src)
        {
            colorAA.RunAndMeasure(src, colorAA);
            dst2 = colorAA.dst2;

            diff.RunAndMeasure(dst2.CvtColor(ColorConversionCodes.BGR2GRAY), diff);
            dst3 = diff.dst2;
        }
    }




    public class CS_BackProject_Basics : CS_Parent
    {
        public Hist_Kalman histK = new Hist_Kalman();
        public Scalar minRange, maxRange;

        public CS_BackProject_Basics(VBtask task) : base(task)
        {
            labels[2] = "Move mouse to backproject a histogram column";
            UpdateAdvice(traceName + ": the global option 'Histogram Bins' controls the histogram.");
            desc = "Mouse over any bin to see the histogram backprojected.";
        }

        public void RunCS(Mat src)
        {
            Mat input = src.Clone();
            if (input.Channels() != 1)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);

            histK.Run(input);
            if (histK.hist.mm.minVal == histK.hist.mm.maxVal)
            {
                SetTrueText("The input image is empty - mm.minVal and mm.maxVal are both zero...");
                return;
            }

            dst2 = histK.dst2;

            long totalPixels = dst2.Total(); // assume we are including zeros.
            if (histK.hist.plot.removeZeroEntry)
                totalPixels = input.CountNonZero();

            double brickWidth = dst2.Width / task.histogramBins;
            double incr = (histK.hist.mm.maxVal - histK.hist.mm.minVal) / task.histogramBins;
            int histIndex = (int)Math.Floor(task.mouseMovePoint.X / brickWidth);

            minRange = new Scalar(histIndex * incr);
            maxRange = new Scalar((histIndex + 1) * incr);
            if (histIndex + 1 == task.histogramBins)
                maxRange = new Scalar(255);

            // For single dimension histograms, backprojection is the same as inRange (and this works for backproject_FeatureLess below)
            dst0 = input.InRange(minRange, maxRange);

            int actualCount = dst0.CountNonZero();
            dst3 = task.color.Clone();
            dst3.SetTo(Scalar.Yellow, dst0);
            float count = histK.hist.histogram.Get<float>(histIndex, 0);
            mmData histMax = GetMinMax(histK.hist.histogram);
            labels[3] = $"Backprojecting {minRange.Val0} to {maxRange.Val0} with {count} of {totalPixels} compared to " +
                        $"mask pixels = {actualCount}.  Histogram max count = {histMax.maxVal}";
            dst2.Rectangle(new Rect((int)(histIndex * brickWidth), 0, (int)brickWidth, dst2.Height), Scalar.Yellow, task.lineWidth);
        }
    }



    public class CS_BackProject_Full : CS_Parent
    {
        public int classCount;

        public CS_BackProject_Full(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "CV_8U format of the backprojection", "dst2 presented with a palette" };
            desc = "Create a color histogram, normalize it, and backproject it with a palette.";
        }

        public void RunCS(Mat src)
        {
            classCount = task.histogramBins;
            if (src.Channels() == 3)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            src.ConvertTo(dst1, MatType.CV_32F);
            Mat histogram = new Mat();
            Rangef[] ranges = new Rangef[] { new Rangef(0, 255) };
            Cv2.CalcHist(new Mat[] { dst1 }, new int[] { 0 }, new Mat(), histogram, 1, new int[] { classCount }, ranges);
            histogram = histogram.Normalize(0, classCount, NormTypes.MinMax);

            Cv2.CalcBackProject(new Mat[] { dst1 }, new int[] { 0 }, histogram, dst2, ranges);

            dst2.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2 * 255 / classCount);
        }
    }




    public class CS_BackProject_Reduction : CS_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        BackProject_Basics backP = new BackProject_Basics();

        public CS_BackProject_Reduction(VBtask task) : base(task)
        {
            task.redOptions.checkSimpleReduction(true);
            labels[3] = "Backprojection of highlighted histogram bin";
            desc = "Use the histogram of a reduced BGR image to isolate featureless portions of an image.";
        }

        public void RunCS(Mat src)
        {
            reduction.Run(src);

            backP.Run(reduction.dst2);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
            int reductionValue = task.redOptions.SimpleReduction;
            labels[2] = "Reduction = " + reductionValue.ToString() + " and bins = " + task.histogramBins.ToString();
        }
    }






    public class CS_BackProject_FeatureLess : CS_Parent
    {
        BackProject_Basics backP = new BackProject_Basics();
        Reduction_Basics reduction = new Reduction_Basics();
        Edge_ColorGap_CPP edges = new Edge_ColorGap_CPP();

        public CS_BackProject_FeatureLess(VBtask task) : base(task)
        {
            task.redOptions.checkBitReduction(true);
            labels = new string[] { "", "", "Histogram of the grayscale image at right",
                                "Move mouse over the histogram to backproject a column" };
            desc = "Create a histogram of the featureless regions";
        }

        public void RunCS(Mat src)
        {
            edges.Run(src);
            reduction.Run(edges.dst3);
            backP.Run(reduction.dst2);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
            int reductionValue = task.redOptions.SimpleReduction;
            labels[2] = "Reduction = " + reductionValue.ToString() + " and bins = " + task.histogramBins.ToString();
        }
    }




    public class CS_BackProject_BasicsKeyboard : CS_Parent
    {
        Keyboard_Basics keys = new Keyboard_Basics();
        BackProject_Image backP = new BackProject_Image();
        public CS_BackProject_BasicsKeyboard(VBtask task) : base(task)
        {
            labels[2] = "Move the mouse away from OpenCVB and use the left and right arrows to move between histogram bins.";
            desc = "Move the mouse off of OpenCVB and then use the left and right arrow keys move around in the backprojection histogram";
        }

        public void RunCS(Mat src)
        {
            keys.Run(src);
            List<string> keyIn = new List<string>(keys.keyInput);
            int incrX = dst1.Width / task.histogramBins;

            if (keyIn.Count > 0)
            {
                task.mouseMovePointUpdated = true;
                for (int i = 0; i < keyIn.Count; i++)
                {
                    switch (keyIn[i])
                    {
                        case "Left":
                            task.mouseMovePoint.X -= incrX;
                            break;
                        case "Right":
                            task.mouseMovePoint.X += incrX;
                            break;
                    }
                }
            }

            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;

            // this is intended to provide a natural behavior for the left and right arrow keys.  The Keyboard_Basics Keyboard Options text box must be active.
            if (task.heartBeat)
            {
                IntPtr hwnd = FindWindow(null, "OpenCVB Algorithm Options");
                SetForegroundWindow(hwnd);
            }
        }

        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll", SetLastError = true)]
        static extern bool SetForegroundWindow(IntPtr hWnd);
    }






    public class CS_BackProject_FullLines : CS_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        Line_Basics lines = new Line_Basics();

        public CS_BackProject_FullLines(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Lines found in the back projection", "Backprojection results" };
            desc = "Find lines in the back projection";
        }

        public void RunCS(Mat src)
        {
            backP.Run(src);
            dst3 = backP.dst3;

            lines.Run(backP.dst2);
            dst2 = lines.dst2;
            labels[3] = lines.lpList.Count.ToString() + " lines were found";
        }
    }





    public class CS_BackProject_PointCloud : CS_Parent
    {
        public Hist_PointCloud hist = new Hist_PointCloud();
        public CS_BackProject_PointCloud(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_32FC3, Scalar.All(0));
            labels = new string[] { "", "", "Backprojection after histogram binning X and Z values", "Backprojection after histogram binning Y and Z values" };
            desc = "Explore Backprojection of the cloud histogram.";
        }

        public void RunCS(Mat src)
        {
            hist.Run(src);

            dst0 = hist.dst2.Threshold(hist.options.threshold, 255, ThresholdTypes.Binary);
            dst1 = hist.dst3.Threshold(hist.options.threshold, 255, ThresholdTypes.Binary);

            dst2 = new Mat(hist.dst2.Size(), MatType.CV_32F, Scalar.All(0));
            dst3 = new Mat(hist.dst3.Size(), MatType.CV_32F, Scalar.All(0));

            Mat mask = new Mat();
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, new int[] { 0, 2 }, dst0, mask, hist.rangesX);
            mask.ConvertTo(mask, MatType.CV_8U);
            task.pointCloud.CopyTo(dst2, mask);

            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, new int[] { 1, 2 }, dst1, mask, hist.rangesY);
            mask.ConvertTo(mask, MatType.CV_8U);
            task.pointCloud.CopyTo(dst3, mask);
        }
    }





    public class CS_BackProject_Display : CS_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        public CS_BackProject_Display(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Back projection", "" };
            desc = "Display the back projected color image";
        }

        public void RunCS(Mat src)
        {
            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
        }
    }


    public class CS_BackProject_Unstable : CS_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        Diff_Basics diff = new Diff_Basics();

        public CS_BackProject_Unstable(VBtask task) : base(task)
        {
            task.gOptions.pixelDiffThreshold = 6;
            labels = new string[] { "", "", "Backprojection output", "Unstable pixels in the backprojection. If flashing, set 'Pixel Difference Threshold' higher." };
            desc = "Highlight the unstable pixels in the backprojection.";
        }

        public void RunCS(Mat src)
        {
            backP.Run(src);
            dst2 = ShowPalette(backP.dst2 * 255 / backP.classCount);

            diff.Run(dst2);
            dst3 = diff.dst2;
        }
    }





    public class CS_BackProject_FullEqualized : CS_Parent
    {
        BackProject_Full backP = new BackProject_Full();
        Hist_EqualizeColor equalize = new Hist_EqualizeColor();

        public CS_BackProject_FullEqualized(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "BackProject_Full output without equalization", "BackProject_Full with equalization" };
            desc = "Create a histogram from the equalized color and then backproject it.";
        }

        public void RunCS(Mat src)
        {
            backP.Run(src);
            backP.dst2.ConvertTo(dst2, MatType.CV_8U);
            var mm = GetMinMax(dst2);
            dst2 = ShowPalette(dst2 * 255 / mm.maxVal);

            equalize.Run(src);
            backP.Run(equalize.dst2);

            backP.dst2.ConvertTo(dst3, MatType.CV_8U);
            mm = GetMinMax(dst3);
            dst3 = ShowPalette(dst3 * 255 / mm.maxVal);
        }
    }




    public class CS_Line_Basics : CS_Parent
    {
        FastLineDetector ld;
        public List<PointPair> lpList = new List<PointPair>();
        public Scalar lineColor = Scalar.White;

        public CS_Line_Basics(VBtask task) : base(task)
        {
            ld = CvXImgProc.CreateFastLineDetector();
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "Use FastLineDetector (OpenCV Contrib) to find all the lines present.";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() == 3)
                dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            else
                dst2 = src.Clone();

            if (dst2.Type() != MatType.CV_8U)
                dst2.ConvertTo(dst2, MatType.CV_8U);

            var lines = ld.Detect(dst2);

            var sortByLen = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
            foreach (var v in lines)
            {
                if (v[0] >= 0 && v[0] <= dst2.Cols && v[1] >= 0 && v[1] <= dst2.Rows &&
                    v[2] >= 0 && v[2] <= dst2.Cols && v[3] >= 0 && v[3] <= dst2.Rows)
                {
                    var p1 = new cv.Point(v[0], v[1]);
                    var p2 = new cv.Point(v[2], v[3]);
                    var lp = new PointPair(p1, p2);
                    sortByLen.Add(lp.length, lp);
                }
            }

            dst2 = src;
            dst3.SetTo(0);
            lpList.Clear();
            foreach (var lp in sortByLen.Values)
            {
                lpList.Add(lp);
                DrawLine(dst2, lp.p1, lp.p2, lineColor, task.lineWidth);
                DrawLine(dst3, lp.p1, lp.p2, 255, task.lineWidth);
            }
            labels[2] = lpList.Count + " lines were detected in the current frame";
        }
    }





    public class CS_BackProject_MaskLines : CS_Parent
    {
        CS_BackProject_Masks masks;
        CS_Line_Basics lines;
        public CS_BackProject_MaskLines(VBtask task) : base(task)
        {
            masks = new CS_BackProject_Masks(task);
            lines = new CS_Line_Basics(task);
            if (standaloneTest()) task.gOptions.setDisplay1();
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            labels = new string[] { "", "lines detected in the backProjection mask", "Histogram of pixels in a grayscale image.  Move mouse to see lines detected in the backprojection mask",
                                "Yellow is backProjection, lines detected are highlighted" };
            desc = "Inspect the lines from individual backprojection masks from a histogram";
        }

        public void RunCS(Mat src)
        {
            masks.RunAndMeasure(src, masks);
            dst2 = masks.dst2;
            dst3 = src.Clone();

            if (task.heartBeat)
                dst1.SetTo(Scalar.All(0));

            lines.RunAndMeasure(masks.mask, lines);
            foreach (var lp in lines.lpList)
            {
                byte val = masks.dst3.At<byte>((int)lp.p1.Y, (int)lp.p1.X);
                if (val == 255)
                    DrawLine(dst1, lp.p1, lp.p2, Scalar.White, task.lineWidth);
            }
            dst3.SetTo(Scalar.Yellow, masks.mask);
            dst3.SetTo(task.HighlightColor, dst1);
        }
    }





    public class CS_BackProject_Masks : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public int histIndex;
        public Mat mask = new Mat();

        public CS_BackProject_Masks(VBtask task) : base(task)
        {
            labels[2] = "Histogram for the gray scale image.  Move mouse to see backprojection of each grayscale mask.";
            desc = "Create all the backprojection masks from a grayscale histogram";
        }

        public Mat maskDetect(Mat gray, int histIndex)
        {
            int brickWidth = dst2.Width / hist.histogram.Rows;
            float brickRange = 255f / hist.histogram.Rows;

            float minRange = (histIndex == hist.histogram.Rows - 1) ? 255 - brickRange : histIndex * brickRange;
            float maxRange = (histIndex == hist.histogram.Rows - 1) ? 255 : (histIndex + 1) * brickRange;

            if (float.IsNaN(minRange) || float.IsInfinity(minRange) || float.IsNaN(maxRange) || float.IsInfinity(maxRange))
            {
                SetTrueText("Input data has no values - exit " + traceName);
                return new Mat();
            }

            Rangef[] ranges = { new Rangef(minRange, maxRange) };

            Cv2.CalcBackProject(new[] { gray }, new[] { 0 }, hist.histogram, mask, ranges);
            return mask;
        }

        public void RunCS(Mat src)
        {
            hist.Run(src);
            dst2 = hist.dst2;

            int brickWidth = dst2.Width / task.histogramBins;
            histIndex = (int)Math.Floor((double)(task.mouseMovePoint.X / brickWidth));

            Mat gray = (src.Channels() == 1) ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = task.color.Clone();
            dst1 = maskDetect(gray, histIndex);
            if (dst1.Width == 0) return;
            dst3.SetTo(Scalar.White, dst1);
            dst2.Rectangle(new Rect(histIndex * brickWidth, 0, brickWidth, dst2.Height), Scalar.Yellow, task.lineWidth);
        }
    }





    public class CS_BackProject_Side : CS_Parent
    {
        OpAuto_YRange autoY = new OpAuto_YRange();
        Projection_HistSide histSide = new Projection_HistSide();

        public CS_BackProject_Side(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Hotspots in the Side View", "Back projection of the hotspots in the Side View" };
            desc = "Display the back projection of the hotspots in the Side View";
        }

        public void RunCS(Mat src)
        {
            histSide.Run(src);
            autoY.Run(histSide.histogram);

            dst2 = autoY.histogram.Threshold(task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            Mat histogram = autoY.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsSide, histogram, dst3, task.rangesSide);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }



    public class CS_BackProject_Top : CS_Parent
    {
        Projection_HistTop histTop = new Projection_HistTop();
        public CS_BackProject_Top(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Hotspots in the Top View", "Back projection of the hotspots in the Top View" };
            desc = "Display the back projection of the hotspots in the Top View";
        }

        public void RunCS(Mat src)
        {
            histTop.Run(src);
            dst2 = histTop.dst2;

            Mat histogram = histTop.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsTop, histogram, dst3, task.rangesTop);
            dst3 = ShowPalette(dst3.ConvertScaleAbs());
        }
    }





    public class CS_BackProject_Horizontal : CS_Parent
    {
        BackProject_Top bpTop = new BackProject_Top();
        BackProject_Side bpSide = new BackProject_Side();

        public CS_BackProject_Horizontal(VBtask task) : base(task)
        {
            desc = "Use both the BackProject_Top to improve the results of the BackProject_Side for finding flat surfaces.";
        }

        public void RunCS(Mat src)
        {
            bpTop.Run(src);
            task.pointCloud.SetTo(0, bpTop.dst3);

            bpSide.Run(src);
            dst2 = bpSide.dst3;
        }
    }





    public class CS_BackProject_Vertical : CS_Parent
    {
        BackProject_Top bpTop = new BackProject_Top();
        BackProject_Side bpSide = new BackProject_Side();

        public CS_BackProject_Vertical(VBtask task) : base(task)
        {
            desc = "Use both the BackProject_Top to improve the results of the BackProject_Side for finding flat surfaces.";
        }

        public void RunCS(cv.Mat src)
        {
            bpSide.Run(src);
            task.pointCloud.SetTo(0, bpSide.dst3);

            bpTop.Run(src);
            dst2 = bpTop.dst3;
        }
    }




    public class CS_BackProject_SoloSide : CS_Parent
    {
        Projection_HistSide histSide = new Projection_HistSide();

        public CS_BackProject_SoloSide(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Solo samples in the Side View", "Back projection of the solo samples in the Side View" };
            desc = "Display the back projection of the solo samples in the Side View";
        }

        public void RunCS(Mat src)
        {
            histSide.Run(src);

            dst3 = histSide.histogram.Threshold(1, 255, ThresholdTypes.TozeroInv);
            dst3.ConvertTo(dst2, MatType.CV_8U, 255);

            histSide.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsSide, histSide.histogram, dst3, task.rangesSide);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }

    public class CS_BackProject_SoloTop : CS_Parent
    {
        Projection_HistTop histTop = new Projection_HistTop();

        public CS_BackProject_SoloTop(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Solo samples in the Top View", "Back projection of the solo samples in the Top View" };
            desc = "Display the back projection of the solo samples in the Top View";
        }

        public void RunCS(Mat src)
        {
            histTop.Run(src);

            dst3 = histTop.histogram.Threshold(1, 255, ThresholdTypes.TozeroInv);
            dst3.ConvertTo(dst2, MatType.CV_8U, 255);

            histTop.histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsTop, histTop.histogram, dst3, task.rangesTop);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }



    public class CS_BackProject_LineTop : CS_Parent
    {
        Line_ViewTop line = new Line_ViewTop();
        public CS_BackProject_LineTop(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Backproject the lines found in the top view.";
        }

        public void RunCS(Mat src)
        {
            line.Run(src);

            dst2.SetTo(0);
            int w = task.lineWidth + 5;
            foreach (var lp in line.lines.lpList)
            {
                var lpNew = lp.edgeToEdgeLine(dst2.Size());
                cv.Point p1 = new cv.Point((int)lpNew.p1.X, (int)lpNew.p1.Y);
                cv.Point p2 = new cv.Point((int)lpNew.p2.X, (int)lpNew.p2.Y);
                dst2.Line(p1, p2, Scalar.White, w, task.lineType);
            }

            var histogram = line.autoX.histogram;
            histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new[] { task.pointCloud }, task.channelsTop, histogram, dst3, task.rangesTop);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }

    public class CS_BackProject_LineSide : CS_Parent
    {
        Line_ViewSide line = new Line_ViewSide();
        public List<PointPair> lpList = new List<PointPair>();

        public CS_BackProject_LineSide(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Backproject the lines found in the side view.";
        }

        public void RunCS(Mat src)
        {
            line.Run(src);

            dst2.SetTo(0);
            int w = task.lineWidth + 5;
            lpList.Clear();
            foreach (var lp in line.lines.lpList)
            {
                if (Math.Abs(lp.slope) < 0.1)
                {
                    var lpNew = lp.edgeToEdgeLine(dst2.Size());
                    cv.Point p1 = new cv.Point((int)lpNew.p1.X, (int)lpNew.p1.Y);
                    cv.Point p2 = new cv.Point((int)lpNew.p2.X, (int)lpNew.p2.Y);
                    dst2.Line(p1, p2, Scalar.White, w, task.lineType);
                    lpList.Add(lp);
                }
            }

            var histogram = line.autoY.histogram;
            histogram.SetTo(0, ~dst2);
            Cv2.CalcBackProject(new[] { task.pointCloud }, task.channelsSide, histogram, dst1, task.rangesSide);
            dst1 = dst1.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst3 = src;
            dst3.SetTo(Scalar.White, dst1);
        }
    }

    public class CS_BackProject_Image : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public Mat mask = new Mat();
        Kalman_Basics kalman = new Kalman_Basics();
        public bool useInrange;

        public CS_BackProject_Image(VBtask task) : base(task)
        {
            labels[2] = "Move mouse to backproject each histogram column";
            desc = "Explore Backprojection of each element of a grayscale histogram.";
        }

        public void RunCS(Mat src)
        {
            Mat input = src;
            if (input.Channels() != 1)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(input);
            if (hist.mm.minVal == hist.mm.maxVal)
            {
                SetTrueText("The input image is empty - mm.minval and mm.maxVal are both zero...");
                return; // the input image is empty...
            }
            dst2 = hist.dst2;

            if (kalman.kInput.Length != 2)
                Array.Resize(ref kalman.kInput, 2);
            kalman.kInput[0] = (float) hist.mm.minVal;
            kalman.kInput[1] = (float) hist.mm.maxVal;
            kalman.Run(empty);
            hist.mm.minVal = Math.Min(kalman.kOutput[0], kalman.kOutput[1]);
            hist.mm.maxVal = Math.Max(kalman.kOutput[0], kalman.kOutput[1]);

            double totalPixels = dst2.Total(); // assume we are including zeros.
            if (hist.plot.removeZeroEntry)
                totalPixels = input.CountNonZero();

            double brickWidth = dst2.Width / task.histogramBins;
            double incr = (hist.mm.maxVal - hist.mm.minVal) / task.histogramBins;
            int histIndex = (int)Math.Round(task.mouseMovePoint.X / brickWidth);

            Scalar minRange = new Scalar(histIndex * incr);
            Scalar maxRange = new Scalar((histIndex + 1) * incr + 1);
            if (histIndex + 1 == task.histogramBins)
            {
                minRange = new Scalar(254);
                maxRange = new Scalar(255);
            }
            if (useInrange)
            {
                if (histIndex == 0 && hist.plot.removeZeroEntry)
                    mask = new Mat(input.Size(), MatType.CV_8U, 0);
                else
                    mask = input.InRange(minRange, maxRange);
            }
            else
            {
                Rangef bRange = new Rangef((float)minRange.Val0, (float)maxRange.Val0);
                Rangef[] ranges = { bRange };
                Cv2.CalcBackProject(new[] { input }, new[] { 0 }, hist.histogram, mask, ranges);
            }
            dst3 = src;
            if (mask.Type() != MatType.CV_8U)
                mask.ConvertTo(mask, MatType.CV_8U);
            dst3.SetTo(Scalar.Yellow, mask);
            int actualCount = mask.CountNonZero();
            float count = hist.histogram.Get<float>(histIndex, 0);
            mmData histMax = GetMinMax(hist.histogram);
            labels[3] = "Backprojecting " + ((int)minRange.Val0).ToString() + " to " + ((int)maxRange.Val0).ToString() + " with " +
                         count.ToString() + " histogram samples and " + actualCount.ToString() + " mask count.  Histogram max count = " +
                         ((int)histMax.maxVal).ToString();
            dst2.Rectangle(new Rect((int)(histIndex * brickWidth), 0, (int)brickWidth, dst2.Height), Scalar.Yellow, task.lineWidth);
        }
    }

    public class CS_BackProject_Mouse : CS_Parent
    {
        CS_BackProject_Image backP;
        public CS_BackProject_Mouse(VBtask task) : base(task)
        {
            backP = new CS_BackProject_Image(task);
            labels[2] = "Use the mouse to select what should be shown in the backprojection of the depth histogram";
            desc = "Use the mouse to select what should be shown in the backprojection of the depth histogram";
        }
        public void RunCS(Mat src)
        {
            backP.RunAndMeasure(src, backP);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
        }
    }

    public class CS_BackProject_Depth : CS_Parent
    {
        CS_BackProject_Image backp;
        public CS_BackProject_Depth(VBtask task) : base(task)
        {
            backp = new CS_BackProject_Image(task);
            desc = "Allow review of the depth backprojection";
        }
        public void RunCS(Mat src)
        {
            var depth = task.pcSplit[2].Threshold(task.MaxZmeters, 255, ThresholdTypes.TozeroInv);
            backp.RunAndMeasure(depth * 1000, backp);
            dst2 = backp.dst2;
            dst3 = src;
            dst3.SetTo(Scalar.White, backp.mask);
        }
    }

    public class CS_BackProject_MeterByMeter : CS_Parent
    {
        Mat histogram = new Mat();
        public CS_BackProject_MeterByMeter(VBtask task) : base(task)
        {
            desc = "Backproject the depth data at 1 meter intervals WITHOUT A HISTOGRAM.";
        }
        public void RunCS(Mat src)
        {
            if (task.histogramBins < task.MaxZmeters) task.gOptions.setHistogramBins( (int)task.MaxZmeters + 1);
            if (task.optionsChanged)
            {
                var incr = task.MaxZmeters / task.histogramBins;
                var histData = new List<float>();
                for (int i = 0; i < task.histogramBins; i++)
                {
                    histData.Add((float)Math.Round(i * incr));
                }

                histogram = new Mat(task.histogramBins, 1, MatType.CV_32F, histData.ToArray());
            }
            var ranges = new[] { new Rangef(0, task.MaxZmeters) };
            Cv2.CalcBackProject(new[] { task.pcSplit[2] }, new[] { 0 }, histogram, dst1, ranges);

            //dst1.SetTo(task.MaxZmeters, task.maxDepthMask);
            dst1.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst1);
        }
    }

    public class CS_BackProject_Hue : CS_Parent
    {
        OEX_CalcBackProject_Demo1 hue = new OEX_CalcBackProject_Demo1();
        public int classCount;
        public CS_BackProject_Hue(VBtask task) : base(task)
        {
            desc = "Create an 8UC1 image with a backprojection of the hue.";
        }
        public void RunCS(Mat src)
        {
            hue.Run(src);
            classCount = hue.classCount;
            dst2 = hue.dst2;
            dst3 = ShowPalette(dst2 * 255 / classCount);
        }
    }






    public class CS_Benford_Basics : CS_Parent
    {
        public float[] expectedDistribution = new float[10];
        public float[] counts;
        Plot_Histogram plot = new Plot_Histogram();
        CS_AddWeighted_Basics addW;
        bool use99;

        public CS_Benford_Basics(VBtask task) : base(task)
        {
            addW = new CS_AddWeighted_Basics(task);
            for (int i = 1; i < expectedDistribution.Length; i++)
            {
                expectedDistribution[i] = (float)Math.Log10(1 + 1.0 / i); // get the precise expected values.
            }

            labels[3] = "Actual distribution of input";
            desc = "Build the capability to perform a Benford analysis.";
        }

        public void setup99()
        {
            expectedDistribution = new float[100];
            for (int i = 1; i < expectedDistribution.Length; i++)
            {
                expectedDistribution[i] = (float)Math.Log10(1 + 1.0 / i);
            }
            counts = new float[expectedDistribution.Length];
            use99 = true;
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                dst2 = src.Channels() == 1 ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
                src = new Mat(dst2.Size(), MatType.CV_32F);
                dst2.ConvertTo(src, MatType.CV_32F);
            }

            src = src.Reshape(1, src.Width * src.Height);
            var indexer = src.GetGenericIndexer<float>();
            counts = new float[expectedDistribution.Length];

            if (!use99)
            {
                for (int i = 0; i < src.Rows; i++)
                {
                    string val = indexer[i].ToString();
                    if (val != "0" && !float.IsNaN(float.Parse(val)))
                    {
                        var firstInt = Regex.Match(val, "[1-9]{1}");
                        if (firstInt.Length > 0) counts[int.Parse(firstInt.Value)] += 1;
                    }
                }
            }
            else
            {
                // this is for the distribution 10-99
                for (int i = 0; i < src.Rows; i++)
                {
                    string val = indexer[i].ToString();
                    if (val != "0" && !float.IsNaN(float.Parse(val)))
                    {
                        var firstInt = Regex.Match(val, "[1-9]{1}").ToString();
                        int index = val.IndexOf(firstInt);
                        if (index < val.Length - 2 && index > 0)
                        {
                            string val99 = val.Substring(index + 1, 2);
                            if (int.TryParse(val99, out int result)) counts[result] += 1;
                        }
                    }
                }
            }

            Mat hist = new Mat(counts.Length, 1, MatType.CV_32F, counts);
            plot.backColor = Scalar.Blue;
            plot.Run(hist);
            dst3 = plot.dst2.Clone();
            for (int i = 0; i < counts.Length; i++)
            {
                counts[i] = src.Rows * expectedDistribution[i];
            }

            hist = new Mat(counts.Length, 1, MatType.CV_32F, counts);
            plot.backColor = Scalar.Gray;
            plot.Run(hist);

            addW.src2 = ~plot.dst2;
            addW.RunAndMeasure(dst3, addW);
            dst2 = addW.dst2;

            float wt = addW.weight;
            labels[2] = "AddWeighted: " + wt.ToString("0.0") + " actual vs. " + (1 - wt).ToString("0.0") + " Benford distribution";
        }
    }






    public class CS_Benford_NormalizedImage : CS_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public CS_Benford_NormalizedImage(VBtask task) : base(task)
        {
            desc = "Perform a Benford analysis of an image normalized to between 0 and 1";
        }
        public void RunCS(Mat src)
        {
            dst3 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            dst3.ConvertTo(gray32f, MatType.CV_32F);

            benford.Run(gray32f.Normalize(1));
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }

    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law
    public class CS_Benford_NormalizedImage99 : CS_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public CS_Benford_NormalizedImage99(VBtask task) : base(task)
        {
            benford.setup99();
            desc = "Perform a Benford analysis for 10-99, not 1-9, of an image normalized to between 0 and 1";
        }
        public void RunCS(Mat src)
        {
            dst3 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            dst3.ConvertTo(gray32f, MatType.CV_32F);

            benford.Run(gray32f.Normalize(1));
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }



    public class CS_Benford_Depth : CS_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public CS_Benford_Depth(VBtask task) : base(task)
        {
            desc = "Apply Benford to the depth data";
        }
        public void RunCS(Mat src)
        {
            benford.Run(task.pcSplit[2]);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
        }
    }



    public class CS_Benford_Primes : CS_Parent
    {
       Sieve_BasicsVB sieve = new Sieve_BasicsVB();
        CS_Benford_Basics benford;
        public CS_Benford_Primes(VBtask task) : base(task)
        {
            benford = new CS_Benford_Basics(task);
            sieve.setMaxPrimes();
            labels = new string[] { "", "", "Actual Distribution of input", "" };
            desc = "Apply Benford to a list of primes";
        }
        public void RunCS(Mat src)
        {
            if (task.optionsChanged)
                sieve.Run(src); // only need to compute this once...
            SetTrueText($"Primes found: {sieve.primes.Count}", 3);

            var tmp = new Mat(sieve.primes.Count, 1, MatType.CV_32S, sieve.primes.ToArray());
            tmp.ConvertTo(tmp, MatType.CV_32F);
            benford.RunAndMeasure(tmp, benford);
            dst2 = benford.dst2;
        }
    }






    public class CS_Bezier_Basics : CS_Parent
    {
        public cv.Point[] points;

        public CS_Bezier_Basics(VBtask task) : base(task)
        {
            points = new cv.Point[]
            {
            new cv.Point(100, 100),
            new cv.Point(150, 50),
            new cv.Point(250, 150),
            new cv.Point(300, 100),
            new cv.Point(350, 150),
            new cv.Point(450, 50)
            };
            UpdateAdvice(traceName + ": Update the public points array variable. No exposed options.");
            desc = "Use n points to draw a Bezier curve.";
        }

        public cv.Point nextPoint(cv.Point[] points, int i, float t)
        {
            double x = Math.Pow(1 - t, 3) * points[i].X +
                       3 * t * Math.Pow(1 - t, 2) * points[i + 1].X +
                       3 * Math.Pow(t, 2) * (1 - t) * points[i + 2].X +
                       Math.Pow(t, 3) * points[i + 3].X;

            double y = Math.Pow(1 - t, 3) * points[i].Y +
                       3 * t * Math.Pow(1 - t, 2) * points[i + 1].Y +
                       3 * Math.Pow(t, 2) * (1 - t) * points[i + 2].Y +
                       Math.Pow(t, 3) * points[i + 3].Y;

            return new cv.Point((int)x, (int)y);
        }

        public void RunCS(Mat src)
        {
            cv.Point p1 = new cv.Point();
            for (int i = 0; i <= points.Length - 4; i += 3)
            {
                for (int j = 0; j <= 100; j++)
                {
                    cv.Point p2 = nextPoint(points, i, j / 100f);
                    if (j > 0) DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
                    p1 = p2;
                }
            }
            labels[2] = "Bezier output";
        }
    }

    public class CS_Bezier_Example : CS_Parent
    {
        CS_Bezier_Basics bezier;
        public cv.Point[] points;

        public CS_Bezier_Example(VBtask task) : base(task)
        {
            bezier = new CS_Bezier_Basics(task);
            points = new cv.Point[] { new cv.Point(task.DotSize, task.DotSize), new cv.Point(dst2.Width / 6, dst2.Width / 6),
                       new cv.Point(dst2.Width * 3 / 4, dst2.Height / 2), new cv.Point(dst2.Width - task.DotSize * 2,
                       dst2.Height - task.DotSize * 2)};
            desc = "Draw a Bezier curve based with the 4 input points.";
        }

        public void RunCS(Mat src)
        {
            dst2.SetTo(Scalar.Black);
            cv.Point p1 = new cv.Point();
            for (int i = 0; i < 100; i++)
            {
                cv.Point p2 = bezier.nextPoint(points, 0, i / 100f);
                if (i > 0) DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
                p1 = p2;
            }

            for (int i = 0; i < points.Length; i++)
            {
                DrawCircle(dst2, points[i], task.DotSize + 2, Scalar.White);
            }

            DrawLine(dst2, points[0], points[1], Scalar.White, task.lineWidth);
            DrawLine(dst2, points[2], points[3], Scalar.White, task.lineWidth);
        }
    }






    public class CS_BGRPattern_Basics : CS_Parent
    {
        Denoise_Pixels denoise = new Denoise_Pixels();
        Color_Basics colorFmt = new Color_Basics();
        public int classCount;

        public CS_BGRPattern_Basics(VBtask task) : base(task)
        {
            cPtr = BGRPattern_Open();
            UpdateAdvice(traceName + ": local options 'Options_ColorFormat' selects color.");
            desc = "Classify each 3-channel input pixel according to their relative values";
        }

        public void RunCS(Mat src)
        {
            colorFmt.Run(src);
            src = colorFmt.dst2;

            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = BGRPattern_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();

            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();

            classCount = BGRPattern_ClassCount(cPtr);
            denoise.classCount = classCount;
            denoise.Run(dst2);
            dst2 = denoise.dst2;

            if (standaloneTest())
            {
                dst2 = dst2 * 255 / classCount;
                dst3 = ShowPalette(dst2);
            }
        }

        public void Close()
        {
            BGRPattern_Close(cPtr);
        }
    }






    public class CS_BGSubtract_Basics : CS_Parent
    {
        public Options_BGSubtract options = new Options_BGSubtract();

        public CS_BGSubtract_Basics(VBtask task) : base(task)
        {
            cPtr = BGSubtract_BGFG_Open(options.currMethod);
            UpdateAdvice(traceName + ": local options 'Correlation Threshold' controls how well the image matches.");
            desc = "Detect motion using background subtraction algorithms in OpenCV - some only available in C++";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                BGSubtract_BGFG_Close(cPtr);
                cPtr = BGSubtract_BGFG_Open(options.currMethod);
            }

            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = BGSubtract_BGFG_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels(), options.learnRate);
            handleSrc.Free();

            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
            labels[2] = options.methodDesc;
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
            {
                cPtr = BGSubtract_BGFG_Close(cPtr);
            }
        }
    }

    // https://github.com/opencv/opencv_contrib/blob/master/modules/bgsegm/samples/bgfg.cpp
    public class CS_BGSubtract_Basics_QT : CS_Parent
    {
        double learnRate;

        public CS_BGSubtract_Basics_QT(VBtask task) : base(task)
        {
            learnRate = (dst2.Width >= 1280) ? 0.5 : 0.1; // learn faster with large images (slower frame rate)
            cPtr = BGSubtract_BGFG_Open(4); // MOG2 is the default method when running in QT mode.
            desc = "Detect motion using background subtraction algorithms in OpenCV - some only available in C++";
        }

        public void RunCS(Mat src)
        {
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = BGSubtract_BGFG_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels(), learnRate);
            handleSrc.Free();

            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
            {
                cPtr = BGSubtract_BGFG_Close(cPtr);
            }
        }
    }

    public class CS_BGSubtract_MOG2 : CS_Parent
    {
        BackgroundSubtractorMOG2 MOG2;
        Options_BGSubtract options = new Options_BGSubtract();

        public CS_BGSubtract_MOG2(VBtask task) : base(task)
        {
            MOG2 = BackgroundSubtractorMOG2.Create();
            desc = "Subtract background using a mixture of Gaussians";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Channels() == 3)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            MOG2.Apply(src, dst2, options.learnRate);
        }
    }

    public class CS_BGSubtract_MOG2_QT : CS_Parent
    {
        BackgroundSubtractorMOG2 MOG2;

        public CS_BGSubtract_MOG2_QT(VBtask task) : base(task)
        {
            MOG2 = BackgroundSubtractorMOG2.Create();
            desc = "Subtract background using a mixture of Gaussians - the QT version";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() == 3)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            double learnRate = (dst2.Width >= 1280) ? 0.5 : 0.1; // learn faster with large images (slower frame rate)
            MOG2.Apply(src, dst2, learnRate);
        }
    }


    public class CS_BGSubtract_MOG : CS_Parent
    {
        BackgroundSubtractorMOG MOG;
        Options_BGSubtract options = new Options_BGSubtract();
        public CS_BGSubtract_MOG(VBtask task) : base(task)
        {
            MOG = BackgroundSubtractorMOG.Create();
            desc = "Subtract background using a mixture of Gaussians";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            MOG.Apply(src, dst2, options.learnRate);
        }
    }

    public class CS_BGSubtract_GMG_KNN : CS_Parent
    {
        BackgroundSubtractorGMG gmg;
        BackgroundSubtractorKNN knn;
        Options_BGSubtract options = new Options_BGSubtract();
        public CS_BGSubtract_GMG_KNN(VBtask task) : base(task)
        {
            gmg = BackgroundSubtractorGMG.Create();
            knn = BackgroundSubtractorKNN.Create();
            desc = "GMG and KNN API's to subtract background";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.frameCount < 120)
            {
                SetTrueText("Waiting to get sufficient frames to learn background.  frameCount = " + task.frameCount);
            }
            else
            {
                SetTrueText("");
            }

            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            gmg.Apply(dst2, dst2, options.learnRate);
            knn.Apply(dst2, dst2, options.learnRate);
        }
    }

    public class CS_BGSubtract_MOG_RGBDepth : CS_Parent
    {
        public Mat grayMat = new Mat();
        Options_BGSubtract options = new Options_BGSubtract();
        BackgroundSubtractorMOG MOGDepth;
        BackgroundSubtractorMOG MOGRGB;
        public CS_BGSubtract_MOG_RGBDepth(VBtask task) : base(task)
        {
            MOGDepth = BackgroundSubtractorMOG.Create();
            MOGRGB = BackgroundSubtractorMOG.Create();
            labels = new string[] { "", "", "Unstable depth", "Unstable color (if there is motion)" };
            desc = "Isolate motion in both depth and color data using a mixture of Gaussians";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            grayMat = task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            MOGDepth.Apply(grayMat, grayMat, options.learnRate);
            dst2 = grayMat.CvtColor(ColorConversionCodes.GRAY2BGR);

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            MOGRGB.Apply(src, dst3, options.learnRate);
        }
    }








    public class CS_BGSubtract_MotionDetect : CS_Parent
    {
        Options_MotionDetect options = new Options_MotionDetect();

        public CS_BGSubtract_MotionDetect(VBtask task) : base(task)
        {
            labels[3] = "Only Motion Added";
            desc = "Detect Motion for use with background subtraction";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged || task.frameCount < 10)
            {
                src.CopyTo(dst3);
            }

            int threadCount = options.threadData[0];
            int width = options.threadData[1], height = options.threadData[2];
            Task[] taskArray = new Task[threadCount];
            int xfactor = src.Width / width;
            int yfactor = Math.Max(src.Height / height, src.Width / width);
            dst2.SetTo(0);
            bool motionFound = false;

            for (int i = 0; i < threadCount; i++)
            {
                int section = i;
                taskArray[i] = Task.Factory.StartNew(() =>
                {
                    Rect roi = new Rect((section % xfactor) * width, height * (int)Math.Floor((double)section / yfactor), width, height);
                    Mat correlation = new Mat();
                    if (roi.X + roi.Width > dst3.Width) roi.Width = dst3.Width - roi.X - 1;
                    if (roi.Y + roi.Height > dst3.Height) roi.Height = dst3.Height - roi.Y - 1;
                    Cv2.MatchTemplate(src[roi], dst3[roi], correlation, TemplateMatchModes.CCoeffNormed);
                    if (options.CCthreshold > correlation.At<float>(0, 0))
                    {
                        src[roi].CopyTo(dst2[roi]);
                        src[roi].CopyTo(dst3[roi]);
                        motionFound = true;
                    }
                });
            }

            Task.WaitAll(taskArray);

            if (!motionFound)
            {
                SetTrueText("No motion detected in any of the regions");
            }
        }
    }






    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law
    public class CS_Benford_JPEG : CS_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        Options_JpegQuality options = new Options_JpegQuality();

        public CS_Benford_JPEG(VBtask task) : base(task)
        {
            desc = "Perform a Benford analysis for 1-9 of a JPEG compressed image.";
        }

        public void RunCS(OpenCvSharp.Mat src)
        {
            options.RunVB();

            byte[] jpeg = src.ImEncode(".jpg", new int[] { (int)OpenCvSharp.ImwriteFlags.JpegQuality, options.quality });
            var tmp = new OpenCvSharp.Mat(jpeg.Length, 1, OpenCvSharp.MatType.CV_8U, jpeg);
            dst3 = OpenCvSharp.Cv2.ImDecode(tmp, OpenCvSharp.ImreadModes.Color);
            benford.Run(tmp);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }

    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law
    public class CS_Benford_JPEG99 : CS_Parent
    {
        public Benford_Basics benford = new Benford_Basics();
        public Options_JpegQuality options = new Options_JpegQuality();

        public CS_Benford_JPEG99(VBtask task) : base(task)
        {
            benford.setup99();
            desc = "Perform a Benford analysis for 10-99, not 1-9, of a JPEG compressed image.";
        }

        public void RunCS(OpenCvSharp.Mat src)
        {
            options.RunVB();

            byte[] jpeg = src.ImEncode(".jpg", new int[] { (int)OpenCvSharp.ImwriteFlags.JpegQuality, options.quality });
            var tmp = new OpenCvSharp.Mat(jpeg.Length, 1, OpenCvSharp.MatType.CV_8U, jpeg);
            dst3 = OpenCvSharp.Cv2.ImDecode(tmp, OpenCvSharp.ImreadModes.Color);
            benford.Run(tmp);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }

    // https://www.codeproject.com/Articles/215620/Detecting-Manipulations-in-Data-with-Benford-s-Law
    public class CS_Benford_PNG : CS_Parent
    {
        Options_PNGCompression options = new Options_PNGCompression();
        public Benford_Basics benford = new Benford_Basics();

        public CS_Benford_PNG(VBtask task) : base(task)
        {
            desc = "Perform a Benford analysis for 1-9 of a JPEG compressed image.";
        }

        public void RunCS(OpenCvSharp.Mat src)
        {
            options.RunVB();

            byte[] png = src.ImEncode(".png", new int[] { (int)OpenCvSharp.ImwriteFlags.PngCompression, options.compression });
            var tmp = new OpenCvSharp.Mat(png.Length, 1, OpenCvSharp.MatType.CV_8U, png);
            dst3 = OpenCvSharp.Cv2.ImDecode(tmp, OpenCvSharp.ImreadModes.Color);
            benford.Run(tmp);
            dst2 = benford.dst2;
            labels[2] = benford.labels[3];
            labels[3] = "Input image";
        }
    }



    public class CS_BGSubtract_MOG_Retina : CS_Parent
    {
        CS_BGSubtract_MOG bgSub;
        Retina_Basics_CPP retina = new Retina_Basics_CPP();

        public CS_BGSubtract_MOG_Retina(VBtask task) : base(task)
        {
            bgSub = new CS_BGSubtract_MOG(task);
            labels = new string[] { "", "", "MOG results of depth motion", "Difference from retina depth motion." };
            desc = "Use the bio-inspired retina algorithm to create a background/foreground using depth.";
        }

        public void RunCS(Mat src)
        {
            retina.Run(task.depthRGB);
            bgSub.RunAndMeasure(retina.dst3.Clone(), bgSub);
            dst2 = bgSub.dst2;
            Cv2.Subtract(bgSub.dst2, retina.dst3, dst3);
        }
    }

    public class CS_BGSubtract_DepthOrColorMotion : CS_Parent
    {
        public Diff_UnstableDepthAndColor motion = new Diff_UnstableDepthAndColor();

        public CS_BGSubtract_DepthOrColorMotion(VBtask task) : base(task)
        {
            desc = "Detect motion with both depth and color changes";
        }

        public void RunCS(Mat src)
        {
            motion.Run(src);
            dst2 = motion.dst2;
            dst3 = motion.dst3;
            var mask = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).ConvertScaleAbs();
            src.CopyTo(dst3, ~mask);
            labels[3] = "Image with instability filled with color data";
        }
    }

    public class CS_BGSubtract_Video : CS_Parent
    {
        CS_BGSubtract_Basics bgSub;
        Video_Basics video = new Video_Basics();

        public CS_BGSubtract_Video(VBtask task) : base(task)
        {
            bgSub = new CS_BGSubtract_Basics(task);
            video.srcVideo = task.HomeDir + "opencv/Samples/Data/vtest.avi";
            desc = "Demonstrate all background subtraction algorithms in OpenCV using a video instead of camera.";
        }

        public void RunCS(Mat src)
        {
            video.Run(src);
            dst3 = video.dst2;
            bgSub.RunAndMeasure(dst3, bgSub);
            dst2 = bgSub.dst2;
        }
    }

    public class CS_BGSubtract_Synthetic_CPP : CS_Parent
    {
        Options_BGSubtractSynthetic options = new Options_BGSubtractSynthetic();

        public CS_BGSubtract_Synthetic_CPP(VBtask task) : base(task)
        {
            labels[2] = "Synthetic background/foreground image.";
            desc = "Generate a synthetic input to background subtraction method";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.optionsChanged)
            {
                if (!task.FirstPass) BGSubtract_Synthetic_Close(cPtr);

                byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
                Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
                GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);

                cPtr = BGSubtract_Synthetic_Open(handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols,
                                                 task.HomeDir + "opencv/Samples/Data/baboon.jpg",
                                                 options.amplitude / 100, options.magnitude, options.waveSpeed / 100, options.objectSpeed);
                handleSrc.Free();
            }
            IntPtr imagePtr = BGSubtract_Synthetic_Run(cPtr);
            if (imagePtr != IntPtr.Zero) dst2 = new Mat(dst2.Rows, dst2.Cols, MatType.CV_8UC3, imagePtr).Clone();
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = BGSubtract_Synthetic_Close(cPtr);
        }
    }

    public class CS_BGSubtract_Synthetic : CS_Parent
    {
        CS_BGSubtract_Basics bgSub;
        CS_BGSubtract_Synthetic_CPP synth;

        public CS_BGSubtract_Synthetic(VBtask task) : base(task)
        {
            synth = new CS_BGSubtract_Synthetic_CPP(task);
            bgSub = new CS_BGSubtract_Basics(task);
            desc = "Demonstrate background subtraction algorithms with synthetic images";
        }

        public void RunCS(Mat src)
        {
            synth.RunAndMeasure(src, synth);
            dst3 = synth.dst2;
            bgSub.RunAndMeasure(dst3, bgSub);
            dst2 = bgSub.dst2;
        }
    }



    public class CS_BGSubtract_Reduction : CS_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        BGSubtract_Basics bgSub = new BGSubtract_Basics();

        public CS_BGSubtract_Reduction(VBtask task) : base(task)
        {
            desc = "Use BGSubtract with the output of a reduction";
        }

        public void RunCS(Mat src)
        {
            reduction.Run(src);
            var mm = GetMinMax(reduction.dst2);
            dst2 = ShowPalette(reduction.dst2 * 255 / mm.maxVal);

            bgSub.Run(dst2);
            dst3 = bgSub.dst2.Clone();

            labels[3] = "Count nonzero = " + dst3.CountNonZero().ToString();
        }
    }





    public class CS_Bin2Way_Basics : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public CS_Mat_4Click mats;
        public float fraction;

        public CS_Bin2Way_Basics(VBtask task) : base(task)
        {
            mats = new CS_Mat_4Click(task);
            fraction = dst2.Total() / 2;
            task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "Image separated into 2 segments from darkest and lightest", "Histogram Of grayscale image" };
            desc = "Split an image into 2 parts - darkest and lightest,";
        }

        public void RunCS(Mat src)
        {
            int halfSplit = 0;
            int bins = task.histogramBins;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst3 = hist.dst2;

            List<float> histArray = hist.histArray.ToList();
            float accum = 0;
            for (int i = 0; i < histArray.Count; i++)
            {
                accum += histArray[i];
                if (accum > fraction)
                {
                    halfSplit = i;
                    break;
                }
            }

            float offset = halfSplit / (float)bins * dst3.Width;
            Cv2.Line(dst3, new cv.Point((int)offset, 0), new cv.Point((int)offset, dst3.Height), Scalar.White);

            mats.mat[0] = src.InRange(0, halfSplit - 1); // darkest
            mats.mat[1] = src.InRange(halfSplit, 255);   // lightest

            if (standaloneTest())
            {
                mats.RunAndMeasure(Mat.Zeros(src.Size(), MatType.CV_8UC1), mats);
                dst2 = mats.dst2;
            }
        }
    }

    public class CS_Bin2Way_KMeans : CS_Parent
    {
        public Bin2Way_Basics bin2 = new Bin2Way_Basics();
        KMeans_Dimensions kmeans = new KMeans_Dimensions();
        Mat_4Click mats = new Mat_4Click();

        public CS_Bin2Way_KMeans(VBtask task) : base(task)
        {
            kmeans.km.options.setK(2);
            labels = new string[] { "", "", "Darkest (upper left), lightest (upper right)", "Selected image from dst2" };
            desc = "Use kmeans with each of the 2-way split images";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            bin2.Run(src);

            kmeans.Run(src);
            for (int i = 0; i < 2; i++)
            {
                mats.mat[i].SetTo(0);
                kmeans.dst3.CopyTo(mats.mat[i], bin2.mats.mat[i]);
            }

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }

    public class CS_Bin2Way_RedCloudDarkest : CS_Parent
    {
        Bin2Way_RecurseOnce bin2 = new Bin2Way_RecurseOnce();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public CS_Bin2Way_RedCloudDarkest(VBtask task) : base(task)
        {
            desc = "Use RedCloud with the darkest regions";
        }

        public void RunCS(Mat src)
        {
            if (standalone) bin2.Run(src);

            flood.inputMask = ~bin2.mats.mat[0];
            flood.Run(bin2.mats.mat[0]);
            dst2 = flood.dst2;
            if (task.heartBeat) labels[2] = task.redCells.Count + " cells were identified";
        }
    }

    public class CS_Bin2Way_RedCloudLightest : CS_Parent
    {
        Bin2Way_RecurseOnce bin2 = new Bin2Way_RecurseOnce();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public CS_Bin2Way_RedCloudLightest(VBtask task) : base(task)
        {
            desc = "Use RedCloud with the lightest regions";
        }

        public void RunCS(Mat src)
        {
            if (standalone) bin2.Run(src);

            flood.inputMask = ~bin2.mats.mat[3];
            flood.Run(bin2.mats.mat[3]);
            dst2 = flood.dst2;
            if (task.heartBeat) labels[2] = task.redCells.Count + " cells were identified";
        }
    }



    public class CS_Bin2Way_RecurseOnce : CS_Parent
    {
        Bin2Way_Basics bin2 = new Bin2Way_Basics();
        public Mat_4Click mats = new Mat_4Click();

        public CS_Bin2Way_RecurseOnce(VBtask task) : base(task)
        {
            desc = "Keep splitting an image between light and dark";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
            {
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }

            bin2.fraction = src.Total() / 2;
            bin2.hist.inputMask = new Mat();
            bin2.Run(src);
            Mat darkestMask = bin2.mats.mat[0].Clone();
            Mat lightestMask = bin2.mats.mat[1].Clone();

            bin2.fraction = src.Total() / 4;
            bin2.hist.inputMask = darkestMask;
            bin2.Run(src);

            mats.mat[0] = bin2.mats.mat[0];
            mats.mat[1] = bin2.mats.mat[1] & ~lightestMask;

            bin2.fraction = src.Total() / 4;
            bin2.hist.inputMask = lightestMask;
            bin2.Run(src);
            mats.mat[2] = bin2.mats.mat[0] & ~darkestMask;
            mats.mat[3] = bin2.mats.mat[1];

            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }

    public class CS_Bin2Way_RedCloud : CS_Parent
    {
        Bin2Way_RecurseOnce bin2 = new Bin2Way_RecurseOnce();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();
        Mat[] cellMaps = new Mat[4];
        List<rcData>[] redCells = new List<rcData>[4];
        Options_Bin2WayRedCloud options = new Options_Bin2WayRedCloud();

        public CS_Bin2Way_RedCloud(VBtask task) : base(task)
        {
            flood.showSelected = false;
            desc = "Identify the lightest, darkest, and other regions separately and then combine the rcData.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, 0);
                }
            }

            bin2.Run(src);

            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                task.cellMap = cellMaps[i];
                task.redCells = redCells[i];
                flood.inputMask = ~bin2.mats.mat[i];
                flood.Run(bin2.mats.mat[i]);
                cellMaps[i] = task.cellMap.Clone();
                redCells[i] = new List<rcData>(task.redCells);
                foreach (var rc in task.redCells)
                {
                    if (rc.index == 0) continue;
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (task.heartBeat)
            {
                labels[2] = $"{task.redCells.Count} cells were identified and matched to the previous image";
            }
        }
    }



    public class CS_Bin3Way_Basics : CS_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        public Mat_4Click mats = new Mat_4Click();
        int firstThird = 0, lastThird = 0;

        public CS_Bin3Way_Basics(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "Image separated into three segments from darkest to lightest and 'Other' (between)", "Histogram Of grayscale image" };
            desc = "Split an image into 3 parts - darkest, lightest, and in-between the 2";
        }

        public void RunCS(Mat src)
        {
            int bins = task.histogramBins;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (task.heartBeat)
            {
                firstThird = 0;
                lastThird = 0;
                hist.Run(src);
                dst3 = hist.dst2;

                var histogram = hist.histArray.ToList();
                double third = src.Total() / 3;
                float accum = 0;
                for (int i = 0; i < histogram.Count; i++)
                {
                    accum += histogram[i];
                    if (accum > third)
                    {
                        if (firstThird == 0)
                        {
                            firstThird = i;
                            accum = 0;
                        }
                        else
                        {
                            lastThird = i;
                            break;
                        }
                    }
                }
            }

            double offset = firstThird / (double)bins * dst3.Width;
            Cv2.Line(dst3, new cv.Point(offset, 0), new cv.Point(offset, dst3.Height), Scalar.White);
            offset = lastThird / (double)bins * dst3.Width;
            Cv2.Line(dst3, new cv.Point(offset, 0), new cv.Point(offset, dst3.Height), Scalar.White);

            mats.mat[0] = src.InRange(0, firstThird - 1);         // darkest
            mats.mat[1] = src.InRange(lastThird, 255);            // lightest
            mats.mat[2] = src.InRange(firstThird, lastThird - 1); // other

            if (standaloneTest())
            {
                mats.Run(Mat.Zeros(src.Size(), MatType.CV_8U));
                dst2 = mats.dst2;
            }
        }
    }

    public class CS_Bin3Way_KMeans : CS_Parent
    {
        public Bin3Way_Basics bin3 = new Bin3Way_Basics();
        KMeans_Dimensions kmeans = new KMeans_Dimensions();
        Mat_4Click mats = new Mat_4Click();

        public CS_Bin3Way_KMeans(VBtask task) : base(task)
        {
            kmeans.km.options.setK(2);
            labels = new string[] { "", "", "Darkest (upper left), mixed (upper right), lightest (bottom left)", "Selected image from dst2" };
            desc = "Use kmeans with each of the 3-way split images";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            bin3.Run(src);

            kmeans.Run(src);
            for (int i = 0; i < 2; i++)
            {
                mats.mat[i].SetTo(0);
                kmeans.dst3.CopyTo(mats.mat[i], bin3.mats.mat[i]);
            }

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }

    public class CS_Bin3Way_Color : CS_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();

        public CS_Bin3Way_Color(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "CV_8U format of the image", "showPalette output of dst2" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Build the palette input that best separates the light and dark regions of an image";
        }

        public void RunCS(Mat src)
        {
            bin3.Run(src);
            dst2.SetTo(4);
            dst2.SetTo(1, bin3.bin3.mats.mat[0]);
            dst2.SetTo(2, bin3.bin3.mats.mat[1]);
            dst2.SetTo(3, bin3.bin3.mats.mat[2]);
            dst3 = ShowPalette(dst2 * 255 / 3);
        }
    }



    public class CS_Bin3Way_RedCloudDarkest : CS_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public CS_Bin3Way_RedCloudDarkest(VBtask task) : base(task)
        {
            desc = "Use RedCloud with the darkest regions";
        }

        public void RunCS(Mat src)
        {
            if (standalone) bin3.Run(src);

            flood.inputMask = ~bin3.bin3.mats.mat[0];
            flood.Run(bin3.bin3.mats.mat[0]);
            dst2 = flood.dst2;
        }
    }

    public class CS_Bin3Way_RedCloudLightest : CS_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();

        public CS_Bin3Way_RedCloudLightest(VBtask task) : base(task)
        {
            desc = "Use RedCloud with the lightest regions";
        }

        public void RunCS(Mat src)
        {
            if (standalone) bin3.Run(src);

            flood.inputMask = ~bin3.bin3.mats.mat[2];
            flood.Run(bin3.bin3.mats.mat[2]);
            dst2 = flood.dst2;
        }
    }

    public class CS_Bin3Way_RedCloudOther : CS_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();

        public CS_Bin3Way_RedCloudOther(VBtask task) : base(task)
        {
            flood.inputMask = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Use RedCloud with the regions that are neither lightest or darkest";
        }

        public void RunCS(Mat src)
        {
            if (standalone) bin3.Run(src);

            flood.inputMask = bin3.bin3.mats.mat[0] | bin3.bin3.mats.mat[1];

            color.Run(src);
            flood.Run(color.dst2);
            dst2 = flood.dst2;
        }
    }

    public class CS_Bin3Way_RedCloud1 : CS_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();
        Mat[] cellMaps = new Mat[3];
        List<rcData>[] redCells = new List<rcData>[3];
        Options_Bin3WayRedCloud options = new Options_Bin3WayRedCloud();

        public CS_Bin3Way_RedCloud1(VBtask task) : base(task)
        {
            desc = "Identify the lightest, darkest, and 'Other' regions separately and then combine the rcData.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
                }
            }

            bin3.Run(src);

            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                task.cellMap = cellMaps[i];
                task.redCells = redCells[i];
                if (i == 2)
                {
                    flood.inputMask = bin3.bin3.mats.mat[0] | bin3.bin3.mats.mat[1];
                    color.Run(src);
                    flood.Run(color.dst2);
                }
                else
                {
                    flood.inputMask = ~bin3.bin3.mats.mat[i];
                    flood.Run(bin3.bin3.mats.mat[i]);
                }
                cellMaps[i] = task.cellMap.Clone();
                redCells[i] = new List<rcData>(task.redCells);
            }

            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < 3; i++)
            {
                foreach (var rc in redCells[i])
                {
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (task.heartBeat) labels[2] = task.redCells.Count + " cells were identified and matched to the previous image";
        }
    }

    public class CS_Bin3Way_RedCloud : CS_Parent
    {
        Bin3Way_KMeans bin3 = new Bin3Way_KMeans();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Color8U_Basics color = new Color8U_Basics();
        Mat[] cellMaps = new Mat[3];
        List<rcData>[] redCells = new List<rcData>[3];
        Options_Bin3WayRedCloud options = new Options_Bin3WayRedCloud();

        public CS_Bin3Way_RedCloud(VBtask task) : base(task)
        {
            flood.showSelected = false;
            desc = "Identify the lightest, darkest, and other regions separately and then combine the rcData.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
                }
            }

            bin3.Run(src);

            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                task.cellMap = cellMaps[i];
                task.redCells = redCells[i];
                flood.inputMask = ~bin3.bin3.mats.mat[i];
                flood.Run(bin3.bin3.mats.mat[i]);
                cellMaps[i] = task.cellMap.Clone();
                redCells[i] = new List<rcData>(task.redCells);
                foreach (var rc in redCells[i])
                {
                    if (rc.index == 0) continue;
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (task.heartBeat) labels[2] = task.redCells.Count + " cells were identified and matched to the previous image";
        }
    }



    public class CS_Bin4Way_Basics : CS_Parent
    {
        CS_Mat_4to1 mats;
        CS_Bin4Way_SplitMean binary;
        Diff_Basics[] diff = new Diff_Basics[4];
        string[] labelStr = new string[4];
        cv.Point[] points = new cv.Point[4];
        int index = 0;
        public CS_Bin4Way_Basics(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i] = new Diff_Basics();
            }
            binary = new CS_Bin4Way_SplitMean(task);
            mats = new CS_Mat_4to1(task);
            labels = new string[] { "", "Quartiles for selected roi.  Click in dst1 to see different roi.", "4 brightness levels - darkest to lightest",
                      "Quartiles for the selected grid element, darkest to lightest" };
            desc = "Highlight the contours for each grid element with stats for each.";
        }

        public void RunCS(Mat src)
        {
            if (task.mousePicTag == 1) index = task.gridMap.At<int>(task.ClickPoint.Y, task.ClickPoint.X);
            Rect roiSave = index < task.gridList.Count ? task.gridList[index] : new Rect();

            if (task.optionsChanged) index = 0;

            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat[] matList = new Mat[4];
            for (int i = 0; i < matList.Length; i++)
            {
                mats.mat[i] = new Mat(mats.mat[i].Size(), MatType.CV_8U, Scalar.All(0));
                binary.mats.mat[i] = new Mat(binary.mats.mat[i].Size(), MatType.CV_8U, Scalar.All(0));
            }

            int quadrant;
            binary.RunAndMeasure(src, binary);
            binary.mats.RunAndMeasure(new Mat(), binary.mats);
            dst2 = binary.mats.dst2;
            dst1 = binary.mats.dst3 * 0.5;
            matList = binary.mats.mat;
            quadrant = binary.mats.quadrant;

            dst0.SetTo(Scalar.All(0));
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i].Run(binary.mats.mat[i]);
                dst0 = dst0 | diff[i].dst2;
            }

            int[,] counts = new int[4, task.gridList.Count];
            List<List<int>> contourCounts = new List<List<int>>();
            List<List<float>> means = new List<List<float>>();

            cv.Point[][] allContours;
            for (int i = 0; i < counts.GetLength(0); i++)
            {
                for (int j = 0; j < task.gridList.Count; j++)
                {
                    Rect roi = task.gridList[j];
                    Mat tmp = new Mat(matList[i], roi);
                    Cv2.FindContours(tmp, out allContours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
                    if (i == 0)
                    {
                        contourCounts.Add(new List<int>());
                        means.Add(new List<float>());
                    }
                    contourCounts[j].Add(allContours.Length);
                    means[j].Add((float)(src[roi].Mean(tmp)[0]));
                    if (i == quadrant) SetTrueText(allContours.Length.ToString(), roi.TopLeft, 1);
                    counts[i, j] = allContours.Length;
                }
            }

            int bump = 3;
            double ratio = (double)dst2.Height / task.gridList[0].Height;
            for (int i = 0; i < matList.Length; i++)
            {
                Mat tmp = new Mat(matList[i], roiSave) * 0.5;
                int nextCount = Cv2.CountNonZero(tmp);
                Mat tmpVolatile = new Mat(dst0, roiSave) & tmp;
                tmp.SetTo(Scalar.All(255), tmpVolatile);
                new Mat(dst0, roiSave).CopyTo(tmp, tmpVolatile);
                Rect r = new Rect(0, 0, (int)(tmp.Width * ratio), (int)(tmp.Height * ratio));
                mats.mat[i][r] = tmp.Resize(new cv.Size(r.Width, r.Height));

                if (task.heartBeat)
                {
                    int plus = mats.mat[i][r].Width / 2;

                    if (i == 0) points[i] = new cv.Point(bump + plus, bump);
                    if (i == 1) points[i] = new cv.Point(bump + dst2.Width / 2 + plus, bump);
                    if (i == 2) points[i] = new cv.Point(bump + plus, bump + dst2.Height / 2);
                    if (i == 3) points[i] = new cv.Point(bump + dst2.Width / 2 + plus, bump + dst2.Height / 2);
                }
            }

            for (int i = 0; i < labelStr.Length; i++)
            {
                SetTrueText(labelStr[i], points[i], 3);
            }

            mats.RunAndMeasure(src, mats);
            dst3 = mats.dst2;

            dst1.Rectangle(roiSave, Scalar.White, task.lineWidth);
            task.color.Rectangle(roiSave, Scalar.White, task.lineWidth);
        }
    }



    public class CS_Bin4Way_Canny : CS_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        Mat_4Click mats = new Mat_4Click();

        public CS_Bin4Way_Canny(VBtask task) : base(task)
        {
            labels[2] = "Edges between halves, lightest, darkest, and the combo";
            desc = "Find edges from each of the binarized images";
        }

        public void RunCS(Mat src)
        {
            binary.Run(src);

            edges.Run(binary.mats.mat[0]);  // the light and dark halves
            mats.mat[0] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);

            edges.Run(binary.mats.mat[1]);  // the lightest of the light half
            mats.mat[1] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[1] | mats.mat[3];

            edges.Run(binary.mats.mat[3]);  // the darkest of the dark half
            mats.mat[2] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[2] | mats.mat[3];

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;

            if (mats.dst3.Channels() == 3)
            {
                labels[3] = "Combo of first 3 below.  Click quadrants in dst2.";
                dst3 = mats.mat[3];
            }
            else
            {
                dst3 = mats.dst3;
            }
        }
    }

    public class CS_Bin4Way_Sobel : CS_Parent
    {
        Edge_Sobel_Old edges = new Edge_Sobel_Old();
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        public Mat_4Click mats = new Mat_4Click();

        public CS_Bin4Way_Sobel(VBtask task) : base(task)
        {
            SetSlider("Sobel kernel Size", 5);
            labels[2] = "Edges between halves, lightest, darkest, and the combo";
            labels[3] = "Click any quadrant in dst2 to view it in dst3";
            desc = "Collect Sobel edges from binarized images";
        }

        public void RunCS(Mat src)
        {
            binary.Run(src);

            edges.Run(binary.mats.mat[0]); // the light and dark halves
            mats.mat[0] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);

            edges.Run(binary.mats.mat[1]); // the lightest of the light half
            mats.mat[1] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[1] | mats.mat[3];

            edges.Run(binary.mats.mat[3]);  // the darkest of the dark half
            mats.mat[2] = edges.dst2.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[3] = mats.mat[2] | mats.mat[3];

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }

    public class CS_Bin4Way_Unstable1 : CS_Parent
    {
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        Diff_Basics diff = new Diff_Basics();

        public CS_Bin4Way_Unstable1(VBtask task) : base(task)
        {
            desc = "Find the unstable pixels in the binary image";
        }

        public void RunCS(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            diff.Run(binary.dst3);
            dst3 = diff.dst2;

            if (task.heartBeat)
            {
                labels[3] = "There are " + dst3.CountNonZero().ToString() + " unstable pixels";
            }
        }
    }

    public class CS_Bin4Way_UnstableEdges : CS_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        Blur_Basics blur = new Blur_Basics();
        Bin4Way_Unstable unstable = new Bin4Way_Unstable();

        public CS_Bin4Way_UnstableEdges(VBtask task) : base(task)
        {
            if (standalone)
            {
                task.gOptions.setDisplay1();
            }
            desc = "Find unstable pixels but remove those that are also edges.";
        }

        public void RunCS(Mat src)
        {
            canny.Run(src);
            blur.Run(canny.dst2);
            dst1 = blur.dst2.Threshold(0, 255, ThresholdTypes.Binary);

            unstable.Run(src);
            dst2 = unstable.dst2;
            dst3 = unstable.dst3;

            if (!task.gOptions.debugChecked)
            {
                dst3.SetTo(0, dst1);
            }
        }
    }


    public class CS_Bin4Way_UnstablePixels : CS_Parent
    {
        Bin4Way_UnstableEdges unstable = new Bin4Way_UnstableEdges();
        public List<byte> gapValues = new List<byte>();

        public CS_Bin4Way_UnstablePixels(VBtask task) : base(task)
        {
            desc = "Identify the unstable grayscale pixel values ";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            unstable.Run(src);
            dst2 = unstable.dst3;

            var points = dst2.FindNonZero();
            if (points.Rows == 0) return;

            int[] pts = new int[points.Rows * 2];
            Marshal.Copy(points.Data, pts, 0, pts.Length);

            List<byte> pixels = new List<byte>();
            SortedList<byte, int> pixelSort = new SortedList<byte, int>(new compareByte());
            for (int i = 0; i < pts.Length; i += 2)
            {
                byte val = src.At<byte>(pts[i + 1], pts[i]);
                if (!pixels.Contains(val))
                {
                    pixelSort.Add(val, 1);
                    pixels.Add(val);
                }
            }

            int gapThreshold = 2;
            gapValues.Clear();
            strOut = "These are the ranges of grayscale bytes where there is fuzziness.\n";
            int lastIndex = 0, lastGap = 0;
            foreach (var index in pixelSort.Keys)
            {
                if (Math.Abs(lastIndex - index) > gapThreshold)
                {
                    strOut += "\n";
                    gapValues.Add((byte)((index + lastGap) / 2));
                    lastGap = index;
                    for (int i = index + 1; i < pixelSort.Keys.Count; i++)
                    {
                        if (pixelSort.Keys.ElementAt(i) - lastGap > gapThreshold) break;
                        lastGap = i;
                    }
                }
                strOut += index.ToString() + "\t";
                lastIndex = index;
            }
            if (gapValues.Count < 4)
            {
                gapValues.Add((byte)((255 + lastGap) / 2));
            }

            strOut += "\n\nThe best thresholds for this image to avoid fuzziness are: \n";
            foreach (var index in gapValues)
            {
                strOut += index.ToString() + "\t";
            }
            SetTrueText(strOut, 3);
            if (task.heartBeat) labels[3] = "There are " + dst2.CountNonZero().ToString() + " unstable pixels";
        }
    }

    public class CS_Bin4Way_SplitValley : CS_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        HistValley_Basics valley = new HistValley_Basics();
        public Mat_4Click mats = new Mat_4Click();

        public CS_Bin4Way_SplitValley(VBtask task) : base(task)
        {
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Binarize an image using the valleys provided by HistValley_Basics";
        }

        public void RunCS(Mat src)
        {
            Mat gray = src.Channels() == 1 ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            binary.Run(gray);
            Mat mask = binary.dst2.Clone();

            if (task.heartBeat) valley.Run(gray);

            mats.mat[0] = gray.InRange(0, valley.valleys[1] - 1);
            mats.mat[1] = gray.InRange(valley.valleys[1], valley.valleys[2] - 1);
            mats.mat[2] = gray.InRange(valley.valleys[2], valley.valleys[3] - 1);
            mats.mat[3] = gray.InRange(valley.valleys[3], 255);

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC1));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            labels[3] = mats.labels[3];
        }
    }

    public class CS_Bin4Way_UnstablePixels1 : CS_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Bin4Way_UnstableEdges unstable = new Bin4Way_UnstableEdges();
        public List<byte> gapValues = new List<byte>();

        public CS_Bin4Way_UnstablePixels1(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(256);
            desc = "Identify the unstable grayscale pixel values ";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            hist.Run(src);

            unstable.Run(src);
            dst2 = unstable.dst3;

            var points = dst2.FindNonZero();
            if (points.Rows == 0) return;

            int[] pts = new int[points.Rows * 2];
            Marshal.Copy(points.Data, pts, 0, pts.Length);

            List<byte> pixels = new List<byte>();
            SortedList<byte, int> pixelSort = new SortedList<byte, int>(new compareByte());
            for (int i = 0; i < pts.Length; i += 2)
            {
                byte val = src.At<byte>(pts[i + 1], pts[i]);
                if (!pixels.Contains(val))
                {
                    pixelSort.Add(val, 1);
                    pixels.Add(val);
                }
            }

            byte[] boundaries = new byte[5];
            boundaries[0] = (byte)(0 * 255 / 4);
            boundaries[1] = (byte)(1 * 255 / 4);
            boundaries[2] = (byte)(2 * 255 / 4);
            boundaries[3] = (byte)(3 * 255 / 4);
            boundaries[4] = 255;

            int gapThreshold = 2, lastIndex = 0, bIndex = 1;
            strOut = "These are the ranges of grayscale bytes where there is fuzziness.\n";
            for (int i = 0; i < pixelSort.Keys.Count; i++)
            {
                byte index = pixelSort.ElementAt(i).Key;
                if (Math.Abs(lastIndex - index) > gapThreshold)
                {
                    strOut += "\n";
                    if (bIndex < boundaries.Length)
                    {
                        boundaries[bIndex] = index;
                        bIndex++;
                    }
                }
                strOut += index.ToString() + "\t";
                lastIndex = index;
            }

            gapValues.Clear();
            for (int i = 1; i < boundaries.Length; i++)
            {
                byte minVal = byte.MaxValue;
                int minIndex = 0;
                for (int j = boundaries[i - 1]; j < boundaries[i]; j++)
                {
                    if (hist.histArray[j] < minVal)
                    {
                        minVal = (byte) hist.histArray[j];
                        minIndex = j;
                    }
                }
                gapValues.Add((byte)minIndex);
            }
            strOut += "\n\nThe best thresholds for this image to avoid fuzziness are: \n";
            foreach (var index in gapValues)
            {
                strOut += index.ToString() + "\t";
            }
            SetTrueText(strOut, 3);
            if (task.heartBeat) labels[3] = "There are " + dst2.CountNonZero().ToString() + " unstable pixels";
        }
    }



    public class CS_Bin4Way_Regions1 : CS_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        public Mat_4Click mats = new Mat_4Click();
        public int classCount = 4; // 4-way split

        public CS_Bin4Way_Regions1(VBtask task) : base(task)
        {
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Binarize an image and split it into quartiles using peaks.";
        }

        public void RunCS(Mat src)
        {
            Mat gray = (src.Channels() == 1) ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            binary.Run(gray);
            Mat mask = binary.dst2.Clone();

            double midColor = binary.meanScalar[0];
            double topColor = Cv2.Mean(gray, mask)[0];
            double botColor = Cv2.Mean(gray, ~mask)[0];
            mats.mat[0] = gray.InRange(0, botColor);
            mats.mat[1] = gray.InRange(botColor, midColor);
            mats.mat[2] = gray.InRange(midColor, topColor);
            mats.mat[3] = gray.InRange(topColor, 255);

            mats.Run(Mat.Zeros(dst1.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            labels[3] = mats.labels[3];
        }
    }


    public class CS_Bin4Way_SplitGaps : CS_Parent
    {
        Bin4Way_UnstablePixels unstable = new Bin4Way_UnstablePixels();
        public Mat_4Click mats = new Mat_4Click();
        Diff_Basics[] diff = new Diff_Basics[4];

        public CS_Bin4Way_SplitGaps(VBtask task) : base(task)
        {
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i] = new Diff_Basics();
                mats.mat[i] = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            }
            if (standalone) task.gOptions.setDisplay1();
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Separate the quartiles of the image using the fuzzy grayscale pixel values";
        }

        public void RunCS(Mat src)
        {
            Mat gray = (src.Channels() == 1) ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            unstable.Run(gray);

            int lastVal = 255;
            for (int i = Math.Min(mats.mat.Length, unstable.gapValues.Count) - 1; i >= 0; i--)
            {
                mats.mat[i] = gray.InRange(unstable.gapValues[i], lastVal);
                lastVal = unstable.gapValues[i];
            }

            dst1.SetTo(Scalar.All(0));
            for (int i = 0; i < diff.Length; i++)
            {
                diff[i].Run(mats.mat[i]);
                dst1 = dst1 | diff[i].dst2;
            }
            mats.Run(Mat.Zeros(dst1.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            if (task.heartBeat) labels[1] = "There are " + dst1.CountNonZero().ToString() + " unstable pixels";
        }
    }

    public class CS_Bin4Way_RegionsLeftRight : CS_Parent
    {
        Bin4Way_SplitGaps binaryLeft = new Bin4Way_SplitGaps();
        Bin4Way_SplitGaps binaryRight = new Bin4Way_SplitGaps();
        public int classCount = 4; // 4-way split

        public CS_Bin4Way_RegionsLeftRight(VBtask task) : base(task)
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            labels = new string[] { "", "", "Left in 4 colors", "Right image in 4 colors" };
            desc = "Add the 4-way split of left and right views.";
        }

        public void RunCS(Mat src)
        {
            binaryLeft.Run(src);

            dst0.SetTo(Scalar.All(1), binaryLeft.mats.mat[0]);
            dst0.SetTo(Scalar.All(2), binaryLeft.mats.mat[1]);
            dst0.SetTo(Scalar.All(3), binaryLeft.mats.mat[2]);
            dst0.SetTo(Scalar.All(4), binaryLeft.mats.mat[3]);

            dst2 = ShowPalette((dst0 * 255 / classCount).ToMat());

            binaryRight.Run(task.rightView);

            dst1.SetTo(Scalar.All(1), binaryRight.mats.mat[0]);
            dst1.SetTo(Scalar.All(2), binaryRight.mats.mat[1]);
            dst1.SetTo(Scalar.All(3), binaryRight.mats.mat[2]);
            dst1.SetTo(Scalar.All(4), binaryRight.mats.mat[3]);

            dst3 = ShowPalette((dst1 * 255 / classCount).ToMat());
        }
    }


    public class CS_Bin4Way_RedCloud : CS_Parent
    {
        Bin4Way_BasicsRed bin2 = new Bin4Way_BasicsRed();
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Mat[] cellMaps = new Mat[4];
        List<rcData>[] redCells = new List<rcData>[4];
        Options_Bin2WayRedCloud options = new Options_Bin2WayRedCloud();

        public CS_Bin4Way_RedCloud(VBtask task) : base(task)
        {
            flood.showSelected = false;
            desc = "Identify the lightest and darkest regions separately and then combine the rcData.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                for (int i = 0; i < redCells.Length; i++)
                {
                    redCells[i] = new List<rcData>();
                    cellMaps[i] = new Mat(dst2.Size(), MatType.CV_8U, 0);
                }
            }

            bin2.Run(src);

            var sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            for (int i = options.startRegion; i <= options.endRegion; i++)
            {
                task.cellMap = cellMaps[i];
                task.redCells = redCells[i];
                flood.inputMask = ~bin2.mats.mat[i];
                flood.Run(bin2.mats.mat[i]);
                cellMaps[i] = task.cellMap.Clone();
                redCells[i] = new List<rcData>(task.redCells);
                foreach (var rc in task.redCells)
                {
                    if (rc.index == 0) continue;
                    sortedCells.Add(rc.pixels, rc);
                }
            }

            dst2 = RebuildCells(sortedCells);

            if (task.heartBeat) labels[2] = $"{task.redCells.Count} cells were identified and matched to the previous image";
        }
    }

    public class CS_Bin4Way_Regions : CS_Parent
    {
        Bin4Way_SplitMean binary = new Bin4Way_SplitMean();
        public int classCount = 4; // 4-way split 

        public CS_Bin4Way_Regions(VBtask task) : base(task)
        {
            rebuildMats();
            labels = new string[] { "", "", "CV_8U version of dst3 with values ranging from 1 to 4", "Palettized version of dst2" };
            desc = "Add the 4-way split of images to define the different regions.";
        }

        void rebuildMats()
        {
            dst2 = new Mat(task.WorkingRes, MatType.CV_8U, 0);
            for (int i = 0; i < binary.mats.mat.Count(); i++)
            {
                binary.mats.mat[i] = new Mat(task.WorkingRes, MatType.CV_8UC1, 0);
            }
        }

        public void RunCS(Mat src)
        {
            binary.Run(src);
            if (dst2.Width != binary.mats.mat[0].Width) rebuildMats();

            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            dst2.SetTo(1, binary.mats.mat[0]);
            dst2.SetTo(2, binary.mats.mat[1]);
            dst2.SetTo(3, binary.mats.mat[2]);
            dst2.SetTo(4, binary.mats.mat[3]);

            dst3 = ShowPalette((dst2 * 255 / classCount).ToMat());
        }
    }





    public class CS_Bin4Way_SplitMean : CS_Parent
    {
        public CS_Binarize_Simple binary;
        public CS_Mat_4Click mats;
        Scalar botColor, midColor, topColor;

        public CS_Bin4Way_SplitMean(VBtask task) : base(task)
        {
            mats = new CS_Mat_4Click(task);
            binary = new CS_Binarize_Simple(task);
            labels[2] = "A 4-way split - darkest (upper left) to lightest (lower right)";
            desc = "Binarize an image and split it into quartiles using peaks.";
        }

        public void RunCS(Mat src)
        {
            Mat gray = (src.Channels() == 1) ? src.Clone() : src.CvtColor(ColorConversionCodes.BGR2GRAY);

            binary.RunAndMeasure(gray, binary);
            Mat mask = binary.dst2.Clone();

            if (task.heartBeat)
            {
                midColor = binary.meanScalar[0];
                topColor = Cv2.Mean(gray, mask)[0];
                botColor = Cv2.Mean(gray, ~mask)[0];
            }

            mats.mat[0] = gray.InRange(new Scalar(0), botColor);
            mats.mat[1] = gray.InRange(botColor, midColor);
            mats.mat[2] = gray.InRange(midColor, topColor);
            mats.mat[3] = gray.InRange(topColor, new Scalar(255));

            mats.RunAndMeasure(Mat.Zeros(gray.Size(), MatType.CV_8UC1), mats);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
            labels[3] = mats.labels[3];
        }
    }


    public class CS_Binarize_Basics : CS_Parent
    {
        public ThresholdTypes thresholdType = ThresholdTypes.Otsu;
        public Mat histogram = new Mat();
        public Scalar meanScalar;
        public Mat mask = new Mat();
        Blur_Basics blur = new Blur_Basics();
        public bool useBlur;

        public CS_Binarize_Basics(VBtask task) : base(task)
        {
            mask = new Mat(dst2.Size(), MatType.CV_8U, 255);
            UpdateAdvice(traceName + ": use local options to control the kernel size and sigma.");
            desc = "Binarize an image using Threshold with OTSU.";
        }

        public void RunCS(Mat src)
        {
            meanScalar = Cv2.Mean(src, mask);

            Mat input = src;
            if (input.Channels() == 3)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (useBlur)
            {
                blur.Run(input);
                dst2 = blur.dst2.Threshold(meanScalar.Val0, 255, thresholdType);
            }
            else
            {
                dst2 = input.Threshold(meanScalar.Val0, 255, thresholdType);
            }
        }
    }

    // https://docs.opencv.org/3.4/d7/d4d/tutorial_py_thresholding.html
    public class CS_Binarize_OTSU : CS_Parent
    {
        Binarize_Basics binarize;
        Options_Binarize options = new Options_Binarize();
        public CS_Binarize_OTSU(VBtask task) : base(task)
        {
            binarize = new Binarize_Basics();
            labels[2] = "Threshold 1) binary 2) Binary+OTSU 3) OTSU 4) OTSU+Blur";
            labels[3] = "Histograms correspond to images on the left";
            desc = "Binarize an image using Threshold with OTSU.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat input = src;
            if (input.Channels() == 3)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);

            binarize.meanScalar = Cv2.Mean(input);

            binarize.useBlur = false;
            switch (labels[2])
            {
                case "Binary":
                    binarize.thresholdType = ThresholdTypes.Binary;
                    break;
                case "Binary + OTSU":
                    binarize.thresholdType = ThresholdTypes.Binary | ThresholdTypes.Otsu;
                    break;
                case "OTSU":
                    binarize.thresholdType = ThresholdTypes.Otsu;
                    break;
                case "OTSU + Blur":
                    binarize.useBlur = true;
                    binarize.thresholdType = ThresholdTypes.Binary | ThresholdTypes.Otsu;
                    break;
            }
            binarize.Run(input);
            dst2 = binarize.dst2;
        }
    }


    public class CS_Binarize_KMeansMasks : CS_Parent
    {
        KMeans_Image km = new KMeans_Image();
        Mat_4Click mats = new Mat_4Click();
        public CS_Binarize_KMeansMasks(VBtask task) : base(task)
        {
            labels[2] = "Ordered from dark to light, top left darkest, bottom right lightest ";
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            desc = "Display the top 4 masks from the BGR kmeans output";
        }
        public void RunCS(Mat src)
        {
            km.Run(src);
            for (int i = 0; i < km.masks.Count; i++)
            {
                mats.mat[i] = km.masks[i];
                dst1.SetTo(i + 1, km.masks[i]);
                if (i >= 3) break;
            }

            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8U));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }



    public class CS_Binarize_KMeansRGB : CS_Parent
    {
        KMeans_Image km = new KMeans_Image();
        Mat_4Click mats = new Mat_4Click();

        public CS_Binarize_KMeansRGB(VBtask task) : base(task)
        {
            labels[2] = "Ordered from dark to light, top left darkest, bottom right lightest ";
            desc = "Display the top 4 masks from the BGR kmeans output";
        }

        public void RunCS(Mat src)
        {
            km.Run(src);
            dst1.SetTo(0);
            for (int i = 0; i < km.masks.Count; i++)
            {
                mats.mat[i] = new Mat(dst2.Size(), MatType.CV_8UC3, Scalar.All(0));
                src.CopyTo(mats.mat[i], km.masks[i]);
                if (i >= 3) break;
            }
            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC3));
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }

    public class CS_Binarize_FourPixelFlips : CS_Parent
    {
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        Mat lastSubD;
        public CS_Binarize_FourPixelFlips(VBtask task) : base(task)
        {
            desc = "Identify the marginal regions that flip between subdivisions based on brightness.";
        }

        public void RunCS(Mat src)
        {
            binar4.Run(src);
            dst2 = ShowPalette(binar4.dst2 * 255 / 5);

            if (task.FirstPass) lastSubD = binar4.dst2.Clone();
            dst3 = lastSubD - binar4.dst2;
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.Binary);
            lastSubD = binar4.dst2.Clone();
        }
    }

    public class CS_Binarize_DepthTiers : CS_Parent
    {
        Depth_TiersZ tiers = new Depth_TiersZ();
        Bin4Way_Regions binar4 = new Bin4Way_Regions();
        public int classCount = 200; // 4-way split with 50 depth levels at 10 cm's each.

        public CS_Binarize_DepthTiers(VBtask task) : base(task)
        {
            task.redOptions.useColorOnlyChecked = true;
            desc = "Add the Depth_TiersZ and Bin4Way_Regions output in preparation for RedCloud";
        }

        public void RunCS(Mat src)
        {
            binar4.Run(src);
            tiers.Run(src);
            dst3 = tiers.dst3;

            dst0 = tiers.dst2 + binar4.dst2;

            if (task.heartBeat)
            {
                dst2 = dst0.Clone();
            }
            else if (task.motionDetected)
            {
                dst0[task.motionRect].CopyTo(dst2[task.motionRect]);
            }
            classCount = binar4.classCount + tiers.classCount;
        }
    }

    public class CS_Binarize_Simple : CS_Parent
    {
        public Scalar meanScalar;
        public int injectVal = 255;

        public CS_Binarize_Simple(VBtask task) : base(task)
        {
            desc = "Binarize an image using Threshold with OTSU.";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            meanScalar = Cv2.Mean(src);
            dst2 = src.Threshold(meanScalar[0], injectVal, ThresholdTypes.Binary);
        }
    }


    public class CS_Binarize_Niblack_Sauvola : CS_Parent
    {
        Options_BinarizeNiBlack options = new Options_BinarizeNiBlack();
        //[InlineData(LocalBinarizationMethods.Niblack)]
        //[InlineData(LocalBinarizationMethods.Sauvola)]
        //[InlineData(LocalBinarizationMethods.Wolf)]
        //[InlineData(LocalBinarizationMethods.Nick)]
        public CS_Binarize_Niblack_Sauvola(VBtask task) : base(task)
        {
            desc = "Binarize an image using Niblack and Sauvola";
            labels[2] = "Binarize Niblack";
            labels[3] = "Binarize Sauvola";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Niblack);
            dst2 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Sauvola);
            dst3 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }



    public class CS_Binarize_Wolf_Nick : CS_Parent
    {
        Options_BinarizeNiBlack options = new Options_BinarizeNiBlack();
        public CS_Binarize_Wolf_Nick(VBtask task) : base(task)
        {
            desc = "Binarize an image using Wolf and Nick";
            labels[2] = "Binarize Wolf";
            labels[3] = "Binarize Nick";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Wolf);
            dst2 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
            CvXImgProc.NiblackThreshold(src, dst0, 255, ThresholdTypes.Binary, 5, 0.5, LocalBinarizationMethods.Nick);
            dst3 = dst0.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }


    public class CS_Blob_Input : CS_Parent
    {
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        Draw_Circles circles = new Draw_Circles();
        Draw_Ellipses ellipses = new Draw_Ellipses();
        Draw_Polygon poly = new Draw_Polygon();
        public Mat_4Click Mats = new Mat_4Click();
        public int updateFrequency = 30;

        public CS_Blob_Input(VBtask task) : base(task)
        {
            SetSlider("DrawCount", 5);
            FindCheckBox("Draw filled (unchecked draw an outline)").Checked = true;

            Mats.mats.lineSeparators = false;

            labels[2] = "Click any quadrant below to view it on the right";
            labels[3] = "Click any quadrant at left to view it below";
            desc = "Generate data to test Blob Detector.";
        }

        public void RunCS(Mat src)
        {
            rotatedRect.Run(src);
            Mats.mat[0] = rotatedRect.dst2;

            circles.Run(src);
            Mats.mat[1] = circles.dst2;

            ellipses.Run(src);
            Mats.mat[2] = ellipses.dst2;

            poly.Run(src);
            Mats.mat[3] = poly.dst3;
            Mats.Run(empty);
            dst2 = Mats.dst2;
            dst3 = Mats.dst3;
        }
    }

    public class CS_Blob_RenderBlobs : CS_Parent
    {
        Blob_Input input = new Blob_Input();

        public CS_Blob_RenderBlobs(VBtask task) : base(task)
        {
            labels[2] = "Input blobs";
            labels[3] = "Largest blob, centroid in yellow";
            desc = "Use connected components to find blobs.";
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                input.Run(src);
                dst2 = input.dst2;
                var gray = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
                var binary = gray.Threshold(0, 255, ThresholdTypes.Otsu | ThresholdTypes.Binary);
                var labelView = dst2.EmptyClone();
                var stats = new Mat();
                var centroids = new Mat();
                var cc = Cv2.ConnectedComponentsEx(binary);
                var labelCount = Cv2.ConnectedComponentsWithStats(binary, labelView, stats, centroids);
                cc.RenderBlobs(labelView);

                foreach (var b in cc.Blobs.Skip(1))
                {
                    dst2.Rectangle(b.Rect, Scalar.Red, task.lineWidth + 1, task.lineType);
                }

                var maxBlob = cc.GetLargestBlob();
                dst3.SetTo(0);
                cc.FilterByBlob(dst2, dst3, maxBlob);

                dst3.Circle(new cv.Point(maxBlob.Centroid.X, maxBlob.Centroid.Y), task.DotSize + 3, Scalar.Blue, -1, task.lineType);
                DrawCircle(dst3, new cv.Point(maxBlob.Centroid.X, maxBlob.Centroid.Y), task.DotSize, Scalar.Yellow);
            }
        }
    }


    public class CS_BlockMatching_Basics : CS_Parent
    {
        Depth_Colorizer_CPP colorizer = new Depth_Colorizer_CPP();
        Options_BlockMatching options = new Options_BlockMatching();

        public CS_BlockMatching_Basics(VBtask task) : base(task)
        {
            if (standaloneTest())
            {
                task.gOptions.setDisplay1();
            }
            labels[2] = "Block matching disparity colorized like depth";
            labels[3] = "Right Image (used with left image)";
            UpdateAdvice(traceName + ": click 'Show All' to see all the available options.");
            desc = "Use OpenCV's block matching on left and right views";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.cameraName == "Azure Kinect 4K")
            {
                SetTrueText("For the K4A 4 Azure camera, the left and right views are the same.");
            }

            var blockMatch = StereoBM.Create();
            blockMatch.BlockSize = options.blockSize;
            blockMatch.MinDisparity = 0;
            blockMatch.ROI1 = new Rect(0, 0, task.leftView.Width, task.leftView.Height);
            blockMatch.ROI2 = new Rect(0, 0, task.leftView.Width, task.leftView.Height);
            blockMatch.PreFilterCap = 31;
            blockMatch.NumDisparities = options.numDisparity;
            blockMatch.TextureThreshold = 10;
            blockMatch.UniquenessRatio = 15;
            blockMatch.SpeckleWindowSize = 100;
            blockMatch.SpeckleRange = 32;
            blockMatch.Disp12MaxDiff = 1;

            Mat tmpLeft = task.leftView.Channels() == 3 ? task.leftView.CvtColor(ColorConversionCodes.BGR2GRAY) : task.leftView;
            Mat tmpRight = task.rightView.Channels() == 3 ? task.rightView.CvtColor(ColorConversionCodes.BGR2GRAY) : task.rightView;

            Mat disparity = new Mat();
            blockMatch.Compute(tmpLeft, tmpRight, disparity);
            disparity.ConvertTo(dst1, MatType.CV_32F, 1.0 / 16);
            dst1 = dst1.Threshold(0, 0, ThresholdTypes.Tozero);

            int topMargin = 10, sideMargin = 8;
            Rect rect = new Rect(options.numDisparity + sideMargin, topMargin, src.Width - options.numDisparity - sideMargin * 2, src.Height - topMargin * 2);
            Cv2.Divide(options.distance, dst1[rect], dst1[rect]); // this needs much more refinement. The trackbar value is just an approximation.
            dst1[rect] = dst1[rect].Threshold(10, 10, ThresholdTypes.Trunc);

            colorizer.Run(dst1);
            dst2[rect] = colorizer.dst2[rect];
            dst3 = task.rightView.Resize(src.Size());
        }
    }


    public class CS_Blur_Basics : CS_Parent
    {
        Options_Blur options = new Options_Blur();
        public CS_Blur_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": use local options to control the kernel size and sigma.");
            desc = "Smooth each pixel with a Gaussian kernel of different sizes.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Cv2.GaussianBlur(src, dst2, new cv.Size(options.kernelSize, options.kernelSize), options.sigma, options.sigma);
        }
    }

    public class CS_Blur_Homogeneous : CS_Parent
    {
        Blur_Basics blur = new Blur_Basics();
        public CS_Blur_Homogeneous(VBtask task) : base(task)
        {
            desc = "Smooth each pixel with a kernel of 1's of different sizes.";
        }
        public void RunCS(Mat src)
        {
            Cv2.Blur(src, dst2, new cv.Size(blur.Options.kernelSize, blur.Options.kernelSize), new cv.Point(-1, -1));
        }
    }

    public class CS_Blur_Median : CS_Parent
    {
        Blur_Basics blur = new Blur_Basics();
        public CS_Blur_Median(VBtask task) : base(task)
        {
            desc = "Replace each pixel with the median of neighborhood of varying sizes.";
        }
        public void RunCS(Mat src)
        {
            Cv2.MedianBlur(src, dst2, blur.Options.kernelSize);
        }
    }

    // https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=bilateralfilter
    // https://www.tutorialspoint.com/opencv/opencv_bilateral_filter.htm
    public class CS_Blur_Bilateral : CS_Parent
    {
        Blur_Basics blur = new Blur_Basics();
        public CS_Blur_Bilateral(VBtask task) : base(task)
        {
            desc = "Smooth each pixel with a Gaussian kernel of different sizes but preserve edges";
        }
        public void RunCS(Mat src)
        {
            Cv2.BilateralFilter(src, dst2, blur.Options.kernelSize, blur.Options.kernelSize * 2, blur.Options.kernelSize / 2);
        }
    }



    public class CS_Blur_PlusHistogram : CS_Parent
    {
        Mat_2to1 mat2to1 = new Mat_2to1();
        Blur_Bilateral blur = new Blur_Bilateral();
        Hist_EqualizeGray myhist = new Hist_EqualizeGray();

        public CS_Blur_PlusHistogram(VBtask task) : base(task)
        {
            labels[2] = "Use Blur slider to see impact on histogram peak values";
            labels[3] = "Top is before equalize, Bottom is after Equalize";
            desc = "Compound algorithms Blur and Histogram";
        }

        public void RunCS(Mat src)
        {
            myhist.Run(src);
            mat2to1.mat[0] = myhist.dst2.Clone();

            blur.Run(src);
            dst2 = blur.dst2.Clone();

            myhist.Run(blur.dst2);
            mat2to1.mat[1] = myhist.dst2.Clone();
            mat2to1.Run(src);
            dst3 = mat2to1.dst2;
        }
    }


    public class CS_Blur_Detection : CS_Parent
    {
        Laplacian_Basics laplace = new Laplacian_Basics();
        Blur_Basics blur = new Blur_Basics();

        public CS_Blur_Detection(VBtask task) : base(task)
        {
            SetSlider("Laplacian Threshold", 50);
            SetSlider("Blur Kernel Size", 11);
            labels = new string[] { "", "", "Draw a rectangle to blur a region in alternating frames and test further", "Detected blur in the highlight regions - non-blur is white." };
            desc = "Detect blur in an image";
        }

        public void RunCS(Mat src)
        {
            Rect r = new Rect(dst2.Width / 2 - 25, dst2.Height / 2 - 25, 50, 50);
            if (standaloneTest())
            {
                if (task.drawRect != new Rect()) r = task.drawRect;
                if (task.frameCount % 2 == 1)
                {
                    blur.Run(src[r]);
                    src[r] = blur.dst2;
                }
            }

            dst2 = src;
            laplace.Run(src);
            dst3 = laplace.dst2;

            Scalar mean, stdev;
            Cv2.MeanStdDev(dst2, out mean, out stdev);
            SetTrueText("Blur variance is " + (stdev.Val0 * stdev.Val0).ToString("F3"), 3);

            if (standaloneTest()) dst2.Rectangle(r, Scalar.White, task.lineWidth);
        }
    }

    public class CS_Blur_Depth : CS_Parent
    {
        Blur_Basics blur = new Blur_Basics();

        public CS_Blur_Depth(VBtask task) : base(task)
        {
            desc = "Blur the depth results to help find the boundaries to large depth regions";
        }

        public void RunCS(Mat src)
        {
            dst3 = task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(0, 255, ThresholdTypes.Binary);

            blur.Run(dst3);
            dst2 = blur.dst2;
        }
    }

    public class CS_Blur_TopoMap : CS_Parent
    {
        Gradient_CartToPolar gradient = new Gradient_CartToPolar();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        Options_BlurTopo options = new Options_BlurTopo();

        public CS_Blur_TopoMap(VBtask task) : base(task)
        {
            labels[2] = "Image Gradient";
            desc = "Create a topo map from the blurred image";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            gradient.Run(src);
            dst2 = gradient.magnitude;

            if (options.kernelSize > 1)
            {
                Cv2.GaussianBlur(dst2, dst3, new cv.Size(options.kernelSize, options.kernelSize), 0, 0);
            }
            dst3 = dst3.Normalize(255);
            dst3 = dst3.ConvertScaleAbs(255);

            dst3 = (dst3 * 1 / options.reduction).ToMat();
            dst3 = (dst3 * options.reduction).ToMat();

            addw.src2 = ShowPalette(dst3);
            addw.Run(task.color);
            dst3 = addw.dst2;

            labels[3] = "Blur = " + options.nextPercent.ToString() + "% Reduction Factor = " + options.reduction.ToString();
            if (task.frameCount % options.frameCycle == 0)
            {
                options.nextPercent -= 1;
            }
            if (options.nextPercent <= 0)
            {
                options.nextPercent = options.savePercent;
            }
        }
    }


    public class CS_BlurMotion_Basics : CS_Parent
    {
        public Mat kernel;
        public Options_MotionBlur options = new Options_MotionBlur();

        public CS_BlurMotion_Basics(VBtask task) : base(task)
        {
            desc = "Use Filter2D to create a motion blur";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest())
            {
                var blurSlider = FindSlider("Motion Blur Length");
                var blurAngleSlider = FindSlider("Motion Blur Angle");
                blurAngleSlider.Value = blurAngleSlider.Value < blurAngleSlider.Maximum ? blurAngleSlider.Value + 1 : blurAngleSlider.Minimum;
            }

            kernel = new Mat(options.kernelSize, options.kernelSize, MatType.CV_32F, Scalar.All(0));
            var pt1 = new cv.Point(0, (options.kernelSize - 1) / 2);
            var pt2 = new cv.Point(options.kernelSize * Math.Cos(options.theta) + pt1.X, options.kernelSize * Math.Sin(options.theta) + pt1.Y);
            kernel.Line(pt1, pt2, new Scalar(1.0 / options.kernelSize));
            dst2 = src.Filter2D(-1, kernel);

            pt1 += new cv.Point(src.Width / 2, src.Height / 2);
            pt2 += new cv.Point(src.Width / 2, src.Height / 2);

            if (options.showDirection)
            {
                dst2.Line(pt1, pt2, Scalar.Yellow, task.lineWidth + 3, task.lineType);
            }
        }
    }

    // https://docs.opencv.org/trunk/d1/dfd/tutorial_motion_deblur_filter.html
    public class CS_BlurMotion_Deblur : CS_Parent
    {
        CS_BlurMotion_Basics mblur;

        Mat calcPSF(cv.Size filterSize, int len, double theta)
        {
            var h = new Mat(filterSize, MatType.CV_32F, Scalar.All(0));
            var pt = new cv.Point(filterSize.Width / 2, filterSize.Height / 2);
            h.Ellipse(pt, new cv.Size(0, len / 2), 90 - theta, 0, 360, new Scalar(255), -1);
            var summa = Cv2.Sum(h);
            return h / summa[0];
        }

        Mat calcWeinerFilter(Mat input_h_PSF, double nsr)
        {
            var h_PSF_shifted = fftShift(input_h_PSF);
            var planes = new Mat[] { h_PSF_shifted.Clone(), new Mat(h_PSF_shifted.Size(), MatType.CV_32F, Scalar.All(0)) };
            var complexI = new Mat();
            Cv2.Merge(planes, complexI);
            Cv2.Dft(complexI, complexI);
            planes = Cv2.Split(complexI);
            var denom = new Mat();
            Cv2.Pow(Cv2.Abs(planes[0]), 2, denom);
            denom += nsr;
            var output_G = new Mat();
            Cv2.Divide(planes[0], denom, output_G);
            return output_G;
        }

        Mat fftShift(Mat inputImg)
        {
            var outputImg = inputImg.Clone();
            int cx = outputImg.Width / 2;
            int cy = outputImg.Height / 2;
            var q0 = new Mat(outputImg, new Rect(0, 0, cx, cy));
            var q1 = new Mat(outputImg, new Rect(cx, 0, cx, cy));
            var q2 = new Mat(outputImg, new Rect(0, cy, cx, cy));
            var q3 = new Mat(outputImg, new Rect(cx, cy, cx, cy));
            var tmp = q0.Clone();
            q3.CopyTo(q0);
            tmp.CopyTo(q3);
            q1.CopyTo(tmp);
            q2.CopyTo(q1);
            tmp.CopyTo(q2);
            return outputImg;
        }

        Mat edgeTaper(Mat inputImg, double gamma, double beta)
        {
            int nx = inputImg.Width;
            int ny = inputImg.Height;
            var w1 = new Mat(1, nx, MatType.CV_32F, Scalar.All(0));
            var w2 = new Mat(ny, 1, MatType.CV_32F, Scalar.All(0));

            float dx = (float)(2.0 * Math.PI / nx);
            float x = (float)-Math.PI;
            for (int i = 0; i < nx; i++)
            {
                w1.Set<float>(0, i, 0.5f * (float)(Math.Tanh((x + gamma / 2) / beta) - Math.Tanh((x - gamma / 2) / beta)));
                x += dx;
            }

            float dy = (float)(2.0 * Math.PI / ny);
            float y = (float)-Math.PI;
            for (int i = 0; i < ny; i++)
            {
                w2.Set<float>(i, 0, 0.5f * (float)(Math.Tanh((y + gamma / 2) / beta) - Math.Tanh((y - gamma / 2) / beta)));
                y += dy;
            }

            var w = w2 * w1;
            var outputImg = new Mat();
            Cv2.Multiply(inputImg, w, outputImg);
            return outputImg;
        }

        Mat filter2DFreq(Mat inputImg, Mat H)
        {
            var planes = new Mat[] { inputImg.Clone(), new Mat(inputImg.Size(), MatType.CV_32F, Scalar.All(0)) };
            var complexI = new Mat();
            Cv2.Merge(planes, complexI);
            Cv2.Dft(complexI, complexI, DftFlags.Scale);
            var planesH = new Mat[] { H.Clone(), new Mat(H.Size(), MatType.CV_32F, Scalar.All(0)) };
            var complexH = new Mat();
            Cv2.Merge(planesH, complexH);
            var complexIH = new Mat();
            Cv2.MulSpectrums(complexI, complexH, complexIH, 0);
            Cv2.Idft(complexIH, complexIH);
            planes = Cv2.Split(complexIH);
            return planes[0];
        }

        public CS_BlurMotion_Deblur(VBtask task) : base(task)
        {
            mblur = new CS_BlurMotion_Basics(task);
            desc = "Deblur a motion blurred image";
            labels[2] = "Blurred Image Input";
            labels[3] = "Deblurred Image Output";
        }

        public void RunCS(Mat src)
        {
            mblur.options.RunVB();

            if (task.heartBeat)
            {
                mblur.options.redoCheckBox.Checked = true;
            }

            if (mblur.options.redoCheckBox.Checked)
            {
                mblur.RunAndMeasure(src, mblur);
                mblur.options.showDirection = false;
                mblur.options.redoCheckBox.Checked = false;
            }
            else
            {
                mblur.RunAndMeasure(src, mblur);
            }

            dst2 = mblur.dst2;
            double beta = 0.2;

            int width = src.Width;
            int height = src.Height;
            var roi = new Rect(0, 0, width % 2 == 0 ? width : width - 1, height % 2 == 0 ? height : height - 1);

            var h = calcPSF(roi.Size, mblur.options.restoreLen, mblur.options.theta);
            var hW = calcWeinerFilter(h, 1.0 / mblur.options.SNR);

            var gray8u = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            var imgIn = new Mat();
            gray8u.ConvertTo(imgIn, MatType.CV_32F);
            imgIn = edgeTaper(imgIn, mblur.options.gamma, beta);

            var imgOut = filter2DFreq(imgIn[roi], hW);
            imgOut.ConvertTo(dst3, MatType.CV_8U);
            dst3.Normalize(0, 255, NormTypes.MinMax);
        }
    }



    public class CS_Boundary_Basics : CS_Parent
    {
        public RedCloud_CPP redCPP = new RedCloud_CPP();
        public List<Rect> rects = new List<Rect>();
        public List<Mat> masks = new List<Mat>();
        public List<List<cv.Point>> contours = new List<List<cv.Point>>();
        public bool runRedCPP = true;
        Color8U_Basics cvt;
        RedCloud_Reduce prep;
        GuidedBP_Depth guided;

        public CS_Boundary_Basics(VBtask task) : base(task)
        {
            cvt = new Color8U_Basics();
            prep = new RedCloud_Reduce();
            guided = new GuidedBP_Depth();
            task.redOptions.setColorSource("Bin4Way_Regions");
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Create a mask of the RedCloud cell boundaries";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
            {
                if (task.redOptions.useColorOnlyChecked)
                {
                    cvt.Run(src);
                    dst1 = cvt.dst2;
                }
                else if (task.redOptions.useDepthChecked)
                {
                    prep.Run(src);
                    dst1 = prep.dst2;
                }
                else
                {
                    guided.Run(src);
                    dst1 = guided.dst2;
                }
            }

            if (runRedCPP)
            {
                redCPP.Run(dst1);

                dst2.SetTo(0);
                rects.Clear();
                masks.Clear();
                contours.Clear();
                for (int i = 1; i < redCPP.classCount; i++)
                {
                    var rect = redCPP.rectList[i - 1];
                    var mask = redCPP.dst2[rect].InRange(i, i);
                    var contour = ContourBuild(mask, ContourApproximationModes.ApproxNone);
                    DrawContour(dst2[rect], contour, 255, task.lineWidth);
                    rects.Add(rect);
                    masks.Add(mask);
                    contours.Add(contour);
                }

                labels[2] = $"{redCPP.classCount} cells were found.";
            }
        }
    }

    public class CS_Boundary_Tiers : CS_Parent
    {
        Boundary_Basics cells = new Boundary_Basics();
        Contour_DepthTiers contours = new Contour_DepthTiers();

        public CS_Boundary_Tiers(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Add the depth tiers to the cell boundaries";
        }

        public void RunCS(Mat src)
        {
            cells.Run(src);
            dst3 = cells.dst2;

            contours.Run(src);
            dst2.SetTo(0);
            foreach (var tour in contours.contourlist)
            {
                DrawContour(dst2, tour.ToList(), 255, 2);
            }
            labels[2] = $"{contours.contourlist.Count} depth tiers were found.";
            labels[3] = cells.labels[2];
        }
    }

    public class CS_Boundary_Rectangles : CS_Parent
    {
        public Boundary_Basics bounds = new Boundary_Basics();
        public List<Rect> rects = new List<Rect>();
        public List<Rect> smallRects = new List<Rect>();
        public List<List<cv.Point>> smallContours = new List<List<cv.Point>>();
        public Options_BoundaryRect options = new Options_BoundaryRect();
        public CS_Boundary_Rectangles(VBtask task) : base(task)
        {
            desc = "Build the boundaries for redCells and remove interior rectangles";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            bounds.Run(src);

            dst2.SetTo(0);
            foreach (var r in bounds.rects)
            {
                dst2.Rectangle(r, task.HighlightColor, task.lineWidth);
            }
            labels[2] = $"{bounds.rects.Count} rectangles before contain test";

            rects.Clear();
            smallRects.Clear();
            smallContours.Clear();
            for (int i = 0; i < bounds.rects.Count * options.percentRect; i++)
            {
                rects.Add(bounds.rects[i]);
            }
            for (int i = bounds.rects.Count - 1; i >= (int)(bounds.rects.Count * options.percentRect); i--)
            {
                var r = bounds.rects[i];
                bool contained = false;
                foreach (var rect in bounds.rects)
                {
                    if (r == rect) continue;
                    if (rect.Contains(r))
                    {
                        contained = true;
                        break;
                    }
                }

                if (contained)
                {
                    smallContours.Add(bounds.contours[i]);
                    smallRects.Add(r);
                }
                else
                {
                    rects.Add(r);
                }
            }

            dst3.SetTo(0);
            foreach (var r in rects)
            {
                dst3.Rectangle(r, task.HighlightColor, task.lineWidth);
            }
            labels[3] = $"{rects.Count} rectangles after contain test";
        }
    }

    public class CS_Boundary_RemovedRects : CS_Parent
    {
        public Boundary_Rectangles bRects = new Boundary_Rectangles();

        public CS_Boundary_RemovedRects(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            desc = "Build the boundaries for redCells and remove interior rectangles";
        }

        public void RunCS(Mat src)
        {
            bRects.Run(src);
            dst2 = bRects.bounds.dst2.Clone();
            dst3 = bRects.dst2;
            dst1 = bRects.dst3;
            labels[3] = $"{bRects.bounds.rects.Count} cells before contain test";

            for (int i = 0; i < bRects.smallRects.Count; i++)
            {
                DrawContour(dst2[bRects.smallRects[i]], bRects.smallContours[i], Scalar.Black, task.lineWidth);
            }
            labels[1] = labels[2];
            labels[2] = $"{bRects.bounds.rects.Count - bRects.smallRects.Count} cells after contain test";
        }
    }

    public class CS_Boundary_Overlap : CS_Parent
    {
        Boundary_Basics bounds = new Boundary_Basics();

        public CS_Boundary_Overlap(VBtask task) : base(task)
        {
            dst2 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            desc = "Determine if 2 contours overlap";
        }

        public void RunCS(Mat src)
        {
            bounds.Run(src);
            dst3 = bounds.dst2;
            bool overlapping = false;
            for (int i = 0; i < bounds.contours.Count; i++)
            {
                var tour = bounds.contours[i];
                var rect = bounds.rects[i];
                for (int j = i + 1; j < bounds.contours.Count; j++)
                {
                    var r = bounds.rects[j];
                    if (r.IntersectsWith(rect))
                    {
                        dst2.SetTo(0);
                        int c1 = tour.Count;
                        int c2 = bounds.contours[j].Count;
                        DrawContour(dst2[rect], tour, 127, task.lineWidth);
                        DrawContour(dst2[r], bounds.contours[j], 255, task.lineWidth);
                        int count = dst2.CountNonZero();
                        if (count != c1 + c2)
                        {
                            overlapping = true;
                            break;
                        }
                    }
                }
                if (overlapping) break;
            }
        }
    }




    public class CS_Brightness_Basics : CS_Parent
    {
        Options_BrightnessContrast Options = new Options_BrightnessContrast();

        public CS_Brightness_Basics(VBtask task) : base(task)
        {
            desc = "Implement a brightness effect";
        }

        public void RunCS(Mat src)
        {
            Options.RunVB();

            dst2 = src.ConvertScaleAbs(Options.brightness, Options.contrast);
            labels[3] = "Brightness level = " + Options.contrast.ToString();
        }
    }

    // https://github.com/spmallick/learnopencv/blob/master/Photoshop-Filters-in-OpenCV/brightness.cpp
    public class CS_Brightness_HSV : CS_Parent
    {
        Options_BrightnessContrast Options = new Options_BrightnessContrast();

        public CS_Brightness_HSV(VBtask task) : base(task)
        {
            labels[3] = "HSV image";
            desc = "Implement the brightness effect for HSV images";
        }

        public void RunCS(Mat src)
        {
            Options.RunVB();

            dst3 = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Mat hsv64 = new Mat();
            dst3.ConvertTo(hsv64, MatType.CV_64F);
            Mat[] split = hsv64.Split();

            split[1] *= Options.hsvBrightness;
            split[1] = split[1].Threshold(255, 255, ThresholdTypes.Trunc);

            split[2] *= Options.hsvBrightness;
            split[2] = split[2].Threshold(255, 255, ThresholdTypes.Trunc);

            Cv2.Merge(split, hsv64);
            hsv64.ConvertTo(dst2, MatType.CV_8UC3);
            dst2 = dst2.CvtColor(ColorConversionCodes.HSV2BGR);
            labels[2] = "Brightness level = " + Options.hsvBrightness.ToString();
        }
    }



    public class CS_BRISK_Basics : CS_Parent
    {
        BRISK brisk;
        public List<cv.Point2f> features = new List<cv.Point2f>();
        Options_Features options = new Options_Features();

        public CS_BRISK_Basics(VBtask task) : base(task)
        {
            brisk = BRISK.Create();
            UpdateAdvice(traceName + ": only the 'Min Distance' option affects the BRISK results.");
            desc = "Detect features with BRISK";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            src.CopyTo(dst2);

            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            KeyPoint[] keyPoints = brisk.Detect(src);

            features.Clear();
            foreach (var pt in keyPoints)
            {
                if (pt.Size > options.minDistance)
                {
                    features.Add(new cv.Point2f(pt.Pt.X, pt.Pt.Y));
                    DrawCircle(dst2, pt.Pt, task.DotSize + 1, task.HighlightColor);
                }
            }
            labels[2] = features.Count + " features found with BRISK";
        }
    }





    public class CS_BackProject2D_Basics : CS_Parent
    {
        public Hist2D_Basics hist2d = new Hist2D_Basics();
        public Color_Basics colorFmt = new Color_Basics();
        public bool backProjectByGrid;
        public int classCount;

        public CS_BackProject2D_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": the global option 'Histogram Bins' controls the histogram.");
            desc = "A 2D histogram is built from 2 channels of any 3-channel input and the results are displayed.";
        }

        public void RunCS(Mat src)
        {
            int index = task.gridMap.At<int>(task.mouseMovePoint.Y, task.mouseMovePoint.X);
            var roi = task.gridList[index];

            colorFmt.Run(src);
            hist2d.Run(colorFmt.dst2);
            dst2 = hist2d.dst2;

            if (standaloneTest())
            {
                dst2.Rectangle(roi, Scalar.White, task.lineWidth, task.lineType);
            }

            Mat histogram = new Mat();
            if (backProjectByGrid)
            {
                task.gridMap.ConvertTo(histogram, MatType.CV_32F);
            }
            else
            {
                histogram = new Mat(hist2d.histogram.Size(), MatType.CV_32F, 0);
                hist2d.histogram[roi].CopyTo(histogram[roi]);
            }
            Cv2.CalcBackProject(new[] { colorFmt.dst2 }, hist2d.channels, histogram, dst0, hist2d.ranges);

            int bpCount = hist2d.histogram[roi].CountNonZero();

            if (backProjectByGrid)
            {
                var mm = GetMinMax(dst0);
                classCount = (int)mm.maxVal;
                task.palette.Run(dst0 * 255 / classCount);
                dst3 = task.palette.dst2;
            }
            else
            {
                dst3.SetTo(Scalar.All(0));
                dst3.SetTo(Scalar.Yellow, dst0);
            }
            if (task.heartBeat)
            {
                labels[2] = colorFmt.options.colorFormat + " format " + (classCount > 0 ? classCount + " classes" : " ");
                int c1 = task.redOptions.channels[0], c2 = task.redOptions.channels[1];
                labels[3] = "That combination of channel " + c1 + "/" + c2 + " has " + bpCount +
                            " pixels while image total is " + dst0.Total().ToString("0");
            }
            SetTrueText("Use Global Algorithm Option 'Grid Square Size' to control the 2D backprojection",
                        new cv.Point(10, dst3.Height - 20), 3);
        }
    }





    public class CS_BackProject2D_Compare : CS_Parent
    {
        PhotoShop_Hue hueSat = new PhotoShop_Hue();
        CS_BackProject2D_Basics backP;
        Mat_4Click mats = new Mat_4Click();

        public CS_BackProject2D_Compare(VBtask task) : base(task)
        {
            backP = new CS_BackProject2D_Basics(task);
            labels[2] = "Hue (upper left), sat (upper right), highlighted backprojection (bottom left)";
            if (standaloneTest()) task.gOptions.setGridSize(10);
            desc = "Compare the hue and brightness images and the results of the Hist_backprojection2d";
        }

        public void RunCS(Mat src)
        {
            hueSat.Run(src.Clone());
            mats.mat[0] = hueSat.dst2;
            mats.mat[1] = hueSat.dst3;

            backP.RunAndMeasure(src, backP);
            mats.mat[2] = backP.dst3;

            if (task.FirstPass) mats.quadrant = RESULT_DST3;
            mats.Run(Mat.Zeros(src.Size(), MatType.CV_8UC3));
            dst2 = mats.dst2;
            dst3 = mats.dst3;

            labels[3] = backP.labels[3];

            SetTrueText("Use Global Algorithm Option 'Grid Square Size' to control this 2D histogram.\n" +
                        "Move mouse in 2D histogram to select a cell to backproject.\n" +
                        "Click any quadrant at left to display that quadrant here.\n",
                        new cv.Point(10, dst3.Height - dst3.Height / 4), 3);
        }
    }

    





    public class CS_BackProject2D_Top : CS_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();

        public CS_BackProject2D_Top(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Top Down HeatMap", "BackProject2D for the top-down view" };
            desc = "Backproject the output of the Top View.";
        }

        public void RunCS(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst2;

            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsTop, heat.histogramTop, dst3, task.rangesTop);
            dst3 = GetNormalize32f(dst3);
            dst3 = ShowPalette(dst3);
        }
    }

    public class CS_BackProject2D_Side : CS_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();

        public CS_BackProject2D_Side(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Side View HeatMap", "BackProject2D for the side view" };
            desc = "Backproject the output of the Side View.";
        }

        public void RunCS(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst3;

            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsSide, heat.histogramSide, dst3, task.rangesSide);
            dst3 = GetNormalize32f(dst3);
            dst3 = ShowPalette(dst3);
        }
    }

    public class CS_BackProject2D_Filter : CS_Parent
    {
        public int threshold;

        public CS_BackProject2D_Filter(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_32FC3, 0);
            task.gOptions.setHistogramBins(100); // extra bins to help isolate the stragglers.
            desc = "Filter a 2D histogram for the backprojection.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                Cv2.CalcHist(new Mat[] { task.pointCloud }, task.channelsSide, new Mat(), dst1, 2, task.bins2D, task.rangesSide);
            }
            dst1.Col(0).SetTo(0);

            dst2 = dst1.Threshold(threshold, 255, cv.ThresholdTypes.Binary);
        }
    }





    public class CS_BackProject2D_FilterSide : CS_Parent
    {
        public BackProject2D_Filter filter = new BackProject2D_Filter();
        Options_HistXD options = new Options_HistXD();

        public CS_BackProject2D_FilterSide(VBtask task) : base(task)
        {
            desc = "Backproject the output of the Side View after removing low sample bins.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat histogram = new Mat();
            Cv2.CalcHist(new Mat[] { task.pointCloud }, task.channelsSide, new Mat(), histogram, 2, task.bins2D, task.rangesSide);

            filter.threshold = options.sideThreshold;
            filter.histogram = histogram;
            filter.Run(src);

            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsSide, filter.dst2, dst1, task.rangesSide);
            dst1.ConvertTo(dst1, MatType.CV_8U);

            dst2.SetTo(0);
            task.pointCloud.CopyTo(dst2, dst1);
        }
    }





    public class CS_BackProject2D_FilterTop : CS_Parent
    {
        BackProject2D_Filter filter = new BackProject2D_Filter();
        Options_HistXD options = new Options_HistXD();

        public CS_BackProject2D_FilterTop(VBtask task) : base(task)
        {
            desc = "Backproject the output of the Side View after removing low sample bins.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat histogram = new Mat();
            Cv2.CalcHist(new Mat[] { task.pointCloud }, task.channelsSide, new Mat(), histogram, 2, task.bins2D, task.rangesSide);

            filter.threshold = options.topThreshold;
            filter.histogram = histogram;
            filter.Run(src);

            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsTop, filter.dst2, dst1, task.rangesTop);
            dst1.ConvertTo(dst1, MatType.CV_8U);

            dst2.SetTo(0);
            task.pointCloud.CopyTo(dst2, dst1);
        }
    }

    public class CS_BackProject2D_FilterBoth : CS_Parent
    {
        BackProject2D_FilterSide filterSide = new BackProject2D_FilterSide();
        BackProject2D_FilterTop filterTop = new BackProject2D_FilterTop();

        public CS_BackProject2D_FilterBoth(VBtask task) : base(task)
        {
            desc = "Backproject the output of the both the top and side views after removing low sample bins.";
        }

        public void RunCS(Mat src)
        {
            filterSide.Run(src);
            filterTop.Run(src);

            dst2.SetTo(0);
            task.pointCloud.CopyTo(dst2, filterSide.dst1);
            task.pointCloud.CopyTo(dst3, filterTop.dst1);
        }
    }




    public class CS_BackProject2D_Full : CS_Parent
    {
        CS_BackProject2D_Basics backP;
        public int classCount;

        public CS_BackProject2D_Full(VBtask task) : base(task)
        {
            backP = new CS_BackProject2D_Basics(task);
            backP.backProjectByGrid = true;
            desc = "Backproject the 2D histogram marking each grid element's backprojection";
        }

        public void RunCS(Mat src)
        {
            backP.RunAndMeasure(src, backP);
            dst2 = backP.dst0;
            dst3 = backP.dst3;
            classCount = backP.classCount;
            labels = backP.labels;
        }
    }



    public class CS_CameraMotion_Basics : CS_Parent
    {
        public int translationX;
        public int translationY;
        Gravity_Horizon gravity = new Gravity_Horizon();
        public bool secondOpinion;
        Swarm_Basics feat = new Swarm_Basics();
        PointPair gravityVec;
        PointPair horizonVec;
        public CS_CameraMotion_Basics(VBtask task) : base(task)
        {
            dst2 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            dst3 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            task.gOptions.setDebugSlider(3);
            desc = "Merge with previous image using just translation of the gravity vector and horizon vector (if present)";
        }

        public void RunCS(Mat src)
        {
            gravity.Run(src);

            if (task.FirstPass)
            {
                gravityVec = new PointPair(task.gravityVec.p1, task.gravityVec.p2);
                horizonVec = new PointPair(task.horizonVec.p1, task.horizonVec.p2);
            }

            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            translationX = task.gOptions.DebugSliderValue;
            translationY = task.gOptions.DebugSliderValue;

            if (Math.Abs(translationX) >= dst2.Width / 2)
                translationX = 0;

            if (horizonVec.p1.Y >= dst2.Height || horizonVec.p2.Y >= dst2.Height || Math.Abs(translationY) >= dst2.Height / 2)
            {
                horizonVec = new PointPair(new Point2f(), new Point2f(336, 0));
                translationY = 0;
            }

            Rect r1, r2;
            if (translationX == 0 && translationY == 0)
            {
                dst2 = src;
                task.camMotionPixels = 0;
                task.camDirection = 0;
            }
            else
            {
                r1 = new Rect(translationX, translationY, Math.Min(dst2.Width - translationX * 2, dst2.Width),
                              Math.Min(dst2.Height - translationY * 2, dst2.Height));
                if (r1.X < 0)
                {
                    r1.X = -r1.X;
                    r1.Width += translationX * 2;
                }
                if (r1.Y < 0)
                {
                    r1.Y = -r1.Y;
                    r1.Height += translationY * 2;
                }

                r2 = new Rect(Math.Abs(translationX), Math.Abs(translationY), r1.Width, r1.Height);

                task.camMotionPixels = (float)Math.Sqrt(translationX * translationX + translationY * translationY);
                if (translationX == 0)
                {
                    if (translationY < 0)
                        task.camDirection = (float)Math.PI / 4;
                    else
                        task.camDirection = (float)Math.PI * 3 / 4;
                }
                else
                {
                    task.camDirection = (float)Math.Atan2(translationY, translationX);
                }

                if (secondOpinion)
                {
                    dst3.SetTo(0);
                    feat.Run(src);
                    strOut = "Swarm distance = " + feat.distanceAvg.ToString("F1") + " when camMotionPixels = " + task.camMotionPixels.ToString("F1");
                    if (feat.distanceAvg < task.camMotionPixels / 2 || task.heartBeat)
                    {
                        task.camMotionPixels = 0;
                        src.CopyTo(dst2);
                    }
                    dst3 = (src - dst2).ToMat().Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
                }
            }

            gravityVec = new PointPair(task.gravityVec.p1, task.gravityVec.p2);
            horizonVec = new PointPair(task.horizonVec.p1, task.horizonVec.p2);
            SetTrueText(strOut, 3);

            labels[2] = "Translation (X, Y) = (" + translationX.ToString() + ", " + translationY.ToString() + ")" +
                        (horizonVec.p1.Y == 0 && horizonVec.p2.Y == 0 ? " there is no horizon present" : "");
            labels[3] = "Camera direction (radians) = " + task.camDirection.ToString("F1") + " with distance = " + task.camMotionPixels.ToString("F1");
        }
    }




    public class CS_CameraMotion_WithRotation : CS_Parent
    {
        public float translationX;
        public float rotationX;
        public Point2f centerX;
        public float translationY;
        public float rotationY;
        public Point2f centerY;
        public Rotate_BasicsQT rotate = new Rotate_BasicsQT();
        PointPair gravityVec;
        PointPair horizonVec;
        public CS_CameraMotion_WithRotation(VBtask task) : base(task)
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst1.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Merge with previous image using rotation AND translation of the camera motion - not as good as translation alone.";
        }
        public void translateRotateX(int x1, int x2)
        {
            rotationX = (float)(Math.Atan(Math.Abs(x1 - x2) / (double)dst2.Height) * 57.2958);
            centerX = new Point2f((task.gravityVec.p1.X + task.gravityVec.p2.X) / 2, (task.gravityVec.p1.Y + task.gravityVec.p2.Y) / 2);
            if (x1 >= 0 && x2 > 0)
            {
                translationX = x1 > x2 ? x1 - x2 : x2 - x1;
                centerX = task.gravityVec.p2;
            }
            else if (x1 <= 0 && x2 < 0)
            {
                translationX = x1 > x2 ? x1 - x2 : x2 - x1;
                centerX = task.gravityVec.p1;
            }
            else if (x1 < 0 && x2 > 0)
            {
                translationX = 0;
            }
            else
            {
                translationX = 0;
                rotationX *= -1;
            }
        }
        public void translateRotateY(int y1, int y2)
        {
            rotationY = (float)(Math.Atan(Math.Abs(y1 - y2) / (double)dst2.Width) * 57.2958);
            centerY = new Point2f((task.horizonVec.p1.X + task.horizonVec.p2.X) / 2, (task.horizonVec.p1.Y + task.horizonVec.p2.Y) / 2);
            if (y1 > 0 && y2 > 0)
            {
                translationY = y1 > y2 ? y1 - y2 : y2 - y1;
                centerY = task.horizonVec.p2;
            }
            else if (y1 < 0 && y2 < 0)
            {
                translationY = y1 > y2 ? y1 - y2 : y2 - y1;
                centerY = task.horizonVec.p1;
            }
            else if (y1 < 0 && y2 > 0)
            {
                translationY = 0;
            }
            else
            {
                translationY = 0;
                rotationY *= -1;
            }
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass)
            {
                gravityVec = task.gravityVec;
                horizonVec = task.horizonVec;
            }
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            int x1 = (int)(gravityVec.p1.X - task.gravityVec.p1.X);
            int x2 = (int)(gravityVec.p2.X - task.gravityVec.p2.X);
            int y1 = (int)(horizonVec.p1.Y - task.horizonVec.p1.Y);
            int y2 = (int)(horizonVec.p2.Y - task.horizonVec.p2.Y);
            translateRotateX(x1, x2);
            translateRotateY(y1, y2);
            dst1.SetTo(Scalar.All(0));
            dst3.SetTo(Scalar.All(0));
            if (Math.Abs(x1 - x2) > 0.5 || Math.Abs(y1 - y2) > 0.5)
            {
                Rect r1 = new Rect((int)translationX, (int)translationY, dst2.Width - (int)translationX, dst2.Height - (int)translationY);
                Rect r2 = new Rect(0, 0, r1.Width, r1.Height);
                src[r1].CopyTo(dst1[r2]);
                rotate.rotateAngle = rotationY;
                rotate.rotateCenter = centerY;
                rotate.Run(dst1);
                dst2 = rotate.dst2;
                dst3 = (src - dst2).ToMat().Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            }
            else
            {
                dst2 = src;
            }
            gravityVec = task.gravityVec;
            horizonVec = task.horizonVec;
            labels[2] = "Translation X = " + translationX.ToString(fmt1) + " rotation X = " + rotationX.ToString(fmt1) + " degrees " +
                        " center of rotation X = " + centerX.X.ToString(fmt0) + ", " + centerX.Y.ToString(fmt0);
            labels[3] = "Translation Y = " + translationY.ToString(fmt1) + " rotation Y = " + rotationY.ToString(fmt1) + " degrees " +
                        " center of rotation Y = " + centerY.X.ToString(fmt0) + ", " + centerY.Y.ToString(fmt0);
        }
    }
    public class CS_CameraMotion_SceneMotion : CS_Parent
    {
        CameraMotion_Basics cMotion = new CameraMotion_Basics();
        Motion_Basics motion = new Motion_Basics();
        public CS_CameraMotion_SceneMotion(VBtask task) : base(task)
        {
            labels[2] = "Image after adjusting for camera motion.";
            desc = "Display both camera motion (on heartbeats) and scene motion.";
        }
        public void RunCS(Mat src)
        {
            cMotion.Run(src);
            dst2 = cMotion.dst3;
            motion.Run(src);
            dst3 = motion.dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }




    public class CS_CamShift_Basics : CS_Parent
    {
        public RotatedRect trackBox = new RotatedRect();
        CamShift_RedHue redHue = new CamShift_RedHue();
        Rect roi = new Rect();
        Mat histogram = new Mat();
        public CS_CamShift_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": Draw on any available red hue area.");
            labels[2] = "Draw anywhere to create histogram and start camshift";
            labels[3] = "Histogram of targeted region (hue only)";
            UpdateAdvice(traceName + ": click 'Show All' to control camShift options.");
            desc = "CamShift Demo - draw on the images to define the object to track.";
        }
        public void RunCS(Mat src)
        {
            redHue.RunVB(src);
            dst2 = redHue.dst2;
            Mat hue = redHue.dst1;
            Mat mask = redHue.dst3;
            Rangef[] ranges = { new Rangef(0, 180) };
            int[] hsize = { task.histogramBins };
            task.drawRect = ValidateRect(task.drawRect);
            Cv2.CalcHist(new Mat[] { hue[task.drawRect] }, new int[] { 0 }, mask[task.drawRect], histogram, 1, hsize, ranges);
            histogram = histogram.Normalize(0, 255, NormTypes.MinMax);
            roi = task.drawRect;
            if (histogram.Rows != 0)
            {
                Cv2.CalcBackProject(new Mat[] { hue }, new int[] { 0 }, histogram, dst1, ranges);
                trackBox = Cv2.CamShift(dst1 & mask, ref roi, new TermCriteria(cv.CriteriaTypes.MaxIter, 10, 1));
                dst3 = Show_HSV_Hist(histogram);
                if (dst3.Channels() == 1) dst3 = src;
                dst3 = dst3.CvtColor(ColorConversionCodes.HSV2BGR);
            }
            if (trackBox.Size.Width > 0)
            {
                dst2.Ellipse(trackBox, Scalar.White, task.lineWidth + 1, task.lineType);
            }
        }
    }
    public class CS_CamShift_RedHue : CS_Parent
    {
        Options_CamShift options = new Options_CamShift();
        public CS_CamShift_RedHue(VBtask task) : base(task)
        {
            labels = new string[] { "", "Hue", "Image regions with red hue", "Mask for hue regions" };
            desc = "Find that portion of the image where red dominates";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            dst3 = hsv.InRange(options.camSBins, new Scalar(180, 255, options.camMax));
            dst2.SetTo(0);
            src.CopyTo(dst2, dst3);
        }
    }





    public class CS_Cartoonify_Basics : CS_Parent
    {
        Options_Cartoonify options = new Options_Cartoonify();
        public CS_Cartoonify_Basics(VBtask task) : base(task)
        {
            labels[2] = "Mask for Cartoon";
            labels[3] = "Cartoonify Result";
            UpdateAdvice(traceName + ": click 'Show All' to control cartoonify options.");
            desc = "Create a cartoon from a color image";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat gray8u = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            gray8u = gray8u.MedianBlur(options.medianBlur);
            Mat edges = gray8u.Laplacian(MatType.CV_8U, options.kernelSize);
            Mat mask = edges.Threshold(options.threshold, 255, ThresholdTypes.Binary);
            dst2 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3 = src.MedianBlur(options.medianBlur2).MedianBlur(options.medianBlur2);
            src.CopyTo(dst3, mask);
        }
    }






    public class CS_Pixel_Unstable : CS_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        List<int> pixelCounts = new List<int>();
        int k = -1;
        List<Mat> unstable = new List<Mat>();
        Mat lastImage;
        public Mat unstablePixels = new Mat();
        System.Windows.Forms.TrackBar kSlider;
        public CS_Pixel_Unstable(VBtask task) : base(task)
        {
            task.gOptions.setPixelDifference(2);
            kSlider = FindSlider("KMeans k");
            labels[2] = "KMeans_Basics output";
            desc = "Detect where pixels are unstable";
        }
        public void RunCS(Mat src)
        {
            k = kSlider.Value;
            km.Run(src);
            dst2 = km.dst2;
            dst2.ConvertTo(dst2, MatType.CV_32F);
            if (lastImage == null) lastImage = dst2.Clone();
            Cv2.Subtract(dst2, lastImage, dst3);
            dst3 = dst3.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            unstable.Add(dst3);
            if (unstable.Count > task.frameHistoryCount) unstable.RemoveAt(0);
            unstablePixels = unstable[0];
            for (int i = 1; i < unstable.Count; i++)
            {
                unstablePixels = unstablePixels | unstable[i];
            }
            dst3 = unstablePixels;
            int unstableCount = dst3.CountNonZero();
            pixelCounts.Add(unstableCount);
            if (pixelCounts.Count > 100) pixelCounts.RemoveAt(0);
            // compute stdev from the list
            double avg = pixelCounts.Average();
            double sum = pixelCounts.Sum(d => Math.Pow(d - avg, 2));
            double stdev = Math.Sqrt(sum / pixelCounts.Count);
            labels[3] = "Unstable pixel count = " + avg.ToString("###,##0") + "    stdev = " + stdev.ToString("0.0");
            lastImage = dst2.Clone();
        }
    }




    public class CS_CComp_Basics : CS_Parent
    {
        public ConnectedComponents connectedComponents;
        public List<Rect> rects = new List<Rect>();
        public List<Point2f> centroids = new List<Point2f>();
        Mat lastImage;
        Options_CComp options = new Options_CComp();
        public CS_CComp_Basics(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            UpdateAdvice(traceName + ": only the local options for threshold is used in CS_CComp_Basics.");
            labels[2] = "Input to ConnectedComponenetsEx";
            desc = "Draw bounding boxes around BGR binarized connected Components";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            rects.Clear();
            centroids.Clear();
            Mat input = src;
            if (input.Channels() == 3)
                input = input.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = input.Threshold(options.threshold, 255, ThresholdTypes.BinaryInv);
            connectedComponents = Cv2.ConnectedComponentsEx(dst2);
            connectedComponents.RenderBlobs(dst3);
            int count = 0;
            foreach (var blob in connectedComponents.Blobs)
            {
                var rect = ValidateRect(blob.Rect);
                var m = Cv2.Moments(dst2[rect], true);
                if (m.M00 == 0) continue; // avoid divide by zero...
                rects.Add(rect);
                centroids.Add(new Point2f((float)(m.M10 / m.M00 + rect.X), (float)(m.M01 / m.M00 + rect.Y)));
                count++;
            }
            lastImage = dst2;
            labels[3] = count + " items found ";
        }
    }




    public class CS_CComp_Shapes : CS_Parent
    {
        Mat shapes;
        Mat_4Click mats = new Mat_4Click();
        public CS_CComp_Shapes(VBtask task) : base(task)
        {
            shapes = new Mat(task.HomeDir + "Data/Shapes.png", ImreadModes.Color);
            labels[2] = "Largest connected component";
            labels[3] = "RectView, LabelView, Binary, grayscale";
            desc = "Use connected components to isolate objects in image.";
        }
        public void RunCS(Mat src)
        {
            var gray = shapes.CvtColor(ColorConversionCodes.BGR2GRAY);
            var binary = gray.Threshold(0, 255, ThresholdTypes.Otsu | ThresholdTypes.Binary);
            var labelview = shapes.EmptyClone();
            var rectView = binary.CvtColor(ColorConversionCodes.GRAY2BGR);
            var cc = Cv2.ConnectedComponentsEx(binary);
            if (cc.LabelCount <= 1) return;
            cc.RenderBlobs(labelview);
            foreach (var blob in cc.Blobs.Skip(1))
            {
                rectView.Rectangle(blob.Rect, Scalar.Red, 2);
            }
            var maxBlob = cc.GetLargestBlob();
            var filtered = new Mat();
            cc.FilterByBlob(shapes, filtered, maxBlob);
            mats.mat[0] = rectView;
            mats.mat[1] = labelview;
            mats.mat[2] = binary;
            mats.mat[3] = gray;
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }




    public class CS_CComp_Both : CS_Parent
    {
        CComp_Stats above = new CComp_Stats();
        CComp_Stats below = new CComp_Stats();
        public CS_CComp_Both(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Connected components in both the lighter and darker halves", "Connected components in the darker half of the image" };
            desc = "Prepare the connected components for both above and below the threshold";
        }
        public void RunCS(Mat src)
        {
            above.options.RunVB();
            var light = src.Threshold(above.options.light, 255, ThresholdTypes.Binary);
            below.Run(light);
            dst2 = below.dst3;
            dst1 = below.dst1;
            labels[3] = above.labels[3];
        }
    }



    public class CS_CComp_Hulls : CS_Parent
    {
        CComp_Both ccomp = new CComp_Both();
        RedCloud_Hulls hulls = new RedCloud_Hulls();
        public CS_CComp_Hulls(VBtask task) : base(task)
        {
            desc = "Create connected components using RedCloud Hulls";
        }
        public void RunCS(Mat src)
        {
            ccomp.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = ccomp.dst3;
            ccomp.dst1.ConvertTo(dst1, MatType.CV_8U);
            hulls.Run(dst1);
            dst2 = hulls.dst3;
            labels[2] = hulls.labels[3];
        }
    }





    // https://docs.opencv.org/master/de/d01/samples_2cpp_2connected_components_8cpp-example.html
    public class CS_CComp_Stats : CS_Parent
    {
        public List<Mat> masks = new List<Mat>();
        public List<Rect> rects = new List<Rect>();
        public List<int> areas = new List<int>();
        public List<cv.Point> centroids = new List<cv.Point>();
        public int numberOfLabels;
        public Options_CComp options = new Options_CComp();
        public CS_CComp_Stats(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "Use a threshold slider on the CComp input";
        }
        public void RunCS(Mat src)
        {
            dst2 = src;
            options.RunVB();
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (standaloneTest())
                src = src.Threshold(options.light, 255, ThresholdTypes.BinaryInv);
            Mat stats = new Mat();
            Mat centroidRaw = new Mat();
            numberOfLabels = Cv2.ConnectedComponentsWithStats(src, dst1, stats, centroidRaw);
            rects.Clear();
            areas.Clear();
            centroids.Clear();
            List<Vec3b> colors = new List<Vec3b>();
            SortedList<float, int> maskOrder = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
            List<Mat> unsortedMasks = new List<Mat>();
            List<Rect> unsortedRects = new List<Rect>();
            List<cv.Point> unsortedCentroids = new List<cv.Point>();
            List<int> index = new List<int>();
            for (int i = 0; i < Math.Min(256, stats.Rows); i++)
            {
                int area = stats.Get<int>(i, 4);
                if (area < 10) continue;
                Rect r1 = ValidateRect(stats.Get<Rect>(i, 0));
                Rect r = ValidateRect(new Rect(r1.X, r1.Y, r1.Width, r1.Height));
                if ((r.Width == dst2.Width && r.Height == dst2.Height) || (r.Width == 1 && r.Height == 1)) continue;
                areas.Add(area);
                unsortedRects.Add(r);
                dst2.Rectangle(r, task.HighlightColor, task.lineWidth);
                index.Add(i);
                colors.Add(task.vecColors[colors.Count]);
                maskOrder.Add(area, unsortedMasks.Count);
                unsortedMasks.Add(dst1.InRange(i, i)[r]);
                cv.Point c = new cv.Point((int)centroidRaw.Get<double>(i, 0), (int)centroidRaw.Get<double>(i, 1));
                unsortedCentroids.Add(c);
            }
            masks.Clear();
            for (int i = 0; i < maskOrder.Count; i++)
            {
                int mIndex = maskOrder.ElementAt(i).Value;
                masks.Add(unsortedMasks[mIndex]);
                rects.Add(unsortedRects[mIndex]);
                centroids.Add(unsortedCentroids[mIndex]);
            }
            dst1.ConvertTo(dst0, MatType.CV_8U);
            dst3 = ShowPalette(dst0 * 255 / centroids.Count);
            labels[3] = masks.Count + " Connected Components";
        }
    }




    public class CS_Cell_Basics : CS_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        PCA_Basics pca = new PCA_Basics();
        Plane_Equation eq = new Plane_Equation();
        public bool runRedCloud;
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_Basics(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(20);
            desc = "Display the statistics for the selected cell.";
        }
        public void statsString()
        {
            if (task.heartBeat)
            {
                var rc = task.rc;
                var gridID = task.gridMap.Get<int>(rc.maxDist.Y, rc.maxDist.X);
                strOut = "rc.index = " + rc.index.ToString() + "\t" + " gridID = " + gridID.ToString() + "\r\n";
                strOut += "rc.rect: " + rc.rect.X.ToString() + ", " + rc.rect.Y.ToString() + ", ";
                strOut += rc.rect.Width.ToString() + ", " + rc.rect.Height.ToString() + "\r\n" + "rc.color = " + rc.color.ToString() + "\r\n";
                strOut += "rc.maxDist = " + rc.maxDist.X.ToString() + "," + rc.maxDist.Y.ToString() + "\r\n";
                strOut += rc.depthPixels > 0 ? "Cell is marked as depthCell \r\n" : "";
                if (rc.depthPixels > 0)
                {
                    strOut += "depth pixels " + rc.pixels.ToString() + "\r\n" + "rc.depthPixels = " + rc.depthPixels.ToString() +
                          " or " + (rc.depthPixels / (float)rc.pixels).ToString("0%") + " depth \r\n";
                }
                else
                {
                    strOut += "depth pixels " + rc.pixels.ToString() + " - no depth data\r\n";
                }
                strOut += "Depth Min/Max/Range: X = " + rc.minVec.X.ToString(fmt1) + "/" + rc.maxVec.X.ToString(fmt1);
                strOut += "/" + (rc.maxVec.X - rc.minVec.X).ToString(fmt1) + "\t";
                strOut += "Y = " + rc.minVec.Y.ToString(fmt1) + "/" + rc.maxVec.Y.ToString(fmt1);
                strOut += "/" + (rc.maxVec.Y - rc.minVec.Y).ToString(fmt1) + "\t";
                strOut += "Z = " + rc.minVec.Z.ToString(fmt2) + "/" + rc.maxVec.Z.ToString(fmt2);
                strOut += "/" + (rc.maxVec.Z - rc.minVec.Z).ToString(fmt2) + "\r\n\r\n";
                strOut += "Cell Mean in 3D: x/y/z = \t" + rc.depthMean[0].ToString(fmt2) + "\t";
                strOut += rc.depthMean[1].ToString(fmt2) + "\t" + rc.depthMean[2].ToString(fmt2) + "\r\n";
                strOut += "Color Mean  RGB: \t" + rc.colorMean[0].ToString(fmt1) + "\t" + rc.colorMean[1].ToString(fmt1) + "\t";
                strOut += rc.colorMean[2].ToString(fmt1) + "\r\n";
                strOut += "Color Stdev RGB: \t" + rc.colorStdev[0].ToString(fmt1) + "\t" + rc.colorStdev[1].ToString(fmt1) + "\t";
                strOut += rc.colorStdev[2].ToString(fmt1) + "\r\n";
                var tmp = new Mat(task.rc.mask.Rows, task.rc.mask.Cols, MatType.CV_32F, 0);
                task.pcSplit[2][task.rc.rect].CopyTo(tmp, task.rc.mask);
                plot.rc = task.rc;
                plot.Run(tmp);
                dst1 = plot.dst2;
                // If rc.depthMean[2] == 0
                // {
                //     strOut += "\r\nNo depth data is available for that cell. ";
                // }
                // else
                // {
                //     eq.rc = rc;
                //     eq.Run(src);
                //     rc = eq.rc;
                //     strOut += "\r\n" + eq.strOut + "\r\n";
                //     pca.Run(empty);
                //     strOut += "\r\n" + pca.strOut;
                // }
            }
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest() || runRedCloud)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
            }

            statsString();
            SetTrueText(strOut, 3);
            labels[1] = "Histogram plot for the cell's depth data - X-axis varies from 0 to " + ((int)task.MaxZmeters).ToString() + " meters";
        }
    }
    public class CS_Cell_PixelCountCompare : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_PixelCountCompare(VBtask task) : base(task)
        {
            task.gOptions.setDebugCheckBox(true);
            desc = "The rc.mask is filled and may completely contain depth pixels.  This alg finds cells that contain depth islands.";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            int missCount = 0;
            foreach (var rc in task.redCells)
            {
                if (rc.depthPixels != 0)
                {
                    if (rc.pixels != rc.depthPixels)
                    {
                        dst3[rc.rect].SetTo(rc.color, rc.mask);
                        var pt = new cv.Point(rc.maxDist.X - 10, rc.maxDist.Y);
                        if (task.gOptions.getDebugCheckBox())
                        {
                            strOut = rc.pixels.ToString() + "/" + rc.depthPixels.ToString();
                        }
                        else
                        {
                            strOut = (rc.depthPixels / (float)rc.pixels).ToString("0%");
                        }
                        if (missCount < task.redOptions.identifyCount) SetTrueText(strOut, pt, 3);
                        missCount++;
                    }
                }
            }
            if (task.heartBeat) labels[3] = "There were " + missCount.ToString() + " cells containing depth - showing rc.pixels/rc.depthpixels";
        }
    }
    public class CS_Cell_ValidateColorCells : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_ValidateColorCells(VBtask task) : base(task)
        {
            labels[3] = "Cells shown below have rc.depthPixels / rc.pixels < 50%";
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            desc = "Validate that all the depthCells are correctly identified.";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst1.SetTo(0);
            dst3.SetTo(0);
            List<float> percentDepth = new List<float>();
            foreach (var rc in task.redCells)
            {
                if (rc.depthPixels > 0) dst1[rc.rect].SetTo(255, rc.mask);
                if (rc.depthPixels > 0 && rc.index > 0)
                {
                    float pc = rc.depthPixels / (float)rc.pixels;
                    percentDepth.Add(pc);
                    if (pc < 0.5f) dst3[rc.rect].SetTo(rc.color, rc.mask);
                }
            }
            int beforeCount = dst1.CountNonZero();
            dst1.SetTo(0, task.depthMask);
            int aftercount = dst1.CountNonZero();
            if (beforeCount != aftercount)
            {
                strOut = "There are color cells with depth in them - not good\r\n";
            }
            else
            {
                strOut = "There are no color cells with depth in them.\r\n";
            }
            if (percentDepth.Count > 0)
            {
                strOut += "Depth cell percentage average " + percentDepth.Average().ToString("0%") + "\r\n";
                strOut += "Depth cell percentage range " + percentDepth.Min().ToString("0%") + " to " + percentDepth.Max().ToString("0%");
            }
            SetTrueText(strOut, 3);
        }
    }




    public class CS_Cell_Distance : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_Distance(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            if (standalone) task.gOptions.setDisplay1();
            dst1 = new cv.Mat(dst1.Size(), cv.MatType.CV_8U, 0);
            dst3 = new cv.Mat(dst3.Size(), cv.MatType.CV_8U, 0);
            labels = new string[] { "", "Depth distance to selected cell", "", "Color distance to selected cell" };
            desc = "Measure the color distance of each cell to the selected cell.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat || task.quarterBeat)
            {
                redC.Run(src);
                dst0 = task.color;
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                List<float> depthDistance = new List<float>();
                List<float> colorDistance = new List<float>();
                cv.Scalar selectedMean = src[task.rc.rect].Mean(task.rc.mask);
                foreach (var rc in task.redCells)
                {
                    colorDistance.Add(distance3D(selectedMean, new Mat(src, rc.rect).Mean(rc.mask)));
                    depthDistance.Add(distance3D(task.rc.depthMean, rc.depthMean));
                }
                dst1.SetTo(0);
                dst3.SetTo(0);
                float maxColorDistance = colorDistance.Max();
                for (int i = 0; i < task.redCells.Count; i++)
                {
                    var rc = task.redCells[i];
                    dst1[rc.rect].SetTo(new cv.Scalar(255 - depthDistance[i] * 255 / task.MaxZmeters), rc.mask);
                    dst3[rc.rect].SetTo(new cv.Scalar(255 - colorDistance[i] * 255 / maxColorDistance), rc.mask);
                }
            }
        }
    }
    public class CS_Cell_Binarize : CS_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_Binarize(VBtask task) : base(task)
        {
            if (standaloneTest())
                task.gOptions.setDisplay1();
            if (standaloneTest())
                task.gOptions.setDisplay1();
            dst1 = new cv.Mat(dst3.Size(), cv.MatType.CV_8U, 0);
            dst3 = new cv.Mat(dst3.Size(), cv.MatType.CV_8U, 0);
            labels = new string[] { "", "Binarized image", "", "Relative gray image" };
            desc = "Separate the image into light and dark using RedCloud cells";
        }
        public void RunCS(Mat src)
        {
            dst0 = src;
            if (task.heartBeat || task.quarterBeat)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                List<float> grayMeans = new List<float>();
                cv.Mat gray = src.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                foreach (var rc in task.redCells)
                {
                    cv.Scalar grayMean, grayStdev;
                    cv.Cv2.MeanStdDev(gray[rc.rect], out grayMean, out grayStdev, rc.mask);
                    grayMeans.Add((float)grayMean[0]);
                }
                float min = grayMeans.Min();
                float max = grayMeans.Max();
                float avg = grayMeans.Average();
                dst3.SetTo(0);
                foreach (var rc in task.redCells)
                {
                    float color = (grayMeans[rc.index] - min) * 255 / (max - min);
                    dst3[rc.rect].SetTo(new cv.Scalar(color), rc.mask);
                    dst1[rc.rect].SetTo(grayMeans[rc.index] > avg ? new cv.Scalar(255) : new cv.Scalar(0), rc.mask);
                }
            }
        }
    }





    public class CS_Cell_Floodfill : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Cell_Basics stats = new Cell_Basics();
        public CS_Cell_Floodfill(VBtask task) : base(task)
        {
            desc = "Provide cell stats on the flood_basics cells.";
        }
        public void RunCS(Mat src)
        {
            flood.Run(src);
            stats.Run(src);
            dst0 = stats.dst0;
            dst1 = stats.dst1;
            dst2 = flood.dst2;
            labels = flood.labels;
            SetTrueText(stats.strOut, 3);
        }
    }





    public class CS_Cell_BasicsPlot : CS_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public bool runRedCloud;
        Cell_Basics stats = new Cell_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_BasicsPlot(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            if (standalone)
                task.gOptions.setDisplay1();
            if (standalone)
                task.gOptions.setHistogramBins(20);
            desc = "Display the statistics for the selected cell.";
        }
        public void statsString(cv.Mat src)
        {
            cv.Mat tmp = new cv.Mat(task.rc.mask.Rows, task.rc.mask.Cols, cv.MatType.CV_32F, 0);
            task.pcSplit[2][task.rc.rect].CopyTo(tmp, task.rc.mask);
            plot.rc = task.rc;
            plot.Run(tmp);
            dst1 = plot.dst2;
            stats.statsString();
            strOut = stats.strOut;
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest() || runRedCloud)
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                if (task.ClickPoint == new cv.Point())
                {
                    if (task.redCells.Count > 1)
                    {
                        task.rc = task.redCells[1];
                        task.ClickPoint = task.rc.maxDist;
                    }
                }
            }
            if (task.heartBeat)
                statsString(src);
            SetTrueText(strOut, 3);
            labels[1] = "Histogram plot for the cell's depth data - X-axis varies from 0 to " + ((int)task.MaxZmeters).ToString() + " meters";
        }
    }




    public class CS_Cell_Stable : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Cell_Stable(VBtask task) : base(task)
        {
            labels[3] = "Below are cells that were not exact matches.";
            desc = "Identify cells which were NOT present in the previous generation.";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            if (task.heartBeat)
                return;
            int retained = 0;
            dst3.SetTo(0);
            foreach (var rc in task.redCells)
            {
                if (rc.exactMatch)
                    retained++;
                else
                    dst3[rc.rect].SetTo(rc.color, rc.mask);
            }
            labels[3] = (task.redCells.Count - retained).ToString() + " were not exact matches (shown below)";
        }
    }





    public class CS_Cell_Generate : CS_Parent
    {
        public int classCount;
        public List<cv.Rect> rectList = new List<cv.Rect>();
        public List<cv.Point> floodPoints = new List<cv.Point>();
        public bool removeContour;
        Diff_Basics diffLeft = new Diff_Basics();
        Diff_Basics diffRight = new Diff_Basics();
        public bool useLeftImage = true;
        Boundary_RemovedRects bounds = new Boundary_RemovedRects();
        RedCloud_CPP redCPP;
        int saveRetained = -1;
        public CS_Cell_Generate(VBtask task) : base(task)
        {
            task.cellMap = new cv.Mat(dst2.Size(), cv.MatType.CV_8U, 0);
            task.redCells = new List<rcData>();
            desc = "Generate the RedCloud cells from the rects, mask, and pixel counts.";
        }
        public void RunCS(Mat src)
        {
            if (standalone)
            {
                bounds.Run(src);
                task.cellMap = bounds.bRects.bounds.dst2;
                src = task.cellMap.BitwiseOr(bounds.dst2);
                if (task.FirstPass)
                    task.cellMap.SetTo(0);
                redCPP = bounds.bRects.bounds.redCPP;
                if (redCPP.classCount == 0)
                    return; // no data to process.
                classCount = redCPP.classCount;
                rectList = redCPP.rectList;
                floodPoints = redCPP.floodPoints;
                removeContour = false;
                src = redCPP.dst2;
            }
            if (useLeftImage)
                diffLeft.Run(task.leftView);
            else
                diffRight.Run(task.rightView);
            SortedList<int, rcData> sortedCells = new SortedList<int, rcData>(new compareAllowIdenticalIntegerInverted());
            List<cv.Vec3b> usedColors = new List<cv.Vec3b> { black };
            int retained = 0;
            List<rcData> initList = new List<rcData> { new rcData() };
            for (int i = 1; i < classCount; i++)
            {
                rcData rc = new rcData();
                rc.rect = rectList[i - 1];
                if (rc.rect.Width == dst2.Width && rc.rect.Height == dst2.Height)
                    continue; // FeatureLess_RedCloud find a cell this big.  
                rc.floodPoint = floodPoints[i - 1];
                rc.mask = src[rc.rect].InRange(i, i);
                if (task.heartBeat || rc.indexLast == 0 || rc.indexLast >= task.redCells.Count)
                {
                    if (useLeftImage)
                        cv.Cv2.MeanStdDev(task.color[rc.rect], out rc.colorMean, out rc.colorStdev, rc.mask);
                    else
                        cv.Cv2.MeanStdDev(task.rightView[rc.rect], out rc.colorMean, out rc.colorStdev, rc.mask);
                }
                else
                {
                    rc.colorMean = task.redCells[rc.indexLast].colorMean;
                }
                rc.naturalColor = new cv.Vec3b((byte)rc.colorMean[0], (byte)rc.colorMean[1], (byte)rc.colorMean[2]);
                rc.naturalGray = (int)(rc.colorMean[2] * 0.299 + rc.colorMean[1] * 0.587 + rc.colorMean[0] * 0.114);
                rc.maxDist = GetMaxDist(ref rc);
                rc.indexLast = task.cellMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                if (useLeftImage)
                    rc.motionPixels = diffLeft.dst2[rc.rect].CountNonZero();
                else
                    rc.motionPixels = diffRight.dst2[rc.rect].CountNonZero();
                if (rc.indexLast > 0 && rc.indexLast < task.redCells.Count)
                {
                    var lrc = task.redCells[rc.indexLast];
                    if ((!task.heartBeat || task.FirstPass) && Math.Abs(lrc.naturalGray - rc.naturalGray) <= 1 && rc.motionPixels == 0)
                    {
                        rc = lrc;
                        rc.exactMatch = true;
                        retained++;
                    }
                }
                initList.Add(rc);
            }
            for (int i = 0; i < initList.Count; i++) {
                var rc = initList[i];
                if (!rc.exactMatch)
                {
                    rc.contour = contourBuild(rc.mask, cv.ContourApproximationModes.ApproxNone); // .ApproxTC89L1
                    DrawContour(rc.mask, rc.contour, 255, -1);
                    if (removeContour)
                        DrawContour(rc.mask, rc.contour, 0, 2); // no overlap with neighbors.
                    rc.maxDStable = rc.maxDist; // assume it has to use the latest.
                    rc.indexLast = task.cellMap.Get<byte>(rc.maxDist.Y, rc.maxDist.X);
                    if (rc.indexLast > 0 && rc.indexLast < task.redCells.Count)
                    {
                        var lrc = task.redCells[rc.indexLast];
                        if (!task.heartBeat && Math.Abs(lrc.naturalGray - rc.naturalGray) <= 1 && rc.motionPixels == 0)
                        {
                            rc = lrc;
                            rc.exactMatch = true;
                        }
                        else
                        {
                            rc.color = lrc.color;
                            byte stableCheck = task.cellMap.Get<byte>(lrc.maxDist.Y, lrc.maxDist.X);
                            if (stableCheck == rc.indexLast)
                                rc.maxDStable = lrc.maxDStable; // keep maxDStable if cell matched to previous
                            byte val = task.cellMap.Get<byte>(rc.maxDStable.Y, rc.maxDStable.X);
                            if (val != rc.indexLast)
                                rc.maxDStable = rc.maxDist; // maxDist has finally hit the edges of the cell.
                            rc.pointMatch = true;
                        }
                    }
                    if (!rc.pointMatch && !rc.exactMatch)
                        rc.color = new cv.Vec3b((byte)msRNG.Next(40, 220), (byte)msRNG.Next(40, 220), (byte)msRNG.Next(40, 220));
                    if (usedColors.Contains(rc.color))
                        rc.color = task.vecColors[sortedCells.Count + 1];
                    usedColors.Add(rc.color);
                    rc.pixels = rc.mask.CountNonZero(); // the number of pixels may have changed with the infill or contour.
                    if (rc.pixels == 0)
                        continue;
                    rc.depthMask = rc.mask.Clone();
                    rc.depthMask.SetTo(0, new Mat(task.noDepthMask, rc.rect));
                    rc.depthPixels = rc.depthMask.CountNonZero();
                    if (rc.depthPixels != 0)
                    {
                        double minVal, maxVal;
                        task.pcSplit[0][rc.rect].MinMaxLoc(out minVal, out maxVal, out rc.minLoc, out rc.maxLoc, rc.depthMask);
                        rc.minVec.X = (float)minVal;
                        rc.maxVec.X = (float)maxVal;
                        task.pcSplit[1][rc.rect].MinMaxLoc(out minVal, out maxVal, out rc.minLoc, out rc.maxLoc, rc.depthMask);
                        rc.minVec.Y = (float)minVal;
                        rc.maxVec.Y = (float)maxVal;
                        task.pcSplit[2][rc.rect].MinMaxLoc(out minVal, out maxVal, out rc.minLoc, out rc.maxLoc, rc.depthMask);
                        rc.minVec.Z = (float)minVal;
                        rc.maxVec.Z = (float)maxVal;
                        cv.Cv2.MeanStdDev(task.pointCloud[rc.rect], out rc.depthMean, out rc.depthStdev, rc.depthMask);
                    }
                }
                sortedCells.Add(rc.pixels, rc);
            }
            task.redCells = new List<rcData>(sortedCells.Values);
            dst2 = RebuildCells(sortedCells);
            if (saveRetained < 0) saveRetained = retained;
            if (retained > 0)
                saveRetained = retained;
            if (task.heartBeat)
                labels[2] = task.redCells.Count.ToString() + " total cells with " + saveRetained.ToString() + " exact matches";
        }
    }


    // http://ptgmedia.pearsoncmg.com/images/0672320665/downloads/The%20Game%20of%20Life.html
    public class CS_CellularAutomata_Life : CS_Parent
    {
        public int lastPopulation;
        CS_Random_Basics random;
        Mat grid;
        Mat nextgrid;
        int factor = 8;
        int generation;
        public int population;
        public Scalar nodeColor = Scalar.White;
        public Scalar backColor = Scalar.Black;
        int savePointCount;
        const int countInit = 200;
        int countdown = countInit;

        int CountNeighbors(int cellX, int cellY)
        {
            int count = 0;
            if (cellX > 0 && cellY > 0)
            {
                if (grid.At<byte>(cellY - 1, cellX - 1) != 0) count++;
                if (grid.At<byte>(cellY - 1, cellX) != 0) count++;
                if (grid.At<byte>(cellY, cellX - 1) != 0) count++;
            }
            if (cellX < grid.Width - 1 && cellY < grid.Height - 1)
            {
                if (grid.At<byte>(cellY + 1, cellX + 1) != 0) count++;
                if (grid.At<byte>(cellY + 1, cellX) != 0) count++;
                if (grid.At<byte>(cellY, cellX + 1) != 0) count++;
            }
            if (cellX > 0 && cellY < grid.Height - 1)
            {
                if (grid.At<byte>(cellY + 1, cellX - 1) != 0) count++;
            }
            if (cellX < grid.Width - 1 && cellY > 0)
            {
                if (grid.At<byte>(cellY - 1, cellX + 1) != 0) count++;
            }
            return count;
        }

        public CS_CellularAutomata_Life(VBtask task) : base(task)
        {
            random = new CS_Random_Basics(task);
            grid = new Mat(dst2.Height / factor, dst2.Width / factor, MatType.CV_8UC1, Scalar.All(0));
            nextgrid = grid.Clone();
            random.range = new Rect(0, 0, grid.Width, grid.Height);
            FindSlider("Random Pixel Count").Value = (int)(grid.Width * grid.Height * 0.3); // we want about 30% of cells filled.
            desc = "Use OpenCV to implement the Game of Life";
        }

        public void RunCS(Mat src)
        {
            if (random.options.count != savePointCount || generation == 0)
            {
                random.RunAndMeasure(empty, random);
                generation = 0;
                savePointCount = random.options.count;
                foreach (var point in random.PointList)
                {
                    grid.Set((int)point.Y, (int)point.X, 1);
                }
            }
            generation++;

            population = 0;
            dst2.SetTo(backColor);
            for (int y = 0; y < grid.Height; y++)
            {
                for (int x = 0; x < grid.Width; x++)
                {
                    int neighbors = CountNeighbors(x, y);
                    if (neighbors == 2 || neighbors == 3)
                    {
                        if (neighbors == 2)
                        {
                            nextgrid.Set(y, x, grid.At<byte>(y, x));
                        }
                        else
                        {
                            nextgrid.Set(y, x, 1);
                        }
                    }
                    else
                    {
                        nextgrid.Set(y, x, 0);
                    }
                    if (nextgrid.At<byte>(y, x) != 0)
                    {
                        cv.Point pt = new cv.Point(x, y) * factor;
                        Cv2.Circle(dst2, pt, factor / 2, nodeColor, -1);
                        population++;
                    }
                }
            }

            string countdownText = "";
            if (lastPopulation == population && countdown == -1) countdown = countInit;
            if (lastPopulation == population)
            {
                countdown--;
                countdownText = " Restart in " + countdown;
                if (countdown == 0)
                {
                    countdownText = "";
                    generation = 0;
                    countdown = countInit;
                }
            }
            else
            { 
                countdown = -1;
            }
            lastPopulation = population;
            labels[2] = "Population " + population + " Generation = " + generation + countdownText;
            grid = nextgrid.Clone();
        }
    }




    public class CS_CellularAutomata_LifeColor : CS_Parent
    {
        CS_CellularAutomata_Life game;
        public CS_CellularAutomata_LifeColor(VBtask task) : base(task)
        {
            game = new CS_CellularAutomata_Life(task);
            game.backColor = Scalar.White;
            game.nodeColor = Scalar.Black;

            labels[2] = "Births are blue, deaths are red";
            desc = "Game of Life but with color added";
        }

        public void RunCS(Mat src)
        {
            Mat lastBoard = game.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            game.RunAndMeasure(src, game);
            dst1 = game.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            Mat deaths = new Mat(), births = new Mat();

            Cv2.Subtract(dst1, lastBoard, births);
            Cv2.Subtract(lastBoard, dst1, deaths);
            births = births.Threshold(0, 255, ThresholdTypes.Binary);
            deaths = deaths.Threshold(0, 255, ThresholdTypes.Binary);
            dst2 = game.dst2.Clone();
            dst2.SetTo(Scalar.Blue, births);
            dst2.SetTo(Scalar.Red, deaths);
        }
    }




    // http://ptgmedia.pearsoncmg.com/images/0672320665/downloads/The%20Game%20of%20Life.html
    public class CS_CellularAutomata_LifePopulation : CS_Parent
    {
        Plot_OverTimeSingle plot = new Plot_OverTimeSingle();
        CS_CellularAutomata_Life game;
        public CS_CellularAutomata_LifePopulation(VBtask task) : base(task)
        {
            game = new CS_CellularAutomata_Life(task);
            desc = "Show Game of Life display with plot of population";
        }

        public void RunCS(Mat src)
        {
            game.RunAndMeasure(src, game);
            dst2 = game.dst2;

            plot.plotData = game.population;
            plot.Run(empty);
            dst3 = plot.dst2;
        }
    }



    // https://mathworld.wolfram.com/ElementaryCellularAutomaton.html
    public class CS_CellularAutomata_All256 : CS_Parent
    {
        CS_CellularAutomata_Basics cell;
        Options_CellAutomata options = new Options_CellAutomata();
        System.Windows.Forms.TrackBar ruleSlider;
        public CS_CellularAutomata_All256(VBtask task) : base(task)
        {
            ruleSlider = FindSlider("Current Rule");
            cell = new CS_CellularAutomata_Basics(task);
            desc = "Run through all 256 combinations of outcomes";
        }

        string createOutcome(int val)
        {
            string outstr = "";
            for (int i = 0; i < 8; i++)
            {
                outstr = (val % 2).ToString() + outstr;
                val = (int)Math.Floor(val / 2.0);
            }
            return outstr;
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                cell.input = new Mat(new cv.Size(src.Width / 4, src.Height / 4), MatType.CV_8UC1, 0);
                cell.input.Set<byte>(0, cell.input.Width / 2, 1);

                labels[2] = createOutcome(options.currentRule) + " options.currentRule = " + options.currentRule.ToString();
                dst2 = cell.createCells(labels[2]);

                options.RunVB();

                if (task.heartBeat)
                {
                    labels[3] = createOutcome(options.currentRule) + " current rule = " + options.currentRule.ToString();
                    dst3 = cell.createCells(labels[3]);
                }
                if (ruleSlider.Value < ruleSlider.Maximum - 1) ruleSlider.Value += 1; else ruleSlider.Value = 0;
            }
        }
    }

    public class CS_CellularAutomata_MultiPoint : CS_Parent
    {
        CS_CellularAutomata_Basics cell;
        Options_CellAutomata options = new Options_CellAutomata();
        int val1 = 0; int val2 = 0;

        public CS_CellularAutomata_MultiPoint(VBtask task) : base(task)
        {
            cell = new CS_CellularAutomata_Basics(task);
            val2 = dst2.Width / 2;
            FindSlider("Current Rule").Value = 4;
            desc = "All256 above starts with just one point. Here we start with multiple points.";
        }

        public void RunCS(Mat src)
        {
            Mat tmp = new Mat(new cv.Size(src.Width / 4, src.Height / 4), MatType.CV_8UC1, 0);
            tmp.Set(0, val1, 1);
            tmp.Set(0, val2, 1);
            cell.RunAndMeasure(tmp, cell);

            dst2 = cell.dst2;
            val1++;
            if (val1 > tmp.Width) val1 = 0;
            if (val2 >= src.Width) val2 = 0;
        }
    }




    public class CS_CellularAutomata_Basics : CS_Parent
    {
        string[] i18 = {"00011110 Rule 30 (chaotic)", "00110110 Rule 54", "00111100 Rule 60", "00111110 Rule 62",
                                  "01011010 Rule 90", "01011110 Rule 94", "01100110 Rule 102", "01101110 Rule 110",
                                  "01111010 Rule 122", "01111110 Rule 126", "10010110 Rule 150", "10011110 Rule 158",
                                  "10110110 Rule 182", "10111100 Rule 188", "10111110 Rule 190", "11011100 Rule 220",
                                  "11011110 Rule 222", "11111010 Rule 250"};
        string inputCombo = "111,110,101,100,011,010,001,000";
        int[,] cellInput = { { 1, 1, 1 }, { 1, 1, 0 }, { 1, 0, 1 }, { 1, 0, 0 }, { 0, 1, 1 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 0 } };
        public Mat input = new Mat();
        int myIndex = 0;
        public CS_CellularAutomata_Basics(VBtask task) : base(task)
        {
            string label = "The 18 most interesting automata from the first 256 in 'New Kind of Science'\nThe input combinations are: " + inputCombo;
            desc = "Visualize the 30 interesting examples from the first 256 in 'New Kind of Science'";
        }

        public Mat createCells(string outStr)
        {
            byte[] outcomes = new byte[8];
            for (int i = 0; i < outcomes.Length; i++)
            {
                outcomes[i] = byte.Parse(outStr.Substring(i, 1));
            }

            Mat dst = input.Clone();
            for (int y = 0; y < dst.Height - 2; y++)
            {
                for (int x = 0; x < dst.Width - 2; x++)
                {
                    byte x1 = dst.At<byte>(y, x - 1);
                    byte x2 = dst.At<byte>(y, x);
                    byte x3 = dst.At<byte>(y, x + 1);
                    for (int i = 0; i <= cellInput.GetUpperBound(0); i++)
                    {
                        if (x1 == cellInput[i, 0] && x2 == cellInput[i, 1] && x3 == cellInput[i, 2])
                        {
                            dst.Set(y + 1, x, outcomes[i]);
                            break;
                        }
                    }
                }
            }
            return dst.ConvertScaleAbs(255).CvtColor(ColorConversionCodes.GRAY2BGR);
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                labels[2] = i18[myIndex];
                myIndex += 1;
                if (myIndex >= i18.Length) myIndex = 0;
            }
            
            if (standalone)
            {
                input = new Mat(new cv.Size(src.Width, src.Height), MatType.CV_8UC1, Scalar.All(0));
                input.Set<byte>(0, src.Width / 2, 1);
                dst2 = createCells(labels[2]);
            }
            else
            {
                input = src.Clone();
                dst2 = createCells(labels[2]);
            }
        }
    }



    public class CS_Classifier_Basics : CS_Parent
    {
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_Open();
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void OEX_Points_Classifier_Close(IntPtr cPtr);
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_ShowPoints(IntPtr cPtr, int imgRows, int imgCols, int DotSize);
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_RunCPP(IntPtr cPtr, int count, int methodIndex, int imgRows, int imgCols, int resetInput);
        Options_Classifier options = new Options_Classifier();

        public CS_Classifier_Basics(VBtask task) : base(task)
        {
            cPtr = OEX_Points_Classifier_Open();
            desc = "OpenCV Example Points_Classifier";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged) task.gOptions.setDebugCheckBox(true);
            IntPtr imagePtr = OEX_Points_Classifier_RunCPP(cPtr, options.sampleCount, options.methodIndex, dst2.Rows, dst2.Cols,
                                                           task.gOptions.getDebugCheckBox() ? 1 : 0);
            task.gOptions.setDebugCheckBox(false);
            dst1 = new Mat(dst0.Rows, dst0.Cols, MatType.CV_32S, imagePtr);

            dst1.ConvertTo(dst0, MatType.CV_8U);
            dst2 = ShowPalette(dst0 * 255 / 2);
            imagePtr = OEX_ShowPoints(cPtr, dst2.Rows, dst2.Cols, task.DotSize);
            dst3 = new Mat(dst2.Rows, dst2.Cols, MatType.CV_8UC3, imagePtr);

            SetTrueText("Click the global DebugCheckBox to get another set of points.", 3);
        }

        public void Close()
        {
            OEX_Points_Classifier_Close(cPtr);
        }
    }

    public class CS_Classifier_Bayesian : CS_Parent
    {
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_Open();
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void OEX_Points_Classifier_Close(IntPtr cPtr);
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_ShowPoints(IntPtr cPtr, int imgRows, int imgCols, int DotSize);
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr OEX_Points_Classifier_RunCPP(IntPtr cPtr, int count, int methodIndex, int imgRows, int imgCols, int resetInput);
        Options_Classifier options = new Options_Classifier();

        public CS_Classifier_Bayesian(VBtask task) : base(task)
        {
            cPtr = OEX_Points_Classifier_Open();
            desc = "Run the Bayesian classifier with the input.";
        }

        public void RunCS(Mat src)
        {
            int sampleCount, methodIndex = 0;
            if (src.Type() != MatType.CV_32FC2)
            {
                options.RunVB();
                sampleCount = options.sampleCount;
                methodIndex = options.methodIndex;
            }
            else
            {
                sampleCount = src.Rows;
            }

            if (task.heartBeat) task.gOptions.setDebugCheckBox(true);
            IntPtr imagePtr = OEX_Points_Classifier_RunCPP(cPtr, sampleCount, methodIndex, dst2.Rows, dst2.Cols,
                                                           task.gOptions.getDebugCheckBox() ? 1 : 0);
            task.gOptions.setDebugCheckBox(false);
            dst1 = new Mat(dst1.Rows, dst1.Cols, MatType.CV_32S, imagePtr);
            dst1.ConvertTo(dst0, MatType.CV_8U);
            dst2 = ShowPalette(dst0 * 255 / 2);
            imagePtr = OEX_ShowPoints(cPtr, dst2.Rows, dst2.Cols, task.DotSize);
        }
    }

    public class CS_Classifier_BayesianTest : CS_Parent
    {
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr Classifier_Bayesian_Open();
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void Classifier_Bayesian_Close(IntPtr cPtr);
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void Classifier_Bayesian_Train(IntPtr cPtr, IntPtr trainInput, IntPtr response, int count);
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)] public static extern IntPtr Classifier_Bayesian_RunCPP(IntPtr cPtr, IntPtr trainInput, int count);

        RedCloud_Basics redC = new RedCloud_Basics();
        Neighbors_Precise nabs = new Neighbors_Precise();

        public CS_Classifier_BayesianTest(VBtask task) : base(task)
        {
            task.redOptions.useColorOnlyChecked = true;
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            labels = new string[] { "", "Mask of the neighbors to the selected cell", "RedCloud_Basics output", "Classifier_Bayesian output" };
            if (standalone) task.gOptions.setDisplay1();
            cPtr = Classifier_Bayesian_Open();
            desc = "Classify the neighbor cells to be similar to the selected cell or not.";
        }

        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;

            SetTrueText("Review the neighbors_Precise algorithm");
            // nabs.redCells = task.redCells;
            // nabs.Run(task.cellMap);

            // List<Scalar> trainList = new List<Scalar>();
            // List<int> responseList = new List<int>();
            // foreach (var rc in task.redCells)
            // {
            //     trainList.Add(rc.depthMean);
            //     responseList.Add(0);
            // }

            // dst1.SetTo(0);
            // foreach (var index in nabs.nabList(task.rc.index))
            // {
            //     var rc = task.redCells[index];
            //     dst1[rc.rect].SetTo(255, rc.mask);
            //     strOut += index + ",";
            //     responseList[index] = -1;
            // }

            // responseList[task.rc.index] = 1;

            // List<Scalar> queryList = new List<Scalar>();
            // List<int> maskList = new List<int>();
            // for (int i = responseList.Count - 1; i >= 0; i--)
            // {
            //     if (responseList[i] == -1)
            //     {
            //         responseList.RemoveAt(i);
            //         queryList.Add(trainList[i]);
            //         trainList.RemoveAt(i);
            //         maskList.Add(i);
            //     }
            // }

            // var vecs = trainList.ToArray();
            // var resp = responseList.ToArray();
            // var handleTrainInput = GCHandle.Alloc(vecs, GCHandleType.Pinned);
            // var handleResponse = GCHandle.Alloc(resp, GCHandleType.Pinned);
            // Classifier_Bayesian_Train(cPtr, handleTrainInput.AddrOfPinnedObject(), handleResponse.AddrOfPinnedObject(), responseList.Count);
            // handleResponse.Free();
            // handleTrainInput.Free();

            // int[] results = new int[queryList.Count];
            // if (queryList.Count > 0)
            // {
            //     var queries = queryList.ToArray();
            //     var handleQueryInput = GCHandle.Alloc(queries, GCHandleType.Pinned);
            //     IntPtr resultsPtr = Classifier_Bayesian_RunCPP(cPtr, handleQueryInput.AddrOfPinnedObject(), queries.Length);
            //     handleQueryInput.Free();

            //     Marshal.Copy(resultsPtr, results, 0, results.Length);
            // }

            // dst3.SetTo(0);
            // bool zeroOutput = true;
            // for (int i = 0; i < maskList.Count; i++)
            // {
            //     if (results[i] > 0)
            //     {
            //         var rc = task.redCells[maskList[i]];
            //         dst3[rc.rect].SetTo(rc.color, rc.mask);
            //         zeroOutput = false;
            //     }
            // }
            // if (zeroOutput) SetTrueText("None of the neighbors were as similar to the selected cell.", 3);
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) Classifier_Bayesian_Close(cPtr);
        }
    }


    public class CS_Clone_Basics : CS_Parent
    {
        public Vec3f colorChangeValues;
        public Vec2f illuminationChangeValues;
        public Vec2f textureFlatteningValues;
        public int cloneSpec; // 0 is colorchange, 1 is illuminationchange, 2 is textureflattening
        public CS_Clone_Basics(VBtask task) : base(task)
        {
            labels[2] = "Clone result - draw anywhere to clone a region";
            labels[3] = "Clone Region Mask";
            desc = "Clone a portion of one image into another. Draw on any image to change selected area.";
            task.drawRect = new Rect(dst2.Width / 4, dst2.Height / 4, dst2.Width / 2, dst2.Height / 2);
        }

        public void RunCS(Mat src)
        {
            Mat mask = new Mat(src.Size(), MatType.CV_8U, Scalar.All(0));
            if (task.drawRect == new Rect())
            {
                mask.SetTo(Scalar.All(255));
            }
            else
            {
                Cv2.Rectangle(mask, task.drawRect, Scalar.White, -1);
            }
            dst3 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);

            if (standaloneTest() && task.frameCount % 10 == 0) cloneSpec += 1;
            switch (cloneSpec % 3)
            {
                case 0:
                    Cv2.ColorChange(src, mask, dst2, colorChangeValues.Item0, colorChangeValues.Item1, colorChangeValues.Item2);
                    break;
                case 1:
                    Cv2.IlluminationChange(src, mask, dst2, illuminationChangeValues.Item0, illuminationChangeValues.Item1);
                    break;
                case 2:
                    Cv2.TextureFlattening(src, mask, dst2, textureFlatteningValues.Item0, textureFlatteningValues.Item1);
                    break;
            }
        }
    }

    public class CS_Clone_ColorChange : CS_Parent
    {
        Clone_Basics clone = new Clone_Basics();
        Options_Clone options = new Options_Clone();
        public CS_Clone_ColorChange(VBtask task) : base(task)
        {
            labels[2] = "Draw anywhere to select different clone region";
            labels[3] = "Mask used for clone";
            desc = "Clone a portion of one image into another controlling rgb. Draw on any image to change selected area.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            
            clone.cloneSpec = 0;
            clone.colorChangeValues = new Vec3f(options.blueChange, options.greenChange, options.redChange);
            clone.Run(src);
            dst2 = clone.dst2;
            dst3 = clone.dst3;
        }
    }

    public class CS_Clone_IlluminationChange : CS_Parent
    {
        Clone_Basics clone = new Clone_Basics();
        Options_Clone options = new Options_Clone();
        public CS_Clone_IlluminationChange(VBtask task) : base(task)
        {
            labels[2] = "Draw anywhere to select different clone region";
            labels[3] = "Mask used for clone";
            desc = "Clone a portion of one image into another controlling illumination. Draw on any image to change selected area.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            
            clone.cloneSpec = 1;
            clone.illuminationChangeValues = new Vec2f(options.alpha, options.beta);
            clone.Run(src);
            dst2 = clone.dst2;
            dst3 = clone.dst3;
        }
    }

    public class CS_Clone_TextureFlattening : CS_Parent
    {
        Clone_Basics clone = new Clone_Basics();
        Options_Clone options = new Options_Clone();
        public CS_Clone_TextureFlattening(VBtask task) : base(task)
        {
            labels[2] = "Draw anywhere to select different clone region";
            labels[3] = "mask used for clone";
            desc = "Clone a portion of one image into another controlling texture. Draw on any image to change selected area.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            clone.cloneSpec = 2;
            clone.textureFlatteningValues = new Vec2f(options.lowThreshold, options.highThreshold);
            clone.Run(src);
            dst2 = clone.dst2;
            dst3 = clone.dst3;
        }
    }



    public class CS_Clone_Eagle : CS_Parent
    {
        Mat sourceImage;
        Mat mask;
        Rect srcROI;
        Rect maskROI;
        cv.Point pt;
        Options_Clone options = new Options_Clone();

        public CS_Clone_Eagle(VBtask task) : base(task)
        {
            sourceImage = Cv2.ImRead(task.HomeDir + "Data/CloneSource.png");
            sourceImage = sourceImage.Resize(new cv.Size(sourceImage.Width * dst2.Width / 1280, sourceImage.Height * dst2.Height / 720));
            srcROI = new Rect(0, 40, sourceImage.Width, sourceImage.Height);

            mask = Cv2.ImRead(task.HomeDir + "Data/Clonemask.png");
            mask = mask.Resize(new cv.Size(mask.Width * dst2.Width / 1280, mask.Height * dst2.Height / 720));
            maskROI = new Rect(srcROI.Width, 40, mask.Width, mask.Height);

            dst3.SetTo(0);
            dst3[srcROI] = sourceImage;
            dst3[maskROI] = mask;

            pt = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            labels[2] = "Move Eagle by clicking in any location.";
            labels[3] = "Source image and source mask.";
            desc = "Clone an eagle into the video stream.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = src.Clone();
            if (task.mouseClickFlag)
            {
                pt = task.ClickPoint;  // pt corresponds to the center of the source image.  Roi can't be outside image boundary.
                if (pt.X + srcROI.Width / 2 >= src.Width) pt.X = src.Width - srcROI.Width / 2;
                if (pt.X - srcROI.Width / 2 < 0) pt.X = srcROI.Width / 2;
                if (pt.Y + srcROI.Height >= src.Height) pt.Y = src.Height - srcROI.Height / 2;
                if (pt.Y - srcROI.Height < 0) pt.Y = srcROI.Height / 2;
            }

            Cv2.SeamlessClone(sourceImage, dst2, mask, pt, dst2, options.cloneFlag);
        }
    }

    // https://www.csharpcodi.com/csharp-examples/OpenCvSharp.Cv2.SeamlessClone(OpenCvSharp.InputArray,%20OpenCvSharp.InputArray,%20OpenCvSharp.InputArray,%20OpenCvSharp.Point,%20OpenCvSharp.OutputArray,%20OpenCvSharp.SeamlessCloneMethods)/
    public class CS_Clone_Seamless : CS_Parent
    {
        Options_Clone options = new Options_Clone();
        public CS_Clone_Seamless(VBtask task) : base(task)
        {
            labels[2] = "Results for SeamlessClone";
            labels[3] = "Mask for Clone";
            desc = "Use the seamlessclone API to merge color and depth...";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            cv.Point center = new cv.Point(src.Width / 2, src.Height / 2);
            int radius = 100;
            if (task.drawRect == new Rect())
            {
                dst3.SetTo(0);
                DrawCircle(dst3, center, radius, Scalar.White);
            }
            else
            {
                Cv2.Rectangle(dst3, task.drawRect, Scalar.White, -1);
            }

            dst2 = src.Clone();
            Cv2.SeamlessClone(task.depthRGB, src, dst3, center, dst2, options.cloneFlag);
            DrawCircle(dst2, center, radius, Scalar.White);
        }
    }

    public class CS_Mat_4Click : CS_Parent
    {
        public CS_Mat_4to1 mats;
        public Mat[] mat;
        public int quadrant = RESULT_DST3;

        public CS_Mat_4Click(VBtask task) : base(task)
        {
            mats = new CS_Mat_4to1(task);
            mat = mats.mat;
            labels[3] = "Click a quadrant in dst2 to view it in dst3";
            desc = "Split an image into 4 segments and allow clicking on a quadrant to open it in dst3";
        }

        public void RunCS(Mat src)
        {
            mat = mats.mat;
            mats.RunAndMeasure(Mat.Zeros(src.Size(), MatType.CV_8UC3), mats);
            dst2 = mats.dst2.Clone();
            if (standalone) mats.defaultMats(src);
            if (task.FirstPass)
            {
                task.ClickPoint = new cv.Point(0, 0);
                task.mousePicTag = RESULT_DST2;
            }

            if (task.mouseClickFlag && task.mousePicTag == RESULT_DST2)
            {
                if (task.ClickPoint.Y < dst2.Rows / 2)
                {
                    quadrant = (task.ClickPoint.X < task.WorkingRes.Width / 2) ? RESULT_DST0 : RESULT_DST1;
                }
                else
                {
                    quadrant = (task.ClickPoint.X < task.WorkingRes.Width / 2) ? RESULT_DST2 : RESULT_DST3;
                }
            }
            mats.RunAndMeasure(Mat.Zeros(src.Size(), MatType.CV_8UC3), mats);
            dst2 = mats.dst2.Clone();
            dst3 = mats.mat[quadrant].Clone();
        }
    }


    public class CS_Mat_4to1 : CS_Parent
    {
        public Mat[] mat = new Mat[4];
        public bool lineSeparators = true; // if they want lines or not...
        public int quadrant = 0;

        public CS_Mat_4to1(VBtask task) : base(task)
        {
            for (int i = 0; i < mat.Length; i++)
            {
                mat[i] = dst2.Clone();
            }
            labels[2] = "Combining 4 images into one";
            labels[3] = "Click any quadrant at left to view it below";
            desc = "Use one Mat for up to 4 images";
        }

        public void defaultMats(Mat src)
        {
            Mat tmpLeft = (task.leftView.Channels() == 1) ? task.leftView.CvtColor(ColorConversionCodes.GRAY2BGR) : task.leftView;
            Mat tmpRight = (task.rightView.Channels() == 1) ? task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : task.rightView;
            mat = new Mat[] { task.color.Clone(), task.depthRGB.Clone(), tmpLeft, tmpRight };
        }

        public void RunCS(Mat src)
        {
            cv.Size nSize = new cv.Size(dst2.Width / 2, dst2.Height / 2);
            Rect roiTopLeft = new Rect(0, 0, nSize.Width, nSize.Height);
            Rect roiTopRight = new Rect(nSize.Width, 0, nSize.Width, nSize.Height);
            Rect roibotLeft = new Rect(0, nSize.Height, nSize.Width, nSize.Height);
            Rect roibotRight = new Rect(nSize.Width, nSize.Height, nSize.Width, nSize.Height);
            if (standalone) defaultMats(src);

            dst2 = new Mat(dst2.Size(), MatType.CV_8UC3);
            Rect roi = new Rect(0, 0, 0, 0);
            for (int i = 0; i < 4; i++)
            {
                Mat tmp = mat[i].Clone();
                if (tmp.Channels() == 1) tmp = mat[i].CvtColor(ColorConversionCodes.GRAY2BGR);
                if (i == 0) roi = roiTopLeft;
                if (i == 1) roi = roiTopRight;
                if (i == 2) roi = roibotLeft;
                if (i == 3) roi = roibotRight;
                dst2[roi] = tmp.Resize(nSize);
            }
            if (lineSeparators)
            {
                dst2.Line(new cv.Point(0, dst2.Height / 2), new cv.Point(dst2.Width, dst2.Height / 2), Scalar.White, task.lineWidth + 1);
                dst2.Line(new cv.Point(dst2.Width / 2, 0), new cv.Point(dst2.Width / 2, dst2.Height), Scalar.White, task.lineWidth + 1);
            }
        }
    }



    public class CS_Cluster_Basics : CS_Parent
    {
        KNN_Core knn = new KNN_Core();
        public List<cv.Point> ptInput = new List<cv.Point>();
        public List<cv.Point> ptList = new List<cv.Point>();
        public List<int> clusterID = new List<int>();
        public SortedList<int, List<cv.Point>> clusters = new SortedList<int, List<cv.Point>>();
        Feature_Basics feat = new Feature_Basics();

        public CS_Cluster_Basics(VBtask task) : base(task)
        {
            FindSlider("Min Distance to next").Value = 10;
            desc = "Group the points based on their proximity to each other.";
        }

        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            if (standalone)
            {
                feat.Run(src);
                ptInput = task.featurePoints;
            }

            if (ptInput.Count <= 3) return;

            knn.queries = task.features;
            knn.trainInput = knn.queries;
            knn.Run(empty);

            ptList.Clear();
            clusterID.Clear();
            clusters.Clear();
            int groupID;
            for (int i = 0; i < knn.queries.Count; i++)
            {
                cv.Point p1 = new cv.Point(knn.queries[i].X, knn.queries[i].Y);
                cv.Point p2 = new cv.Point(knn.queries[knn.result[i, 1]].X, knn.queries[knn.result[i, 1]].Y);
                int index1 = ptList.IndexOf(p1);
                int index2 = ptList.IndexOf(p2);
                if (index1 >= 0 && index2 >= 0) continue;
                if (index1 < 0 && index2 < 0)
                {
                    ptList.Add(p1);
                    ptList.Add(p2);
                    groupID = clusters.Count;
                    List<cv.Point> newList = new List<cv.Point> { p1, p2 };
                    clusters.Add(groupID, newList);
                    clusterID.Add(groupID);
                    clusterID.Add(groupID);
                }
                else
                {
                    cv.Point pt = index1 < 0 ? p1 : p2;
                    int index = index1 < 0 ? index2 : index1;
                    groupID = clusterID[index];
                    ptList.Add(pt);
                    clusterID.Add(groupID);
                    clusters.ElementAt(groupID).Value.Add(pt);
                }
            }

            foreach (var group in clusters)
            {
                for (int i = 0; i < group.Value.Count; i++)
                {
                    for (int j = 0; j < group.Value.Count; j++)
                    {
                        Cv2.Line(dst2, group.Value[i], group.Value[j], Scalar.White);
                    }
                }
            }
            dst3.SetTo(0);
            for (int i = 0; i < knn.queries.Count; i++)
            {
                Cv2.Circle(dst2, new cv.Point(knn.queries[i].X, knn.queries[i].Y), task.DotSize, Scalar.Red);
                Cv2.Circle(dst3, new cv.Point(knn.queries[i].X, knn.queries[i].Y), task.DotSize, task.HighlightColor);
            }
            labels[2] = $"{clusters.Count} groups built from {ptInput.Count} by combining each input point and its nearest neighbor.";
        }
    }

    public class CS_Cluster_Hulls : CS_Parent
    {
        Cluster_Basics cluster = new Cluster_Basics();
        public List<List<cv.Point>> hulls = new List<List<cv.Point>>();
        Feature_Basics feat = new Feature_Basics();

        public CS_Cluster_Hulls(VBtask task) : base(task)
        {
            desc = "Create hulls for each cluster of feature points found in Cluster_Basics";
        }

        public void RunCS(Mat src)
        {
            dst2 = src.Clone();

            feat.Run(src);
            cluster.ptInput = task.featurePoints;
            cluster.Run(src);
            dst2 = cluster.dst2;
            dst3 = cluster.dst3;

            hulls.Clear();
            foreach (var group in cluster.clusters)
            {
                cv.Point[] hullPoints = Cv2.ConvexHull(group.Value.ToArray(), true);
                List<cv.Point> hull = new List<cv.Point>();
                if (hullPoints.Length > 2)
                {
                    hull.AddRange(hullPoints.Select(pt => new cv.Point(pt.X, pt.Y)));
                }
                else if (hullPoints.Length == 2)
                {
                    Cv2.Line(dst3, hullPoints[0], hullPoints[1], Scalar.White);
                }

                hulls.Add(hull);
                if (hull.Count > 0) Cv2.DrawContours(dst3, new[] { hull }, 0, Scalar.White, task.lineWidth);
            }
        }
    }



    public class CS_Coherence_Basics : CS_Parent
    {
        Options_Coherence options = new Options_Coherence();
        public CS_Coherence_Basics(VBtask task) : base(task)
        {
            labels[2] = "Coherence - draw rectangle to apply";
            desc = "Find lines that are artistically coherent in the image";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            int side;
            switch (src.Height)
            {
                case 120:
                case 180:
                    side = 64;
                    break;
                case 360:
                case 480:
                    side = 256;
                    break;
                case 720:
                    side = 512;
                    break;
                default:
                    side = 50;
                    break;
            }

            int xoffset = src.Width / 2 - side / 2;
            int yoffset = src.Height / 2 - side / 2;
            Rect srcRect = new Rect(xoffset, yoffset, side, side);
            if (task.drawRect.Width != 0) srcRect = task.drawRect;

            dst2 = src.Clone();
            src = new Mat(src, srcRect);

            Mat gray = new Mat();
            Mat eigen = new Mat();
            Mat[] split;

            for (int i = 0; i < 4; i++)
            {
                gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                eigen = gray.CornerEigenValsAndVecs(options.str_sigma, options.eigenkernelsize);
                split = eigen.Split();
                Mat x = split[2], y = split[3];

                Mat gxx = gray.Sobel(MatType.CV_32F, 2, 0, options.sigma);
                Mat gxy = gray.Sobel(MatType.CV_32F, 1, 1, options.sigma);
                Mat gyy = gray.Sobel(MatType.CV_32F, 0, 2, options.sigma);

                Mat tmpX = new Mat(), tmpXY = new Mat(), tmpY = new Mat();
                Cv2.Multiply(x, x, tmpX);
                Cv2.Multiply(tmpX, gxx, tmpX);
                Cv2.Multiply(x, y, tmpXY);
                Cv2.Multiply(tmpXY, gxy, tmpXY);
                tmpXY = tmpXY * 2;

                Cv2.Multiply(y, y, tmpY);
                Cv2.Multiply(tmpY, gyy, tmpY);

                Mat gvv = tmpX + tmpXY + tmpY;

                Mat mask = gvv.Threshold(0, 255, ThresholdTypes.BinaryInv).ConvertScaleAbs();

                Mat erode = src.Erode(new Mat());
                Mat dilate = src.Dilate(new Mat());

                Mat imgl = erode;
                dilate.CopyTo(imgl, mask);
                src = src * (1 - options.blend) + imgl * options.blend;
            }

            src.CopyTo(new Mat(dst2, srcRect));
            Cv2.Rectangle(dst2, srcRect, Scalar.Yellow, 2);
            dst3.SetTo(0);
        }
    }

    public class CS_Coherence_Depth : CS_Parent
    {
        Coherence_Basics coherent = new Coherence_Basics();
        public CS_Coherence_Depth(VBtask task) : base(task)
        {
            desc = "Find coherent lines in the depth image";
        }
        public void RunCS(Mat src)
        {
            coherent.Run(task.depthRGB);
            dst2 = coherent.dst2;
        }
    }


    public class CS_Color_Basics : CS_Parent
    {
        public Options_Color options = new Options_Color();
        public CS_Color_Basics(VBtask task) : base(task)
        {
            desc = "Choose a color source";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (options.colorFormat == null) options.colorFormat = "BGR"; // multiple invocations cause this to be necessary but how to fix?

            switch (options.colorFormat)
            {
                case "BGR":
                    dst2 = src.Clone();
                    break;
                case "LAB":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2Lab);
                    break;
                case "HSV":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2HSV);
                    break;
                case "XYZ":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2XYZ);
                    break;
                case "HLS":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2HLS);
                    break;
                case "YUV":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2YUV);
                    break;
                case "YCrCb":
                    dst2 = src.CvtColor(ColorConversionCodes.BGR2YCrCb);
                    break;
            }
        }
    }



    public class CS_Color8U_Basics : CS_Parent
    {
        public int classCount;
        public object classifier;
        object[] colorMethods = {new BackProject_Full(), new BackProject2D_Full(), new Bin4Way_Regions(), new Binarize_DepthTiers(), new FeatureLess_Groups(),
                                 new Hist3Dcolor_Basics(), new KMeans_Basics(), new LUT_Basics(), new Reduction_Basics() };
        public CS_Color8U_Basics(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U);
            labels[3] = "vbPalette output of dst2 at left";
            UpdateAdvice(traceName + ": redOptions 'Color Source' controls which color source is used.");
            desc = "Classify pixels by color using a variety of techniques";
        }
        public void RunCS(Mat src)
        {
            if (task.optionsChanged || classifier == null)
                classifier = colorMethods[task.redOptions.colorInputIndex];

            if (task.redOptions.colorInputName == "BackProject2D_Full")
            {
                ((dynamic)classifier).Run(src);
            }
            else
            {
                dst1 = src.Channels() == 3 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
                ((dynamic)classifier).Run(dst1);
            }

            if (task.heartBeat)
            {
                dst2 = ((dynamic)classifier).dst2.Clone();
            }
            else if (task.motionDetected)
            {
                ((dynamic)classifier).dst2[task.motionRect].CopyTo(dst2[task.motionRect]);
            }

            classCount = ((dynamic)classifier).classCount;

            // Commented out as in original code
            // if (task.maxDepthMask.Rows > 0)
            // {
            //     classCount += 1;
            //     dst2.SetTo(classCount, task.maxDepthMask);
            // }

            dst3 = ((dynamic)classifier).dst3;
            labels[2] = $"Color_Basics: method = {traceName} produced {classCount} pixel classifications";
        }
    }

    public class CS_Color8U_Grayscale : CS_Parent
    {
        Options_Grayscale8U options = new Options_Grayscale8U();

        public CS_Color8U_Grayscale(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Color_Grayscale", "" };
            desc = "Manually create a grayscale image. The only reason for this example is to show how slow it can be to do the work manually in C#";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (options.useOpenCV)
            {
                dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            else
            {
                dst2 = new Mat(src.Size(), MatType.CV_8U, 0);
                Parallel.For(0, src.Rows, y =>
                {
                    for (int x = 0; x < src.Cols; x++)
                    {
                        Vec3b cc = src.Get<Vec3b>(y, x);
                        dst2.Set<byte>(y, x, (byte)((cc[0] * 1140 + cc[1] * 5870 + cc[2] * 2989) / 10000));
                    }
                });
            }
        }
    }

    public class CS_Color8U_Depth : CS_Parent
    {
        public Reduction_Basics reduction = new Reduction_Basics();
        public CS_Depth_InRange depth;
        public int classCount;

        public CS_Color8U_Depth(VBtask task) : base(task)
        {
            depth = new CS_Depth_InRange(task);
            task.gOptions.setLineType(1); // linetype = link4
            labels = new string[] { "", "", "Color Reduction Edges", "Depth Range Edges" };
            desc = "Add depth regions edges to the color Reduction image.";
        }

        public void RunCS(Mat src)
        {
            reduction.Run(src);
            dst2 = reduction.dst2;
            classCount = reduction.classCount;

            depth.RunAndMeasure(src, depth);
            dst2.SetTo(0, depth.dst3);
            dst3.SetTo(0);
            dst3.SetTo(Scalar.White, depth.dst3);
        }
    }

    public class CS_Color8U_KMeans : CS_Parent
    {
        public KMeans_Basics km0 = new KMeans_Basics();
        public KMeans_Basics km1 = new KMeans_Basics();
        public KMeans_Basics km2 = new KMeans_Basics();
        public Color_Basics colorFmt = new Color_Basics();

        public CS_Color8U_KMeans(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels[0] = "Recombined channels in other images.";
            desc = "Run KMeans on each of the 3 color channels";
        }

        public void RunCS(Mat src)
        {
            colorFmt.Run(src);
            dst0 = colorFmt.dst2;

            Mat[] split = dst0.Split();

            km0.Run(split[0]);
            dst1 = km0.dst2 * 255 / km0.classCount;

            km1.Run(split[1]);
            dst2 = km1.dst2 * 255 / km0.classCount;

            km2.Run(split[2]);
            dst3 = km2.dst2 * 255 / km0.classCount;

            for (int i = 1; i <= 3; i++)
            {
                labels[i] = $"{colorFmt.options.colorFormat} channel {i - 1}";
            }
        }
    }



    public class CS_Color8U_RedHue : CS_Parent
    {
        Options_CamShift options = new Options_CamShift();

        public CS_Color8U_RedHue(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": This mask of red hue areas is available for use.");
            labels = new string[] { "", "", "Pixels with Red Hue", "" };
            desc = "Find all the reddish pixels in the image - indicate some life form.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Mat mask = hsv.InRange(options.camSBins, new Scalar(180, 255, options.camMax));
            dst2.SetTo(0);
            src.CopyTo(dst2, mask);
        }
    }

    public class CS_Color8U_Complementary : CS_Parent
    {
        public CS_Color8U_Complementary(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Current image in complementary colors", "HSV version of the current image but hue is flipped to complementary value." };
            desc = "Display the current image in complementary colors";
        }

        public void RunCS(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Mat[] split = hsv.Split();
            split[0] += 90 % 180;
            Cv2.Merge(split, dst3);
            dst2 = dst3.CvtColor(ColorConversionCodes.HSV2BGR);
        }
    }

    public class CS_Color8U_ComplementaryTest : CS_Parent
    {
        Image_Basics images = new Image_Basics();
        Color8U_Complementary comp = new Color8U_Complementary();

        public CS_Color8U_ComplementaryTest(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Original Image", "Color_Complementary version looks identical to the correct version at the link above " };
            desc = "Create the complementary images for Gilles Tran's 'Glasses' image for comparison";
        }

        public void RunCS(Mat src)
        {
            images.options.fileNameForm.setFileName(task.HomeDir + "Data/Glasses by Gilles Tran.png");
            images.Run(new Mat());
            dst2 = images.dst2;

            comp.Run(dst2);
            dst3 = comp.dst2;
        }
    }

    public class CS_Color8U_InRange : CS_Parent
    {
        public CS_Color8U_InRange(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Original", "After InRange processing" };
            desc = "Use inRange to isolate colors from the background";
        }

        public void RunCS(Mat src)
        {
            dst2 = Cv2.ImRead(task.HomeDir + "Data/1.jpg", ImreadModes.Grayscale);
            dst1 = dst2.InRange(105, 165); // should make this a slider and experiment further...
            dst3 = dst2.Clone();
            dst3.SetTo(0, dst1);
        }
    }

    public class CS_Color8U_TopX : CS_Parent
    {
        Hist3Dcolor_TopXColors topX = new Hist3Dcolor_TopXColors();
        Options_Color8UTopX options = new Options_Color8UTopX();

        public CS_Color8U_TopX(VBtask task) : base(task)
        {
            desc = "Classify every BGR pixel into some common colors";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat input = src;
            input = input.Resize(task.lowRes, 0, 0, InterpolationFlags.Nearest);

            topX.mapTopX = options.topXcount;
            topX.Run(input);

            List<Vec3b> top = new List<Vec3b>();
            foreach (var pt in topX.topXPixels)
            {
                top.Add(new Vec3b((byte)pt.X, (byte)pt.Y, (byte)pt.Z));
            }

            dst2 = input.Clone();
            for (int y = 0; y < input.Rows; y++)
            {
                for (int x = 0; x < input.Cols; x++)
                {
                    List<float> distances = new List<float>();
                    Vec3b vec = input.Get<Vec3b>(y, x);
                    foreach (var pt in top)
                    {
                        distances.Add(distance3D(pt, new Vec3b(vec.Item0, vec.Item1, vec.Item2)));
                    }
                    Vec3b best = top[distances.IndexOf(distances.Min())];
                    dst2.Set(y, x, new Vec3b(best.Item0, best.Item1, best.Item2));
                }
            }
            labels[2] = "The BGR image mapped to " + topX.mapTopX + " colors";
        }
    }

    public class CS_Color8U_Common : CS_Parent
    {
        List<Vec3b> common = new List<Vec3b>();
        List<Scalar> commonScalar = new List<Scalar> { Scalar.Blue, Scalar.Green, Scalar.Red, Scalar.Yellow, Scalar.Pink, Scalar.Purple, Scalar.Brown,
                                                           Scalar.Gray, Scalar.Black, Scalar.White };

        public CS_Color8U_Common(VBtask task) : base(task)
        {
            foreach (var c in commonScalar)
            {
                common.Add(new Vec3b((byte)c[0], (byte)c[1], (byte)c[2]));
            }
            desc = "Classify every BGR pixel into some common colors";
        }

        public void RunCS(Mat src)
        {
            for (int y = 0; y < src.Rows; y++)
            {
                for (int x = 0; x < src.Cols; x++)
                {
                    List<float> distances = new List<float>();
                    Vec3b vec = src.Get<Vec3b>(y, x);
                    foreach (var pt in common)
                    {
                        distances.Add(distance3D(pt, new Vec3b(vec.Item0, vec.Item1, vec.Item2)));
                    }
                    Vec3b best = common[distances.IndexOf(distances.Min())];
                    dst2.Set(y, x, new Vec3b(best.Item0, best.Item1, best.Item2));
                }
            }
            labels[2] = "The BGR image mapped to " + common.Count + " common colors";
        }
    }

    public class CS_Color8U_Smoothing : CS_Parent
    {
        History_Basics frames = new History_Basics();

        public CS_Color8U_Smoothing(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Averaged BGR image over the last X frames", "" };
            dst0 = new Mat(dst0.Size(), MatType.CV_32FC3, 0);
            desc = "Merge that last X BGR frames to smooth out differences.";
        }

        public void RunCS(Mat src)
        {
            frames.Run(src);
            dst2 = frames.dst2;
            labels[2] = "The image below is the average of " + frames.saveFrames.Count + " the last BGR frames";
        }
    }

    public class CS_Color8U_Denoise : CS_Parent
    {
        Denoise_Pixels denoise = new Denoise_Pixels();

        public CS_Color8U_Denoise(VBtask task) : base(task)
        {
            denoise.standalone = true;
            desc = "Remove single pixels between identical pixels for all color classifiers.";
        }

        public void RunCS(Mat src)
        {
            denoise.Run(src);
            dst2 = denoise.dst2;
            dst3 = denoise.dst3;
            SetTrueText(denoise.strOut, 2);
        }
    }

    public class CS_Color8U_MotionFiltered : CS_Parent
    {
        Color8U_Basics colorClass = new Color8U_Basics();
        public int classCount;
        Motion_Color motionColor = new Motion_Color();

        public CS_Color8U_MotionFiltered(VBtask task) : base(task)
        {
            desc = "Prepare a Color8U_Basics image using the task.motionRect";
        }

        public void RunCS(Mat src)
        {
            motionColor.Run(src);

            dst3 = motionColor.dst2;
            colorClass.Run(motionColor.dst2);
            dst2 = colorClass.dst3;
            classCount = colorClass.classCount;
        }
    }

    public class CS_Color8U_Hue : CS_Parent
    {
        public CS_Color8U_Hue(VBtask task) : base(task)
        {
            desc = "Isolate those regions in the image that have a reddish hue.";
        }

        public void RunCS(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Scalar loBins = new Scalar(0, 40, 32);
            Scalar hiBins = new Scalar(180, 255, 255);
            dst2 = hsv.InRange(loBins, hiBins);
        }
    }

    public class CS_Color8U_BlackAndWhite : CS_Parent
    {
        Options_StdevGrid options = new Options_StdevGrid();

        public CS_Color8U_BlackAndWhite(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Mask to identify all 'black' regions", "Mask identifies all 'white' regions" };
            desc = "Create masks for black and white";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2 = dst1.Threshold(options.minThreshold, 255, ThresholdTypes.BinaryInv);
            dst3 = dst1.Threshold(options.maxThreshold, 255, ThresholdTypes.Binary);
        }
    }



    public class CS_Complexity_Basics : CS_Parent
    {
        Complexity_Dots complex = new Complexity_Dots();
        public CS_Complexity_Basics(VBtask task) : base(task) 
        {
            desc = "Plot all the available complexity runs.";
        }
        public void RunCS(Mat src)
        {
            complex.options.RunVB();

            string saveLatestFile = complex.options.filename.FullName;

            complex.maxTime = 0;
            for (int i = 0; i < complex.options.filenames.Count; i++)
            {
                complex.fileName = complex.options.filenames[i];
                complex.Run(src);
            }

            complex.initialize = true;
            for (int i = 0; i < complex.options.filenames.Count; i++)
            {
                complex.fileName = complex.options.filenames[i];
                complex.plotColor = complex.options.setPlotColor();
                complex.Run(src);
                complex.initialize = false;
            }

            dst3 = complex.dst2.Clone();

            SetTrueText(">>>>>> Increasing input data >>>>>>" + "\n" + "All available complexity runs",
                        new cv.Point(dst2.Width / 4, 10), 3);
            SetTrueText(" TIME " + "(Max = " + complex.maxTime.ToString(fmt0) + ")", new cv.Point(0, dst2.Height / 2), 3);

            complex.initialize = true;
            complex.fileName = saveLatestFile;
            complex.plotColor = complex.options.setPlotColor();
            complex.Run(src);
            dst2 = complex.dst2;

            SetTrueText(" >>>>>> Increasing input data >>>>>>" + "\n" + complex.options.filename.Name,
                        new cv.Point(dst2.Width / 4, 10));
            SetTrueText(" TIME " + "(Max = " + complex.maxTime.ToString(fmt0) + ")", new cv.Point(0, dst2.Height / 2));
            labels[2] = complex.labels[2];
            labels[3] = "Plots For all available complexity runs";
        }
    }

    public class CS_Complexity_PlotOpenCV : CS_Parent
    {
        public Plot_Basics_CPP plot = new Plot_Basics_CPP();
        public int maxFrameCount;
        public SortedList<int, int> sortData = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public Options_Complexity options = new Options_Complexity();
        public float sessionTime;
        public CS_Complexity_PlotOpenCV(VBtask task) : base(task)
        {
            desc = "Plot the algorithm's input data rate (X) vs. time to complete work on that input (Y).";
        }
        public void prepareSortedData(string filename)
        {
            string contents = File.ReadAllText(filename);
            string[] lines = contents.Split(new[] { "\n" }, StringSplitOptions.RemoveEmptyEntries);
            int nextSize = 0, myFrameCount = 0;
            List<float> times = new List<float>();
            sortData.Clear();

            foreach (string line in lines)
            {
                string trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("Image"))
                {
                    string[] split = trimmedLine.Split('\t');
                    nextSize = int.Parse(split[2]) * int.Parse(split[1]);
                }
                else if (trimmedLine.StartsWith("Ending"))
                {
                    string[] split = trimmedLine.Split('\t');
                    myFrameCount = int.Parse(split[1]);
                    if (myFrameCount > maxFrameCount) maxFrameCount = myFrameCount;
                    times.Add(float.Parse(split[2].Split()[0]));
                }

                if (trimmedLine.StartsWith("-") && nextSize > 0)
                {
                    sortData.Add(nextSize, myFrameCount);
                }
            }

            sessionTime = times.Average();
        }
        public float plotData(float maxTime)
        {
            foreach (var el in sortData)
            {
                plot.srcX.Add(el.Key);
                float nextTime = sessionTime * maxFrameCount / el.Value;
                plot.srcY.Add(nextTime);
                if (nextTime > maxTime) maxTime = nextTime;
            }
            plot.Run(new Mat());
            dst2 = plot.dst2.Clone();
            return maxTime;
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            maxFrameCount = 0;
            plot.srcX.Clear();
            plot.srcY.Clear();
            prepareSortedData(options.filename.FullName);

            float maxTime = plotData(0);

            SetTrueText(">>>>>> Increasing input data >>>>>>", new cv.Point(dst2.Width / 4, 10));
            SetTrueText(" TIME", new cv.Point(0, dst2.Height / 2));
            SetTrueText("Max Time = " + maxTime.ToString(fmt0), new cv.Point(10, 10));
            labels[2] = "Complexity plot for " + Path.GetFileNameWithoutExtension(options.filename.Name);
        }
    }

    public class CS_Complexity_Dots : CS_Parent
    {
        public Options_Complexity options = new Options_Complexity();
        public bool initialize = true;
        public float maxTime;
        public string fileName;
        public Scalar plotColor;
        Mat dst;
        public CS_Complexity_Dots(VBtask task) : base(task)
        {
            dst = new Mat(new cv.Size(task.lowRes.Width * 2, task.lowRes.Height * 2), MatType.CV_8UC3, Scalar.Black);
            desc = "Plot the results of multiple runs at various resolutions.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (!string.IsNullOrEmpty(fileName)) options.filename = new FileInfo(fileName);
            string contents = File.ReadAllText(options.filename.FullName);
            string[] lines = contents.Split(new[] { "\n" }, StringSplitOptions.RemoveEmptyEntries);

            SortedList<int, int> sortData = new SortedList<int, int>(new compareAllowIdenticalInteger());
            int nextSize = 0, myFrameCount = 0;
            List<float> times = new List<float>();
            float maxFrameCount = 0;
            List<double> srcX = new List<double>(), srcY = new List<double>();

            foreach (string line in lines)
            {
                string trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("Image"))
                {
                    string[] split = trimmedLine.Split('\t');
                    nextSize = int.Parse(split[2]) * int.Parse(split[1]);
                }
                else if (trimmedLine.StartsWith("Ending"))
                {
                    string[] split = trimmedLine.Split('\t');
                    myFrameCount = int.Parse(split[1]);
                    if (myFrameCount > maxFrameCount) maxFrameCount = myFrameCount;
                    times.Add(float.Parse(split[2].Split()[0]));
                }

                if (trimmedLine.StartsWith("-") && nextSize > 0)
                {
                    int index = srcX.IndexOf(nextSize);
                    if (index != -1)
                    {
                        srcY[index] = (myFrameCount + srcY[index]) / 2;
                    }
                    else
                    {
                        srcX.Add(nextSize);
                        srcY.Add(myFrameCount);
                    }
                }
            }

            float sessionTime = times.Average();

            for (int i = 0; i < srcX.Count; i++)
            {
                float nextTime = sessionTime * maxFrameCount / (float)srcY[i];
                if (maxTime < nextTime) maxTime = nextTime;
                sortData.Add((int)srcX[i], (int) nextTime);
            }

            double maxX = srcX.Max();
            List<cv.Point> pointSet = new List<cv.Point>();
            if (initialize) dst.SetTo(Scalar.Black);

            for (int i = 0; i < sortData.Count; i++)
            {
                cv.Point pt = new cv.Point(dst.Width * sortData.ElementAt(i).Key / maxX,
                                     dst.Height - dst.Height * sortData.ElementAt(i).Value / maxTime);
                Cv2.Circle(dst, pt, task.DotSize, plotColor, -1);
                pointSet.Add(pt);
            }

            for (int i = 1; i < pointSet.Count; i++)
            {
                Cv2.Line(dst, pointSet[i - 1], pointSet[i], plotColor);
            }

            SetTrueText(">>>>>> Increasing input data >>>>>>" + "\n" + options.filename.Name,
                        new cv.Point(dst2.Width / 4, 10));
            SetTrueText(" TIME " + "(Max = " + maxTime.ToString(fmt0) + ")", new cv.Point(0, dst2.Height / 2));
            labels[2] = "Complexity plot for " + Path.GetFileNameWithoutExtension(options.filename.Name);
            dst2 = dst.Resize(dst2.Size());
        }
    }



    public class CS_Concat_Basics : CS_Parent
    {
        public CS_Concat_Basics(VBtask task) : base(task)
        {
            labels[2] = "Horizontal concatenation";
            labels[3] = "Vertical concatenation";
            desc = "Concatenate 2 images - horizontally and vertically";
        }
        public void RunCS(Mat src)
        {
            Mat tmp = new Mat();
            Cv2.HConcat(src, task.depthRGB, tmp);
            dst2 = tmp.Resize(src.Size());
            Cv2.VConcat(src, task.depthRGB, tmp);
            dst3 = tmp.Resize(src.Size());
        }
    }

    public class CS_Concat_4way : CS_Parent
    {
        public Mat[] img = new Mat[4];
        public CS_Concat_4way(VBtask task) : base(task)
        {
            for (int i = 0; i < img.Length; i++)
            {
                img[i] = new Mat();
            }
            labels[2] = "Color/RGBDepth/Left/Right views";
            desc = "Concatenate 4 images - horizontally and vertically";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                img[0] = src;
                img[1] = task.depthRGB;
                img[2] = task.leftView.Channels() == 1 ? task.leftView.CvtColor(ColorConversionCodes.GRAY2BGR) : task.leftView;
                img[3] = task.rightView.Channels() == 1 ? task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : task.rightView;
            }

            Mat tmp1 = new Mat();
            Mat tmp2 = new Mat();
            Mat tmp3 = new Mat();

            Cv2.HConcat(img[0], img[1], tmp1);
            Cv2.HConcat(img[2], img[3], tmp2);
            Cv2.VConcat(tmp1, tmp2, tmp3);
            dst2 = tmp3.Resize(src.Size());
        }
    }



    public class CS_Contour_Basics : CS_Parent
    {
        Color8U_Basics colorClass = new Color8U_Basics();
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        public SortedList<int, int> sortedList = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());

        public CS_Contour_Basics(VBtask task) : base(task)
        {
            FindRadio("FloodFill").Checked = true;
            UpdateAdvice(traceName + ": redOptions color class determines the input. Use local options in 'Options_Contours' to further control output.");
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            colorClass.Run(src);
            dst2 = colorClass.dst2;

            if (options.retrievalMode == RetrievalModes.FloodFill)
            {
                dst2.ConvertTo(dst1, MatType.CV_32SC1);
                Cv2.FindContours(dst1, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxSimple);
            }
            else
            {
                Cv2.FindContours(dst2, out allContours, out _, options.retrievalMode, options.ApproximationMode);
            }
            if (allContours.Length <= 1) return;

            sortedList.Clear();
            for (int i = 0; i < allContours.Length; i++)
            {
                if (allContours[i].Length < 4) continue;
                double count = Cv2.ContourArea(allContours[i]);
                if (count > 2) sortedList.Add((int)count, i);
            }

            dst3.SetTo(0);
            contourlist.Clear();
            dst2 = colorClass.dst3;
            for (int i = 0; i < sortedList.Count; i++)
            {
                cv.Point[] tour = allContours[sortedList.ElementAt(i).Value];
                contourlist.Add(tour);
                Scalar color = vecToScalar(dst2.Get<Vec3b>(tour[0].Y, tour[0].X));
                DrawContour(dst3, tour.ToList(), color, -1);
            }
            labels[3] = $"Top {sortedList.Count} contours found";
        }
    }

    public class CS_Contour_General : CS_Parent
    {
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        int minLengthContour = 4; // use any contour With enough points To make a contour!

        public CS_Contour_General(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunCS(Mat src)
        {
            if (standalone)
            {
                if (!task.heartBeat) return;
                rotatedRect.Run(src);
                dst2 = rotatedRect.dst2;
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            }
            else
            {
                dst2 = src.Channels() == 3 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
            }

            if (dst2.Type() == MatType.CV_8U)
            {
                Cv2.FindContours(dst2, out allContours, out _, RetrievalModes.External, ContourApproximationModes.ApproxTC89KCOS);
            }
            else
            {
                if (dst2.Type() != MatType.CV_32S) dst2.ConvertTo(dst2, MatType.CV_32S);
                Cv2.FindContours(dst2, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxTC89KCOS);
            }

            contourlist.Clear();
            foreach (var c in allContours)
            {
                double area = Cv2.ContourArea(c);
                if (area >= options.minPixels && c.Length >= minLengthContour) contourlist.Add(c);
            }

            dst3.SetTo(0);
            foreach (var ctr in allContours)
            {
                DrawContour(dst3, ctr.ToList(), Scalar.Yellow);
            }
        }
    }

    public class CS_Contour_GeneralWithOptions : CS_Parent
    {
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        int minLengthContour = 4; // use any contour With enough points To make a contour!
        public CS_Contour_GeneralWithOptions(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest())
            {
                if (!task.heartBeat) return;
                rotatedRect.Run(src);
                dst2 = rotatedRect.dst2;
                if (dst2.Channels() == 3)
                {
                    dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).ConvertScaleAbs(255);
                }
                else
                {
                    dst2 = dst2.ConvertScaleAbs(255);
                }
            }
            else
            {
                dst2 = src.Channels() == 3 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src;
            }

            if (options.retrievalMode == RetrievalModes.FloodFill) dst2.ConvertTo(dst2, MatType.CV_32SC1);
            Cv2.FindContours(dst2, out allContours, out _, options.retrievalMode, options.ApproximationMode);

            contourlist.Clear();
            foreach (var c in allContours)
            {
                double area = Cv2.ContourArea(c);
                if (area >= options.minPixels && c.Length >= minLengthContour) contourlist.Add(c);
            }

            dst3.SetTo(0);
            foreach (var ctr in allContours)
            {
                DrawContour(dst3, ctr.ToList(), Scalar.Yellow);
            }
        }
    }



    public class CS_Contour_RotatedRects : CS_Parent
    {
        public Rectangle_Rotated rotatedRect = new Rectangle_Rotated();
        Contour_General basics = new Contour_General();

        public CS_Contour_RotatedRects(VBtask task) : base(task)
        {
            labels[3] = "Find contours of several rotated rects";
            desc = "Demo options on FindContours.";
        }

        public void RunCS(Mat src)
        {
            Mat imageInput = new Mat();
            rotatedRect.Run(src);
            imageInput = rotatedRect.dst2;
            if (imageInput.Channels() == 3)
            {
                dst2 = imageInput.CvtColor(ColorConversionCodes.BGR2GRAY).ConvertScaleAbs(255);
            }
            else
            {
                dst2 = imageInput.ConvertScaleAbs(255);
            }

            basics.Run(dst2);
            dst2 = basics.dst2;
            dst3 = basics.dst3;
        }
    }

    //public class CS_Contour_RemoveLines : CS_Parent
    //{
    //    Options_Morphology options = new Options_Morphology();
    //    public CS_Contour_RemoveLines(VBtask task) : base(task)
    //    {
    //        labels[2] = "Original image";
    //        labels[3] = "Original with horizontal/vertical lines removed";
    //        desc = "Remove the lines from an invoice image";
    //    }

    //    public void RunCS(Mat src)
    //    {
    //        options.RunVB();

    //        Mat input = FeatureSrc;
    //        Mat tmp = Cv2.ImRead(task.HomeDir + "Data/invoice.jpg");
    //        float height = src.Height;
    //        float factor = (float)(src.Height / tmp.Height);
    //        cv.Size dstSize = new cv.Size(factor * src.Width), src.Height);
    //        cv.Rect dstRect = new cv.Rect(0, 0, dstSize.Width, src.Height);
    //        tmp = tmp.Resize(dstSize);
    //        dst2 = tmp.Resize(dst2.Size());
    //        Mat gray = tmp.CvtColor(ColorConversionCodes.BGR2GRAY);
    //        Mat thresh = gray.Threshold(0, 255, ThresholdTypes.BinaryInv | ThresholdTypes.Otsu);

    //        // remove horizontal lines
    //        Mat hkernel = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(options.widthHeight, 1));
    //        Mat removedH = new Mat();
    //        Cv2.MorphologyEx(thresh, removedH, MorphTypes.Open, hkernel, iterations: options.iterations);
    //        cv.Point[][] cnts = Cv2.FindContoursAsArray(removedH, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
    //        for (int i = 0; i < cnts.Length; i++)
    //        {
    //            Cv2.DrawContours(tmp, cnts, i, Scalar.White, task.lineWidth);
    //        }

    //        Mat vkernel = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(1, options.widthHeight));
    //        Mat removedV = new Mat();
    //        Cv2.MorphologyEx(thresh, removedV, MorphTypes.Open, vkernel, iterations: options.iterations);
    //        cnts = Cv2.FindContoursAsArray(removedV, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
    //        for (int i = 0; i < cnts.Length; i++)
    //        {
    //            Cv2.DrawContours(tmp, cnts, i, Scalar.White, task.lineWidth);
    //        }

    //        dst3 = tmp.Resize(dst3.Size());
    //        Cv2.ImShow("Altered image at original resolution", tmp);
    //    }
    //}

    public class CS_Contour_Edges : CS_Parent
    {
        Edge_ResizeAdd edges = new Edge_ResizeAdd();
        Contour_General contour = new Contour_General();
        Mat lastImage;
        int minLengthContour = 4; // use any contour With enough points To make a contour!
        public CS_Contour_Edges(VBtask task) : base(task)
        {
            lastImage = new Mat(task.WorkingRes, MatType.CV_8UC3, 0);
            desc = "Create contours for Edge_MotionAccum";
        }

        public void RunCS(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2;

            contour.Run(dst2);

            dst3.SetTo(0);
            List<Vec3b> colors = new List<Vec3b>();
            Scalar color;
            foreach (var c in contour.allContours)
            {
                if (c.Length > minLengthContour)
                {
                    Vec3b vec = lastImage.Get<Vec3b>(c[0].Y, c[0].X);
                    if (vec == black || colors.Contains(vec))
                    {
                        color = new Scalar(msRNG.Next(10, 240), msRNG.Next(10, 240), msRNG.Next(10, 240)); // trying to avoid extreme colors... 
                    }
                    else
                    {
                        color = new Scalar(vec[0], vec[1], vec[2]);
                    }
                    colors.Add(vec);
                    DrawContour(dst3, c.ToList(), color, -1);
                }
            }
            lastImage = dst3.Clone();
        }
    }

    public class CS_Contour_SidePoints : CS_Parent
    {
        public Vec3f vecLeft, vecRight, vecTop, vecBot;
        public cv.Point ptLeft, ptRight, ptTop, ptBot;
        public Profile_Basics sides = new Profile_Basics();

        public CS_Contour_SidePoints(VBtask task) : base(task)
        {
            desc = "Find the left/right and top/bottom sides of a contour";
        }

        string Vec3fToString(Vec3f v)
        {
            return string.Format("{0:F3}\t{1:F3}\t{2:F3}", v[0], v[1], v[2]);
        }

        public void RunCS(Mat src)
        {
            sides.Run(src);
            dst2 = sides.dst2;
            var rc = task.rc;

            if (sides.corners.Count > 0 && task.heartBeat)
            {
                ptLeft = sides.corners[1];
                ptRight = sides.corners[2];
                ptTop = sides.corners[3];
                ptBot = sides.corners[4];

                vecLeft = sides.corners3D[1];
                vecRight = sides.corners3D[2];

                vecTop = sides.corners3D[3];
                vecBot = sides.corners3D[4];

                if (rc.contour.Count > 0)
                {
                    dst3.SetTo(0);
                    DrawContour(dst3[rc.rect], rc.contour, Scalar.Yellow);
                    Cv2.Line(dst3, ptLeft, ptRight, Scalar.White);
                    Cv2.Line(dst3, ptTop, ptBot, Scalar.White);
                }
                if (task.heartBeat)
                {
                    strOut = "X     \tY     \tZ \t 3D location (units=meters)\n";
                    strOut += Vec3fToString(vecLeft) + "\t Left side average (blue)\n";
                    strOut += Vec3fToString(vecRight) + "\t Right side average (red)\n";
                    strOut += Vec3fToString(vecTop) + "\t Top side average (green)\n";
                    strOut += Vec3fToString(vecBot) + "\t Bottom side average (white)\n\n";
                    strOut += "The contour may show points further away but they don't have depth.";
                }
            }
            SetTrueText(strOut, 3);
        }
    }


    public class CS_Contour_Foreground : CS_Parent
    {
        Foreground_KMeans2 km = new Foreground_KMeans2();
        Contour_General contour = new Contour_General();

        public CS_Contour_Foreground(VBtask task) : base(task)
        {
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            labels = new string[] { "", "", "Kmeans foreground output", "Contour of foreground" };
            desc = "Build a contour for the foreground";
        }

        public void RunCS(Mat src)
        {
            km.Run(task.pcSplit[2]);
            dst2 = km.dst2;

            contour.Run(dst2);
            dst3.SetTo(0);
            foreach (var ctr in contour.contourlist)
            {
                Cv2.DrawContours(dst3, new[] { ctr }, 0, new Scalar(255), -1);
            }
        }
    }

    public class CS_Contour_Sorted : CS_Parent
    {
        Contour_GeneralWithOptions contours = new Contour_GeneralWithOptions();
        SortedList<int, cv.Point[]> sortedContours = new SortedList<int, cv.Point[]>(new compareAllowIdenticalIntegerInverted());
        SortedList<int, int> sortedByArea = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
        Diff_Basics diff = new Diff_Basics();
        Erode_Basics erode = new Erode_Basics();
        Dilate_Basics dilate = new Dilate_Basics();
        Options_Contours options = new Options_Contours();
        int minLengthContour = 4; // use any contour With enough points To make a contour!
        public CS_Contour_Sorted(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Contours in the detected motion", "Diff output - detected motion" };
            task.gOptions.pixelDiffThreshold = 25;
            desc = "Display the contours from largest to smallest in the motion output";
        }

        public void RunCS(Mat src)
        {
            diff.Run(src);
            erode.Run(diff.dst2); // remove solo points.

            contours.Run(diff.dst2);
            dst2 = contours.dst2;
            dst1 = contours.dst2.Clone();

            sortedByArea.Clear();
            sortedContours.Clear();
            dst3.SetTo(0);
            for (int i = 0; i < contours.contourlist.Count; i++)
            {
                double area = Cv2.ContourArea(contours.contourlist[i]);
                if (area > options.minPixels && contours.contourlist[i].Length > minLengthContour)
                {
                    sortedByArea.Add((int)area, i);
                    sortedContours.Add((int)area, Cv2.ApproxPolyDP(contours.contourlist[i], contours.options.epsilon, true));
                    Cv2.DrawContours(dst3, new[] { contours.contourlist[i] }, 0, Scalar.White, -1);
                }
            }

            dilate.Run(dst3);
            dst3 = dilate.dst2;

            int beforeCount = Cv2.CountNonZero(dst1);
            dst1.SetTo(0, dst3);
            int afterCount = Cv2.CountNonZero(dst1);
            SetTrueText($"Before dilate: {beforeCount}\nAfter dilate {afterCount}\nRemoved = {beforeCount - afterCount}", 1);

            SetTrueText($"The motion detected produced {sortedContours.Count} contours after filtering for length and area.", 3);
        }
    }

    public class CS_Contour_Outline : CS_Parent
    {
        public rcData rc = new rcData();
        RedCloud_Basics redC = new RedCloud_Basics();

        public CS_Contour_Outline(VBtask task) : base(task)
        {
            desc = "Create a simplified contour of the selected cell";
        }

        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            List<cv.Point> ptList = rc.contour;

            dst3.SetTo(0);

            List<cv.Point> newContour = new List<cv.Point>();
            rc = task.rc;
            if (rc.contour.Count == 0) return;
            cv.Point p1 = new cv.Point(0, 0), p2;
            newContour.Add(p1);
            for (int i = 0; i < rc.contour.Count - 1; i++)
            {
                p1 = rc.contour[i];
                p2 = rc.contour[i + 1];
                Cv2.Line(dst3[rc.rect], p1, p2, Scalar.White, task.lineWidth + 1);
                newContour.Add(p2);
            }
            rc.contour = new List<cv.Point>(newContour);
            Cv2.Line(dst3[rc.rect], rc.contour[rc.contour.Count - 1], rc.contour[0], Scalar.White, task.lineWidth + 1);

            labels[2] = $"Input points = {rc.contour.Count}";
        }
    }

    public class CS_Contour_SelfIntersect : CS_Parent
    {
        public rcData rc = new rcData();
        RedCloud_Basics redC = new RedCloud_Basics();

        public CS_Contour_SelfIntersect(VBtask task) : base(task)
        {
            desc = "Search the contour points for duplicates indicating the contour is self-intersecting.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                rc = task.rc;
                DrawContour(dst2[rc.rect], rc.contour, cv.Scalar.White);
                labels[2] = redC.labels[2];
            }

            bool selfInt = false;
            HashSet<string> ptSet = new HashSet<string>();
            dst3 = rc.mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            for (int i = 0; i < rc.contour.Count; i++)
            {
                cv.Point pt = rc.contour[i];
                string ptStr = $"{pt.X:0000}{pt.Y:0000}";
                if (ptSet.Contains(ptStr))
                {
                    double pct = (double)i / rc.contour.Count;
                    if (pct > 0.1 && pct < 0.9)
                    {
                        selfInt = true;
                        Cv2.Circle(dst3, pt, task.DotSize, Scalar.Red, -1);
                    }
                }
                ptSet.Add(ptStr);
            }
            labels[3] = selfInt ? "Self intersecting - red shows where" : "Not self-intersecting";
        }
    }




    public class CS_Contour_Largest : CS_Parent
    {
        public List<cv.Point> bestContour = new List<cv.Point>();
        public cv.Point[][] allContours;
        public Options_Contours options = new Options_Contours();
        Rectangle_Rotated rotatedRect = new Rectangle_Rotated();

        public CS_Contour_Largest(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": use the local options in 'Options_Contours'");
            labels = new string[] { "", "", "Input to FindContours", "Largest single contour in the input image." };
            desc = "Create a mask from the largest contour of the input.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest())
            {
                if (task.heartBeat)
                {
                    rotatedRect.Run(src);
                    dst2 = rotatedRect.dst2;
                }
            }
            else
            {
                dst2 = src;
            }

            if (dst2.Channels() != 1)
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (options.retrievalMode == RetrievalModes.FloodFill)
            {
                dst2.ConvertTo(dst1, MatType.CV_32SC1);
                Cv2.FindContours(dst1, out allContours, out _, options.retrievalMode, options.ApproximationMode);
                dst1.ConvertTo(dst3, MatType.CV_8UC1);
            }
            else
            {
                Cv2.FindContours(dst2, out allContours, out _, options.retrievalMode, options.ApproximationMode);
            }

            int maxCount = 0, maxIndex = -1;
            if (allContours.Length == 0) return;

            for (int i = 0; i < allContours.Length; i++)
            {
                int len = allContours[i].Length;
                if (len > maxCount)
                {
                    maxCount = len;
                    maxIndex = i;
                }
            }

            bestContour = allContours[maxIndex].ToList();

            if (standaloneTest())
            {
                dst3.SetTo(0);
                if (maxIndex >= 0 && maxCount >= 2)
                {
                    DrawContour(dst3, allContours[maxIndex].ToList(), Scalar.White);
                }
            }
        }
    }

    public class CS_Contour_Compare : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public Options_Contours options = new Options_Contours();

        public CS_Contour_Compare(VBtask task) : base(task)
        {
            desc = "Compare findContours options - ApproxSimple, ApproxNone, etc.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];

            Mat tmp = task.rc.mask.Clone();

            cv.Point[][] allContours;
            if (options.retrievalMode == RetrievalModes.FloodFill)
                tmp.ConvertTo(tmp, MatType.CV_32SC1);

            Cv2.FindContours(tmp, out allContours, out _, RetrievalModes.External, options.ApproximationMode);

            dst3.SetTo(0);
            Cv2.DrawContours(dst3[task.rc.rect], allContours, -1, Scalar.Yellow);
        }
    }

    public class CS_Contour_RedCloudCorners : CS_Parent
    {
        public cv.Point[] corners = new cv.Point[4];
        public rcData rc = new rcData();
        RedCloud_Basics redC = new RedCloud_Basics();

        public CS_Contour_RedCloudCorners(VBtask task) : base(task)
        {
            labels[2] = "The RedCloud Output with the highlighted contour to smooth";
            desc = "Find the point farthest from the center in each cell.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                redC.Run(src);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                rc = task.rc;
            }

            dst3.SetTo(0);
            Cv2.Circle(dst3, rc.maxDist, task.DotSize, Scalar.White, -1);
            cv.Point center = new cv.Point(rc.maxDist.X - rc.rect.X, rc.maxDist.Y - rc.rect.Y);
            float[] maxDistance = new float[4];

            for (int i = 0; i < corners.Length; i++)
            {
                corners[i] = center; // default is the center - a triangle shape can omit a corner
            }

            if (rc.contour == null) return;

            foreach (cv.Point pt in rc.contour)
            {
                int quad;
                if (pt.X - center.X >= 0 && pt.Y - center.Y <= 0) quad = 0; // upper right quadrant
                else if (pt.X - center.X >= 0 && pt.Y - center.Y >= 0) quad = 1; // lower right quadrant
                else if (pt.X - center.X <= 0 && pt.Y - center.Y >= 0) quad = 2; // lower left quadrant
                else quad = 3; // upper left quadrant

                float dist = (float)Math.Sqrt(Math.Pow(center.X - pt.X, 2) + Math.Pow(center.Y - pt.Y, 2));
                if (dist > maxDistance[quad])
                {
                    maxDistance[quad] = dist;
                    corners[quad] = pt;
                }
            }

            DrawContour(dst3[rc.rect], rc.contour, Scalar.White);
            for (int i = 0; i < corners.Length; i++)
            {
                Cv2.Line(dst3[rc.rect], center, corners[i], Scalar.White);
            }
        }
    }



    public class CS_Contour_Gray : CS_Parent
    {
        public List<cv.Point> contour = new List<cv.Point>();
        public Options_Contours options = new Options_Contours();
        int myFrameCount;
        Reduction_Basics reduction = new Reduction_Basics();

        public CS_Contour_Gray(VBtask task) : base(task)
        {
            myFrameCount = task.frameCount;
            desc = "Find the contour for the src.";
        }

        public void RunCS(Mat src)
        {
            if (myFrameCount != task.frameCount)
            {
                options.RunVB(); // avoid running options more than once per frame.
                myFrameCount = task.frameCount;
            }

            if (standalone)
            {
                task.redOptions.setColorSource("Reduction_Basics");
                reduction.Run(src);
                src = reduction.dst2;
            }

            cv.Point[][] allContours;
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            Cv2.FindContours(src, out allContours, out _, RetrievalModes.External, options.ApproximationMode);
            if (allContours.Length == 0)
                return;

            dst2 = src;
            foreach (var tour in allContours)
            {
                DrawContour(dst2, tour.ToList(), Scalar.White, task.lineWidth);
            }
            labels[2] = $"There were {allContours.Length} contours found.";
        }
    }

    public class CS_Contour_WholeImage : CS_Parent
    {
        Contour_Basics contour = new Contour_Basics();

        public CS_Contour_WholeImage(VBtask task) : base(task)
        {
            FindSlider("Max contours").Value = 20;
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Find the top X contours by size and display them.";
        }

        public void RunCS(Mat src)
        {
            contour.Run(src);
            var sortedContours = new SortedList<int, List<cv.Point>>(new compareAllowIdenticalIntegerInverted());
            foreach (var tour in contour.contourlist)
            {
                sortedContours.Add(tour.Length, tour.ToList());
            }

            dst2.SetTo(0);
            for (int i = 0; i < sortedContours.Count; i++)
            {
                var tour = sortedContours.ElementAt(i).Value;
                DrawContour(dst2, tour, 255, task.lineWidth);
            }
        }
    }

    public class CS_Contour_DepthTiers : CS_Parent
    {
        public Options_Contours options = new Options_Contours();
        public int classCount;
        public List<cv.Point[]> contourlist = new List<cv.Point[]>();

        public CS_Contour_DepthTiers(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            FindRadio("FloodFill").Checked = true;
            UpdateAdvice(traceName + ": redOptions color class determines the input.  Use local options in 'Options_Contours' to further control output.");
            labels = new string[] { "", "", "FindContour input", "Draw contour output" };
            desc = "General purpose contour finder";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            task.pcSplit[2].ConvertTo(dst1, MatType.CV_32S, 100 / options.cmPerTier, 1);

            cv.Point[][] allContours;
            Cv2.FindContours(dst1, out allContours, out _, RetrievalModes.FloodFill, ContourApproximationModes.ApproxSimple);
            if (allContours.Length <= 1)
                return;

            var sortedList = new SortedList<int, int>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < allContours.Length; i++)
            {
                if (allContours[i].Length < 4)
                    continue;
                int count = (int)Cv2.ContourArea(allContours[i]);
                if (count < options.minPixels)
                    continue;
                if (count > 2)
                    sortedList.Add(count, i);
            }

            dst2.SetTo(0);
            contourlist.Clear();
            for (int i = 0; i < sortedList.Count; i++)
            {
                var tour = allContours[sortedList.ElementAt(i).Value];
                byte val = dst2.Get<byte>(tour[0].Y, tour[0].X);
                if (val == 0)
                {
                    int index = dst1.Get<int>(tour[0].Y, tour[0].X);
                    contourlist.Add(tour);
                    DrawContour(dst2, tour.ToList(), index, -1);
                }
            }

            dst2.SetTo(1, dst2.Threshold(0, 255, ThresholdTypes.BinaryInv));
            classCount = (int)(task.MaxZmeters * 100 / options.cmPerTier);

            if (standaloneTest())
                dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[3] = $"All depth pixels are assigned a tier with {classCount} contours.";
        }
    }

    public class CS_Contour_FromPoints : CS_Parent
    {
        Contour_Basics contour = new Contour_Basics();
        Random_Basics random = new Random_Basics();

        public CS_Contour_FromPoints(VBtask task) : base(task)
        {
            FindSlider("Random Pixel Count").Value = 3;
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Create a contour from some random points";
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                random.Run(src);
                dst2.SetTo(0);
                foreach (var p1 in random.PointList)
                {
                    foreach (var p2 in random.PointList)
                    {
                        DrawLine(dst2, p1, p2, Scalar.White, task.lineWidth);
                    }
                }
            }

            var hullPoints = Cv2.ConvexHull(random.PointList.ToArray(), true).ToList();

            var hull = new List<cv.Point>();
            foreach (var pt in hullPoints)
            {
                hull.Add(new cv.Point(pt.X, pt.Y));
            }

            dst3.SetTo(0);
            DrawContour(dst3, hull, Scalar.White, -1);
        }
    }



    public class CS_Contrast_POW : CS_Parent
    {
        Options_BrightnessContrast options = new Options_BrightnessContrast();
        public CS_Contrast_POW(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Original Image", "Contrast reduced with POW function" };
            desc = "Reduce contrast with POW function";
        }
         
        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst2.ConvertTo(dst3, MatType.CV_32FC3);
            dst3 = dst3.Normalize();
            dst3 = dst3.Pow(options.exponent);
        }
    }

    public class CS_Contrast_Basics : CS_Parent
    {
        Options_BrightnessContrast options = new Options_BrightnessContrast();

        public CS_Contrast_Basics(VBtask task) : base(task)
        {
            labels[2] = "Brightness/Contrast";
            UpdateAdvice(traceName + ": use the local options to control brightness and contrast.");
            desc = "Show image with varying contrast and brightness.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = src.ConvertScaleAbs(options.brightness, options.contrast);
        }
    }


    public class CS_Convex_Basics : CS_Parent
    {
        public cv.Point[] hull;
        Options_Convex options = new Options_Convex();

        public CS_Convex_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": use the local options to control the number of points.");
            desc = "Surround a set of random points with a convex hull";
            labels = new string[] { "", "", "Convex Hull - red dot is center and the black dots are the input points", "" };
        }

        public List<cv.Point> BuildRandomHullPoints()
        {
            int pad = 4;
            int w = dst2.Width - dst2.Width / pad;
            int h = dst2.Height - dst2.Height / pad;

            var hullList = new List<cv.Point>();
            for (int i = 0; i < options.hullCount; i++)
            {
                hullList.Add(new cv.Point(msRNG.Next(dst2.Width / pad, w), msRNG.Next(dst2.Height / pad, h)));
            }
            return hullList;
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            List<cv.Point> hullList = task.rc.contour;
            if (standaloneTest())
            {
                if (!task.heartBeat) return;
                hullList = BuildRandomHullPoints();
            }

            if (hullList.Count == 0)
            {
                SetTrueText("No points were provided. Update hullList before running.");
                return;
            }

            hull = Cv2.ConvexHull(hullList.ToArray(), true);

            dst2.SetTo(0);

            using (var pMat = new Mat(hull.Length, 1, MatType.CV_32SC2, hull))
            {
                Scalar sum = pMat.Sum();
                DrawContour(dst2, hullList, Scalar.White, -1);

                for (int i = 0; i < hull.Length; i++)
                {
                    Cv2.Line(dst2, hull[i], hull[(i + 1) % hull.Length], Scalar.White);
                }
            }
        }
    }

    public class CS_Convex_RedCloud : CS_Parent
    {
        CS_Convex_Basics convex;
        public RedCloud_Basics redC = new RedCloud_Basics();

        public CS_Convex_RedCloud(VBtask task) : base(task)
        {
            convex = new CS_Convex_Basics(task);
            labels = new string[] { "", "", "Selected contour - line shows hull with white is contour. Click to select another contour.", "RedCloud cells" };
            desc = "Get lots of odd shapes from the RedCloud_Basics output and use ConvexHull to simplify them.";
        }

        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;

            if (task.rc.contour != null)
            {
                convex.RunAndMeasure(src, convex);

                dst3.SetTo(0);
                convex.dst2[new Rect(0, 0, task.rc.rect.Width, task.rc.rect.Height)].CopyTo(dst3[task.rc.rect]);
                Cv2.Circle(dst3, task.rc.maxDist, task.DotSize, Scalar.White, -1);
            }
        }
    }

    public class CS_Convex_Defects : CS_Parent
    {
        CS_Contour_Largest contours;

        public CS_Convex_Defects(VBtask task) : base(task)
        {
            contours = new CS_Contour_Largest(task);
            dst2 = Cv2.ImRead(task.HomeDir + "Data/star2.png").Threshold(200, 255, ThresholdTypes.Binary).Resize(task.WorkingRes);
            dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);

            labels = new string[] { "", "", "Input to the ConvexHull and ConvexityDefects", "Yellow = ConvexHull, Red = ConvexityDefects, Yellow dots are convexityDefect 'Far' points" };
            desc = "Find the convexityDefects in the image";
        }

        public void RunCS(Mat src)
        {
            contours.RunAndMeasure(dst2.Clone(), contours);
            cv.Point[] c = contours.bestContour.ToArray();
            dst3 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            cv.Point[] hull = Cv2.ConvexHull(c, false);
            int[] hullIndices = Cv2.ConvexHullIndices(c, false);
            DrawContour(dst3, hull.ToList(), task.HighlightColor);

            Vec4i[] defects = Cv2.ConvexityDefects(contours.bestContour, hullIndices.ToList());
            foreach (Vec4i v in defects)
            {
                Cv2.Line(dst3, c[v[0]], c[v[2]], Scalar.Red, task.lineWidth + 1, LineTypes.Link8);
                Cv2.Line(dst3, c[v[1]], c[v[2]], Scalar.Red, task.lineWidth + 1, LineTypes.Link8);
                Cv2.Circle(dst3, c[v[2]], task.DotSize + 2, task.HighlightColor, -1);
            }
        }
    }

    public class CS_Convex_RedCloudDefects : CS_Parent
    {
        CS_Convex_RedCloud convex;
        CS_Contour_Largest contours;

        public CS_Convex_RedCloudDefects(VBtask task) : base(task)
        {
            convex = new CS_Convex_RedCloud(task);
            contours = new CS_Contour_Largest(task);

            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "", "Hull outline in green, lines show defects.", "Output of RedCloud_Basics" };
            desc = "Find the convexityDefects in the selected RedCloud cell";
        }

        public List<cv.Point> BetterContour(List<cv.Point> c, Vec4i[] defects)
        {
            int lastV = -1;
            var newC = new List<cv.Point>();
            foreach (Vec4i v in defects)
            {
                if (v[0] != lastV && lastV >= 0)
                {
                    for (int i = lastV; i < v[0]; i++)
                    {
                        newC.Add(c[i]);
                    }
                }
                newC.Add(c[v[0]]);
                newC.Add(c[v[2]]);
                newC.Add(c[v[1]]);
                lastV = v[1];
            }
            if (defects.Length > 0)
            {
                if (lastV != defects[0][0])
                {
                    for (int i = lastV; i < c.Count; i++)
                    {
                        newC.Add(c[i]);
                    }
                }
                newC.Add(c[defects[0][0]]);
            }
            return newC;
        }

        public void RunCS(Mat src)
        {
            convex.RunAndMeasure(src, convex);
            dst1 = convex.redC.dst2;
            labels[1] = convex.redC.labels[2];
            dst3 = convex.dst3;

            var rc = task.rc;
            if (rc.mask == null) return;

            dst2 = rc.mask.Resize(dst2.Size(), 0, 0, InterpolationFlags.Nearest);
            contours.RunAndMeasure(dst2, contours);
            var c = contours.bestContour;

            cv.Point[] hull = Cv2.ConvexHull(c, false);
            int[] hullIndices = Cv2.ConvexHullIndices(c, false);
            dst2.SetTo(0);
            DrawContour(dst2, hull.ToList(), vecToScalar(rc.color), -1);

            try
            {
                Vec4i[] defects = Cv2.ConvexityDefects(contours.bestContour, hullIndices.ToList());
                rc.contour = BetterContour(c, defects);
            }
            catch (Exception)
            {
                SetTrueText("Convexity defects failed due to self-intersection.", 3);
            }

            DrawContour(dst2, rc.contour, Scalar.Red);
        }
    }



    public class CS_Corners_Basics : CS_Parent
    {
        public List<Point2f> features = new List<Point2f>();
        public Options_Features options = new Options_Features();
        public Options_Corners optionCorner = new Options_Corners();

        public CS_Corners_Basics(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U);
            desc = "Find interesting points with the FAST (Features from Accelerated Segment Test) algorithm";
        }

        public void RunCS(Mat src)
        {
            optionCorner.RunVB();
            options.RunVB();

            dst2 = src.Clone();
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            KeyPoint[] kpoints = Cv2.FAST(src, task.FASTthreshold, optionCorner.useNonMax);

            features.Clear();
            foreach (KeyPoint kp in kpoints)
            {
                features.Add(new cv.Point2f(kp.Pt.X, kp.Pt.Y));
            }

            if (standaloneTest())
            {
                dst3.SetTo(new Scalar(0));
                foreach (KeyPoint kp in kpoints)
                {
                    DrawCircle(dst2, kp.Pt, task.DotSize, Scalar.Yellow, -1);
                    dst3.Set((int)kp.Pt.Y, (int)kp.Pt.X, (byte)255);
                }
            }
            labels[2] = $"There were {features.Count} key points detected using FAST";
        }
    }

    public class CS_Corners_Harris : CS_Parent
    {
        public Options_HarrisCorners options = new Options_HarrisCorners();
        public Mat gray, mc;
        public mmData mm;

        public CS_Corners_Harris(VBtask task) : base(task)
        {
            desc = "Find corners using Eigen values and vectors";
            labels[3] = "Corner Eigen values";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            mc = new Mat(gray.Size(), MatType.CV_32FC1, new Scalar(0));
            dst2 = new Mat(gray.Size(), MatType.CV_8U, new Scalar(0));
            Cv2.CornerEigenValsAndVecs(gray, dst2, options.blockSize, options.aperture, BorderTypes.Default);

            for (int y = 0; y < gray.Rows - 1; y++)
            {
                for (int x = 0; x < gray.Cols - 1; x++)
                {
                    float lambda_1 = dst2.Get<Vec6f>(y, x)[0];
                    float lambda_2 = dst2.Get<Vec6f>(y, x)[1];
                    mc.Set(y, x, (float)(lambda_1 * lambda_2 - 0.04f * Math.Pow(lambda_1 + lambda_2, 2)));
                }
            }

            mm = GetMinMax(mc);

            src.CopyTo(dst2);
            int count = 0;
            for (int y = 0; y < gray.Rows - 1; y++)
            {
                for (int x = 0; x < gray.Cols - 1; x++)
                {
                    if (mc.Get<float>(y, x) > mm.minVal + (mm.maxVal - mm.minVal) * options.quality / options.qualityMax)
                    {
                        Cv2.Circle(dst2, new cv.Point(x, y), task.DotSize, task.HighlightColor, -1);
                        count += 1;
                    }
                }
            }

            labels[2] = $"Corners_Harris found {count} corners in the image."; 
            Mat McNormal = new Mat();
            Cv2.Normalize(mc, McNormal, 127, 255, NormTypes.MinMax);
            McNormal.ConvertTo(dst3, MatType.CV_8U);
        }
    }

    public class CS_Corners_PreCornerDetect : CS_Parent
    {
        public Math_Median_CDF median = new Math_Median_CDF();
        public Options_PreCorners options = new Options_PreCorners();

        public CS_Corners_PreCornerDetect(VBtask task) : base(task)
        {
            desc = "Use PreCornerDetect to find features in the image.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat prob = new Mat();
            Cv2.PreCornerDetect(gray, prob, options.kernelSize);

            Cv2.Normalize(prob, prob, 0, 255, NormTypes.MinMax);
            prob.ConvertTo(gray, MatType.CV_8U);
            median.Run(gray.Clone());
            dst2 = gray.CvtColor(ColorConversionCodes.GRAY2BGR);
            dst3 = gray.Threshold(160, 255, ThresholdTypes.BinaryInv).CvtColor(ColorConversionCodes.GRAY2BGR);
            labels[3] = $"median = {median.medianVal}";
        }
    }

    public class CS_Corners_ShiTomasi_CPP : CS_Parent
    {
        public Options_ShiTomasi options = new Options_ShiTomasi();

        public CS_Corners_ShiTomasi_CPP(VBtask task) : base(task)
    {
            desc = "Find corners using Eigen values and vectors";
            labels[3] = "Corner Eigen values using ShiTomasi which is also what is used in GoodFeatures.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            byte[] data = new byte[src.Total() * src.Channels()];
            GCHandle handle = GCHandle.Alloc(data, GCHandleType.Pinned);
            Marshal.Copy(src.Data, data, 0, data.Length);
            IntPtr imagePtr = Corners_ShiTomasi(handle.AddrOfPinnedObject(), src.Rows, src.Cols, options.blocksize, options.aperture);
            handle.Free();

            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_32F, imagePtr).Clone();

            dst3 = GetNormalize32f(dst2);
            dst3 = dst3.Threshold(options.threshold, 255, ThresholdTypes.Binary);
        }

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Corners_ShiTomasi(IntPtr grayPtr, int rows, int cols, int blocksize, int aperture);
    }

    public class CS_Corners_BasicsCentroid : CS_Parent
    {
        public Corners_Basics fast = new Corners_Basics();
        public Kalman_Basics kalman = new Kalman_Basics();

        public CS_Corners_BasicsCentroid(VBtask task) : base(task)
    {
            kalman.kInput = new float[2];
            desc = "Find interesting points with the FAST and smooth the centroid with kalman";
        }

        public void RunCS(Mat src)
        {
            fast.Run(src);
            dst2 = fast.dst2;
            foreach (Point2f pt in fast.features)
            {
                DrawCircle(dst3, pt, task.DotSize + 2, Scalar.White, -1);
            }
            Mat gray = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            Moments m = Cv2.Moments(gray, true);
            if (m.M00 > 5000)
            {
                kalman.kInput[0] = (float)(m.M10 / m.M00);
                kalman.kInput[1] = (float)(m.M01 / m.M00);
                kalman.Run(src);
                Cv2.Circle(dst3, new cv.Point((int)kalman.kOutput[0], (int)kalman.kOutput[1]), 10, Scalar.Red, -1);
            }
        }
    }

    public class CS_Corners_BasicsStablePoints : CS_Parent
    {
        public List<cv.Point> features = new List<cv.Point>();
        public Corners_Basics fast = new Corners_Basics();

        public CS_Corners_BasicsStablePoints(VBtask task) : base(task)
    {
            labels = new string[] { "", "", "", "FAST stable points without context" };
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, new Scalar(0));
            desc = "Find and save only the stable points in the FAST output.";
        }

        public void RunCS(Mat src)
        {
            fast.Run(src);

            if (task.motionFlag || task.optionsChanged)
            {
                foreach (Point2f pt in fast.features)
                {
                    features.Add(new cv.Point((int)pt.X, (int)pt.Y));
                }
            }
            List<cv.Point> newPts = new List<cv.Point>();
            dst2 = src.Clone();
            dst3.SetTo(new Scalar(0));
            foreach (Point2f pt in fast.features)
            {
                cv.Point test = new cv.Point((int)pt.X, (int)pt.Y);
                if (features.Contains(test))
                {
                    Cv2.Circle(dst2, test, task.DotSize, Scalar.Yellow, -1);
                    newPts.Add(test);
                    dst3.Set(test.Y, test.X, (byte)255);
                }
            }

            features = newPts;
            labels[2] = $"{features.Count.ToString("000")} identified FAST stable points - slider adjusts threshold";
        }
    }

    public class CS_Corners_BasicsCentroids : CS_Parent
    {
        public Corners_Basics fast = new Corners_Basics();
        public Point2f[] fastCenters;

        public CS_Corners_BasicsCentroids(VBtask task) : base(task)
    {
            if (standaloneTest()) task.gOptions.setGridSize(16);
            desc = "Use a thread grid to find the centroids in each grid element";
        }

        public void RunCS(Mat src)
        {
            dst2 = src.Clone();

            fast.Run(src);
            fastCenters = new Point2f[task.gridList.Count];
            for (int i = 0; i < task.gridList.Count; i++)
            {
                Rect roi = task.gridList[i];
                Mat tmp = fast.dst3[roi];
                var nonZero = tmp.FindNonZero();
                if (nonZero.Rows > 0)
                {
                    Scalar mean = Cv2.Mean(tmp, null);
                    fastCenters[i] = new Point2f((float)(roi.X + mean.Val0), (float)(roi.Y + mean.Val1));
                }
            }

            foreach (Point2f center in fastCenters)
            {
                DrawCircle(dst2, center, task.DotSize, Scalar.Yellow);
            }
            dst2.SetTo(new Scalar(255), task.gridMask);
        }
    }

    public class CS_Corners_Harris_CPP : CS_Parent
    {
        public AddWeighted_Basics addw = new AddWeighted_Basics();
        public Options_Harris options = new Options_Harris();

        public CS_Corners_Harris_CPP(VBtask task) : base(task)
    {
            cPtr = Harris_Features_Open();
            desc = "Use Harris feature detectors to identify interesting points.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] dataSrc = new byte[src.Total() * src.Channels()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Harris_Features_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.threshold,
                                                  (short) options.neighborhood, (short) options.aperture, options.harrisParm);
            handleSrc.Free();

            Mat gray32f = new Mat(src.Rows, src.Cols, MatType.CV_32F, imagePtr);
            // gray32f = GetNormalize32f(gray32f);
            gray32f.ConvertTo(dst2, MatType.CV_8U);
            addw.src2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.Run(task.color);
            dst3 = addw.dst2;
            labels[3] = "RGB overlaid with Harris result.";
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Harris_Features_Close(cPtr);
        }

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Features_Open();

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Features_Close(IntPtr Harris_FeaturesPtr);

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Features_Run(IntPtr Harris_FeaturesPtr, IntPtr inputPtr, int rows, int cols, float threshold, short neighborhood, short aperture, float HarrisParm);
    }

    public class CS_Corners_HarrisDetector : CS_Parent
    {
        public List<Point2f> features = new List<Point2f>();
        public Options_Features options = new Options_Features();

        public CS_Corners_HarrisDetector(VBtask task) : base(task)
    {
            cPtr = Harris_Detector_Open();
            desc = "Use Harris detector to identify interesting points.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = src.Clone();

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] dataSrc = new byte[src.Total() * src.Channels()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Harris_Detector_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.quality);
            handleSrc.Free();
            int ptCount = Harris_Detector_Count(cPtr);
            if (ptCount > 1)
            {
                Mat ptMat = new Mat(ptCount, 2, MatType.CV_32S, imagePtr).Clone();
                features.Clear();
                for (int i = 0; i < ptCount; i++)
                {
                    features.Add(new Point2f(ptMat.Get<int>(i, 0), ptMat.Get<int>(i, 1)));
                    DrawCircle(dst2, features[i], task.DotSize, Scalar.Yellow, -1);
                }
            }
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Harris_Detector_Close(cPtr);
        }

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern int Harris_Detector_Count(IntPtr cPtr);

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Detector_Open();

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Detector_Close(IntPtr Harris_FeaturesPtr);

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr Harris_Detector_Run(IntPtr Harris_FeaturesPtr, IntPtr inputPtr, int rows, int cols, double qualityLevel);
    }

    public class CS_Corners_RedCloud : CS_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        public Neighbors_Intersects corners = new Neighbors_Intersects();

        public CS_Corners_RedCloud(VBtask task) : base(task)
    {
            labels = new string[] { "", "", "Grayscale", "Highlighted points show where more than 2 cells intersect." };
            desc = "Find the corners for each RedCloud cell.";
        }

        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];

            corners.Run(task.cellMap);

            dst3 = new Mat();
            src.CopyTo(dst3);
            foreach (Point2f pt in corners.nPoints)
            {
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor, -1);
                DrawCircle(dst3, pt, task.DotSize, Scalar.Yellow, -1);
            }
        }
    }

    public class CS_Corners_SubPix : CS_Parent
    {
        public Feature_Basics feat = new Feature_Basics();
        public Options_PreCorners options = new Options_PreCorners();

        public CS_Corners_SubPix(VBtask task) : base(task)
        {
            labels[2] = "Output of PreCornerDetect";
            desc = "Use PreCornerDetect to refine the feature points to sub-pixel accuracy.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = src.Clone();
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            feat.Run(src);
            cv.TermCriteria term = new cv.TermCriteria((cv.CriteriaTypes)((int)cv.CriteriaTypes.Eps + (int)cv.CriteriaTypes.Count), 10, 1.0);
            Cv2.CornerSubPix(src, task.features, new cv.Size(options.subpixSize, options.subpixSize), new cv.Size(-1, -1), term);

            List<cv.Point> featurePoints = new List<cv.Point>();
            for (int i = 0; i < task.features.Count; i++)
            {
                Point2f pt = task.features[i];
                featurePoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor, -1);
            }
        }
    }


    public class CS_Correlation_Basics : CS_Parent
    {
        KMeans_Edges kFlood = new KMeans_Edges();
        Options_FeatureMatch options = new Options_FeatureMatch();

        public CS_Correlation_Basics(VBtask task) : base(task)
        {
            labels[3] = "Plot of z (vertical scale) to x with ranges shown on the plot.";
            UpdateAdvice(traceName + ": there are several local options panels.");
            desc = "Compute a correlation for src rows (See also: Match.cs";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            kFlood.Run(src);
            dst1 = kFlood.dst2;
            dst2 = kFlood.dst3;

            int row = task.mouseMovePoint.Y;
            if (row == 0)
                SetTrueText("Move mouse across image to see the relationship between X and Z\n" +
                            "A linear relationship is a useful correlation", new cv.Point(0, 10), 3);

            Mat dataX = new Mat(src.Size(), MatType.CV_32F, Scalar.All(0));
            Mat dataY = new Mat(src.Size(), MatType.CV_32F, Scalar.All(0));
            Mat dataZ = new Mat(src.Size(), MatType.CV_32F, Scalar.All(0));

            Mat mask = kFlood.dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            task.pcSplit[0].CopyTo(dataX, mask);
            task.pcSplit[1].CopyTo(dataY, mask);
            task.pcSplit[2].CopyTo(dataZ, mask);

            Mat row1 = dataX.Row(row);
            Mat row2 = dataZ.Row(row);
            Cv2.Line(dst2, new cv.Point(0, row), new cv.Point(dst2.Width, row), Scalar.Yellow, task.lineWidth + 1);

            Mat correlationMat = new Mat();
            Cv2.MatchTemplate(row1, row2, correlationMat, options.matchOption);
            float correlation = correlationMat.Get<float>(0, 0);
            labels[2] = $"Correlation of X to Z = {correlation:F2}";

            dst3.SetTo(Scalar.All(0));
            List<float> plotX = new List<float>();
            List<float> plotZ = new List<float>();
            for (int i = 0; i < row1.Cols; i++)
            {
                float x = row1.Get<float>(0, i);
                float z = row2.Get<float>(0, i);
                if (x != 0 && z != 0)
                {
                    plotX.Add(x);
                    plotZ.Add(z);
                }
            }

            if (plotX.Count > 0)
            {
                float minx = plotX.Min(), maxx = plotX.Max();
                float minZ = plotZ.Min(), maxZ = plotZ.Max();
                for (int i = 0; i < plotX.Count; i++)
                {
                    float x = dst3.Width * (plotX[i] - minx) / (maxx - minx);
                    float y = dst3.Height * (plotZ[i] - minZ) / (maxZ - minZ);
                    Cv2.Circle(dst3, new cv.Point(x, y), task.DotSize, Scalar.Yellow, -1);
                }
                SetTrueText($"Z-min {minZ:F2}", new cv.Point(10, 5), 3);
                SetTrueText($"Z-max {maxZ:F2}\n\tX-min {minx:F2}", new cv.Point(0, dst3.Height - 20), 3);
                SetTrueText($"X-max {maxx:F2}", new cv.Point(dst3.Width - 40, dst3.Height - 10), 3);
            }
        }
    }


    public class CS_Covariance_Basics : CS_Parent
    {
        CS_Random_Basics random;
        public Mat mean = new Mat();
        public Mat covariance = new Mat();
        cv.Point2f lastCenter;
        public CS_Covariance_Basics(VBtask task) : base(task)
        {
            random = new CS_Random_Basics(task);
            UpdateAdvice(traceName + ": use the local options to control the number of points.");
            desc = "Calculate the covariance of random depth data points.";
        }

        public void RunCS(Mat src)
        {
            dst3.SetTo(0);
            if (standaloneTest())
            {
                random.RunAndMeasure(empty, random);
                src = new Mat(random.PointList.Count, 2, MatType.CV_32F, random.PointList.ToArray());
                for (int i = 0; i < random.PointList.Count; i++)
                {
                    DrawCircle(dst3, random.PointList[i], 3, Scalar.White);
                }
            }

            Mat samples2 = src.Reshape(2);
            Cv2.CalcCovarMatrix(src, covariance, mean, CovarFlags.Cols);

            strOut = "The Covariance Mat:\n";
            for (int j = 0; j < covariance.Rows; j++)
            {
                for (int i = 0; i < covariance.Cols; i++)
                {
                    strOut += string.Format(fmt3, covariance.Get<double>(j, i)) + ", ";
                }
                strOut += "\n";
            }
            strOut += "\n";

            Scalar overallMean = Cv2.Mean(samples2);
            cv.Point2f center = new Point2f((float)overallMean[0], (float)overallMean[1]);
            strOut += $"Mean (img1, img2) = ({center.X.ToString(fmt0)}, {center.Y.ToString(fmt0)})\n";

            if (standaloneTest())
            {
                if (task.FirstPass) lastCenter = center;
                DrawCircle(dst3, center, 5, Scalar.Red);
                DrawCircle(dst3, lastCenter, 5, Scalar.Yellow, task.lineWidth + 1);
                DrawLine(dst3, center, lastCenter, Scalar.Red, task.lineWidth + 1);
                lastCenter = center;
                strOut += "Yellow is last center, red is the current center";
            }
            SetTrueText(strOut);
        }
    }

    public class CS_Covariance_Test : CS_Parent
    {
        Covariance_Basics covar = new Covariance_Basics();

        public CS_Covariance_Test(VBtask task) : base(task)
        {
            desc = "Test the covariance basics algorithm.";
        }

        public void RunCS(Mat src)
        {
            double[] testInput = { 1.5, 2.3, 3.0, 1.7, 1.2, 2.9, 2.1, 2.2, 3.1, 3.1, 1.3, 2.7, 2.0, 1.7, 1.0, 2.0, 0.5, 0.6, 1.0, 0.9 };
            Mat samples = new Mat(10, 2, MatType.CV_64F, testInput);
            covar.Run(samples);
            SetTrueText(covar.strOut, new cv.Point(20, 60));
            SetTrueText("Results should be a symmetric array with 2.1 and -2.1", new cv.Point(20, 150));
        }
    }

    public class CS_Covariance_Images : CS_Parent
    {
        Covariance_Basics covar = new Covariance_Basics();
        public Mat mean;
        public Mat covariance;
        Mat last32f = new Mat();

        public CS_Covariance_Images(VBtask task) : base(task)
        {
            desc = "Calculate the covariance of 2 images";
        }

        public void RunCS(Mat src)
        {
            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (task.optionsChanged) gray.ConvertTo(last32f, MatType.CV_32F);
            dst2 = gray;

            Mat gray32f = new Mat();
            gray.ConvertTo(gray32f, MatType.CV_32F);
            Cv2.Merge(new[] { gray32f, last32f }, dst0);
            Mat samples = dst0.Reshape(1, dst0.Rows * dst0.Cols);
            covar.Run(samples);

            last32f = gray32f;

            SetTrueText(covar.strOut, new cv.Point(10, 10), 3);

            mean = covar.mean;
            covariance = covar.covariance;
        }
    }


    public class CS_Crypto_Hash : CS_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        List<Mat> images = new List<Mat>();
        List<string> guids = new List<string>();

        public CS_Crypto_Hash(VBtask task) : base(task)
        {
            flow.parentData = this;
            desc = "Experiment with hashing algorithm and guid";
        }

        public void RunCS(Mat src)
        {
            int iSize = (int)(src.Total() * src.ElemSize());
            int maxImages = 10;
            images.Add(src);

            if (images.Count >= maxImages)
            {
                byte[] bytes = new byte[iSize * maxImages];
                images.RemoveAt(0);

                int index = 0;
                foreach (Mat mat in images)
                {
                    Marshal.Copy(mat.Data, bytes, iSize * index, iSize);
                    index++;
                }

                using (MD5 algorithm = MD5.Create())
                {
                    bytes = algorithm.ComputeHash(bytes);
                }

                guids.Add(new Guid(bytes).ToString());
                flow.flowText.Clear();

                for (int i = 0; i < guids.Count; i++)
                {
                    flow.flowText.Add(guids[i]);
                }

                if (guids.Count >= flow.maxLines)
                {
                    guids.RemoveAt(0);
                }


                flow.Run(empty);
            }
        }
    }



    public class CS_CSV_Basics : CS_Parent
    {
        public string InputFile { get; set; }
        public string[,] Array { get; set; }
        public List<List<string>> ArrayList { get; set; }

        public CS_CSV_Basics(VBtask task) : base(task)
        {
            var fileInput = new FileInfo(Path.Combine(task.HomeDir, "Data/agaricus-lepiota.data"));
            InputFile = fileInput.FullName;
            desc = "Read and prepare a .csv file";
            ArrayList = new List<List<string>>();
        }

        public void RunCS(Mat src)
        {
            string[] readText = File.ReadAllLines(InputFile);
            string[] variables = readText[0].Split(',');
            Array = new string[readText.Length, variables.Length];

            for (int i = 0; i < Array.GetLength(0); i++)
            {
                variables = readText[i].Split(',');
                for (int j = 0; j < Array.GetLength(1); j++)
                {
                    Array[i, j] = variables[j];
                }
            }

            for (int i = 0; i < Array.GetLength(1); i++)
            {
                ArrayList.Add(new List<string>());
                for (int j = 0; j < Array.GetLength(0); j++)
                {
                    ArrayList[i].Add(Array[j, i]);
                }
            }

            if (standaloneTest())
            {
                SetTrueText($"{InputFile} is now loaded into the csv.array");
            }
        }
    }




    public class CS_DCT_Basics : CS_Parent
    {
        public Options_DCT options = new Options_DCT();

        public CS_DCT_Basics(VBtask task) : base(task)
        {
            labels[3] = "Difference from original";
            UpdateAdvice(traceName + ": local options control the Discrete Cosine Transform'");
            desc = "Apply OpenCV's Discrete Cosine Transform to a grayscale image and use slider to remove the highest frequencies.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            Mat src32f = new Mat();
            src.ConvertTo(src32f, MatType.CV_32F, 1.0 / 255);

            Mat frequencies = new Mat();
            Cv2.Dct(src32f, frequencies, (cv.DctFlags) options.removeFrequency);

            Rect roi = new Rect(0, 0, options.removeFrequency, src32f.Height);
            if (roi.Width > 0)
                frequencies[roi].SetTo(0);
            labels[2] = "Frequencies below " + options.removeFrequency.ToString() + " removed";

            Cv2.Dct(frequencies, src32f, DctFlags.Inverse);
            src32f.ConvertTo(dst2, MatType.CV_8UC1, 255);

            Cv2.Subtract(src, dst2, dst3);
        }
    }

    public class CS_DCT_RGB : CS_Parent
    {
        public DCT_Basics dct = new DCT_Basics();

        public CS_DCT_RGB(VBtask task) : base(task)
        {
            labels[3] = "Difference from original";
            desc = "Apply OpenCV's Discrete Cosine Transform to a BGR image and use slider to remove the highest frequencies.";
        }

        public void RunCS(Mat src)
        {
            dct.options.RunVB();

            Mat[] srcPlanes = Cv2.Split(src);

            Mat[] freqPlanes = new Mat[3];
            for (int i = 0; i < srcPlanes.Length; i++)
            {
                Mat src32f = new Mat();
                srcPlanes[i].ConvertTo(src32f, MatType.CV_32FC3, 1.0 / 255);
                freqPlanes[i] = new Mat();
                Cv2.Dct(src32f, freqPlanes[i], DctFlags.None);

                Rect roi = new Rect(0, 0, dct.options.removeFrequency, src32f.Height);
                if (roi.Width > 0)
                    freqPlanes[i][roi].SetTo(0);

                Cv2.Dct(freqPlanes[i], src32f, dct.options.dctFlag);
                src32f.ConvertTo(srcPlanes[i], MatType.CV_8UC1, 255);
            }
            labels[2] = dct.labels[2];

            Cv2.Merge(srcPlanes, dst2);

            Cv2.Subtract(src, dst2, dst3);
        }
    }

    public class CS_DCT_Depth : CS_Parent
    {
        DCT_Basics dct = new DCT_Basics();

        public CS_DCT_Depth(VBtask task) : base(task)
        {
            labels[3] = "Subtract DCT inverse from Grayscale depth";
            desc = "Find featureless surfaces in the depth data - expected to be useful only on the K4A for Azure camera.";
        }

        public void RunCS(Mat src)
        {
            Mat gray = task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat frequencies = new Mat();
            Mat src32f = new Mat();
            gray.ConvertTo(src32f, MatType.CV_32F, 1.0 / 255);
            Cv2.Dct(src32f, frequencies, dct.options.dctFlag);

            Rect roi = new Rect(0, 0, dct.options.removeFrequency, src32f.Height);
            if (roi.Width > 0)
                frequencies[roi].SetTo(0);
            labels[2] = dct.labels[2];

            Cv2.Dct(frequencies, src32f, DctFlags.Inverse);
            src32f.ConvertTo(dst2, MatType.CV_8UC1, 255);

            Cv2.Subtract(gray, dst2, dst3);
        }
    }

    public class CS_DCT_FeatureLess : CS_Parent
    {
        public DCT_Basics dct = new DCT_Basics();

        public CS_DCT_FeatureLess(VBtask task) : base(task)
        {
            desc = "Find surfaces that lack any texture. Remove just the highest frequency from the DCT to get horizontal lines through the image.";
            labels[3] = "FeatureLess BGR regions";
        }

        public void RunCS(Mat src)
        {
            dct.Run(src);

            dst2.SetTo(0);
            for (int i = 0; i < dct.dst2.Rows; i++)
            {
                int runLen = 0;
                int runStart = 0;
                for (int j = 1; j < dct.dst2.Cols; j++)
                {
                    if (dct.dst2.Get<byte>(i, j) == dct.dst2.Get<byte>(i, j - 1))
                    {
                        runLen++;
                    }
                    else
                    {
                        if (runLen > dct.options.runLengthMin)
                        {
                            Rect roi = new Rect(runStart, i, runLen, 1);
                            dst2[roi].SetTo(255);
                        }
                        runStart = j;
                        runLen = 1;
                    }
                }
            }

            dst3.SetTo(0);
            if (dst2.Channels() == 3)
            {
                dst2 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(1, 255, ThresholdTypes.Binary);
            }
            else
            {
                dst2 = dst2.Threshold(1, 255, ThresholdTypes.Binary);
            }
            src.CopyTo(dst3, ~dst2);
            labels[2] = "Mask of DCT with highest frequency removed";
        }
    }

    public class CS_DCT_Surfaces_debug : CS_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        DCT_FeatureLess dct = new DCT_FeatureLess();
        Font_FlowText flow = new Font_FlowText();
        Plane_CellColor plane = new Plane_CellColor();

        public CS_DCT_Surfaces_debug(VBtask task) : base(task)
        {
            flow.parentData = this;
            labels = new string[] { "", "", "Stats on the largest region below DCT threshold", "Various views of regions with DCT below threshold" };
            task.gOptions.setDisplay0();
            desc = "Find plane equation for a featureless surface - debugging one region for now.";
        }

        public void RunCS(Mat src)
        {
            mats.mat[0] = src.Clone();
            mats.mat[0].SetTo(Scalar.White, task.gridMask);

            dct.Run(src);
            mats.mat[1] = dct.dst2.CvtColor(ColorConversionCodes.GRAY2BGR).Clone();
            mats.mat[2] = dct.dst3.Clone();

            Mat mask = dct.dst2.Clone();
            task.pcSplit[2].SetTo(0, ~mask);

            int maxIndex = 0;
            int[] roiCounts = new int[task.gridList.Count];
            for (int i = 0; i < task.gridList.Count; i++)
            {
                roiCounts[i] = mask[task.gridList[i]].CountNonZero();
                if (roiCounts[i] > roiCounts[maxIndex])
                    maxIndex = i;
            }

            mats.mat[3] = new Mat(src.Size(), MatType.CV_8UC3, 0);
            src[task.gridList[maxIndex]].CopyTo(mats.mat[3][task.gridList[maxIndex]], mask[task.gridList[maxIndex]]);
            mats.Run(new Mat());
            dst3 = mats.dst2;

            Rect roi = task.gridList[maxIndex];
            if (roi.X == task.gridList[maxIndex].X && roi.Y == task.gridList[maxIndex].Y)
            {
                if (roiCounts[maxIndex] > roi.Width * roi.Height / 4)
                {
                    List<Point3f> fitPoints = new List<Point3f>();
                    float minDepth = float.MaxValue, maxDepth = float.MinValue;
                    for (int j = 0; j < roi.Height; j++)
                    {
                        for (int i = 0; i < roi.Width; i++)
                        {
                            float nextD = task.pcSplit[2][roi].Get<float>(j, i);
                            if (nextD != 0)
                            {
                                if (minDepth > nextD) minDepth = nextD;
                                if (maxDepth < nextD) maxDepth = nextD;
                                Point3f wpt = new Point3f(roi.X + i, roi.Y + j, nextD);
                                fitPoints.Add(getWorldCoordinates(wpt));
                            }
                        }
                    }
                    if (fitPoints.Count > 0)
                    {
                        var eq = fitDepthPlane(fitPoints);
                        if (!float.IsNaN(eq[0]))
                        {
                            flow.nextMsg = $"a={eq[0]:F2} b={eq[1]:F2} c={Math.Abs(eq[2]):F2}\t" +
                                          $"depth={-eq[3]:F2}m roi(x,y) = {roi.X:000},{roi.Y:000}\t" +
                                          $"Min={minDepth:F1}m Max={maxDepth:F1}m";
                        }
                    }
                }
            }
            flow.Run(empty);
        }
    }


    public class CS_Delaunay_Basics : CS_Parent
    {
        public List<Point2f> inputPoints;
        public List<List<cv.Point>> facetList = new List<List<cv.Point>>();
        public Mat facet32s;
        Random_Enumerable randEnum = new Random_Enumerable();
        Subdiv2D subdiv = new Subdiv2D();

        public CS_Delaunay_Basics(VBtask task) : base(task)
        {
            facet32s = new Mat(dst2.Size(), MatType.CV_32SC1, 0);
            labels[3] = "CV_8U map of Delaunay cells";
            desc = "Subdivide an image based on the points provided.";
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat && standalone)
            {
                randEnum.Run(null);
                inputPoints = randEnum.points.ToList();
            }

            subdiv.InitDelaunay(new Rect(0, 0, dst2.Width, dst2.Height));
            subdiv.Insert(inputPoints.ToArray());

            cv.Point2f[][] facets = null;
            var facetIndices = new List<int>();
            var facetCenters = new Point2f[1];
            subdiv.GetVoronoiFacetList(facetIndices, out facets, out facetCenters);

            facetList.Clear();
            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var ptList = new List<cv.Point>();
                for (int j = 0; j < facets[i].Length - 1; j++)
                {
                    ptList.Add(new cv.Point(facets[i][j].X, facets[i][j].Y));
                }

                facet32s.FillConvexPoly(ptList.ToArray(), i, task.lineType);
                facetList.Add(ptList);
            }
            facet32s.ConvertTo(dst3, MatType.CV_8U);
            dst2 = ShowPalette(dst3);
            labels[2] = traceName + ": " + inputPoints.Count.ToString("000") + " cells were present.";
        }
    }

    public class CS_Delaunay_SubDiv : CS_Parent
    {
        Random_Basics random = new Random_Basics();

        public CS_Delaunay_SubDiv(VBtask task) : base(task)
        {
            FindSlider("Random Pixel Count").Value = 100;
            desc = "Use Delaunay to subdivide an image into triangles.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (!task.heartBeat) return;
            }

            var subdiv = new Subdiv2D(new Rect(0, 0, dst2.Width, dst2.Height));
            random.Run(null);
            dst2.SetTo(new Scalar(0));

            foreach (var pt in random.PointList)
            {
                subdiv.Insert(pt);
                var edgeList = subdiv.GetEdgeList();
                foreach (var e in edgeList)
                {
                    var p0 = new cv.Point(Math.Round(e[0]), Math.Round(e[1]));
                    var p1 = new cv.Point(Math.Round(e[2]), Math.Round(e[3]));
                    DrawLine(dst2, p0, p1, new Scalar(255), task.lineWidth);
                }
            }

            foreach (var pt in random.PointList)
            {
                DrawCircle(dst2, pt, task.DotSize + 1, new Scalar(255, 0, 0), -1);
            }

            cv.Point2f[][] facets = null;
            var centers = new Point2f[1];
            subdiv.GetVoronoiFacetList(null, out facets, out centers);

            var ifacet = new cv.Point[1];
            var ifacets = new cv.Point[1][];

            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                Array.Resize(ref ifacet, facets[i].Length - 1);
                for (int j = 0; j < facets[i].Length - 1; j++)
                {
                    ifacet[j] = new cv.Point(Math.Round(facets[i][j].X), Math.Round(facets[i][j].Y));
                }
                ifacets[0] = ifacet;
                dst3.FillConvexPoly(ifacet, task.scalarColors[i % task.scalarColors.Length], task.lineType);
                Cv2.Polylines(dst3, ifacets, true, new Scalar(0, 0, 0), task.lineWidth, LineTypes.AntiAlias, 0);
            }
        }
    }

    public class CS_Delaunay_Subdiv2D : CS_Parent
    {
        public CS_Delaunay_Subdiv2D(VBtask task) : base(task)
        {
            labels[3] = "Voronoi facets for the same subdiv2D";
            desc = "Generate random points and divide the image around those points.";
        }

        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            dst2.SetTo(new Scalar(0));
            var points = Enumerable.Range(0, 100)
                .Select(i => new Point2f(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height)))
                .ToArray();

            foreach (var p in points)
            {
                DrawCircle(dst2, p, task.DotSize + 1, 255, -1);
            }
            dst3 = dst2.Clone();

            var subdiv = new Subdiv2D(new Rect(0, 0, dst3.Width, dst3.Height));
            subdiv.Insert(points);

            cv.Point2f[][] facets = null;
            var facetCenters = new Point2f[1];
            subdiv.GetVoronoiFacetList(null, out facets, out facetCenters);

            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var before = facets[i][facets[i].Length - 1];
                foreach (var p in facets[i])
                {
                    DrawLine(dst2, before, p, new Scalar(0, 255, 0), 1);
                    before = p;
                }
            }

            var edgelist = subdiv.GetEdgeList();
            foreach (var edge in edgelist)
            {
                var p1 = new Point2f(edge[0], edge[1]);
                var p2 = new Point2f(edge[2], edge[3]);
                DrawLine(dst2, p1, p2, new Scalar(0, 255, 0), 1);
            }
        }
    }

    public class CS_Delaunay_GenerationsNoKNN : CS_Parent
    {
        public List<Point2f> inputPoints;
        public Delaunay_Basics facet = new Delaunay_Basics();
        Random_Basics random = new Random_Basics();

        public CS_Delaunay_GenerationsNoKNN(VBtask task) : base(task)
        {
            FindSlider("Random Pixel Count").Value = 10;
            dst3 = new Mat(dst3.Size(), MatType.CV_32S, 0);
            labels = new string[] { "", "Mask of unmatched regions - generation set to 0", "Facet Image with index of each region", "Generation counts for each region." };
            desc = "Create a region in an image for each cv.Point provided without using KNN.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest() && task.heartBeat)
            {
                random.Run(null);
                inputPoints = random.PointList.ToList();
            }

            facet.inputPoints = inputPoints;
            facet.Run(src);
            dst2 = facet.dst2;

            var generationMap = dst3.Clone();
            dst3.SetTo(new Scalar(0));
            var usedG = new List<int>();
            var g = 0;
            foreach (var pt in inputPoints)
            {
                var index = facet.facet32s.Get<int>((int)pt.Y, (int)pt.X);
                if (index >= facet.facetList.Count) continue;
                var nextFacet = facet.facetList[index];
                // insure that each facet has a unique generation number
                if (task.FirstPass)
                {
                    g = usedG.Count;
                }
                else
                {
                    g = generationMap.Get<int>((int)pt.Y, (int)pt.X) + 1;
                    while (usedG.Contains(g))
                    {
                        g++;
                    }
                }
                dst3.FillConvexPoly(nextFacet.ToArray(), g, task.lineType);
                usedG.Add(g);
                SetTrueText(g.ToString(), new cv.Point((int)pt.X, (int)pt.Y), 2);
            }
            generationMap = dst3.Clone();
        }
    }

    public class CS_Delaunay_Generations : CS_Parent
    {
        public List<Point2f> inputPoints;
        public Delaunay_Basics facet = new Delaunay_Basics();
        KNN_Basics knn = new KNN_Basics();
        Random_Basics random = new Random_Basics();

        public CS_Delaunay_Generations(VBtask task) : base(task)
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32S, 0);
            labels = new string[] { "", "Mask of unmatched regions - generation set to 0", "Facet Image with count for each region", "Generation counts in CV_32SC1 format" };
            FindSlider("Random Pixel Count").Value = 10;
            desc = "Create a region in an image for each cv.Point provided";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (task.heartBeat)
                {
                    random.Run(null);
                }
                inputPoints = random.PointList.ToList();
            }

            knn.queries = inputPoints;
            knn.Run(null);

            facet.inputPoints = inputPoints;
            facet.Run(src);
            dst2 = facet.dst2;

            var generationMap = dst0.Clone();
            dst0.SetTo(new Scalar(0));
            var usedG = new List<int>();
            var g = 0;
            foreach (var mp in knn.matches)
            {
                var index = facet.facet32s.Get<int>((int)mp.p2.Y, (int)mp.p2.X);
                if (index >= facet.facetList.Count) continue;
                var nextFacet = facet.facetList[index];
                // insure that each facet has a unique generation number
                if (task.FirstPass)
                {
                    g = usedG.Count;
                }
                else
                {
                    g = generationMap.Get<int>((int)mp.p2.Y, (int)mp.p2.X) + 1;
                    while (usedG.Contains(g))
                    {
                        g++;
                    }
                }
                dst0.FillConvexPoly(nextFacet.ToArray(), g, task.lineType);
                usedG.Add(g);
                SetTrueText(g.ToString(), new cv.Point(mp.p2.X, mp.p2.Y), 2);
            }
        }
    }

    public class CS_Delaunay_ConsistentColor : CS_Parent
    {
        public List<Point2f> inputPoints;
        public List<List<cv.Point>> facetList = new List<List<cv.Point>>();
        public Mat facet32s;
        Random_Enumerable randEnum = new Random_Enumerable();
        Subdiv2D subdiv = new Subdiv2D();

        public CS_Delaunay_ConsistentColor(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            facet32s = new Mat(dst2.Size(), MatType.CV_32SC1, 0);
            UpdateAdvice(traceName + ": use local options to control the number of points");
            labels[1] = "Input points to subdiv";
            labels[3] = "Inconsistent colors in dst2 are duplicate randomCellColor output.";
            desc = "Subdivide an image based on the points provided.";
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat && standalone)
            {
                randEnum.Run(null);
                inputPoints = randEnum.points.ToList();
            }

            subdiv.InitDelaunay(new Rect(0, 0, dst2.Width, dst2.Height));
            subdiv.Insert(inputPoints.ToArray());

            cv.Point2f[][] facets = null;
            var facetCenters = new Point2f[1];
            subdiv.GetVoronoiFacetList(new List<int>(), out facets, out facetCenters);

            var usedColors = new List<Vec3b>(); 
            usedColors.Add(new Vec3b(0, 0, 0));
            facetList.Clear();
            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var nextFacet = new List<cv.Point>();
                for (int j = 0; j < facets[i].Length - 1; j++)
                {
                    nextFacet.Add(new cv.Point(facets[i][j].X, facets[i][j].Y));
                }

                var pt = inputPoints[i];
                var nextColor = dst3.Get<Vec3b>((int)pt.Y, (int)pt.X);
                if (usedColors.Contains(nextColor))
                {
                    nextColor = randomCellColor();
                }
                usedColors.Add(nextColor);

                dst2.FillConvexPoly(nextFacet.ToArray(), vecToScalar(nextColor));
                facet32s.FillConvexPoly(nextFacet.ToArray(), i, task.lineType);
                facetList.Add(nextFacet);
            }
            dst3 = dst2.Clone();
            dst1.SetTo(0);
            foreach (var pt in inputPoints)
            {
                dst1.Circle(new cv.Point((int)pt.X, (int)pt.Y), task.DotSize, task.HighlightColor, -1, task.lineType);
            }
            dst1 = dst3.Clone();
            labels[2] = traceName + ": " + inputPoints.Count.ToString("000") + " cells were present.";
        }
    }

    public class CS_Delaunay_Contours : CS_Parent
    {
        public List<Point2f> inputPoints;
        Random_Enumerable randEnum = new Random_Enumerable();
        Subdiv2D subdiv = new Subdiv2D();

        public CS_Delaunay_Contours(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            labels[3] = "CV_8U map of Delaunay cells";
            desc = "Subdivide an image based on the points provided.";
        }

        public void RunCS(Mat src)
        {
            if (task.heartBeat && standalone)
            {
                randEnum.Run(null);
                inputPoints = randEnum.points.ToList();
            }

            subdiv.InitDelaunay(new Rect(0, 0, dst2.Width, dst2.Height));
            subdiv.Insert(inputPoints.ToArray());

            cv.Point2f[][] facets = null;
            cv.Point2f[] facetCenters = null;
            subdiv.GetVoronoiFacetList(new List<int>(), out facets, out facetCenters);
            dst2.SetTo(0);
            for (int i = 0; i < facets.GetUpperBound(0); i++)
            {
                var ptList = new List<cv.Point>();
                for (int j = 0; j < facets[i].Length; j++)
                {
                    ptList.Add(new cv.Point(facets[i][j].X, facets[i][j].Y));
                }

                DrawContour(dst2, ptList, 255, 1);
            }
            labels[2] = traceName + ": " + inputPoints.Count.ToString("000") + " cells were present.";
        }
    }


    public class CS_Denoise_Basics_CPP : CS_Parent
    {
        Diff_Basics diff = new Diff_Basics();

        public CS_Denoise_Basics_CPP(VBtask task) : base(task)
        {
            cPtr = Denoise_Basics_Open(3);
            labels = new string[] { "", "", "Input image", "Output: Use PixelViewer to see changes" };
            desc = "Denoise example.";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY) - 1;

            byte[] dataSrc = new byte[src.Total()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Denoise_Basics_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();

            if (imagePtr != IntPtr.Zero)
            {
                dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();
                diff.Run(dst2);
                dst3 = diff.dst2;
            }
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Denoise_Basics_Close(cPtr);
        }
    }

    public class CS_Denoise_Pixels : CS_Parent
    {
        public int classCount;
        Options_Denoise options = new Options_Denoise();
        Reduction_Basics reduction = new Reduction_Basics();

        public CS_Denoise_Pixels(VBtask task) : base(task)
        {
            cPtr = Denoise_Pixels_Open();
            labels = new string[] { "", "", "Before removing single pixels", "After removing single pixels" };
            desc = "Remove single pixels between identical pixels";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest())
            {
                reduction.Run(src);
                src = reduction.dst2;
                classCount = reduction.classCount;
            }

            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (options.removeSinglePixels)
            {
                byte[] cppData = new byte[src.Total()];
                Marshal.Copy(src.Data, cppData, 0, cppData.Length);
                GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
                IntPtr imagePtr = Denoise_Pixels_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
                handleSrc.Free();
                dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr).Clone();
            }
            else
            {
                dst2 = src;
            }

            if (standaloneTest())
            {
                dst2 *= 255.0 / classCount;
                dst3 = ShowPalette(dst2);
            }

            if (task.heartBeat)
            {
                strOut = $"{classCount} pixel classes\n";
                strOut += $"{Denoise_Pixels_EdgeCountBefore(cPtr)} edges before\n";
                strOut += $"{Denoise_Pixels_EdgeCountAfter(cPtr)} edges after";
            }

            SetTrueText(strOut, 2);
        }

        public void Close()
        {
            Denoise_Pixels_Close(cPtr);
        }
    }



    public class CS_Depth_Basics : CS_Parent
    {
        Depth_Colorizer_CPP colorizer = new Depth_Colorizer_CPP();

        public CS_Depth_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": use global option to control 'Max Depth'.");
            desc = "Colorize the depth data into task.depthRGB";
        }

        public void RunCS(Mat src)
        {
            dst2 = task.pcSplit[2];

            task.pcSplit[2] = task.pcSplit[2].Threshold(task.MaxZmeters, task.MaxZmeters, ThresholdTypes.Trunc);
            if (task.FirstPass)
            {
                task.maxDepthMask = task.pcSplit[2].ConvertScaleAbs().InRange(task.MaxZmeters, task.MaxZmeters);
                task.maxDepthMask.SetTo(0);
            }
            if (standalone) dst3 = task.maxDepthMask;
            SetTrueText(task.gMat.strOut, 3);

            colorizer.Run(task.pcSplit[2]);
            task.depthRGB = colorizer.dst2;
        }
    }

    public class CS_Depth_Display : CS_Parent
    {
        public CS_Depth_Display(VBtask task) : base(task)
        {
            task.gOptions.setDisplay1();
            task.gOptions.setDisplay1();
            labels = new string[] { "task.pcSplit[2]", "task.pointcloud", "task.depthMask", "task.noDepthMask" };
            desc = "Display the task.pcSplit[2], task.pointcloud, task.depthMask, and task.noDepthMask";
        }

        public void RunCS(Mat src)
        {
            dst0 = task.pcSplit[2];
            dst1 = task.pointCloud;
            dst2 = task.depthMask;
            dst3 = task.noDepthMask;
        }
    }


    public class CS_Depth_FirstLastDistance : CS_Parent
    {
        public CS_Depth_FirstLastDistance(VBtask task) : base(task)
        {
            desc = "Monitor the first and last depth distances";
        }

        void identifyMinMax(cv.Point pt, string text)
        {
            Cv2.Circle(dst2, pt, task.DotSize, task.HighlightColor);
            SetTrueText(text, pt, 2);

            Cv2.Circle(dst3, pt, task.DotSize, task.HighlightColor);
            SetTrueText(text, pt, 3);
        }

        public void RunCS(Mat src)
        {
            var mm = GetMinMax(task.pcSplit[2], task.depthMask);
            task.depthRGB.CopyTo(dst2);

            if (task.heartBeat) dst3.SetTo(0);
            labels[2] = $"Min Depth {mm.minVal:F1}m";
            identifyMinMax(mm.minLoc, labels[2]);

            labels[3] = $"Max Depth {mm.maxVal:F1}m";
            identifyMinMax(mm.maxLoc, labels[3]);
        }
    }

    public class CS_Depth_HolesRect : CS_Parent
    {
        Depth_Holes shadow = new Depth_Holes();

        public CS_Depth_HolesRect(VBtask task) : base(task)
        {
            labels[2] = "The 10 largest contours in the depth holes.";
            desc = "Identify the minimum rectangles of contours of the depth shadow";
        }

        public void RunCS(Mat src)
        {
            shadow.Run(src);

            cv.Point[][] contours;
            if (shadow.dst3.Channels() == 3)
                shadow.dst3 = shadow.dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            Cv2.FindContours(shadow.dst3, out contours, out _, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);

            var sortContours = new SortedList<int, List<cv.Point>>(new compareAllowIdenticalIntegerInverted());
            foreach (var c in contours)
            {
                sortContours.Add(c.Length, c.ToList());
            }
            dst3.SetTo(0);
            for (int i = 0; i < Math.Min(sortContours.Count, 10); i++)
            {
                var contour = sortContours.ElementAt(i).Value;
                var minRect = Cv2.MinAreaRect(contour);
                var nextColor = new Scalar(task.vecColors[i % 256][0], task.vecColors[i % 256][1], task.vecColors[i % 256][2]);
                DrawRotatedRectangle(minRect, dst2, nextColor);
                Cv2.DrawContours(dst3, new[] { contour }, 0, Scalar.White, task.lineWidth);
            }
            Cv2.AddWeighted(dst2, 0.5, task.depthRGB, 0.5, 0, dst2);
        }
    }

    public class CS_Depth_MeanStdev_MT : CS_Parent
    {
        Mat meanSeries;
        float maxMeanVal, maxStdevVal;

        public CS_Depth_MeanStdev_MT(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Rows, dst2.Cols, MatType.CV_8U, 0);
            dst3 = new Mat(dst3.Rows, dst3.Cols, MatType.CV_8U, 0);
            desc = "Collect a time series of depth mean and stdev to highlight where depth is unstable.";
        }

        public void RunCS(Mat src)
        {
            if (task.optionsChanged)
                meanSeries = new Mat(task.gridList.Count, task.frameHistoryCount, MatType.CV_32F, 0);

            int index = task.frameCount % task.frameHistoryCount;
            float[] meanValues = new float[task.gridList.Count];
            float[] stdValues = new float[task.gridList.Count];

            Parallel.For(0, task.gridList.Count, i =>
            {
                var roi = task.gridList[i];
                Cv2.MeanStdDev(task.pcSplit[2][roi], out Scalar mean, out Scalar stdev, task.depthMask[roi]);
                meanSeries.Set(i, index, (float)mean.Val0);
                if (task.frameCount >= task.frameHistoryCount - 1)
                {
                    Cv2.MeanStdDev(meanSeries.Row(i), out mean, out stdev);
                    meanValues[i] = (float)mean.Val0;
                    stdValues[i] = (float)stdev.Val0;
                }
            });

            if (task.frameCount >= task.frameHistoryCount)
            {
                var means = new Mat(task.gridList.Count, 1, MatType.CV_32F, meanValues);
                var stdevs = new Mat(task.gridList.Count, 1, MatType.CV_32F, stdValues);
                var meanmask = means.Threshold(1, task.MaxZmeters, ThresholdTypes.Binary).ConvertScaleAbs();
                var mm = GetMinMax(means, meanmask);
                var stdMask = stdevs.Threshold(0.001, task.MaxZmeters, ThresholdTypes.Binary).ConvertScaleAbs();
                var mmStd = GetMinMax(stdevs, stdMask);

                maxMeanVal = Math.Max(maxMeanVal, (float)mm.maxVal);
                maxStdevVal = Math.Max(maxStdevVal, (float)mmStd.maxVal);

                Parallel.For(0, task.gridList.Count, i =>
                {
                    var roi = task.gridList[i];
                    dst3[roi].SetTo(255 * stdevs.Get<float>(i, 0) / maxStdevVal);
                    dst3[roi].SetTo(0, task.noDepthMask[roi]);

                    dst2[roi].SetTo(255 * means.Get<float>(i, 0) / maxMeanVal);
                    dst2[roi].SetTo(0, task.noDepthMask[roi]);
                });

                if (task.heartBeat)
                {
                    maxMeanVal = 0;
                    maxStdevVal = 0;
                }

                if (standaloneTest())
                {
                    for (int i = 0; i < task.gridList.Count; i++)
                    {
                        var roi = task.gridList[i];
                        SetTrueText($"{meanValues[i]:F3}\n{stdValues[i]:F3}", new cv.Point(roi.X, roi.Y), 3);
                    }
                }

                dst3 = dst3 | task.gridMask;
                labels[2] = $"The regions where the depth is volatile are brighter.  Stdev min {mmStd.minVal:F3} Stdev Max {mmStd.maxVal:F3}";
                labels[3] = $"Mean/stdev for each ROI: Min {mm.minVal:F3} Max {mm.maxVal:F3}";
            }
        }
    }



    public class CS_Depth_MeanStdevPlot : CS_Parent
    {
        Plot_OverTimeSingle plot1 = new Plot_OverTimeSingle();
        Plot_OverTimeSingle plot2 = new Plot_OverTimeSingle();

        public CS_Depth_MeanStdevPlot(VBtask task) : base(task)
        {
            desc = "Plot the mean and stdev of the depth image";
        }

        public void RunCS(Mat src)
        {
            Scalar mean, stdev;
            Mat depthMask = task.depthMask;
            Cv2.MeanStdDev(task.pcSplit[2], out mean, out stdev, depthMask);

            plot1.plotData = (float)mean[0];
            plot1.Run(src);
            dst2 = plot1.dst2;

            plot2.plotData = (float)stdev[0];
            plot2.Run(src);
            dst3 = plot2.dst2;

            labels[2] = $"Plot of mean depth = {mean[0].ToString(fmt1)} min = {plot1.min.ToString(fmt2)} max = {plot1.max.ToString(fmt2)}";
            labels[3] = $"Plot of depth stdev = {stdev[0].ToString(fmt1)} min = {plot2.min.ToString(fmt2)} max = {plot2.max.ToString(fmt2)}";
        }
    }

    public class CS_Depth_Uncertainty : CS_Parent
    {
        Retina_Basics_CPP retina = new Retina_Basics_CPP();
        Options_Uncertainty options = new Options_Uncertainty();

        public CS_Depth_Uncertainty(VBtask task) : base(task)
        {
            labels[3] = "Mask of areas with stable depth";
            desc = "Use the bio-inspired retina algorithm to determine depth uncertainty.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            retina.Run(task.depthRGB);
            dst2 = retina.dst2;
            Cv2.Threshold(retina.dst3, dst3, options.uncertaintyThreshold, 255, ThresholdTypes.Binary);
        }
    }

    public class CS_Depth_Palette : CS_Parent
    {
        Mat customColorMap = new Mat();
        Gradient_Color gColor = new Gradient_Color();

        public CS_Depth_Palette(VBtask task) : base(task)
        {
            desc = "Use a palette to display depth from the raw depth data.";
        }

        public void RunCS(Mat src)
        {
            gColor.gradientWidth = 255;
            gColor.Run(empty);
            customColorMap = gColor.gradient;

            double mult = 255 / task.MaxZmeters;
            Mat depthNorm = (task.pcSplit[2] * mult).ToMat();
            depthNorm.ConvertTo(depthNorm, MatType.CV_8U);
            Mat ColorMap = new Mat(256, 1, MatType.CV_8UC3, customColorMap.Data);
            Cv2.ApplyColorMap(src, dst2, ColorMap);
        }
    }

    public class CS_Depth_Colorizer_CPP : CS_Parent
    {
        public CS_Depth_Colorizer_CPP(VBtask task) : base(task)
        {
            cPtr = Depth_Colorizer_Open();
            desc = "Display depth data with InRange. Higher contrast than others - yellow to blue always present.";
        }

        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F)
                src = task.pcSplit[2];

            byte[] depthData = new byte[src.Total() * src.ElemSize()];
            GCHandle handleSrc = GCHandle.Alloc(depthData, GCHandleType.Pinned);
            Marshal.Copy(src.Data, depthData, 0, depthData.Length);
            IntPtr imagePtr = Depth_Colorizer_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, task.MaxZmeters);
            handleSrc.Free();

            if (imagePtr != IntPtr.Zero)
                dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr);
        }

        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Depth_Colorizer_Close(cPtr);
        }
    }

    public class CS_Depth_LocalMinMax_MT : CS_Parent
    {
        public Point2f[] minPoint = new Point2f[1];
        public Point2f[] maxPoint = new Point2f[1];

        public CS_Depth_LocalMinMax_MT(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Highlight (usually yellow) is min distance, red is max distance",
                                "Highlight is min, red is max. Lines would indicate planes are present." };
            desc = "Find min and max depth in each segment.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                src.CopyTo(dst2);
                dst2.SetTo(Scalar.White, task.gridMask);
            }

            if (minPoint.Length != task.gridList.Count)
            {
                Array.Resize(ref minPoint, task.gridList.Count);
                Array.Resize(ref maxPoint, task.gridList.Count);
            }

            if (task.heartBeat)
                dst3.SetTo(0);

            Parallel.For(0, task.gridList.Count, i =>
            {
                Rect roi = task.gridList[i];
                mmData mm = GetMinMax(task.pcSplit[2][roi], task.depthMask[roi]);
                if (mm.minLoc.X < 0 || mm.minLoc.Y < 0)
                    mm.minLoc = new cv.Point(0, 0);
                minPoint[i] = new cv.Point(mm.minLoc.X + roi.X, mm.minLoc.Y + roi.Y);
                maxPoint[i] = new cv.Point(mm.maxLoc.X + roi.X, mm.maxLoc.Y + roi.Y);

                Cv2.Circle(dst2[roi], mm.minLoc, task.DotSize, task.HighlightColor);
                Cv2.Circle(dst2[roi], mm.maxLoc, task.DotSize, Scalar.Red);

                cv.Point p1 = new cv.Point(mm.minLoc.X + roi.X, mm.minLoc.Y + roi.Y);
                cv.Point p2 = new cv.Point(mm.maxLoc.X + roi.X, mm.maxLoc.Y + roi.Y);
                Cv2.Circle(dst3, p1, task.DotSize, task.HighlightColor);
                Cv2.Circle(dst3, p2, task.DotSize, Scalar.Red);
            });
        }
    }



    public class CS_Depth_Median : CS_Parent
    {
        Math_Median_CDF median;
        public CS_Depth_Median(VBtask task) : base(task)
        {
            median = new Math_Median_CDF();
            median.rangeMax = (int)task.MaxZmeters;
            median.rangeMin = 0;
            desc = "Divide the depth image ahead and behind the median.";
        }
        public void RunCS(Mat src)
        {
            median.Run(task.pcSplit[2]);

            Mat mask = task.pcSplit[2].LessThan(median.medianVal);
            task.pcSplit[2].CopyTo(dst2, mask);

            dst2.SetTo(0, task.noDepthMask);

            labels[2] = "Median Depth < " + median.medianVal.ToString("F1");

            dst3.SetTo(0);
            task.depthRGB.CopyTo(dst3, ~mask);
            dst3.SetTo(0, task.noDepthMask);
            labels[3] = "Median Depth > " + median.medianVal.ToString("F1");
        }
    }

    public class CS_Depth_SmoothingMat : CS_Parent
    {
        Options_Depth options = new Options_Depth();
        Mat lastDepth;
        public CS_Depth_SmoothingMat(VBtask task) : base(task)
        {
            labels[3] = "Depth pixels after smoothing";
            desc = "Use depth rate of change to smooth the depth values in close range";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            Rect rect = task.drawRect.Width != 0 ? task.drawRect : new Rect(0, 0, src.Width, src.Height);

            if (task.FirstPass) lastDepth = task.pcSplit[2].Clone();
            Cv2.Subtract(lastDepth, task.pcSplit[2], dst2);

            dst2 = dst2.Threshold(options.mmThreshold, 0, ThresholdTypes.TozeroInv).Threshold(-options.mmThreshold, 0, ThresholdTypes.Tozero);
            Cv2.Add(task.pcSplit[2], dst2, dst3);
            lastDepth = task.pcSplit[2];

            labels[2] = "Smoothing Mat: range to " + task.MaxZmeters.ToString() + " meters";
        }
    }

    public class CS_Depth_Smoothing : CS_Parent
    {
        Depth_SmoothingMat smooth = new Depth_SmoothingMat();
        Reduction_Basics reduction = new Reduction_Basics();
        public Mat reducedDepth = new Mat();
        Mat_4to1 mats = new Mat_4to1();
        Depth_ColorMap colorize = new Depth_ColorMap();
        public CS_Depth_Smoothing(VBtask task) : base(task)
        {
            task.redOptions.checkBitReduction(true);
            labels[3] = "Mask of depth that is smooth";
            desc = "This attempt to get the depth data to 'calm' down is not working well enough to be useful - needs more work";
        }
        public void RunCS(Mat src)
        {
            smooth.Run(task.pcSplit[2]);
            Mat input = smooth.dst2.Normalize(0, 255, NormTypes.MinMax);
            input.ConvertTo(mats.mat[0], MatType.CV_8UC1);
            Mat tmp = new Mat();
            Cv2.Add(smooth.dst3, smooth.dst2, tmp);
            mats.mat[1] = tmp.Normalize(0, 255, NormTypes.MinMax).ConvertScaleAbs();

            reduction.Run(task.pcSplit[2]);
            reduction.dst2.ConvertTo(reducedDepth, MatType.CV_32F);
            colorize.Run(reducedDepth);
            dst2 = colorize.dst2;
            mats.Run(new Mat());
            dst3 = mats.dst2;
            labels[2] = smooth.labels[2];
        }
    }

    public class CS_Depth_HolesOverTime : CS_Parent
    {
        List<Mat> images = new List<Mat>();
        public CS_Depth_HolesOverTime(VBtask task) : base(task)
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            dst1 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            labels[3] = "Latest hole mask";
            desc = "Integrate memory holes over time to identify unstable depth";
        }
        public void RunCS(Mat src)
        {
            if (task.optionsChanged)
            {
                images.Clear();
                dst0.SetTo(0);
            }

            dst3 = task.noDepthMask;
            dst1 = dst3.Threshold(0, 1, ThresholdTypes.Binary);
            images.Add(dst1);

            dst0 += dst1;
            dst2 = dst0.Threshold(0, 255, ThresholdTypes.Binary);

            labels[2] = "Depth holes integrated over the past " + images.Count.ToString() + " images";
            if (images.Count >= task.frameHistoryCount)
            {
                dst0 -= images[0];
                images.RemoveAt(0);
            }
        }
    }

    public class CS_Depth_Holes : CS_Parent
    {
        Mat element;
        Options_DepthHoles options = new Options_DepthHoles();
        public CS_Depth_Holes(VBtask task) : base(task)
        {
            labels[3] = "Shadow Edges (use sliders to expand)";
            element = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(5, 5));
            desc = "Identify holes in the depth image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = task.pcSplit[2].Threshold(0.01, 255, ThresholdTypes.BinaryInv).ConvertScaleAbs(255);
            dst2 = dst2.Dilate(element, null, options.holeDilation);
            dst3 = dst2.Dilate(element, null, options.borderDilation);
            dst3 = dst3.Xor(dst2);
            if (standaloneTest()) task.depthRGB.CopyTo(dst3, dst3);
        }
    }

    public class CS_Depth_Dilate : CS_Parent
    {
        Dilate_Basics dilate = new Dilate_Basics();
        public CS_Depth_Dilate(VBtask task) : base(task)
        {
            desc = "Dilate the depth data to fill holes.";
        }
        public void RunCS(Mat src)
        {
            dilate.Run(task.pcSplit[2]);
            dst2 = dilate.dst2;
        }
    }

    public class CS_Depth_ForegroundHead : CS_Parent
    {
        Depth_ForegroundBlob fgnd = new Depth_ForegroundBlob();
        Kalman_Basics kalman = new Kalman_Basics();
        //Rect trustedRect;
        public bool trustworthy = false;
        public CS_Depth_ForegroundHead(VBtask task) : base(task)
        {
            labels[2] = "Blue is current, red is kalman, green is trusted";
            desc = "Use Depth_ForeGround to find the foreground blob.  Then find the probable head of the person in front of the camera.";
        }
        public void RunCS(Mat src)
        {
            fgnd.Run(src);

            //trustworthy = false;
            //if (fgnd.dst2.CountNonZero() > 0 && fgnd.maxIndex >= 0)
            //{
            //    int rectSize = 50;
            //    if (src.Width > 1000) rectSize = 250;
            //    int xx = fgnd.blobLocation[fgnd.maxIndex].X - rectSize / 2;
            //    int yy = fgnd.blobLocation[fgnd.maxIndex].Y;
            //    if (xx < 0) xx = 0;
            //    if (xx + rectSize / 2 > src.Width) xx = src.Width - rectSize;
            //    dst2 = fgnd.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);

            //    kalman.kInput = new float[] { xx, yy, rectSize, rectSize };
            //    kalman.Run(src);
            //    Rect nextRect = new Rect(xx, yy, rectSize, rectSize);
            //    Rect kRect = new Rect((int)kalman.kOutput[0], (int)kalman.kOutput[1], (int)kalman.kOutput[2], (int)kalman.kOutput[3]);
            //    dst2.Rectangle(kRect, Scalar.Red, 2);
            //    dst2.Rectangle(nextRect, Scalar.Blue, 2);
            //    if (Math.Abs(kRect.X - nextRect.X) < rectSize / 4 && Math.Abs(kRect.Y - nextRect.Y) < rectSize / 4)
            //    {
            //        trustedRect = ValidateRect(kRect);
            //        trustworthy = true;
            //        dst2.Rectangle(trustedRect, Scalar.Green, 5);
            //    }
            //}
        }
        Rect ValidateRect(Rect rect)
        {
            throw new NotImplementedException();
        }
    }

    public class CS_Depth_RGBShadow : CS_Parent
    {
        public CS_Depth_RGBShadow(VBtask task) : base(task)
        {
            desc = "Merge the BGR and Depth Shadow";
        }
        public void RunCS(Mat src)
        {
            dst2 = src;
            dst2.SetTo(0, task.noDepthMask);
        }
    }

    public class CS_Depth_BGSubtract : CS_Parent
    {
        BGSubtract_Basics bgSub = new BGSubtract_Basics();
        public CS_Depth_BGSubtract(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Latest task.noDepthMask", "BGSubtract output for the task.noDepthMask" };
            desc = "Create a mask for the missing depth across multiple frame";
        }
        public void RunCS(Mat src)
        {
            dst2 = task.noDepthMask;

            bgSub.Run(dst2);
            dst3 = bgSub.dst2;
        }
    }

    public class CS_Depth_Averaging : CS_Parent
    {
        Math_ImageAverage avg = new Math_ImageAverage();
        Depth_Colorizer_CPP colorize = new Depth_Colorizer_CPP();
        public CS_Depth_Averaging(VBtask task) : base(task)
        {
            labels[3] = "32-bit format depth data";
            desc = "Take the average depth at each pixel but eliminate any pixels that had zero depth.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F) src = task.pcSplit[2];
            avg.Run(src);

            dst3 = avg.dst2;
            colorize.Run(dst3);
            dst2 = colorize.dst2;
        }
    }

    public class CS_Depth_MaxMask : CS_Parent
    {
        Contour_General contour = new Contour_General();
        public CS_Depth_MaxMask(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Depth that is too far", "Contour of depth that is too far..." };
            desc = "Display the task.maxDepthMask and its contour containing depth that is greater than maxdepth (global setting)";
        }
        public void RunCS(Mat src)
        {
            dst2 = src;

            //    If task.maxDepthMask.Width = 0 Then
            //    task.maxDepthMask = task.pcSplit(2).InRange(task.MaxZmeters, task.MaxZmeters).ConvertScaleAbs()
            //End If
            if (task.maxDepthMask.Width == 0) task.maxDepthMask = task.pcSplit[2].InRange(task.MaxZmeters, task.MaxZmeters).ConvertScaleAbs();
            dst2.SetTo(Scalar.White, task.maxDepthMask);
            contour.Run(task.maxDepthMask);
            dst3 = new Mat();
            dst3.SetTo(Scalar.All(0));
            foreach (var c in contour.allContours)
            {
                List<cv.Point> hull = Cv2.ConvexHull(c.ToArray(), true).ToList();
                DrawContour(dst3, hull, Scalar.White, -1);
            }
        }
    }

    public class CS_Depth_ForegroundOverTime : CS_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        Depth_Foreground fore = new Depth_Foreground();
        Contour_Largest contours = new Contour_Largest();
        List<Mat> lastFrames = new List<Mat>();
        public CS_Depth_ForegroundOverTime(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Foreground objects", "Edges for the Foreground Objects" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            task.frameHistoryCount = 5;
            desc = "Create a fused foreground mask over x number of frames (task.frameHistoryCount)";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged) lastFrames.Clear();

            fore.Run(src);
            lastFrames.Add(fore.dst3);
            dst2.SetTo(Scalar.All(0));
            foreach (Mat m in lastFrames)
            {
                dst2 += m;
            }
            if (lastFrames.Count >= task.frameHistoryCount) lastFrames.RemoveAt(0);

            contours.Run(dst2);
            dst2.SetTo(Scalar.All(0));
            dst3.SetTo(Scalar.All(0));
            foreach (var ctr in contours.allContours)
            {
                if (ctr.Length >= options.minSizeContour)
                {
                    DrawContour(dst2, ctr.ToList(), Scalar.White, -1);
                    DrawContour(dst3, ctr.ToList(), Scalar.White, 1);
                }
            }
        }
    }




    public class CS_Depth_ForegroundBlob : CS_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        List<cv.Point> blobLocation = new List<cv.Point>();
        int maxIndex;

        public CS_Depth_ForegroundBlob(VBtask task) : base(task)
        {
            labels[2] = "Mask for the largest foreground blob";
            desc = "Use InRange to define foreground and find the largest blob in the foreground";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Cv2.InRange(task.pcSplit[2], 0.01, options.maxForegroundDepthInMeters, dst2);
            dst3 = dst2.Clone();

            List<int> blobSize = new List<int>();
            blobLocation.Clear();

            for (int y = 0; y < dst2.Rows; y++)
            {
                for (int x = 0; x < dst2.Cols; x++)
                {
                    byte nextByte = dst2.At<byte>(y, x);
                    if (nextByte != 0)
                    {
                        int count = Cv2.FloodFill(dst2, new cv.Point(x, y), cv.Scalar.All(0), out _, new Scalar(0), new Scalar(0));
                        if (count > 10)
                        {
                            blobSize.Add(count);
                            blobLocation.Add(new cv.Point(x, y));
                        }
                    }
                }
            }

            if (blobSize.Count > 0)
            {
                int maxBlob = blobSize.Max();
                maxIndex = blobSize.IndexOf(maxBlob);
                Cv2.FloodFill(dst3, blobLocation[maxIndex], cv.Scalar.All(250), out _, new Scalar(0), new Scalar(0));
                Cv2.InRange(dst3, 250, 250, dst2);
                Cv2.BitwiseAnd(dst2, task.noDepthMask, dst2);
                labels[3] = "Mask of all depth pixels < " + options.maxForegroundDepthInMeters.ToString("0.0") + "m";
            }
        }
    }

    public class CS_Depth_Foreground : CS_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        Contour_Largest contours = new Contour_Largest();

        public CS_Depth_Foreground(VBtask task) : base(task)
        {
            labels[2] = "Foreground objects";
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Create a mask for the objects in the foreground";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Cv2.Threshold(task.pcSplit[2], dst1, options.maxForegroundDepthInMeters, 255, cv.ThresholdTypes.BinaryInv);
            dst1 = dst1.ConvertScaleAbs();

            Cv2.BitwiseAnd(dst1, task.noDepthMask, dst1);

            contours.Run(dst1);
            dst2.SetTo(Scalar.All(0));
            dst3.SetTo(Scalar.All(0));

            foreach (var ctr in contours.allContours)
            {
                if (ctr.Length >= options.minSizeContour)
                {
                    DrawContour(dst2, ctr.ToList(), Scalar.White, -1);
                    DrawContour(dst3, ctr.ToList(), Scalar.White, -1);
                }
            }
        }
    }

    public class CS_Depth_Grid : CS_Parent
    {
        public CS_Depth_Grid(VBtask task) : base(task)
        {
            task.gOptions.setGridSize(4);
            labels = new string[] { "", "", "White regions below are likely depth edges where depth changes rapidly", "Depth 32f display" };
            desc = "Find boundaries in depth to separate featureless regions.";
        }

        public void RunCS(Mat src)
        {
            dst3 = task.pcSplit[2];
            dst2 = task.gridMask.Clone();

            foreach (Rect roi in task.gridList)
            {
                double minVal, maxVal;
                Cv2.MinMaxLoc(dst3[roi], out minVal, out maxVal);
                if (Math.Abs(minVal - maxVal) > 0.1)
                {
                    dst2[roi].SetTo(Scalar.White);
                }
            }
        }
    }

    public class CS_Depth_InRange : CS_Parent
    {
        Options_ForeGround options = new Options_ForeGround();
        Contour_Largest contours = new Contour_Largest();
        int classCount = 1;

        public CS_Depth_InRange(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Looks empty! But the values are there - 0 to classcount.  Run standaloneTest() to see the palette output for this", "Edges between the depth regions." };
            if (standaloneTest()) { task.gOptions.setDisplay1(); }
            dst3 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            desc = "Create the selected number of depth ranges ";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            List<Mat> regMats = new List<Mat>();
            for (int i = 0; i < options.numberOfRegions; i++)
            {
                double upperBound = (i + 1) * options.depthPerRegion;
                if (i == options.numberOfRegions - 1) { upperBound = 1000; }
                Mat tmp = new Mat();
                Cv2.InRange(task.pcSplit[2], i * options.depthPerRegion, upperBound, tmp);
                regMats.Add(tmp);
                if (i == 0) { regMats[0].SetTo(0, task.noDepthMask); }
            }

            dst2 = new Mat(dst0.Size(), MatType.CV_8U, Scalar.All(0));
            dst3.SetTo(0);
            classCount = 1;
            foreach (Mat regMat in regMats)
            {
                contours.Run(regMat);
                foreach (var ctr in contours.allContours)
                {
                    if (ctr.Length >= options.minSizeContour)
                    {
                        DrawContour(dst2, ctr.ToList(), Scalar.White, -1);
                        classCount++;
                        DrawContour(dst3, ctr.ToList(), Scalar.White, -1);
                    }
                }
            }

            dst0 = src.Clone();
            dst0.SetTo(cv.Scalar.White, dst3);

            if (standaloneTest())
            {
                dst2 = ShowPalette(dst2 * 255 / classCount);
            }

            if (task.heartBeat) { labels[2] = classCount.ToString("000") + " regions were found"; }
        }
    }






    public class CS_Depth_Regions : CS_Parent
    {
        int classCount = 5;

        public CS_Depth_Regions(VBtask task) : base(task)
        {
            desc = "Separate the scene into a specified number of regions by depth";
        }

        public void RunCS(Mat src)
        {
            Cv2.Threshold(task.pcSplit[2], dst1, task.gOptions.maxDepth, 255, ThresholdTypes.Binary);
            dst0 = (task.pcSplit[2] / task.gOptions.maxDepth) * 255 / classCount;
            Cv2.ConvertScaleAbs(dst0, dst2);
            Cv2.BitwiseAnd(dst2, task.noDepthMask, dst2);

            if (standaloneTest()) { dst3 = ShowPalette(dst2); }
            labels[2] = classCount.ToString() + " regions defined in the depth data";
        }
    }


    public class CS_Depth_PunchIncreasing : CS_Parent
    {
        Depth_PunchDecreasing depth = new Depth_PunchDecreasing();

        public CS_Depth_PunchIncreasing(VBtask task) : base(task)
        {
            depth.Increasing = true;
            desc = "Identify where depth is increasing - retreating from the camera.";
        }

        public void RunCS(Mat src)
        {
            depth.Run(src);
            dst2 = depth.dst2;
        }
    }

    public class CS_Depth_PunchDecreasing : CS_Parent
    {
        public bool Increasing { get; set; }
        Depth_Foreground fore = new Depth_Foreground();
        Mat lastDepth;
        Options_Depth options = new Options_Depth();
        public CS_Depth_PunchDecreasing(VBtask task) : base(task)
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_32F, Scalar.All(0));
            desc = "Identify where depth is decreasing - coming toward the camera.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            fore.Run(src);
            dst1.SetTo(0);
            Cv2.CopyTo(dst1, fore.dst2, task.noDepthMask);

            if (task.FirstPass) lastDepth = dst1.Clone();
            if (Increasing)
            {
                dst2 = new Mat();
                Cv2.Subtract(dst1, lastDepth, dst2);
            }
            else
            {
                dst2 = new Mat();
                Cv2.Subtract(lastDepth, dst1, dst2);
            }
            Cv2.Threshold(dst2, dst2, options.mmThreshold, 0, cv.ThresholdTypes.Tozero);
            Cv2.Threshold(dst2, dst2, 0, 255, cv.ThresholdTypes.Binary);
            lastDepth = dst1.Clone();
        }
    }

    public class CS_Depth_PunchBlob : CS_Parent
    {
        Depth_PunchDecreasing depthDec = new Depth_PunchDecreasing();
        Depth_PunchIncreasing depthInc = new Depth_PunchIncreasing();
        Contour_General contours = new Contour_General();
        int lastContoursCount;
        int punchCount;
        int showMessage;
        int showWarningInfo;

        public CS_Depth_PunchBlob(VBtask task) : base(task)
        {
            desc = "Identify the punch with a rectangle around the largest blob";
        }

        public void RunCS(Mat src)
        {
            depthInc.Run(src);
            dst1 = depthInc.dst2;

            double minVal, maxVal;
            Cv2.MinMaxLoc(dst1, out minVal, out maxVal);
            Cv2.ConvertScaleAbs(dst1, dst2);
            contours.Run(dst2);
            dst3 = contours.dst3;

            if (contours.contourlist.Count > 0) { showMessage = 30; }

            if (showMessage == 30 && lastContoursCount == 0) { punchCount++; }
            lastContoursCount = contours.contourlist.Count;
            labels[3] = punchCount.ToString() + " Punches Thrown";

            if (showMessage > 0)
            {
                SetTrueText("Punched!!!", new cv.Point(10, 100), 3);
                showMessage--;
            }

            if (contours.contourlist.Count > 3) { showWarningInfo = 100; }

            if (showWarningInfo > 0)
            {
                showWarningInfo--;
                SetTrueText("Too many contours!  Reduce the Max Depth.", new cv.Point(10, 130), 3);
            }
        }
    }

    public class CS_Depth_PunchBlobNew : CS_Parent
    {
        Depth_PunchDecreasing depthDec = new Depth_PunchDecreasing();
        Depth_PunchIncreasing depthInc = new Depth_PunchIncreasing();
        Contour_General contours = new Contour_General();
        Mat lastColor;
        Options_Depth options = new Options_Depth();
        public CS_Depth_PunchBlobNew(VBtask task) : base(task)
        {
            desc = "Identify a punch using both depth and color";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.FirstPass) lastColor = task.color.Clone();
            dst2 = task.color.Clone();

            Cv2.Absdiff(dst2, lastColor, dst2);
            Cv2.Threshold(dst2, dst3, 0, options.threshold, ThresholdTypes.Binary);
            Cv2.ConvertScaleAbs(dst3, dst3);

            Cv2.Threshold(dst2, dst2, 0, 255, ThresholdTypes.Binary);

            lastColor = task.color.Clone();
        }
    }

    public class CS_Depth_Contour : CS_Parent
    {
        Contour_General contour = new Contour_General();

        public CS_Depth_Contour(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            labels[2] = "task.depthMask contour";
            desc = "Create and display the task.depthMask output as a contour.";
        }

        public void RunCS(Mat src)
        {
            contour.Run(task.depthMask);

            dst2.SetTo(0);
            foreach (var tour in contour.contourlist)
            {
                DrawContour(dst2, tour.ToList(), Scalar.All(255), -1);
            }
        }
    }

    public class CS_Depth_Outline : CS_Parent
    {
        Contour_General contour = new Contour_General();

        public CS_Depth_Outline(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, Scalar.All(0));
            labels[2] = "Contour separating depth from no depth";
            desc = "Provide a line that separates depth from no depth throughout the image.";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest()) { src = task.depthMask; }
            contour.Run(src);

            dst2.SetTo(0);
            foreach (var tour in contour.contourlist)
            {
                DrawContour(dst2, tour.ToList(), Scalar.All(255), task.lineWidth);
            }

            if (standaloneTest())
            {
                if (task.heartBeat) { dst3.SetTo(0); }
                Cv2.BitwiseOr(dst3, dst2, dst3);
            }
        }
    }

    public class CS_Depth_StableAverage : CS_Parent
    {
        Depth_Averaging dAvg = new Depth_Averaging();
        Depth_StableMinMax extrema = new Depth_StableMinMax();

        public CS_Depth_StableAverage(VBtask task) : base(task)
        {
            FindRadio("Use farthest distance").Checked = true;
            desc = "Use Depth_StableMax to remove the artifacts from the Depth_Averaging";
        }

        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F) { src = task.pcSplit[2]; }
            extrema.Run(src);

            if (extrema.options.useNone)
            {
                dst2 = extrema.dst2;
                dst3 = extrema.dst3;
            }
            else
            {
                dAvg.Run(extrema.dst3);
                dst2 = dAvg.dst2;
                dst3 = dAvg.dst3;
            }
        }
    }

    public class CS_Depth_MinMaxNone : CS_Parent
    {
        Options_MinMaxNone options = new Options_MinMaxNone();
        int filtered;

        public CS_Depth_MinMaxNone(VBtask task) : base(task)
        {
            desc = "To reduce z-Jitter, use the closest or farthest point as long as the camera is stable";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat[] split = src.Type() == MatType.CV_32FC3 ? src.Split() : task.pcSplit;

            if (task.heartBeat)
            {
                dst3 = split[2];
                filtered = 0;
            }
            labels[2] = "Point cloud unchanged";
            if (options.useMax)
            {
                labels[2] = "Point cloud maximum values at each pixel";
                Cv2.Max(split[2], dst3, split[2]);
            }
            if (options.useMin)
            {
                labels[2] = "Point cloud minimum values at each pixel";
                Mat saveMat = split[2].Clone();
                Cv2.Min(split[2], dst3, split[2]);
                Mat mask = new Mat();
                Cv2.InRange(split[2], 0, 0.1, mask);
                Cv2.CopyTo(saveMat, split[2], mask);
            }
            Cv2.Merge(split, dst2);
            dst3 = split[2];
            filtered++;
            labels[2] += " after " + filtered.ToString() + " images";
        }
    }

    public class CS_Depth_StableMin : CS_Parent
    {
        Mat stableMin;
        Depth_Colorizer_CPP colorize = new Depth_Colorizer_CPP();

        public CS_Depth_StableMin(VBtask task) : base(task)
        {
            task.gOptions.setUnfiltered(true);
            labels = new string[] { "", "", "InRange depth with low quality depth removed.", "Motion in the BGR image. Depth updated in rectangle." };
            desc = "To reduce z-Jitter, use the closest depth value at each pixel as long as the camera is stable";
        }

        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1) { src = task.pcSplit[2]; }

            if (task.heartBeat)
            {
                stableMin = src.Clone();
                dst3.SetTo(0);
            }
            else if (task.motionDetected)
            {
                Cv2.CopyTo(stableMin[task.motionRect], src[task.motionRect]);
                if (src.Type() != stableMin.Type()) { Cv2.ConvertScaleAbs(src, stableMin); }
                Cv2.CopyTo(src[task.motionRect], stableMin[task.motionRect], task.noDepthMask);
                Cv2.Min(src, stableMin, stableMin);
            }

            colorize.Run(stableMin);
            dst2 = colorize.dst2;
        }
    }

    public class CS_Depth_StableMax : CS_Parent
    {
        Mat stableMax;
        Depth_Colorizer_CPP colorize = new Depth_Colorizer_CPP();

        public CS_Depth_StableMax(VBtask task) : base(task)
        {
            task.gOptions.setUnfiltered(true);
            labels = new string[] { "", "", "InRange depth with low quality depth removed.", "Motion in the BGR image. Depth updated in rectangle." };
            desc = "To reduce z-Jitter, use the farthest depth value at each pixel as long as the camera is stable";
        }

        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1) { src = task.pcSplit[2]; }

            if (task.heartBeat)
            {
                stableMax = src.Clone();
                dst3.SetTo(0);
            }
            else if (task.motionDetected)
            {
                Cv2.CopyTo(stableMax[task.motionRect], src[task.motionRect]);
                if (src.Type() != stableMax.Type()) { Cv2.ConvertScaleAbs(src, stableMax); }
                Cv2.CopyTo(src[task.motionRect], stableMax[task.motionRect], task.noDepthMask);
                Cv2.Max(src, stableMax, stableMax);
            }

            colorize.Run(stableMax);
            dst2 = colorize.dst2;
        }
    }

    public class CS_Depth_StableMinMax : CS_Parent
    {
        Depth_Colorizer_CPP colorize = new Depth_Colorizer_CPP();
        Depth_StableMin dMin = new Depth_StableMin();
        Depth_StableMax dMax = new Depth_StableMax();
        Options_MinMaxNone options = new Options_MinMaxNone();

        public CS_Depth_StableMinMax(VBtask task) : base(task)
        {
            task.gOptions.setUnfiltered(true);
            labels[2] = "Depth map colorized";
            labels[3] = "32-bit StableDepth";
            desc = "To reduce z-Jitter, use the closest or farthest point as long as the camera is stable";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Type() != MatType.CV_32FC1) { src = task.pcSplit[2]; }
            if (task.optionsChanged) { dst3 = task.pcSplit[2]; }

            if (options.useMax)
            {
                dMax.Run(src);
                dst3 = dMax.stableMax;
                dst2 = dMax.dst2;
            }
            else if (options.useMin)
            {
                dMin.Run(src);
                dst3 = dMin.stableMin;
                dst2 = dMin.dst2;
            }
            else if (options.useNone)
            {
                dst3 = task.pcSplit[2];
                dst2 = task.depthRGB;
            }
        }
    }

    public class CS_Depth_WorldXYMT : CS_Parent
    {
        bool depthUnitsMeters = false;

        public CS_Depth_WorldXYMT(VBtask task) : base(task)
        {
            labels[3] = "dst3 = pointcloud";
            desc = "Create OpenGL point cloud from depth data (slow)";
        }

        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1) { src = task.pcSplit[2]; }

            dst3 = new Mat(src.Size(), MatType.CV_32FC3, Scalar.All(0));
            if (!depthUnitsMeters) { src = src * 0.001; }
            double multX = task.pointCloud.Width / src.Width;
            double multY = task.pointCloud.Height / src.Height;

            Parallel.ForEach(task.gridList, roi =>
            {
                Point3f xy = new Point3f();
                for (int y = roi.Y; y < roi.Y + roi.Height; y++)
                {
                    for (int x = roi.X; x < roi.X + roi.Width; x++)
                    {
                        xy.X = x * (float)multX;
                        xy.Y = y * (float)multY;
                        xy.Z = src.At<float>(y, x);
                        if (xy.Z != 0)
                        {
                            Point3f xyz = getWorldCoordinates(xy);
                            dst3.Set<Point3f>(y, x, xyz);
                        }
                    }
                }
            });

            SetTrueText("OpenGL data prepared.");
        }
    }


    public class CS_Depth_WorldXYZ : CS_Parent
    {
        public bool depthUnitsMeters = false;

        public CS_Depth_WorldXYZ(VBtask task) : base(task)
        {
            labels[3] = "dst3 = pointcloud";
            desc = "Create 32-bit XYZ format from depth data (too slow to be useful.)";
        }

        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC1)
                src = task.pcSplit[2];

            if (!depthUnitsMeters)
                src = (src * 0.001).ToMat();

            dst2 = new Mat(src.Size(), MatType.CV_32FC3, 0);
            Point3f xy = new Point3f();

            for (xy.Y = 0; xy.Y < dst2.Height; xy.Y++)
            {
                for (xy.X = 0; xy.X < dst2.Width; xy.X++)
                {
                    xy.Z = src.Get<float>((int)xy.Y, (int)xy.X);
                    if (xy.Z != 0)
                    {
                        Point3f xyz = getWorldCoordinates(xy);
                        dst2.Set((int)xy.Y, (int)xy.X, xyz);
                    }
                }
            }

            SetTrueText("OpenGL data prepared and in dst2.", 3);
        }
    }

    public class CS_Depth_World : CS_Parent
    {
        Math_Template template = new Math_Template();

        public CS_Depth_World(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Merged templates and depth32f - should be similar to upper right image", "" };
            desc = "Build the (approximate) point cloud using camera intrinsics - see CameraOakD.cs for comparable calculations";
        }

        public void RunCS(Mat src)
        {
            if (task.FirstPass)
                template.Run(empty);

            if (src.Type() != MatType.CV_32F)
                src = task.pcSplit[2];

            Cv2.Multiply(template.dst2, src, dst0);
            dst0 *= 1 / task.calibData.fx;

            Cv2.Multiply(template.dst3, src, dst1);
            dst1 *= 1 / task.calibData.fy;

            Cv2.Merge(new Mat[] { dst0, dst1, src }, dst2);

            if (standaloneTest())
            {
                var colorizer = new Depth_Colorizer_CPP();
                colorizer.Run(dst2);
                dst2 = colorizer.dst2;
            }
        }
    }

    public class CS_Depth_TiersZ : CS_Parent
    {
        public int classCount;
        Options_Contours options = new Options_Contours();

        public CS_Depth_TiersZ(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": gOptions 'Max Depth (meters)' and local options for cm's per tier.");
            desc = "Create a reduced image of the depth data to define tiers of similar values";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Type() != MatType.CV_32F) src = task.pcSplit[2];

            dst1 = (src * 100 / options.cmPerTier).ToMat();
            dst1.ConvertTo(dst2, MatType.CV_8U);

            classCount = (int)(task.MaxZmeters * 100 / options.cmPerTier) + 1;

            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = $"{classCount} regions found.";
        }
    }

    public class CS_Depth_TierCount : CS_Parent
    {
        public HistValley_Depth1 valley = new HistValley_Depth1();
        public int classCount;
        List<int> kValues = new List<int>();

        public CS_Depth_TierCount(VBtask task) : base(task)
        {
            labels = new string[] { "", "Histogram of the depth data with instantaneous valley lines", "", "" };
            desc = "Determine the 'K' value for the best number of clusters for the depth";
        }

        public void RunCS(Mat src)
        {
            valley.Run(src);
            dst2 = valley.dst2;

            kValues.Add(valley.valleyOrder.Count);

            classCount = (int)kValues.Average();
            if (kValues.Count > task.frameHistoryCount * 10)
                kValues.RemoveAt(0);

            SetTrueText($"'K' value = {classCount} after averaging. Instantaneous value = {valley.valleyOrder.Count}", 3);
            labels[2] = $"There are {classCount}";
        }
    }

    public class CS_Depth_Flatland : CS_Parent
    {
        Options_FlatLand options = new Options_FlatLand();

        public CS_Depth_Flatland(VBtask task) : base(task)
        {
            labels[3] = "Grayscale version";
            desc = "Attempt to stabilize the depth image.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = task.depthRGB / options.reductionFactor;
            dst2 *= options.reductionFactor;
            dst3 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }


    public class CS_Derivative_Basics : CS_Parent
    {
        public Options_Derivative options = new Options_Derivative();
        BackProject_Image backp = new BackProject_Image();
        public Plot_Histogram plot = new Plot_Histogram();

        public CS_Derivative_Basics(VBtask task) : base(task)
        {
            backp.hist.plot.removeZeroEntry = false;
            UpdateAdvice(traceName + ": gOptions histogram Bins and several local options are important.");
            desc = "Display a first or second derivative of the selected depth dimension and direction.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (src.Type() != MatType.CV_32F)
            {
                src = task.pcSplit[options.channel].Sobel(MatType.CV_32F, 1, 0, options.kernelSize);
            }

            Rangef[] ranges = { new Rangef(-options.derivativeRange, options.derivativeRange) };
            Mat histogram = new Mat();
            Cv2.CalcHist(new[] { src }, new[] { 0 }, task.depthMask, histogram, 1, new[] { task.histogramBins }, ranges);

            plot.Run(histogram);
            histogram = plot.histogram; // reflect any updates to the 0 entry...
            dst2 = plot.dst2;

            int index = 1;
            for (int i = 0; i < plot.histArray.Length; i++)
            {
                if (plot.histArray[i] != 0)
                {
                    plot.histArray[i] = index;
                    index++;
                }
            }
            histogram = new Mat(plot.histArray.Length, 1, MatType.CV_32F, plot.histArray.ToArray());

            int brickWidth = dst2.Width / task.histogramBins;
            int histIndex = (int)(task.mouseMovePoint.X / brickWidth);

            Mat mask = new Mat();
            Cv2.CalcBackProject(new[] { src }, new[] { 0 }, histogram, mask, ranges);
            mask.ConvertTo(mask, MatType.CV_8U);
            dst0 = mask;
            mask = mask.InRange(histIndex, histIndex);

            dst3 = task.color.Clone();
            dst3.SetTo(Scalar.White, mask);
            dst3.SetTo(0, task.noDepthMask);
            Cv2.Rectangle(dst2, new Rect(histIndex * brickWidth, 0, brickWidth, dst2.Height), Scalar.Yellow, task.lineWidth);
            string deriv = string.Format(fmt2, options.derivativeRange);
            labels[2] = "Histogram of first or second derivatives.  Range -" + deriv + " to " + deriv;
            labels[3] = "Backprojection into the image for the selected histogram entry - move mouse over dst2.";
        }
    }

    public class CS_Derivative_Sobel : CS_Parent
    {
        CS_Derivative_Basics deriv;

        public CS_Derivative_Sobel(VBtask task) : base(task)
        {
            deriv = new CS_Derivative_Basics(task);
            if (standalone) task.gOptions.setDisplay1();
            if (standalone) task.gOptions.setDisplay1();
            desc = "Display the derivative of the selected depth dimension.";
        }

        public void RunCS(Mat src)
        {
            int channel = deriv.options.channel;
            string chanName = "X";
            if (channel != 0)
            {
                chanName = channel == 1 ? "Y" : "Z";
            }
            int kern = deriv.options.kernelSize;
            src = task.pcSplit[channel].Sobel(MatType.CV_32F, 1, 0, kern);
            deriv.RunAndMeasure(src, deriv);
            dst0 = deriv.dst2.Clone();
            dst1 = deriv.dst3.Clone();
            labels[0] = "Horizontal derivatives for " + chanName + " dimension of the point cloud";
            labels[1] = "Backprojection of horizontal derivatives indicated - move mouse in the image at left";

            src = task.pcSplit[channel].Sobel(MatType.CV_32F, 0, 1, kern);
            deriv.RunAndMeasure(src, deriv);
            dst2 = deriv.dst2;
            dst3 = deriv.dst3;
            labels[2] = "Vertical derivatives for " + chanName + " dimension of the point cloud";
            labels[3] = "Backprojection of vertical derivatives indicated - move mouse in the image at left";
        }
    }

    public class CS_Derivative_Laplacian : CS_Parent
    {
        Options_LaplacianKernels options = new Options_LaplacianKernels();
        CS_Derivative_Basics deriv;

        public CS_Derivative_Laplacian(VBtask task) : base(task)
        {
            deriv = new CS_Derivative_Basics(task);
            desc = "Create a histogram and backprojection for the second derivative of depth in the selected dimension.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            int channel = deriv.options.channel;
            cv.Size gausskern = new cv.Size((int)options.gaussiankernelSize, (int)options.gaussiankernelSize);
            dst1 = task.pcSplit[channel].GaussianBlur(gausskern, 0, 0);
            dst1 = dst1.Laplacian(MatType.CV_32F, options.LaplaciankernelSize, 1, 0);

            deriv.RunAndMeasure(dst1, deriv);
            dst2 = deriv.dst2;
            dst3 = deriv.dst3;
            labels[2] = deriv.labels[2];
            labels[3] = deriv.labels[3];
        }
    }

    public class CS_Derivative_Classes : CS_Parent
    {
        CS_Derivative_Basics deriv;
        public int classCountX;
        public int classCountY;

        public CS_Derivative_Classes(VBtask task) : base(task)
        {
            deriv = new CS_Derivative_Basics(task);
            desc = "Display the X and Y derivatives for the whole image.";
        }

        int derivClassCount(ref Mat dst)
        {
            int count = 0;
            for (int i = 0; i < deriv.plot.histArray.Length; i++)
            {
                if (deriv.plot.histArray[i] > 0) count++;
            }
            dst = ShowPalette(deriv.dst0 * 255 / count);
            dst.SetTo(0, task.noDepthMask);
            return count;
        }

        public void RunCS(Mat src)
        {
            deriv.RunAndMeasure(task.pcSplit[deriv.options.channel].Sobel(MatType.CV_32F, 1, 0, deriv.options.kernelSize), deriv);
            classCountX = derivClassCount(ref dst2);
            labels[2] = $"Backprojection of X dimension of task.pcSplit({deriv.options.channel})";

            deriv.RunAndMeasure(task.pcSplit[deriv.options.channel].Sobel(MatType.CV_32F, 0, 1, deriv.options.kernelSize), deriv);
            classCountY = derivClassCount(ref dst3);
            labels[3] = $"Backprojection of Y dimension of task.pcSplit({deriv.options.channel})";
        }
    }


    public class CS_DFT_Basics : CS_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        public Mat magnitude = new Mat();
        public Mat spectrum = new Mat();
        public Mat complexImage = new Mat();
        public Mat grayMat;
        public int rows;
        public int cols;

        public CS_DFT_Basics(VBtask task) : base(task)
        {
            mats.lineSeparators = false;

            desc = "Explore the Discrete Fourier Transform.";
            labels[2] = "Image after inverse DFT";
            labels[3] = "DFT_Basics Spectrum Magnitude";
        }

        public Mat InverseDFT(Mat complexImage)
        {
            Mat invDFT = new Mat();
            Cv2.Dft(complexImage, invDFT, DftFlags.Inverse | DftFlags.RealOutput);
            invDFT = invDFT.Normalize(0, 255, NormTypes.MinMax);
            invDFT.ConvertTo(invDFT, MatType.CV_8U);
            return invDFT;
        }
        public void RunCS(Mat src)
        {
            grayMat = src;
            if (src.Channels() == 3)
                grayMat = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            rows = Cv2.GetOptimalDFTSize(grayMat.Rows);
            cols = Cv2.GetOptimalDFTSize(grayMat.Cols);
            Mat padded = new Mat(grayMat.Width, grayMat.Height, MatType.CV_8UC3);
            Cv2.CopyMakeBorder(grayMat, padded, 0, rows - grayMat.Rows, 0, cols - grayMat.Cols, BorderTypes.Constant, Scalar.All(0));
            Mat padded32 = new Mat();
            padded.ConvertTo(padded32, MatType.CV_32F);
            Mat[] planes = { padded32, new Mat(padded.Size(), MatType.CV_32F, 0) };
            Cv2.Merge(planes, complexImage);
            Cv2.Dft(complexImage, complexImage);

            planes = complexImage.Split();

            Cv2.Magnitude(planes[0], planes[1], magnitude);
            magnitude += Scalar.All(1);
            Cv2.Log(magnitude, magnitude);

            spectrum = magnitude[new Rect(0, 0, magnitude.Cols & -2, magnitude.Rows & -2)];
            spectrum = spectrum.Normalize(0, 255, NormTypes.MinMax);
            spectrum.ConvertTo(padded, MatType.CV_8U);

            int cx = padded.Cols / 2;
            int cy = padded.Rows / 2;

            mats.mat[3] = padded[new Rect(0, 0, cx, cy)].Clone();
            mats.mat[2] = padded[new Rect(cx, 0, cx, cy)].Clone();
            mats.mat[1] = padded[new Rect(0, cy, cx, cy)].Clone();
            mats.mat[0] = padded[new Rect(cx, cy, cx, cy)].Clone();
            mats.Run(empty);
            dst3 = mats.dst2;

            dst2 = InverseDFT(complexImage);
        }
    }

    public class CS_DFT_Inverse : CS_Parent
    {
        Mat_2to1 mats = new Mat_2to1();
        CS_DFT_Basics dft;

        public CS_DFT_Inverse(VBtask task) : base(task)
        {
            dft = new CS_DFT_Basics(task);
            labels[2] = "Image after Inverse DFT";
            desc = "Take the inverse of the Discrete Fourier Transform.";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat gray32f = new Mat();
            src.ConvertTo(gray32f, MatType.CV_32F);
            Mat[] planes = { gray32f, new Mat(gray32f.Size(), MatType.CV_32F, 0) };
            Mat complex = new Mat();
            Mat complexImage = new Mat();
            Cv2.Merge(planes, complex);
            Cv2.Dft(complex, complexImage);

            dst2 = dft.InverseDFT(complexImage);

            Mat diff = new Mat();
            Cv2.Absdiff(src, dst2, diff);
            mats.mat[0] = diff.Threshold(0, 255, ThresholdTypes.Binary);
            mats.mat[1] = (diff * 50).ToMat();
            mats.Run(empty);
            if (mats.mat[0].CountNonZero() > 0)
            {
                dst3 = mats.dst2;
                labels[3] = "Mask of difference (top) and relative diff (bot)";
            }
            else
            {
                labels[3] = "InverseDFT reproduced original";
                dst3.SetTo(0);
            }
        }
    }




    public class CS_DFT_ButterworthDepth : CS_Parent
    {
        DFT_ButterworthFilter_MT bfilter = new DFT_ButterworthFilter_MT();

        public CS_DFT_ButterworthDepth(VBtask task) : base(task)
        {
            desc = "Use the Butterworth filter on a DFT image - RGBDepth as input.";
            labels[2] = "Image with Butterworth Low Pass Filter Applied";
            labels[3] = "Same filter with radius / 2";
        }

        public void RunCS(Mat src)
        {
            bfilter.Run(task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = bfilter.dst2;
            dst3 = bfilter.dst3;
        }
    }

    public class CS_DFT_Shapes : CS_Parent
    {
        CS_DFT_Basics dft;
        Draw_Circles circle = new Draw_Circles();
        Draw_Ellipses ellipse = new Draw_Ellipses();
        Draw_Polygon polygon = new Draw_Polygon();
        Rectangle_Basics rectangle = new Rectangle_Basics();
        Draw_Lines lines = new Draw_Lines();
        Draw_SymmetricalShapes symShapes = new Draw_SymmetricalShapes();
        Options_Draw options = new Options_Draw();
        Options_DFTShape optionsDFT = new Options_DFTShape();

        public CS_DFT_Shapes(VBtask task) : base(task)
        {
            dft = new CS_DFT_Basics(task);
            FindSlider("DrawCount").Value = 1;
            labels = new string[] { "Inverse of the DFT - the same grayscale input.", "", "Input to the DFT", "Discrete Fourier Transform Output" };
            desc = "Show the spectrum magnitude for some standard shapes";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            optionsDFT.RunVB();

            switch (optionsDFT.dftShape)
            {
                case "Draw Circle":
                    circle.Run(src);
                    dst2 = circle.dst2;
                    break;
                case "Draw Ellipse":
                    ellipse.Run(src);
                    dst2 = ellipse.dst2;
                    break;
                case "Draw Line":
                    lines.Run(src);
                    dst2 = lines.dst2;
                    break;
                case "Draw Rectangle":
                    rectangle.Run(src);
                    dst2 = rectangle.dst2;
                    break;
                case "Draw Polygon":
                    polygon.Run(src);
                    dst2 = polygon.dst2;
                    break;
                case "Draw Symmetrical Shapes":
                    symShapes.Run(src);
                    dst2 = symShapes.dst2;
                    break;
                case "Draw Point":
                    if (task.heartBeat)
                    {
                        dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
                        var pt1 = new cv.Point(msRNG.Next(0, dst2.Width / 10), msRNG.Next(0, dst2.Height / 10));
                        var pt2 = new cv.Point(msRNG.Next(0, dst2.Width / 10), msRNG.Next(0, dst2.Height / 10));
                        dst2.Set<byte>(pt1.Y, pt1.X, 255);
                        dst2.Set<byte>(pt2.Y, pt2.X, 255);
                        labels[2] = $"pt1 = ({pt1.X},{pt1.Y})  pt2 = ({pt2.X},{pt2.Y})";
                    }
                    break;
            }

            dft.RunAndMeasure(dst2, dft);
            dst3 = dft.dst3;

            // the following line to view the inverse of the DFT transform.
            // It is the grayscale image of the input - no surprise.  It works!
            dst2 = dft.InverseDFT(dft.complexImage);
        }
    }








    public class CS_Diff_Basics : CS_Parent
    {
        public int changedPixels;
        public Mat lastFrame;

        public CS_Diff_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Unstable mask", "" };
            UpdateAdvice(traceName + ": use goption 'Pixel Difference Threshold' to control changed pixels.");
            desc = "Capture an image and compare it to previous frame using absDiff and threshold";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (task.FirstPass) lastFrame = src.Clone();
            if (task.optionsChanged || lastFrame.Size() != src.Size())
                lastFrame = src.Clone();

            Cv2.Absdiff(src, lastFrame, dst0);
            dst2 = dst0.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            changedPixels = dst2.CountNonZero();

            if (changedPixels > 0)
            {
                lastFrame = src.Clone();
                int pixelD = task.gOptions.pixelDiffThreshold;
                strOut = "Motion detected - " + changedPixels.ToString() + " pixels changed with threshold " + pixelD.ToString();
                if (task.heartBeat)
                    labels[3] = strOut;
            }
            else
            {
                strOut = "No motion detected";
            }

            SetTrueText(strOut, 3);
        }
    }

    public class CS_Diff_Color : CS_Parent
    {
        public CS_Diff_Basics diff;

        public CS_Diff_Color(VBtask task) : base(task)
        {
            diff = new CS_Diff_Basics(task);
            labels = new string[] { "", "", "Each channel displays the channel's difference", "Mask with all differences" };
            desc = "Use Diff_Basics with a color image.";
        }

        public void RunCS(Mat src)
        {
            if (task.FirstPass)
                diff.lastFrame = src.Reshape(1, src.Rows * 3);

            diff.RunAndMeasure(src.Reshape(1, src.Rows * 3), diff);
            dst2 = diff.dst2.Reshape(3, src.Rows);
            dst3 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
        }
    }

    public class CS_Diff_UnstableDepthAndColor : CS_Parent
    {
        public CS_Diff_Basics diff;
        public Depth_NotMissing depth = new Depth_NotMissing();

        public CS_Diff_UnstableDepthAndColor(VBtask task) : base(task)
        {
            diff = new CS_Diff_Basics(task);
            labels = new string[] { "", "", "Stable depth and color", "Unstable depth/color mask" };
            desc = "Build a mask for any pixels that have either unstable depth or color";
        }

        public void RunCS(Mat src)
        {
            diff.RunAndMeasure(src, diff);
            Mat unstableGray = diff.dst2.Clone();
            depth.Run(task.depthRGB);
            Mat unstableDepth = new Mat();
            Mat mask = new Mat();
            Cv2.BitwiseNot(depth.dst3, unstableDepth);

            if (unstableGray.Channels() == 3)
                unstableGray = unstableGray.CvtColor(ColorConversionCodes.BGR2GRAY);

            Cv2.BitwiseOr(unstableGray, unstableDepth, mask);
            dst2 = src.Clone();
            dst2.SetTo(Scalar.Black, mask);
            dst3 = mask;
        }
    }

    public class CS_Diff_RGBAccum : CS_Parent
    {
        public CS_Diff_Basics diff;
        List<Mat> history = new List<Mat>();

        public CS_Diff_RGBAccum(VBtask task) : base(task)
        {
            diff = new CS_Diff_Basics(task);
            labels = new string[] { "", "", "Accumulated BGR image", "Mask of changed pixels" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, Scalar.Black);
            desc = "Run Diff_Basics and accumulate BGR diff data.";
        }

        public void RunCS(Mat src)
        {
            diff.RunAndMeasure(src, diff);
            if (task.optionsChanged)
                history.Clear();

            history.Add(diff.dst2);
            if (history.Count > task.frameHistoryCount)
                history.RemoveAt(0);

            dst2.SetTo(Scalar.Black);
            foreach (Mat m in history)
            {
                Cv2.BitwiseOr(dst2, m, dst2);
            }
        }
    }

    public class CS_Diff_Lines : CS_Parent
    {
        Diff_RGBAccum diff = new Diff_RGBAccum();
        Line_Basics lines = new Line_Basics();

        public CS_Diff_Lines(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Add motion to see Diff output and lines input", "Lines output" };
            desc = "identify lines in the diff output";
        }

        public void RunCS(Mat src)
        {
            diff.Run(src);
            dst2 = diff.dst2;

            lines.Run(dst2);
            dst3 = src.Clone();
            foreach (var lp in lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, Scalar.Yellow, task.lineWidth);
            }
        }
    }



    public class CS_Diff_Heartbeat : CS_Parent
    {
        public int cumulativePixels;

        public CS_Diff_Heartbeat(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            labels = new string[] { "", "", "Unstable mask", "Pixel difference" };
            desc = "Diff an image with one from the last heartbeat.";
        }

        public void RunCS(Mat src)
        {
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            if (task.heartBeat)
            {
                dst1 = src.Clone();
                dst2.SetTo(0);
            }

            Cv2.Absdiff(src, dst1, dst3);
            cumulativePixels = Cv2.CountNonZero(dst3);
            dst2 = dst2 | dst3.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
        }
    }

    public class CS_Diff_DepthAccum : CS_Parent
    {
        Diff_Depth32S diff = new Diff_Depth32S();
        History_Basics frames = new History_Basics();

        public CS_Diff_DepthAccum(VBtask task) : base(task)
        {
            desc = "Accumulate the mask of depth differences.";
        }

        public void RunCS(Mat src)
        {
            diff.Run(src);
            frames.Run(diff.dst2);
            dst2 = frames.dst2;
            labels = diff.labels;
        }
    }

    public class CS_Diff_Depth32S : CS_Parent
    {
        public Mat lastDepth32s;
        Options_Depth options = new Options_Depth();

        public CS_Diff_Depth32S(VBtask task) : base(task)
        {
            lastDepth32s = dst0.Clone();
            desc = "Where is the depth difference between frames greater than X millimeters.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            Mat depth32f = 1000 * task.pcSplit[2];
            depth32f.ConvertTo(dst0, MatType.CV_32S);

            if (task.optionsChanged)
                lastDepth32s = dst0.Clone();

            Cv2.Absdiff(dst0, lastDepth32s, dst1);
            dst1 = dst1.ConvertScaleAbs();
            var mm = GetMinMax(dst1);

            dst2 = dst1.Threshold(options.millimeters - 1, 255, ThresholdTypes.Binary);

            lastDepth32s = dst0.Clone();
            if (task.heartBeat)
            {
                labels[2] = $"Mask where depth difference between frames is more than {options.millimeters} mm's";
                int count = Cv2.CountNonZero(dst2);
                labels[3] = $"{count} pixels ({(double)count / Cv2.CountNonZero(task.depthMask):P0} of all depth pixels) were different by more than {options.millimeters} mm's";
            }
        }
    }

    public class CS_Diff_Depth32f : CS_Parent
    {
        public Mat lastDepth32f;
        Options_Depth options = new Options_Depth();

        public CS_Diff_Depth32f(VBtask task) : base(task)
        {
            lastDepth32f = dst0.Clone();
            desc = "Where is the depth difference between frames greater than X centimeters.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
                lastDepth32f = task.pcSplit[2].Clone();

            Cv2.Absdiff(task.pcSplit[2], lastDepth32f, dst1);
            var mm = GetMinMax(dst1);

            dst2 = dst1.Threshold(options.mmThreshold, 255, ThresholdTypes.Binary);

            lastDepth32f = task.pcSplit[2].Clone();
            if (task.heartBeat)
            {
                labels[2] = $"Mask where depth difference between frames is more than {options.mmThreshold} mm's";
                int count = Cv2.CountNonZero(dst2);
                labels[3] = $"{count} pixels ({(double)count / Cv2.CountNonZero(task.depthMask):P0} of all depth pixels) were different by more than {options.mmThreshold} mm's";
            }
        }
    }


    public class CS_Dilate_Basics : CS_Parent
    {
        public Options_Dilate options = new Options_Dilate();

        public CS_Dilate_Basics(VBtask task) : base(task)
        {
            desc = "Dilate the image provided.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (options.noshape || options.iterations == 0)
                dst2 = src;
            else
                dst2 = src.Dilate(options.element, null, options.iterations);

            if (standaloneTest())
            {
                dst3 = task.depthRGB.Dilate(options.element, null, options.iterations);
                labels[3] = $"Dilated Depth {options.iterations} times";
            }
            labels[2] = $"Dilated BGR {options.iterations} times";
        }
    }

    public class CS_Dilate_OpenClose : CS_Parent
    {
        Options_Dilate options = new Options_Dilate();

        public CS_Dilate_OpenClose(VBtask task) : base(task)
        {
            desc = "Erode and dilate with MorphologyEx on the BGR and Depth image.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            MorphTypes openClose = options.iterations > 0 ? MorphTypes.Open : MorphTypes.Close;
            Cv2.MorphologyEx(task.depthRGB, dst3, openClose, options.element);
            Cv2.MorphologyEx(src, dst2, openClose, options.element);
        }
    }

    public class CS_Dilate_Erode : CS_Parent
    {
        Options_Dilate options = new Options_Dilate();

        public CS_Dilate_Erode(VBtask task) : base(task)
        {
            desc = "Erode and dilate with MorphologyEx on the input image.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();
            Cv2.MorphologyEx(src, dst2, MorphTypes.Open, options.element);
            Cv2.MorphologyEx(dst2, dst2, MorphTypes.Close, options.element);
        }
    }


    public class CS_DisparityFunction_Basics : CS_Parent
    {
        FeatureLeftRight_Basics match = new FeatureLeftRight_Basics();
        string depthStr;
        string dispStr;

        public CS_DisparityFunction_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "AddWeighted output: lines show disparity between left and right images",
                                "Disparity as a function of depth" };
            desc = "Using FeatureMatch results build a function for disparity given depth";
        }

        public int DisparityFormula(float depth)
        {
            if (depth == 0) return 0;
            return (int)(task.baseline * 1000 * task.focalLength / depth);
        }

        public void RunCS(Mat src)
        {
            if (task.cameraName == "Azure Kinect 4K")
            {
                SetTrueText("Kinect for Azure does not have a left and right view to compute disparities", 2);
                return;
            }

            match.Run(src);
            dst2 = match.dst1;
            if (match.mpList.Count == 0) return; // no data...

            var disparity = new SortedDictionary<int, float>(new CompareAllowIdenticalIntegerInverted());
            for (int i = 0; i < match.mpList.Count; i++)
            {
                var mp = match.mpList[i];
                disparity.Add((int)(mp.p1.X - mp.p2.X), match.mpCorrelation[i]);
            }

            if (task.heartBeat)
            {
                dispStr = "Disparity: \n";
                depthStr = "Depth: \n";
                int index = 0;
                foreach (var entry in disparity)
                {
                    dispStr += $"{entry.Key}, ";
                    depthStr += $"{entry.Value:F3}, ";
                    index++;
                    if (index % 20 == 0)
                    {
                        dispStr += "\n";
                        depthStr += "\n";
                    }
                }

                int testIndex = Math.Min(disparity.Count - 1, 10);
                float actualDisparity = task.disparityAdjustment * disparity.ElementAt(testIndex).Key;
                float actualDepth = disparity.ElementAt(testIndex).Value;

                strOut = "Computing disparity from depth: disparity = ";
                strOut += "baseline * focal length / actual depth\n";
                strOut += "A disparity adjustment that is dependent on working resolution is used here \n";
                strOut += "to adjust the observed disparity to match the formula.\n";
                strOut += $"At working resolution = {task.WorkingRes.Width}x{task.WorkingRes.Height}";
                strOut += $" the adjustment factor is {task.disparityAdjustment:F3}\n\n";

                int disparityformulaoutput = DisparityFormula(actualDepth);
                strOut += $"At actual depth {actualDepth:F3}\n";

                strOut += $"Disparity formula is: {task.baseline:F3}";
                strOut += $" * {task.focalLength:F3} * 1000 / {actualDepth:F3}\n";

                strOut += $"Disparity formula:\t{disparityformulaoutput:F3} pixels\n";
                strOut += $"Disparity actual:\t\t{actualDisparity:F3} pixels\n";
                strOut += "Predicted disparity = baseline * focal length * 1000 / actual depth / disparityAdjustment\n";
                strOut += $"Predicted disparity at {actualDepth:F3}m = {(int)(disparityformulaoutput / task.disparityAdjustment)} pixels";
            }

            SetTrueText(depthStr + "\n\n" + dispStr, 3);
            SetTrueText(strOut, new cv.Point(0, dst2.Height / 3), 3);
        }
    }



    public class CS_Distance_Basics : CS_Parent
    {
        Options_Distance options = new Options_Distance();

        public CS_Distance_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Distance transform - create a mask with threshold", "" };
            UpdateAdvice(traceName + ": use local options to control which method is used.");
            desc = "Distance algorithm basics.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest()) src = task.depthRGB;
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            dst0 = src.DistanceTransform(options.distanceType, 0);
            dst1 = GetNormalize32f(dst0);
            dst1.ConvertTo(dst2, MatType.CV_8UC1);
        }
    }

    public class CS_Distance_Labels : CS_Parent
    {
        Options_Distance options = new Options_Distance();

        public CS_Distance_Labels(VBtask task) : base(task)
        {
            labels[2] = "Distance results";
            labels[3] = "Input mask to distance transform";
            desc = "Distance algorithm basics.";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest()) src = task.depthRGB;
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);

            // Commented out code
            //Mat labels;
            //Cv2.DistanceTransformWithLabels(src, dst0, out labels, DistanceTypes.L2, DistanceTransformMasks.Precise);
            //Mat dist32f = dst0.Normalize(0, 255, NormTypes.MinMax);
            //dist32f.ConvertTo(src, MatType.CV_8UC1);
            //dst2 = src.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }

    public class CS_Distance_Foreground : CS_Parent
    {
        Distance_Basics dist = new Distance_Basics();
        Foreground_KMeans2 foreground = new Foreground_KMeans2();
        public bool useBackgroundAsInput;

        public CS_Distance_Foreground(VBtask task) : base(task)
        {
            labels[2] = "Distance results";
            labels[3] = "Input mask to distance transform";
            desc = "Distance algorithm basics.";
        }

        public void RunCS(Mat src)
        {
            var cRadio = FindRadio("C");
            var l1Radio = FindRadio("L1");

            foreground.Run(src);
            dst3 = useBackgroundAsInput ? foreground.dst2 : foreground.dst3;

            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            DistanceTypes DistanceType = DistanceTypes.L2;
            if (cRadio.Checked) DistanceType = DistanceTypes.C;
            if (l1Radio.Checked) DistanceType = DistanceTypes.L1;

            src = dst3 & src;
            Mat dist = src.DistanceTransform(DistanceType, cv.DistanceTransformMasks.Precise);
            Mat dist32f = dist.Normalize(0, 255, NormTypes.MinMax);
            dist32f.ConvertTo(src, MatType.CV_8UC1);
            dst2 = src.CvtColor(ColorConversionCodes.GRAY2BGR);
        }
    }

    public class CS_Distance_Background : CS_Parent
    {
        Distance_Foreground dist = new Distance_Foreground();

        public CS_Distance_Background(VBtask task) : base(task)
        {
            dist.useBackgroundAsInput = true;
            desc = "Use distance algorithm on the background";
        }

        public void RunCS(Mat src)
        {
            dist.Run(src);
            dst2 = dist.dst2;
            dst3 = dist.dst3;
            labels[2] = dist.labels[2];
            labels[3] = dist.labels[3];
        }
    }

    public class CS_Distance_Point3D : CS_Parent
    {
        public Point3f inPoint1;
        public Point3f inPoint2;
        public float distance;

        public CS_Distance_Point3D(VBtask task) : base(task)
        {
            desc = "Compute the distance in meters between 3D points in the point cloud";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest() && task.heartBeat)
            {
                inPoint1 = new Point3f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height), msRNG.Next(0, 10000));
                inPoint2 = new Point3f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height), msRNG.Next(0, 10000));

                dst2.SetTo(0);
                cv.Point p1 = new cv.Point((int)inPoint1.X, (int)inPoint1.Y);
                cv.Point p2 = new cv.Point((int)inPoint2.X, (int)inPoint2.Y);
                Cv2.Line(dst2, p1, p2, task.HighlightColor, task.lineWidth);

                Point3f vec1 = task.pointCloud.Get<Point3f>(p1.Y, p1.X);
                Point3f vec2 = task.pointCloud.Get<Point3f>(p2.Y, p2.X);
            }

            float x = inPoint1.X - inPoint2.X;
            float y = inPoint1.Y - inPoint2.Y;
            float z = inPoint1.Z - inPoint2.Z;
            distance = (float)Math.Sqrt(x * x + y * y + z * z);

            string strOut = $"{inPoint1.X:F3}, {inPoint1.Y:F3}, {inPoint1.Z:F3}\n";
            strOut += $"{inPoint2.X:F3}, {inPoint2.Y:F3}, {inPoint2.Z:F3}\n";
            strOut += $"Distance = {distance:F3}";
            SetTrueText(strOut, 3);
        }
    }

    public class CS_Distance_Point4D : CS_Parent
    {
        public Vec4f inPoint1;
        public Vec4f inPoint2;
        public float distance;

        public CS_Distance_Point4D(VBtask task) : base(task)
        {
            desc = "Compute the distance between 4D points";
        }

        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                inPoint1 = new Vec4f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height),
                                     msRNG.Next(0, (int)task.MaxZmeters), msRNG.Next(0, (int)task.MaxZmeters));
                inPoint2 = new Vec4f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height),
                                     msRNG.Next(0, (int)task.MaxZmeters), msRNG.Next(0, (int)task.MaxZmeters));
            }

            float x = inPoint1[0] - inPoint2[0];
            float y = inPoint1[1] - inPoint2[1];
            float z = inPoint1[2] - inPoint2[2];
            float d = inPoint1[3] - inPoint2[3];
            distance = (float)Math.Sqrt(x * x + y * y + z * z + d * d);

            string strOut = $"{inPoint1}\n{inPoint2}\nDistance = {distance:F1}";
            SetTrueText(strOut, new cv.Point(10, 10), 2);
        }
    }

    public class CS_Distance_RedCloud : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public List<List<float>> pixelVector = new List<List<float>>();
        SortedList<double, int> distances = new SortedList<double, int>(new compareAllowIdenticalDoubleInverted());
        SortedList<double, int> lastDistances = new SortedList<double, int>(new compareAllowIdenticalDoubleInverted());
        List<rcData> lastredCells = new List<rcData>();

        public CS_Distance_RedCloud(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.redOptions.setUseColorOnly(true);
            task.redOptions.setHistBinBar3D(5);
            labels[1] = "3D Histogram distance for each of the cells at left";
            desc = "Identify RedCloud cells using the cell's 3D histogram distance from zero";
        }

        double distanceFromZero(List<float> histlist)
        {
            double result = 0;
            foreach (var d in histlist)
            {
                result += d * d;
            }
            return Math.Sqrt(result);
        }

        public void RunCS(Mat src)
        {
            redC.Run(src);

            pixelVector.Clear();
            distances.Clear();
            for (int i = 0; i < task.redCells.Count; i++)
            {
                var rc = task.redCells[i];
                hColor.inputMask = rc.mask;
                hColor.Run(src.SubMat(rc.rect));

                double nextD = distanceFromZero(hColor.histArray.ToList());
                distances.Add(nextD, i);
            }

            if (task.heartBeat)
            {
                string strOut = "3D histogram distances from zero for each cell\n";
                int index = 0;
                foreach (var el in distances)
                {
                    strOut += $"({el.Value}) {el.Key:F1}\t";
                    if (index % 6 == 5) strOut += "\n";
                    index++;

                    var rc = task.redCells[el.Value];
                    SetTrueText(el.Value.ToString(), rc.maxDist);
                }

                strOut += "----------------------\n";
                index = 0;
                foreach (var el in lastDistances)
                {
                    strOut += $"({el.Value}) {el.Key:F1}\t";
                    if (index % 6 == 5) strOut += "\n";
                    index++;
                    var rc = lastredCells[el.Value];
                    SetTrueText(el.Value.ToString(), new cv.Point(rc.maxDist.X, rc.maxDist.Y + 10));
                }

                foreach (var el in distances)
                {
                    var rc = task.redCells[el.Value];
                    SetTrueText(el.Value.ToString(), rc.maxDist);
                }
            }

            foreach (var el in lastDistances)
            {
                var rp = lastredCells[el.Value];
                SetTrueText(el.Value.ToString(), new cv.Point(rp.maxDist.X, rp.maxDist.Y + 10));
            }

            SetTrueText(strOut, 1);

            dst2.SetTo(0);
            dst3.SetTo(0);
            for (int i = 0; i < distances.Count; i++)
            {
                var rp = task.redCells[distances.ElementAt(i).Value];
                task.color.SubMat(rp.rect).CopyTo(dst2.SubMat(rp.rect), rp.mask);
                dst3.SubMat(rp.rect).SetTo(task.scalarColors[i], rp.mask);
            }
            labels[2] = redC.labels[3];

            lastDistances.Clear();
            foreach (var el in distances)
            {
                lastDistances.Add(el.Key, el.Value);
            }

            lastredCells = new List<rcData>(task.redCells);
        }
    }



    public class CS_Distance_BinaryImage : CS_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        Distance_Basics distance = new Distance_Basics();

        public CS_Distance_BinaryImage(VBtask task) : base(task)
        {
            if (standalone)
            {
                task.gOptions.setDisplay1();
            }
            desc = "Measure the fragmentation of a binary image by using the distance transform";
        }

        public void RunCS(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            labels[2] = binary.labels[2] + " Draw a rectangle to measure specific area.";

            if (task.drawRect.Width > 0)
            {
                distance.Run(dst2[task.drawRect]);
            }
            else
            {
                distance.Run(dst2);
            }
            dst3 = distance.dst2;
            dst1 = dst3.Threshold(task.gOptions.DebugSliderValue, 255, ThresholdTypes.Binary);
        }
    }


    public class CS_Draw_Noise : CS_Parent
    {
        public int maxNoiseWidth = 3;
        public bool addRandomColor;
        public Mat noiseMask;
        Options_DrawNoise options = new Options_DrawNoise();    
        public CS_Draw_Noise(VBtask task) : base(task)
        {
            desc = "Add Noise to the color image";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            src.CopyTo(dst2);
            noiseMask = new Mat(src.Size(), MatType.CV_8UC1, Scalar.Black);
            for (int n = 0; n < options.noiseCount; n++)
            {
                int i = msRNG.Next(0, src.Cols - 1);
                int j = msRNG.Next(0, src.Rows - 1);
                Point2f center = new Point2f(i, j);
                Scalar c = addRandomColor ? new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255)) : Scalar.Black;
                int noiseWidth = msRNG.Next(1, options.noiseWidth);
                DrawCircle(dst2, center, noiseWidth, c, -1);
                DrawCircle(noiseMask, center, noiseWidth, Scalar.White, -1);
            }
        }
    }
    public class CS_Draw_Ellipses : CS_Parent
    {
        Options_Draw options = new Options_Draw();
        public CS_Draw_Ellipses(VBtask task) : base(task)
        {
            desc = "Draw the requested number of ellipses.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                for (int i = 0; i < options.drawCount; i++)
                {
                    Point2f nPoint = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    Size2f eSize = new Size2f((float)msRNG.Next(0, src.Cols - (int)nPoint.X - 1), (float)msRNG.Next(0, src.Rows - (int)nPoint.Y - 1));
                    float angle = 180.0f * (float)msRNG.Next(0, 1000) / 1000.0f;
                    Scalar nextColor = new Scalar(task.vecColors[i][0], task.vecColors[i][1], task.vecColors[i][2]);
                    Cv2.Ellipse(dst2, new RotatedRect(nPoint, eSize, angle), nextColor, options.drawFilled);
                }
            }
        }
    }
    public class CS_Draw_Circles : CS_Parent
    {
        Options_Draw options = new Options_Draw();
        public CS_Draw_Circles(VBtask task) : base(task)
        {
            desc = "Draw the requested number of circles.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                for (int i = 0; i < options.drawCount; i++)
                {
                    Point2f nPoint = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    int radius = msRNG.Next(10, 10 + msRNG.Next(src.Cols / 4));
                    Scalar nextColor = new Scalar(task.vecColors[i][0], task.vecColors[i][1], task.vecColors[i][2]);
                    DrawCircle(dst2, nPoint, radius, nextColor, options.drawFilled);
                }
            }
        }
    }
    public class CS_Draw_Lines : CS_Parent
    {
        Options_Draw options = new Options_Draw();
        public CS_Draw_Lines(VBtask task) : base(task)
        {
            desc = "Draw the requested number of Lines.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                for (int i = 0; i < options.drawCount; i++)
                {
                    Point2f nPoint1 = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    Point2f nPoint2 = new Point2f(msRNG.Next(src.Cols / 4, src.Cols * 3 / 4), msRNG.Next(src.Rows / 4, src.Rows * 3 / 4));
                    Scalar nextColor = new Scalar(task.vecColors[i][0], task.vecColors[i][1], task.vecColors[i][2]);
                    DrawLine(dst2, nPoint1, nPoint2, nextColor, options.drawFilled);
                }
            }
        }
    }
    public class CS_Draw_Polygon : CS_Parent
    {
        Options_Draw options = new Options_Draw();
        public CS_Draw_Polygon(VBtask task) : base(task)
        {
            desc = "Draw Polygon figures";
            labels = new string[] { "", "", "Convex Hull for the same points", "Polylines output" };
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (!task.heartBeat) return;
            int height = src.Height / 8;
            int width = src.Width / 8;
            Scalar polyColor = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
            dst3.SetTo(Scalar.Black);
            for (int i = 0; i < options.drawCount; i++)
            {
                List<cv.Point> points = new List<cv.Point>();
                List<List<cv.Point>> listOfPoints = new List<List<cv.Point>>();
                for (int j = 0; j < 11; j++)
                {
                    points.Add(new cv.Point(msRNG.Next(width, width * 7), msRNG.Next(height, height * 7)));
                }
                listOfPoints.Add(points);
                if (options.drawFilled != -1)
                {
                    Cv2.Polylines(dst3, listOfPoints, true, polyColor, task.lineWidth + 1, task.lineType);
                }
                else
                {
                    Cv2.FillPoly(dst3, listOfPoints, new Scalar(0, 0, 255));
                }
                cv.Point[] hull = Cv2.ConvexHull(points, true);
                listOfPoints = new List<List<cv.Point>>();
                points = new List<cv.Point>();
                for (int j = 0; j < hull.Length; j++)
                {
                    points.Add(new cv.Point(hull[j].X, hull[j].Y));
                }
                listOfPoints.Add(points);
                dst2.SetTo(Scalar.Black);
                Cv2.DrawContours(dst2, listOfPoints, 0, polyColor, options.drawFilled);
            }
        }
    }
    public class CS_Draw_Shapes : CS_Parent
    {
        public CS_Draw_Shapes(VBtask task) : base(task)
        {
            desc = "Use RNG to draw the same set of shapes every time";
        }
        public void RunCS(Mat src)
        {
            int offsetX = 25, offsetY = 25, lineLength = 25, thickness = 2;
            dst2.SetTo(0);
            for (int i = 1; i <= 256; i++)
            {
                cv.Point p1 = new cv.Point(thickness * i + offsetX, offsetY);
                cv.Point p2 = new cv.Point(thickness * i + offsetX, offsetY + lineLength);
                Cv2.Line(dst2, p1, p2, new Scalar(i, i, i), thickness);
            }
            for (int i = 1; i <= 256; i++)
            {
                Scalar color = new Scalar(msRNG.Next(0, 255), msRNG.Next(0, 255), msRNG.Next(0, 255));
                switch (msRNG.Next(0, 3))
                {
                    case 0: // circle
                        cv.Point center = new cv.Point(msRNG.Next(offsetX, dst2.Cols - offsetX), msRNG.Next(offsetY + lineLength, dst2.Rows - offsetY));
                        int radius = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        Cv2.Circle(dst2, center, radius, color, -1);
                        break;
                    case 1: // Rectangle
                        center = new cv.Point(msRNG.Next(offsetX, dst2.Cols - offsetX), msRNG.Next(offsetY + lineLength, dst2.Rows - offsetY));
                        int width = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        int height = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        Rect rcenter = new Rect(center.X - width, center.Y - height / 2, width, height);
                        Cv2.Rectangle(dst2, rcenter, color, -1, LineTypes.Link8);
                        break;
                    case 2: // Ellipse
                        center = new cv.Point(msRNG.Next(offsetX, dst2.Cols - offsetX), msRNG.Next(offsetY + lineLength, dst2.Rows - offsetY));
                        width = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        height = msRNG.Next(1, Math.Min(offsetX, offsetY));
                        int angle = msRNG.Next(0, 180);
                        Cv2.Ellipse(dst2, center, new cv.Size(width / 2, height / 2), angle, 0, 360, color, -1, LineTypes.Link8);
                        break;
                }
            }
        }
    }
    public class CS_Draw_SymmetricalShapes : CS_Parent
    {
        Options_SymmetricalShapes options = new Options_SymmetricalShapes();
        public CS_Draw_SymmetricalShapes(VBtask task) : base(task)
        {
            desc = "Generate shapes programmatically";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.heartBeat)
            {
                dst2.SetTo(Scalar.Black);
                cv.Point pt = new cv.Point();
                cv.Point center = new cv.Point(src.Width / 2, src.Height / 2);
                List<cv.Point> points = new List<cv.Point>();
                for (int i = 0; i < options.numPoints; i++)
                {
                    double theta = i * options.dTheta;
                    double ripple = options.radius2 * Math.Cos(options.nGenPer * theta);
                    if (!options.symmetricRipple) ripple = Math.Abs(ripple);
                    if (options.reverseInOut) ripple = -ripple;
                    pt.X = (int)(center.X + (options.radius1 + ripple) * Math.Cos(theta + options.rotateAngle) + 0.5);
                    pt.Y = (int)(center.Y - (options.radius1 + ripple) * Math.Sin(theta + options.rotateAngle) + 0.5);
                    points.Add(pt);
                }
                for (int i = 0; i < options.numPoints; i++)
                {
                    cv.Point p1 = points[i];
                    cv.Point p2 = points[(i + 1) % options.numPoints];
                    Cv2.Line(dst2, p1, p2, task.scalarColors[i % task.scalarColors.Count()], task.lineWidth + 1, task.lineType);
                }
                if (options.fillRequest) Cv2.FloodFill(dst2, center, options.fillColor);
            }
        }
    }
    public class CS_Draw_Arc : CS_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        Rect rect;
        float angle;
        float startAngle;
        float endAngle;
        int colorIndex;
        int thickness;
        Options_DrawArc options = new Options_DrawArc();
        public CS_Draw_Arc(VBtask task) : base(task)
        {
            desc = "Use OpenCV's ellipse function to draw an arc";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.heartBeat)
            {
                rect = InitRandomRect(options.saveMargin);
                angle = msRNG.Next(0, 360);
                colorIndex = msRNG.Next(0, 255);
                thickness = msRNG.Next(1, 5);
                startAngle = msRNG.Next(1, 360);
                endAngle = msRNG.Next(1, 360);
                kalman.kInput = new[] { rect.X, rect.Y, rect.Width, rect.Height, angle, startAngle, endAngle };
            }
            kalman.kInput = new[] { rect.X, rect.Y, rect.Width, rect.Height, angle, startAngle, endAngle };
            kalman.Run(src);
            Rect r = new Rect((int)kalman.kOutput[0], (int)kalman.kOutput[1], (int)kalman.kOutput[2], (int)kalman.kOutput[3]);
            if (r.Width <= 5) r.Width = 5;
            if (r.Height <= 5) r.Height = 5;
            RotatedRect rr = new RotatedRect(new Point2f(r.X, r.Y), new Size2f(r.Width, r.Height), angle);
            Scalar color = task.scalarColors[colorIndex];
            dst2.SetTo(Scalar.White);
            if (options.drawFull)
            {
                Cv2.Ellipse(dst2, rr, color, thickness, task.lineType);
                DrawRotatedOutline(rr, dst2, task.scalarColors[colorIndex]);
            }
            else
            {
                angle = kalman.kOutput[4];
                startAngle = kalman.kOutput[5];
                endAngle = kalman.kOutput[6];
                if (options.drawFill) thickness = -1;
                Rect r1 = rr.BoundingRect();
                Cv2.Ellipse(dst2, new cv.Point(rr.Center.X, rr.Center.Y), new cv.Size(r1.Width, r1.Height),
                            angle, startAngle, endAngle, color, thickness, task.lineType);  
            }
        }
    }
    public class CS_Draw_ClipLine : CS_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        Kalman_Basics kalman = new Kalman_Basics();
        cv.Point pt1;
        cv.Point pt2;
        Rect rect;
        int linenum = 0;
        int hitCount = 0;
        void setup()
        {
            kalman.kInput = new float[9];
            Rect r = InitRandomRect(25);
            pt1 = new cv.Point(r.X, r.Y);
            pt2 = new cv.Point(r.X + r.Width, r.Y + r.Height);
            rect = InitRandomRect(25);
            if (task.gOptions.GetUseKalman()) flow.flowText.Add("--------------------------- setup ---------------------------");
        }
        public CS_Draw_ClipLine(VBtask task) : base(task)
        {
            flow.parentData = this;
            setup();
            desc = "Demonstrate the use of the ClipLine function in OpenCV. NOTE: when clipline returns true, p1/p2 are clipped by the rectangle";
        }
        public void RunCS(Mat src)
        {
            dst3 = src;
            kalman.kInput = new float[] { pt1.X, pt1.Y, pt2.X, pt2.Y, rect.X, rect.Y, rect.Width, rect.Height };
            kalman.Run(src);
            cv.Point p1 = new cv.Point((int)kalman.kOutput[0], (int)kalman.kOutput[1]);
            cv.Point p2 = new cv.Point((int)kalman.kOutput[2], (int)kalman.kOutput[3]);
            if (kalman.kOutput[6] < 5) kalman.kOutput[6] = 5; // don't let the width/height get too small...
            if (kalman.kOutput[7] < 5) kalman.kOutput[7] = 5;
            Rect r = new Rect((int)kalman.kOutput[4], (int)kalman.kOutput[5], (int)kalman.kOutput[6], (int)kalman.kOutput[7]);
            bool clipped = Cv2.ClipLine(r, ref p1, ref p2); // Returns false when the line and the rectangle don't intersect.
            Cv2.Line(dst3, p1, p2, clipped ? Scalar.White : Scalar.Black, task.lineWidth + 1, task.lineType);
            Cv2.Rectangle(dst3, r, clipped ? Scalar.Yellow : Scalar.Red, task.lineWidth + 1, task.lineType);
            flow.nextMsg = $"({linenum}) line {(clipped ? "intersects rectangle" : "does not intersect rectangle")}";
            linenum++;
            hitCount += clipped ? 1 : 0;
            SetTrueText($"There were {hitCount:###,##0} intersects and {linenum - hitCount} misses",
                         new cv.Point(src.Width / 2, 200));
            if (r == rect) setup();
            flow.Run(empty);
        }
    }
    //public class CS_Draw_Hexagon : CS_Parent
    //{
    //    ImageForm alpha = new ImageForm();
    //    public CS_Draw_Hexagon(VBtask task) : base(task)
    //    {
    //        alpha.ImagePic.Image = Image.(task.HomeDir + "Data/GestaltCube.gif");
    //        alpha.Show();
    //        alpha.Size = new System.Drawing.Size(512, 512);
    //        alpha.Text = "Perception is the key";
    //        desc = "What it means to recognize a cube.  Zygmunt Pizlo - UC Irvine";
    //    }
    //    public void RunCS(Mat src)
    //    {
    //    }
    //}
    public class CS_Draw_Line : CS_Parent
    {
        public cv.Point p1, p2;
        public bool externalUse;
        public CS_Draw_Line(VBtask task) : base(task)
        {
            desc = "Draw a line between the selected p1 and p2 - either by clicking twice in the image or externally providing p1 and p2.";
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) task.ClickPoint = new cv.Point();
            if (p1 != new cv.Point() && p2 != new cv.Point() && task.ClickPoint != new cv.Point())
            {
                p1 = new cv.Point();
                p2 = new cv.Point();
            }
            dst2 = src;
            if (task.ClickPoint != new cv.Point() || externalUse)
            {
                if (p1 == new cv.Point()) p1 = task.ClickPoint; else p2 = task.ClickPoint;
            }
            if (p1 != new cv.Point() && p2 == new cv.Point()) Cv2.Circle(dst2, p1, task.DotSize, task.HighlightColor);
            if (p1 != new cv.Point() && p2 != new cv.Point())
            {
                Cv2.Line(dst2, p1, p2, task.HighlightColor);
            }
            SetTrueText("Click twice in the image to provide the points below and they will be connected with a line\n" +
                        "P1 = " + p1.ToString() + "\nP2 = " + p2.ToString(), 3);
            task.ClickPoint = new cv.Point();
        }
    }
    public class CS_Draw_LineTest : CS_Parent
    {
        Draw_Line line = new Draw_Line();
        public CS_Draw_LineTest(VBtask task) : base(task)
        {
            desc = "Test the external use of the Draw_Line algorithm - provide 2 points and draw the line...";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                line.p1 = new cv.Point(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height));
                line.p2 = new cv.Point(msRNG.Next(0, src.Width), msRNG.Next(0, src.Height));
            }
            line.Run(src);
            dst2 = line.dst2;
        }
    }
    public class CS_Draw_Frustrum : CS_Parent
    {
        public Depth_WorldXYZ xyzDepth = new Depth_WorldXYZ();
        public CS_Draw_Frustrum(VBtask task) : base(task)
        {
            xyzDepth.depthUnitsMeters = true;
            labels[3] = "Frustrum 3D pointcloud";
            desc = "Draw a frustrum for a camera viewport";
        }
        public void RunCS(Mat src)
        {
            src = new Mat(task.WorkingRes, MatType.CV_32F, 0);
            int mid = src.Height / 2;
            float zIncr = task.MaxZmeters / mid;
            dst2 = src.Clone();
            Rect fRect = new Rect((src.Width - src.Height) / 2, 0, src.Height, src.Height);
            for (int i = 0; i <= src.Height / 2; i++)
            {
                Cv2.Rectangle(dst2[fRect], new Rect(mid - i, mid - i, i * 2, (i + 1) * 2), i * zIncr, 1);
            }
            xyzDepth.Run(dst2);
            dst3 = xyzDepth.dst2.Resize(task.WorkingRes);
        }
    }

    public class CS_Duster_Basics : CS_Parent
    {
        public Duster_MaskZ dust = new Duster_MaskZ();
        public CS_Duster_Basics(VBtask task) : base(task)
        {
            desc = "Removed blowback in the pointcloud";
        }
        public void RunCS(Mat src)
        {
            dust.Run(src);
            for (int i = 1; i <= dust.classCount; i++)
            {
                Mat mask = dust.dst2.InRange(i, i);
                Scalar depth = task.pcSplit[2].Mean(mask);
                task.pcSplit[2].SetTo(depth[0], mask);
            }
            Cv2.Merge(task.pcSplit, dst2);
            dst2.SetTo(0, ~dust.dst0);
            dst2.SetTo(0, task.maxDepthMask);
            dst3 = dust.dst3;
        }
    }
    public class CS_Duster_MaskZ : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public int classCount;
        public Options_GuidedBPDepth options = new Options_GuidedBPDepth();
        public CS_Duster_MaskZ(VBtask task) : base(task)
        {
            labels[3] = "Any flickering below is from changes in the sorted order of the clusters.  It should not be a problem.";
            desc = "Build a histogram that finds the clusters of depth data";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            hist.bins = options.bins;
            Mat src32f = task.pcSplit[2];
            task.maxDepthMask = src32f.InRange(task.MaxZmeters, task.MaxZmeters).ConvertScaleAbs();
            src32f.SetTo(task.MaxZmeters, task.maxDepthMask);
            hist.fixedRanges = new[] { new Rangef(0.001f, task.MaxZmeters) };
            hist.Run(src32f);
            List<float> histArray = hist.histArray.ToList();
            // This ensures that the maxDepthMask is separate from any previous cluster
            histArray[histArray.Count - 1] = 0;
            int start = 0;
            SortedList<int, Vec2i> clusters = new SortedList<int, Vec2i>(new compareAllowIdenticalIntegerInverted());
            float lastEntry = 0;
            int sampleCount = 0;
            for (int i = 0; i < histArray.Count; i++)
            {
                if (histArray[i] > 0 && lastEntry == 0) start = i;
                if (histArray[i] == 0 && lastEntry > 0)
                {
                    clusters.Add(sampleCount, new Vec2i(start, i));
                    sampleCount = 0;
                }
                lastEntry = histArray[i];
                sampleCount += (int)histArray[i];
            }
            float incr = task.MaxZmeters / options.bins;
            classCount = 0;
            for (int i = 0; i < Math.Min(clusters.Count, options.maxClusters); i++)
            {
                Vec2i vec = clusters.ElementAt(i).Value;
                classCount++;
                for (int j = vec[0]; j <= vec[1]; j++)
                {
                    histArray[j] = classCount;
                }
            }
            Marshal.Copy(histArray.ToArray(), 0, hist.histogram.Data, histArray.Count);
            Cv2.CalcBackProject(new[] { src32f }, new[] { 0 }, hist.histogram, dst1, hist.ranges);
            dst1.ConvertTo(dst2, MatType.CV_8U);
            classCount++;
            dst2.SetTo(classCount, task.maxDepthMask);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            if (task.heartBeat) labels[2] = $"dst2 = CV_8U version of depth segmented into {classCount} clusters.";
            dst0 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }
    public class CS_Duster_BasicsY : CS_Parent
    {
        Duster_MaskZ dust = new Duster_MaskZ();
        public CS_Duster_BasicsY(VBtask task) : base(task)
        {
            desc = "Removed blowback in the pointcloud";
        }
        public void RunCS(Mat src)
        {
            dust.Run(src);
            for (int i = 1; i <= dust.classCount; i++)
            {
                Mat mask = dust.dst2.InRange(i, i);
                Scalar pcY = task.pcSplit[1].Mean(mask);
                task.pcSplit[1].SetTo(pcY[0], mask);
            }
            Cv2.Merge(task.pcSplit, dst2);
            dst2.SetTo(0, ~dust.dst0);
            dst2.SetTo(0, task.maxDepthMask);
            dst3 = dust.dst3;
        }
    }
    public class CS_Duster_RedCloud : CS_Parent
    {
        Duster_Basics duster = new Duster_Basics();
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Duster_RedCloud(VBtask task) : base(task)
        {
            desc = "Run Bin3Way_RedCloud on the largest regions identified in Duster_Basics";
        }
        public void RunCS(Mat src)
        {
            duster.Run(src);
            dst1 = duster.dust.dst2.InRange(1, 1);
            dst3.SetTo(0);
            src.CopyTo(dst3, dst1);
            redC.inputMask = ~dst1;
            redC.Run(dst3);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }


    public class CS_Edge_All : CS_Parent
    {
        Options_Edges_All options = new Options_Edges_All();
        public CS_Edge_All(VBtask task) : base(task)
        {
            desc = "Use Radio Buttons to select the different edge algorithms.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            options.RunEdges(src);
            dst2 = options.dst2.Channels() == 1 ? options.dst2 : options.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            labels[2] = traceName + " - selection = " + options.edgeSelection;
        }
    }
    public class CS_Edge_DepthAndColor : CS_Parent
    {
        Depth_Holes shadow = new Depth_Holes();
        Edge_Canny canny = new Edge_Canny();
        Dilate_Basics dilate = new Dilate_Basics();
        public CS_Edge_DepthAndColor(VBtask task) : base(task)
        {
            FindRadio("Dilate shape: Rect").Checked = true;
            FindSlider("Canny threshold1").Value = 100;
            FindSlider("Canny threshold2").Value = 100;
            desc = "Find all the edges in an image include Canny from the grayscale image and edges of depth shadow.";
            labels[2] = "Edges in color and depth after dilate";
            labels[3] = "Edges in color and depth no dilate";
        }
        public void RunCS(Mat src)
        {
            canny.Run(src);
            shadow.Run(src);
            dst3 = shadow.dst3.Channels() != 1 ? shadow.dst3.CvtColor(ColorConversionCodes.BGR2GRAY) : shadow.dst3;
            dst3 += canny.dst2.Threshold(1, 255, ThresholdTypes.Binary);
            dilate.Run(dst3);
            dilate.dst2.SetTo(0, shadow.dst2);
            dst2 = dilate.dst2;
        }
    }
    public class CS_Edge_Scharr : CS_Parent
    {
        Options_Edges options = new Options_Edges();
        public CS_Edge_Scharr(VBtask task) : base(task)
        {
            labels[3] = "x field + y field in CV_32F format";
            desc = "Scharr is most accurate with 3x3 kernel.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat xField = gray.Scharr(MatType.CV_32FC1, 1, 0);
            Mat yField = gray.Scharr(MatType.CV_32FC1, 0, 1);
            Cv2.Add(xField, yField, dst3);
            dst3.ConvertTo(dst2, MatType.CV_8U, options.scharrMultiplier);
        }
    }
    public class CS_Edge_Preserving : CS_Parent
    {
        Options_Edges options = new Options_Edges();
        public CS_Edge_Preserving(VBtask task) : base(task)
        {
            labels[3] = "Edge preserving blur for BGR depth image above";
            desc = "OpenCV's edge preserving filter.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (options.recurseCheck)
            {
                Cv2.EdgePreservingFilter(src, dst2, EdgePreservingMethods.RecursFilter, options.EP_Sigma_s, options.EP_Sigma_r);
            }
            else
            {
                Cv2.EdgePreservingFilter(src, dst2, EdgePreservingMethods.NormconvFilter, options.EP_Sigma_s, options.EP_Sigma_r);
            }
            if (options.recurseCheck)
            {
                Cv2.EdgePreservingFilter(task.depthRGB, dst3, EdgePreservingMethods.RecursFilter, options.EP_Sigma_s, options.EP_Sigma_r);
            }
            else
            {
                Cv2.EdgePreservingFilter(task.depthRGB, dst3, EdgePreservingMethods.NormconvFilter, options.EP_Sigma_s, options.EP_Sigma_r);
            }
        }
    }
    public class CS_Edge_RandomForest_CPP : CS_Parent
    {
        byte[] rgbData;
        Options_Edges2 options = new Options_Edges2();
        public CS_Edge_RandomForest_CPP(VBtask task) : base(task)
        {
            desc = "Detect edges using structured forests - Opencv Contrib";
            rgbData = new byte[dst2.Total() * dst2.ElemSize()];
            labels[3] = "Thresholded Edge Mask (use slider to adjust)";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.frameCount < 100)
                SetTrueText("On the first call only, it takes a few seconds to load the randomForest model.", new cv.Point(10, 100));
            if (task.frameCount == 5)
            {
                FileInfo modelInfo = new FileInfo(Path.Combine(task.HomeDir, "Data/model.yml.gz"));
                cPtr = Edge_RandomForest_Open(modelInfo.FullName);
            }
            if (task.frameCount > 5)
            {
                Marshal.Copy(src.Data, rgbData, 0, rgbData.Length);
                GCHandle handleRGB = GCHandle.Alloc(rgbData, GCHandleType.Pinned);
                IntPtr imagePtr = Edge_RandomForest_Run(cPtr, handleRGB.AddrOfPinnedObject(), src.Rows, src.Cols);
                handleRGB.Free();
                dst3 = new Mat(src.Rows, src.Cols, MatType.CV_8U, imagePtr).Threshold(options.edgeRFthreshold, 255, ThresholdTypes.Binary);
            }
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Edge_RandomForest_Close(cPtr);
        }
    }
    public class CS_Edge_DCTfrequency : CS_Parent
    {
        Options_Edges2 options = new Options_Edges2();
        public CS_Edge_DCTfrequency(VBtask task) : base(task)
        {
            labels[3] = "Mask for the isolated frequencies";
            desc = "Find edges by removing all the highest frequencies.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat gray = task.depthRGB.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat frequencies = new Mat();
            Mat src32f = new Mat();
            gray.ConvertTo(src32f, MatType.CV_32F, 1.0 / 255);
            Cv2.Dct(src32f, frequencies, DctFlags.None);
            Rect roi = new Rect(0, 0, options.removeFrequencies, src32f.Height);
            if (roi.Width > 0)
                frequencies.SubMat(roi).SetTo(0);
            labels[2] = $"Highest {options.removeFrequencies} frequencies removed from RGBDepth";
            Cv2.Dct(frequencies, src32f, DctFlags.Inverse);
            src32f.ConvertTo(dst2, MatType.CV_8UC1, 255);
            dst3 = dst2.Threshold(options.dctThreshold, 255, ThresholdTypes.Binary);
        }
    }
    public class CS_Edge_Deriche_CPP : CS_Parent
    {
        Options_Edges3 options = new Options_Edges3();
        public CS_Edge_Deriche_CPP(VBtask task) : base(task)
        {
            cPtr = Edge_Deriche_Open();
            labels[3] = "Image enhanced with Deriche results";
            desc = "Edge detection using the Deriche X and Y gradients";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = Edge_Deriche_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.alpha, options.omega);
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero)
                dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
            dst3 = src | dst2;
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Edge_Deriche_Close(cPtr);
        }
    }
    public class CS_Edge_DCTinput : CS_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        DCT_FeatureLess dct = new DCT_FeatureLess();
        public CS_Edge_DCTinput(VBtask task) : base(task)
        {
            labels[2] = "Canny edges produced from original grayscale image";
            labels[3] = "Edges produced with featureless regions cleared";
            desc = "Use the featureless regions to enhance the edge detection";
        }
        public void RunCS(Mat src)
        {
            edges.Run(src);
            dst2 = edges.dst2.Clone();
            dct.Run(src);
            Mat tmp = src.SetTo(Scalar.White, dct.dst2);
            edges.Run(tmp);
            dst3 = edges.dst2;
        }
    }

    public class CS_EdgeDraw_Basics : CS_Parent
    {
        public CS_EdgeDraw_Basics(VBtask task) : base(task)
        {
            cPtr = EdgeDraw_Edges_Open();
            labels = new string[] { "", "", "CS_EdgeDraw_Basics output", "" };
            desc = "Access the EdgeDraw algorithm directly rather than through to CPP_Basics interface - more efficient";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = EdgeDraw_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, task.lineWidth);
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero)
                dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC1, imagePtr);
            Cv2.Rectangle(dst2, new Rect(0, 0, dst2.Width, dst2.Height), new Scalar(255), task.lineWidth);
        }
        public void Close()
        {
            EdgeDraw_Edges_Close(cPtr);
        }
    }
    public class CS_EdgeDraw_Segments : CS_Parent
    {
        public List<Point2f> segPoints = new List<Point2f>();
        public CS_EdgeDraw_Segments(VBtask task) : base(task)
        {
            cPtr = EdgeDraw_Lines_Open();
            labels = new string[] { "", "", "CS_EdgeDraw_Segments output", "" };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, new Scalar(0));
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, new Scalar(0));
            desc = "Access the EdgeDraw algorithm directly rather than through to CPP_Basics interface - more efficient";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr vecPtr = EdgeDraw_Lines_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, task.lineWidth);
            handleSrc.Free();
            Mat ptData = new Mat(EdgeDraw_Lines_Count(cPtr), 2, MatType.CV_32FC2, vecPtr).Clone();
            dst2.SetTo(new Scalar(0));
            if (task.heartBeat)
                dst3.SetTo(new Scalar(0));
            segPoints.Clear();
            for (int i = 0; i < ptData.Rows; i += 2)
            {
                Point2f pt1 = ptData.Get<Point2f>(i, 0);
                Point2f pt2 = ptData.Get<Point2f>(i, 1);
                DrawLine(dst2, pt1, pt2, Scalar.White, task.lineWidth);
                Cv2.Add(dst3, dst2, dst3);
                segPoints.Add(pt1);
                segPoints.Add(pt2);
            }
        }
        public void Close()
        {
            EdgeDraw_Lines_Close(cPtr);
        }
    }



    public class CS_Eigen_Basics : CS_Parent
    {
        public CS_Eigen_Basics(VBtask task) : base(task)
        {
            desc = "Solve system of equations using OpenCV's EigenVV";
            labels[2] = "EigenVec (solution)";
            labels[3] = "Relationship between Eigen Vec and Vals";
        }
        public void RunCS(Mat src)
        {
            double[] a = { 1.96, -6.49, -0.47, -7.2, -0.65,
                       -6.49, 3.8, -6.39, 1.5, -6.34,
                       -0.47, -6.39, 4.17, -1.51, 2.67,
                       -7.2, 1.5, -1.51, 5.7, 1.8,
                       -0.65, -6.34, 2.67, 1.8, -7.1 };
            Mat mat = new Mat(5, 5, MatType.CV_64FC1, a);
            Mat eigenVal = new Mat();
            Mat eigenVec = new Mat();
            Cv2.Eigen(mat, eigenVal, eigenVec);
            double[] solution = new double[mat.Cols];
            string nextLine = "Eigen Vals\tEigen Vectors\t\t\t\t\tOriginal Matrix\n\n";
            Scalar scalar;
            for (int i = 0; i < eigenVal.Rows; i++)
            {
                scalar = eigenVal.Get<Scalar>(0, i);
                solution[i] = scalar.Val0;
                nextLine += string.Format("{0:F2}\t\t", scalar.Val0);
                for (int j = 0; j < eigenVec.Rows; j++)
                {
                    scalar = eigenVec.Get<Scalar>(i, j);
                    nextLine += string.Format("{0:F2}\t", scalar.Val0);
                }
                for (int j = 0; j < eigenVec.Rows; j++)
                {
                    nextLine += string.Format("\t{0:F2}", a[i * 5 + j]);
                }
                nextLine += "\n\n";
            }
            for (int i = 0; i < eigenVec.Rows; i++)
            {
                string plusSign = " + ";
                for (int j = 0; j < eigenVec.Cols; j++)
                {
                    scalar = eigenVec.Get<Scalar>(i, j);
                    if (j == eigenVec.Cols - 1) plusSign = "\t";
                    nextLine += string.Format("{0:F2} * {1:F2}{2}", scalar.Val0, solution[j], plusSign);
                }
                nextLine += " = \t0.0\n";
            }
            SetTrueText(nextLine);
        }
    }
    public class CS_Eigen_FitLineInput : CS_Parent
    {
        public List<Point2f> points = new List<Point2f>();
        public float m;
        public float bb;
        public Options_Eigen options = new Options_Eigen();
        public CS_Eigen_FitLineInput(VBtask task) : base(task)
        {
            labels[2] = "Use sliders to adjust the width and intensity of the line";
            desc = "Generate a noisy line in a field of random data.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.heartBeat)
            {
                if (!task.testAllRunning) options.recompute = false;
                dst2.SetTo(0);
                int width = src.Width;
                int height = src.Height;
                points.Clear();
                Random rand = new Random();
                for (int i = 0; i < options.randomCount; i++)
                {
                    Point2f pt = new Point2f((float)(rand.NextDouble() * width), (float)(rand.NextDouble() * height));
                    pt.X = Math.Max(0, Math.Min(pt.X, width));
                    pt.Y = Math.Max(0, Math.Min(pt.Y, height));
                    points.Add(pt);
                    Cv2.Circle(dst2, (cv.Point)points[i], task.DotSize, Scalar.White, -1);
                }
                Point2f p1, p2;
                if (rand.NextDouble() * 2 - 1 >= 0)
                {
                    p1 = new Point2f((float)(rand.NextDouble() * width), 0);
                    p2 = new Point2f((float)(rand.NextDouble() * width), height);
                }
                else
                {
                    p1 = new Point2f(0, (float)(rand.NextDouble() * height));
                    p2 = new Point2f(width, (float)(rand.NextDouble() * height));
                }
                if (p1.X == p2.X) p1.X += 1;
                if (p1.Y == p2.Y) p1.Y += 1;
                m = (p2.Y - p1.Y) / (p2.X - p1.X);
                bb = p2.Y - p2.X * m;
                float startx = Math.Min(p1.X, p2.X);
                float incr = (Math.Max(p1.X, p2.X) - startx) / options.linePairCount;
                Scalar highLight = options.highlight ? Scalar.Gray : Scalar.White;
                for (int i = 0; i < options.linePairCount; i++)
                {
                    float noiseOffsetX = (float)((rand.NextDouble() * 2 - 1) * options.noiseOffset);
                    float noiseOffsetY = (float)((rand.NextDouble() * 2 - 1) * options.noiseOffset);
                    cv.Point pt = new cv.Point(
                        startx + i * incr + noiseOffsetX,
                        Math.Max(0, Math.Min(m * (startx + i * incr) + bb + noiseOffsetY, height))
                    );
                    pt.X = Math.Max(0, Math.Min(pt.X, width));
                    pt.Y = Math.Max(0, Math.Min(pt.Y, height));
                    points.Add((Point2f)pt);
                    Cv2.Circle(dst2, pt, task.DotSize + 1, highLight, -1);
                }
            }
        }
    }
    public class CS_Eigen_Fitline : CS_Parent
    {
        Eigen_FitLineInput noisyLine = new Eigen_FitLineInput();
        Mat eigenVec = new Mat(2, 2, MatType.CV_32F, 0);
        Mat eigenVal = new Mat(2, 2, MatType.CV_32F, 0);
        float theta;
        float len;
        float m2;
        public CS_Eigen_Fitline(VBtask task) : base(task)
        {
            labels[2] = "blue is Ground Truth, red is fitline, yellow is EigenFit";
            labels[3] = "Raw input (use sliders below to explore)";
            desc = "Remove outliers when trying to fit a line. Fitline and the Eigen computation below produce the same result.";
        }
        public void RunCS(Mat src)
        {
            noisyLine.options.recompute = true;
            noisyLine.Run(src);
            dst3 = noisyLine.dst2.Clone();
            dst2.SetTo(0);
            noisyLine.options.recompute = false;
            int width = src.Width;
            var nLines = Cv2.FitLine(noisyLine.points, DistanceTypes.L2, 1, 0.01, 0.01); 
            Vec4f line = new Vec4f((float)nLines.Vx, (float)nLines.Vy, (float)nLines.X1, (float)nLines.Y1);
            float m = line[1] / line[0];
            float bb = line[3] - m * line[2];
            cv.Point p1 = new cv.Point(0, bb);
            cv.Point p2 = new cv.Point(width, m * width + bb);
            Cv2.Line(dst2, p1, p2, Scalar.Red, 20, LineTypes.Link8);
            Mat pointMat = new Mat(noisyLine.options.randomCount, 1, MatType.CV_32FC2, noisyLine.points.ToArray());
            Scalar mean = Cv2.Mean(pointMat);
            Mat[] split = Cv2.Split(pointMat);
            var mmX = GetMinMax(split[0]);
            var mmY = GetMinMax(split[1]);
            Vec4f eigenInput = new Vec4f();
            foreach (Point2f pt in noisyLine.points)
            {
                float x = pt.X - (float)mean.Val0;
                float y = pt.Y - (float)mean.Val1;
                eigenInput[0] += x * x;
                eigenInput[1] += x * y;
                eigenInput[3] += y * y;
            }
            eigenInput[2] = eigenInput[1];
            List<Point2f> vec4f = new List<Point2f>
        {
            new Point2f(eigenInput[0], eigenInput[1]),
            new Point2f(eigenInput[1], eigenInput[3])
        };
            Mat D = new Mat(2, 2, MatType.CV_32FC1, vec4f.ToArray());
            Cv2.Eigen(D, eigenVal, eigenVec);
            theta = (float)Math.Atan2(eigenVec.Get<float>(1, 0), eigenVec.Get<float>(0, 0));
            len = (float)Math.Sqrt(Math.Pow(mmX.maxVal - mmX.minVal, 2) + Math.Pow(mmY.maxVal - mmY.minVal, 2));
            p1 = new cv.Point((int)(mean.Val0 - Math.Cos(theta) * len / 2), (int)(mean.Val1 - Math.Sin(theta) * len / 2));
            p2 = new cv.Point((int)(mean.Val0 + Math.Cos(theta) * len / 2), (int)(mean.Val1 + Math.Sin(theta) * len / 2));
            m2 = (p2.Y - p1.Y) / (p2.X - p1.X);
            if (Math.Abs(m2) > 1.0)
            {
                Cv2.Line(dst2, (cv.Point)p1, (cv.Point)p2, task.HighlightColor, 10, LineTypes.Link8);
            }
            else
            {
                p1 = new cv.Point((int)(mean.Val0 - Math.Cos(-theta) * len / 2), (int)(mean.Val1 - Math.Sin(-theta) * len / 2));
                p2 = new cv.Point((int)(mean.Val0 + Math.Cos(-theta) * len / 2), (int)(mean.Val1 + Math.Sin(-theta) * len / 2));
                m2 = (p2.Y - p1.Y) / (p2.X - p1.X);
                Cv2.Line(dst2, (cv.Point)p1, (cv.Point)p2, Scalar.Yellow, 10, LineTypes.Link8);
            }
            p1 = new cv.Point(0, noisyLine.bb);
            p2 = new cv.Point(width, noisyLine.m * width + noisyLine.bb);
            Cv2.Line(dst2, p1, p2, Scalar.Blue, task.lineWidth + 2, LineTypes.Link8);
            SetTrueText($"Ground Truth m = {noisyLine.m:F2} eigen m = {m2:F2}    len = {(int)len}\n" +
                        $"Confidence = {eigenVal.Get<float>(0, 0) / eigenVal.Get<float>(1, 0):F1}\n" +
                        $"theta: atan2({eigenVec.Get<float>(1, 0):F1}, {eigenVec.Get<float>(0, 0):F1}) = {theta:F4}");
        }
    }


    public class CS_EMax_Basics : CS_Parent
    {
        public EMax_InputClusters emaxInput = new EMax_InputClusters();
        public List<int> eLabels = new List<int>();
        public List<Point2f> eSamples = new List<Point2f>();
        public int dimension = 2;
        public int regionCount;
        public List<Point2f> centers = new List<Point2f>();
        Options_Emax options = new Options_Emax();
        bool useInputClusters;
        Palette_Variable palette = new Palette_Variable();
        public CS_EMax_Basics(VBtask task) : base(task)
        {
            cPtr = EMax_Open();
            FindSlider("EMax Number of Samples per region").Value = 1;
            labels[3] = "Emax regions as integers";
            UpdateAdvice(traceName + ": use local options to control EMax.");
            desc = "Use EMax - Expectation Maximization - to classify the regions around a series of labeled points";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (eLabels.Count == 0 || useInputClusters)
            {
                useInputClusters = true;
                emaxInput.Run(empty);
                eLabels = new List<int>(emaxInput.eLabels);
                eSamples = new List<Point2f>(emaxInput.eSamples);
                regionCount = emaxInput.regionCount;
            }
            if (centers.Count == 0) centers = new List<Point2f>(emaxInput.centers);
            labels[2] = $"{eLabels.Count} samples provided in {regionCount} regions";
            GCHandle handleSrc = GCHandle.Alloc(eSamples.ToArray(), GCHandleType.Pinned);
            GCHandle handleLabels = GCHandle.Alloc(eLabels.ToArray(), GCHandleType.Pinned);
            IntPtr imagePtr = EMax_Run(cPtr, handleSrc.AddrOfPinnedObject(), handleLabels.AddrOfPinnedObject(), eLabels.Count, dimension,
                                       dst2.Rows, dst2.Cols, regionCount, options.predictionStepSize, (int)options.covarianceType);
            handleLabels.Free();
            handleSrc.Free();
            dst1 = new Mat(dst1.Rows, dst1.Cols, MatType.CV_32S, imagePtr).Clone();
            dst1.ConvertTo(dst0, MatType.CV_8U);
            if (options.consistentcolors)
            {
                palette.colors.Clear();
                Vec3b[] newLabels = new Vec3b[regionCount + 1];
                for (int i = 0; i < eLabels.Count; i++)
                {
                    Point2f pt = eSamples[i];
                    if (pt.X < 0 || pt.X >= dst2.Width || pt.Y < 0 || pt.Y >= dst2.Height) continue;
                    byte newLabel = dst0.Get<byte>((int)pt.Y, (int)pt.X);
                    int original = eLabels[i];
                    Vec3b c = palette.originalColorMap.Get<Vec3b>(0, original % 256);
                    if (!newLabels.Contains(c) && newLabel <= regionCount) newLabels[newLabel] = c;
                }
                palette.colors = new List<Vec3b>(newLabels);
                palette.Run(dst0);
                dst2 = palette.dst2;
            }
            else
            {
                dst0 *= 255 / regionCount;
                dst2 = ShowPalette(dst0);
            }
            centers = new List<Point2f>(emaxInput.centers);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = EMax_Close(cPtr);
        }
    }
    public class CS_EMax_Centers : CS_Parent
    {
        EMax_Basics emax = new EMax_Basics();
        public CS_EMax_Centers(VBtask task) : base(task)
        {
            labels[2] = "Centers are highlighted, Previous centers are black";
            desc = "Display the Emax centers as they move";
        }
        public void RunCS(Mat src)
        {
            emax.Run(src);
            dst2 = emax.dst2;
            List<Point2f> lastCenters = new List<Point2f>(emax.centers);
            for (int i = 0; i < emax.centers.Count; i++)
            {
                Cv2.Circle(dst2, emax.centers[i].ToPoint(), task.DotSize + 1, task.HighlightColor);
                if (i < lastCenters.Count)
                {
                    Cv2.Circle(dst2, lastCenters[i].ToPoint(), task.DotSize + 2, Scalar.Black);
                }
            }
            lastCenters = new List<Point2f>(emax.centers);
        }
    }
    public class CS_EMax_InputClusters : CS_Parent
    {
        public int regionCount;
        public int[] eLabels;
        public List<Point2f> eSamples = new List<Point2f>();
        public List<Point2f> centers = new List<Point2f>();
        Options_EmaxInputClusters options = new Options_EmaxInputClusters();
        public CS_EMax_InputClusters(VBtask task) : base(task)
        {
            labels[2] = "EMax algorithms input samples";
            desc = "Options for EMax algorithms.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.FirstPass)
            {
                task.gOptions.setGridMaximum(dst2.Width);
                task.gOptions.setGridSize((int)(dst2.Width / 3));
                task.grid.Run(dst2);
            }
            if (regionCount != task.gridList.Count) task.optionsChanged = true;
            regionCount = task.gridList.Count;
            Mat samples = new Mat(regionCount * options.samplesPerRegion, 2, MatType.CV_32F).Reshape(2, 0);
            Mat eLabelMat = new Mat(regionCount * options.samplesPerRegion, 1, MatType.CV_32S);
            for (int i = 0; i < regionCount; i++)
            {
                Rect roi = task.gridList[i];
                eLabelMat.RowRange(i * options.samplesPerRegion, (i + 1) * options.samplesPerRegion).SetTo(i);
                Mat tmp = samples.RowRange(i * options.samplesPerRegion, (i + 1) * options.samplesPerRegion);
                Cv2.Randn(tmp, new Scalar(roi.X + task.gridSize / 2, roi.Y + task.gridSize / 2),
                          Scalar.All(options.sigma));
            }
            samples = samples.Reshape(1, 0);
            dst2.SetTo(0);
            eSamples.Clear();
            centers.Clear();
            for (int i = 0; i < regionCount * options.samplesPerRegion; i++)
            {
                Point2f pt = samples.Get<Point2f>(i, 0);
                centers.Add(pt);
                eSamples.Add(new Point2f((int)pt.X, (int)pt.Y));
                int label = eLabelMat.Get<int>(i);
                Cv2.Circle(dst2, pt.ToPoint(), task.DotSize + 2, task.HighlightColor, -1);
            }
            eLabels = new int[eLabelMat.Rows];
            Marshal.Copy(eLabelMat.Data, eLabels, 0, eLabels.Length);
        }
    }
    public class CS_EMax_VB_Failing : CS_Parent
    {
        public EMax_InputClusters emaxInput = new EMax_InputClusters();
        public List<int> eLabels = new List<int>();
        public List<Point2f> eSamples = new List<Point2f>();
        public int dimension = 2;
        public int regionCount;
        public CS_EMax_VB_Failing(VBtask task) : base(task)
        {
            desc = "OpenCV expectation maximization example.";
        }
        public void RunCS(Mat src)
        {
            emaxInput.Run(empty);
            eLabels = new List<int>(emaxInput.eLabels);
            eSamples = new List<Point2f>(emaxInput.eSamples);
            regionCount = emaxInput.regionCount;
            SetTrueText("The EMax algorithm fails as a result of a bug in em_model.Predict2.  See code for details." + "\n" +
                        "The C++ version works fine (EMax_RedCloud) and the 2 are functionally identical.", new cv.Point(20, 100));
            return; // Comment this line to see the bug in the C# version of this Predict2 below. Any answers would be gratefully received.
            //EM em_model = EM.Create();
            //em_model.ClustersNumber = regionCount;
            //em_model.CovarianceMatrixType = EMTypes.CovMatSpherical;
            //em_model.TermCriteria = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 300, 1.0);
            //Mat samples = new Mat(eSamples.Count, 2, MatType.CV_32FC1, eSamples.ToArray());
            //Mat eLabelsMat = new Mat(eLabels.Count, 1, MatType.CV_32S, eLabels.ToArray());
            //em_model.TrainEM(samples, null, eLabelsMat, null);
            //Mat sample = new Mat(1, 2, MatType.CV_32FC1, 0);
            //for (int i = 0; i < dst2.Rows; i++)
            //{
            //    for (int j = 0; j < dst2.Cols; j++)
            //    {
            //        sample.Set<float>(0, 0, (float)j);
            //        sample.Set<float>(0, 1, (float)i);
            //        double response = Math.Round(em_model.Predict2(sample)[1]);
            //        Scalar c = task.vecColors[(int)response];
            //        Cv2.Circle(dst2, new cv.Point(j, i), task.DotSize, c);
            //    }
            //}
        }
    }


    public class CS_EMax_PointTracker : CS_Parent
    {
        KNN_Core knn = new KNN_Core();
        EMax_Basics emax = new EMax_Basics();
        public CS_EMax_PointTracker(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Output of EMax_RedCloud", "Emax centers tracked and smoothed." };
            desc = "Use KNN to track the EMax Centers";
        }
        public void RunCS(Mat src)
        {
            emax.Run(src);
            dst2 = emax.dst2;
            knn.queries = new List<Point2f>(emax.centers);
            knn.Run(empty);
            if (task.FirstPass)
            {
                knn.trainInput = new List<Point2f>(knn.queries);
                return;
            }
            dst3.SetTo(0);
            for (int i = 0; i < knn.queries.Count; i++)
            {
                Point2f p1 = knn.queries[i];
                Point2f p2 = knn.trainInput[knn.result[i, 0]];
                DrawCircle(dst3, p1, task.DotSize, task.HighlightColor, -1);
                DrawCircle(dst3, p2, task.DotSize, Scalar.Red, -1);
                DrawLine(dst3, p1, p2, Scalar.White, task.lineWidth);
            }
            knn.trainInput = new List<Point2f>(knn.queries);
            dst2 = dst2 | emax.emaxInput.dst2;
        }
    }
    public class CS_EMax_RandomClusters : CS_Parent
    {
        Random_Clusters clusters = new Random_Clusters();
        EMax_Basics emax = new EMax_Basics();
        public CS_EMax_RandomClusters(VBtask task) : base(task)
        {
            FindSlider("Number of points per cluster").Value = 1;
            labels = new string[] { "", "", "Random_Clusters output", "EMax layout for the random clusters supplied" };
            desc = "Build an EMax layout for random set of clusters (not a grid)";
        }
        public void RunCS(Mat src)
        {
            var regionSlider = FindSlider("Number of Clusters");
            emax.regionCount = regionSlider.Value;
            clusters.Run(empty);
            dst3 = clusters.dst2;
            emax.eLabels.Clear();
            emax.eSamples.Clear();
            for (int i = 0; i < emax.regionCount; i++)
            {
                var cList = clusters.clusters[i];
                var cLabels = clusters.clusterLabels[i];
                for (int j = 0; j < cList.Count; j++)
                {
                    emax.eSamples.Add(cList[j]);
                    emax.eLabels.Add(cLabels[j]);
                }
            }
            emax.Run(src);
            dst2 = emax.dst2;
        }
    }



    public class CS_Encode_Basics : CS_Parent
    {
        Options_Encode options = new Options_Encode();
        public CS_Encode_Basics(VBtask task) : base(task)
        {
            desc = "Error Level Analysis - to verify a jpg image has not been modified.";
            labels[2] = "absDiff with original";
            labels[3] = "Original decompressed";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.FirstPass) FindSlider("Encode Output Scaling").Value = 10;

            int[] encodeParams = { (int)options.encodeOption, options.qualityLevel };
            byte[] buf = src.ImEncode(".jpg", encodeParams);
            Mat image = new Mat(buf.Length, 1, MatType.CV_8U, buf);
            dst3 = Cv2.ImDecode(image, ImreadModes.AnyColor);
            Mat output = new Mat();
            Cv2.Absdiff(src, dst3, output);
            output.ConvertTo(dst2, MatType.CV_8UC3, options.scalingLevel);
            double compressionRatio = (double)buf.Length / (src.Rows * src.Cols * src.ElemSize());
            labels[3] = $"Original compressed to len={buf.Length} ({compressionRatio:P1})";
        }
    }
    public class CS_Encode_Scaling : CS_Parent
    {
        Options_Encode options = new Options_Encode();
        public CS_Encode_Scaling(VBtask task) : base(task)
        {
            desc = "JPEG Encoder";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.FirstPass) FindSlider("Encode Output Scaling").Value = 10;

            int[] encodeParams = { (int)options.encodeOption, options.qualityLevel };
            byte[] buf = src.ImEncode(".jpg", encodeParams);
            Mat image = new Mat(buf.Length, 1, MatType.CV_8U, buf);
            dst3 = Cv2.ImDecode(image, ImreadModes.AnyColor);
            Mat output = new Mat();
            Cv2.Absdiff(src, dst3, output);
            output.ConvertTo(dst2, MatType.CV_8UC3, options.scalingLevel);
            double compressionRatio = (double)buf.Length / (src.Rows * src.Cols * src.ElemSize());
        }
    }


    public class CS_Entropy_Basics : CS_Parent
    {
        Entropy_Rectangle entropy = new Entropy_Rectangle();
        public CS_Entropy_Basics(VBtask task) : base(task)
        {
            labels[2] = "Control entropy values with histogram bins slider";
            desc = "Compute the entropy in an image - a measure of contrast(iness)";
        }
        Rect ValidatePreserve(Rect r)
        {
            if (r.Width <= 0) r.Width = 1;
            if (r.Height <= 0) r.Height = 1;
            if (r.X < 0) r.X = 0;
            if (r.Y < 0) r.Y = 0;
            if (r.X + r.Width >= task.WorkingRes.Width) r.X = task.WorkingRes.Width - r.Width - 1;
            if (r.Y + r.Height >= task.WorkingRes.Height) r.Y = task.WorkingRes.Height - r.Height - 1;
            return r;
        }
        public void RunCS(Mat src)
        {
            int stdSize = 30;
            if (task.drawRect == new Rect())
            {
                task.drawRect = new Rect(30, 30, stdSize, stdSize); // arbitrary rectangle
            }
            if (task.mouseClickFlag)
            {
                task.drawRect = ValidatePreserve(new Rect(task.ClickPoint.X, task.ClickPoint.Y, stdSize, stdSize));
            }
            task.drawRect = ValidateRect(task.drawRect);
            if (src.Channels() == 3)
            {
                entropy.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY)[task.drawRect]);
            }
            else
            {
                entropy.Run(src[task.drawRect]);
            }
            dst2 = entropy.dst2;
            Cv2.Rectangle(dst2, task.drawRect, Scalar.White, task.lineWidth);
            if (task.heartBeat)
            {
                strOut = $"Click anywhere to measure the entropy with rect(pt.x, pt.y, {stdSize}, {stdSize})\n\n" +
                         $"Total entropy = {entropy.entropyVal.ToString(fmt1)}\n{entropy.strOut}";
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_Entropy_Highest : CS_Parent
    {
        Entropy_Rectangle entropy = new Entropy_Rectangle();
        public Rect eMaxRect;
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public CS_Entropy_Highest(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setGridSize((int)(dst2.Width / 10));
            labels[2] = "Highest entropy marked with red rectangle";
            desc = "Find the highest entropy section of the color image.";
        }
        public void RunCS(Mat src)
        {
            Mat entropyMap = new Mat(src.Size(), MatType.CV_32F);
            float[] entropyList = new float[task.gridList.Count];
            float maxEntropy = float.MinValue;
            float minEntropy = float.MaxValue;
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            for (int i = 0; i < task.gridList.Count; i++)
            {
                Rect roi = task.gridList[i];
                entropy.Run(src[roi]);
                entropyMap[roi].SetTo(entropy.entropyVal);
                if (entropy.entropyVal > maxEntropy || task.optionsChanged)
                {
                    maxEntropy = entropy.entropyVal;
                    eMaxRect = roi;
                }
                if (entropy.entropyVal < minEntropy) minEntropy = entropy.entropyVal;
                if (standaloneTest())
                {
                    cv.Point pt = new cv.Point(roi.X, roi.Y);
                    SetTrueText(entropy.entropyVal.ToString(fmt2), pt, 2);
                    SetTrueText(entropy.entropyVal.ToString(fmt2), pt, 3);
                }
            }
            dst2 = entropyMap.ConvertScaleAbs(255 / (maxEntropy - minEntropy), minEntropy);
            addw.src2 = src;
            addw.Run(dst2);
            dst2 = addw.dst2;
            if (standaloneTest())
            {
                Cv2.Rectangle(dst2, eMaxRect, new Scalar(255), task.lineWidth);
                dst3.SetTo(0);
                Cv2.Rectangle(dst3, eMaxRect, Scalar.White, task.lineWidth);
            }
            labels[2] = $"Lighter = higher entropy. Range: {minEntropy:0.0} to {maxEntropy:0.0}";
        }
    }
    public class CS_Entropy_FAST : CS_Parent
    {
        Corners_Basics fast = new Corners_Basics();
        Entropy_Highest entropy = new Entropy_Highest();
        public CS_Entropy_FAST(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Output of Corners_FAST, input to entropy calculation", "Lighter color is higher entropy, highlight shows highest" };
            desc = "Use FAST markings to add to entropy";
        }
        public void RunCS(Mat src)
        {
            fast.Run(src);
            entropy.Run(fast.dst2);
            dst2 = entropy.dst2;
            dst3 = entropy.dst2;
            Cv2.Rectangle(dst3, entropy.eMaxRect, task.HighlightColor, task.lineWidth);
        }
    }
    public class CS_Entropy_Rectangle : CS_Parent
    {
        public float entropyVal;
        public CS_Entropy_Rectangle(VBtask task) : base(task)
        {
            desc = "Calculate the entropy in the drawRect when run standalone";
        }
        public float ChannelEntropy(int total, Mat hist)
        {
            float channelEntropy = 0;
            for (int i = 0; i < hist.Rows; i++)
            {
                float hc = Math.Abs(hist.Get<float>(i));
                if (hc != 0) channelEntropy += -(hc / total) * (float)Math.Log10(hc / total);
            }
            return channelEntropy;
        }
        public void RunCS(Mat src)
        {
            int[] dimensions = new int[] { task.histogramBins };
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var mm = GetMinMax(src);
            Rangef[] ranges = new Rangef[] { new Rangef((float)mm.minVal, (float)mm.maxVal) };
            if (mm.minVal == mm.maxVal) ranges = new Rangef[] { new Rangef(0, 255) };
            if (standalone)
            {
                if (task.drawRect.Width == 0 || task.drawRect.Height == 0)
                {
                    task.drawRect = new Rect(10, 10, 50, 50); // arbitrary template to match
                }
                src = src[task.drawRect];
            }
            Mat hist = new Mat();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, null, hist, 1, dimensions, ranges);
            Mat histNormalized = hist.Normalize(0, hist.Rows, NormTypes.MinMax);
            entropyVal = ChannelEntropy((int)src.Total(), histNormalized) * 1000;
            strOut = $"Entropy X1000 {entropyVal.ToString(fmt1)}\n";
            dst2 = src;
            Cv2.Rectangle(dst2, task.drawRect, Scalar.White, task.lineWidth);
            dst3 = src;
            SetTrueText(strOut, 3);
        }
    }
    public class CS_Entropy_SubDivisions : CS_Parent
    {
        Entropy_Rectangle entropy = new Entropy_Rectangle();
        List<List<float>> entropies = new List<List<float>>();
        List<List<Rect>> eROI = new List<List<Rect>>();
        public List<Rect> roiList = new List<Rect>();
        public CS_Entropy_SubDivisions(VBtask task) : base(task)
        {
            labels[2] = "The top entropy values in each subdivision";
            for (int i = 0; i < task.subDivisionCount; i++)
            {
                entropies.Add(new List<float>()); // 4 quadrants
                eROI.Add(new List<Rect>()); // 4 quadrants
            }
            desc = "Find the highest entropy in each quadrant";
        }
        public void RunCS(Mat src)
        {
            dst2 = task.color.Clone();
            for (int i = 0; i < task.subDivisionCount; i++)
            {
                entropies[i].Clear();
                eROI[i].Clear();
            }
            dst1 = src.Channels() == 1 ? src : src.CvtColor(ColorConversionCodes.BGR2GRAY);
            int[] dimensions = new int[] { task.histogramBins };
            Rangef[] ranges = new Rangef[] { new Rangef(0, 255) };
            Mat hist = new Mat();
            for (int i = 0; i < task.gridList.Count; i++)
            {
                Rect roi = task.gridList[i];
                Cv2.CalcHist(new Mat[] { dst1[roi] }, new int[] { 0 }, null, hist, 1, dimensions, ranges);
                hist = hist.Normalize(0, hist.Rows, NormTypes.MinMax);
                float nextEntropy = entropy.channelEntropy((int)dst1[roi].Total(), hist) * 1000;
                entropies[task.subDivisions[i]].Add(nextEntropy);
                eROI[task.subDivisions[i]].Add(roi);
                if (standaloneTest()) SetTrueText(nextEntropy.ToString(fmt2), new cv.Point(roi.X, roi.Y), 3);
            }
            roiList.Clear();
            for (int i = 0; i < task.subDivisionCount; i++)
            {
                var eList = entropies[i];
                float maxEntropy = eList.Max();
                Rect roi = eROI[i][eList.IndexOf(maxEntropy)];
                roiList.Add(roi);
                Cv2.Rectangle(dst2, roi, Scalar.White);
            }
            cv.Point p1 = new cv.Point(0, dst2.Height / 3);
            cv.Point p2 = new cv.Point(dst2.Width, dst2.Height / 3);
            DrawLine(dst2, p1, p2, Scalar.White, task.lineWidth);
            p1 = new cv.Point(0, dst2.Height * 2 / 3);
            p2 = new cv.Point(dst2.Width, dst2.Height * 2 / 3);
            DrawLine(dst2, p1, p2, Scalar.White, task.lineWidth);
            p1 = new cv.Point(dst2.Width / 3, 0);
            p2 = new cv.Point(dst2.Width / 3, dst2.Height);
            DrawLine(dst2, p1, p2, Scalar.White, task.lineWidth);
            p1 = new cv.Point(dst2.Width * 2 / 3, 0);
            p2 = new cv.Point(dst2.Width * 2 / 3, dst2.Height);
            DrawLine(dst2, p1, p2, Scalar.White, task.lineWidth);
        }
    }
    public class CS_Entropy_BinaryImage : CS_Parent
    {
        Binarize_Simple binary = new Binarize_Simple();
        Entropy_Basics entropy = new Entropy_Basics();
        public CS_Entropy_BinaryImage(VBtask task) : base(task)
        {
            desc = "Measure entropy in a binary image";
        }
        public void RunCS(Mat src)
        {
            binary.Run(src);
            dst2 = binary.dst2;
            labels[2] = binary.labels[2];
            entropy.Run(dst2);
            SetTrueText(entropy.strOut, 3);
        }
    }



    public class CS_Erode_Basics : CS_Parent
    {
        public Options_Erode options = new Options_Erode();
        public CS_Erode_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": use local options to control erosion.");
            desc = "Erode the image provided.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (options.noshape || options.iterations == 0)
                dst2 = src;
            else
                dst2 = src.Erode(options.element, null, options.iterations);
            if (standaloneTest())
            {
                dst3 = task.depthRGB.Erode(options.element, null, options.iterations);
                labels[3] = "Eroded Depth " + options.iterations.ToString() + " times";
            }
            labels[2] = "Eroded BGR " + (-options.iterations).ToString() + " times";
        }
    }
    public class CS_Erode_CloudXY : CS_Parent
    {
        Erode_Basics erode = new Erode_Basics();
        Dilate_Basics dilate = new Dilate_Basics();
        Erode_Basics erodeMask = new Erode_Basics();
        public CS_Erode_CloudXY(VBtask task) : base(task)
        {
            FindSlider("Dilate Iterations").Value = 2;
            FindRadio("Erode shape: Ellipse").Checked = true;
            labels = new string[] { "", "", "Eroded point cloud X", "Erode point cloud Y" };
            desc = "Erode depth and then find edges";
        }
        public void RunCS(Mat src)
        {
            var dilateSlider = FindSlider("Dilate Iterations");
            var erodeSlider = FindSlider("Erode Iterations");
            erodeMask.Run(task.depthMask);
            dst1 = ~erodeMask.dst2;
            dilate.Run(task.pcSplit[0]);
            var mm = GetMinMax(dilate.dst2, erodeMask.dst2);
            dst2 = (dilate.dst2 - mm.minVal) / (mm.maxVal - mm.minVal);
            dst2.SetTo(0, dst1);
            erode.Run(task.pcSplit[1]);
            mm = GetMinMax(dilate.dst2, erodeMask.dst2);
            dst3 = (erode.dst2 - mm.minVal) / (mm.maxVal - mm.minVal);
            dst3.SetTo(0, dst1);
        }
    }
    public class CS_Erode_DepthSeed : CS_Parent
    {
        Erode_Basics erode = new Erode_Basics();
        Options_Erode options = new Options_Erode();
        public CS_Erode_DepthSeed(VBtask task) : base(task)
        {
            desc = "Erode depth to build a depth mask for inrange data.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Cv2.Erode(task.pcSplit[2], dst0, erode.options.element);
            dst0 = task.pcSplit[2] - dst0;
            dst3 = dst0.LessThan(options.flatDepth).ToMat();
            dst1 = task.pcSplit[2].GreaterThan(0).ToMat();
            dst1.SetTo(0, task.pcSplit[2].GreaterThan(task.MaxZmeters));
            dst3 = dst3 & dst1;
            dst2.SetTo(0);
            task.depthRGB.CopyTo(dst2, dst3);
        }
    }

    public class CS_Erode_Dilate : CS_Parent
    {
        Options_Dilate options = new Options_Dilate();
        public CS_Erode_Dilate(VBtask task) : base(task)
        {
            desc = "Erode and then dilate with MorphologyEx on the input image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Cv2.MorphologyEx(src, dst2, MorphTypes.Close, options.element);
            Cv2.MorphologyEx(dst2, dst2, MorphTypes.Open, options.element);
        }
    }




    public class CS_Etch_ASketch : CS_Parent
    {
        Keyboard_Basics keys;
        Scalar slateColor = new Scalar(122, 122, 122);
        cv.Point cursor;
        Random ms_rng = new Random();
        Options_Etch_ASketch options = new Options_Etch_ASketch();
        cv.Point lastCursor;
        cv.Point RandomCursor()
        {
            cv.Point nextCursor = new cv.Point(ms_rng.Next(0, dst2.Width), ms_rng.Next(0, dst2.Height));
            lastCursor = nextCursor;
            return nextCursor;
        }
        public CS_Etch_ASketch(VBtask task) : base(task)
        {
            keys = new Keyboard_Basics();
            cursor = RandomCursor();
            dst2.SetTo(slateColor);
            desc = "Use OpenCV to simulate the Etch-a-Sketch Toy";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            keys.Run(src);
            List<string> keyIn = new List<string>(keys.keyInput);
            if (options.demoMode)
            {
                keyIn.Clear(); // ignore any keyboard input when in Demo mode.
                string nextKey = new[] { "Down", "Up", "Left", "Right" }[ms_rng.Next(0, 4)];
                labels[2] = "CS_Etch_ASketch demo mode - moving randomly";
                for (int i = 0; i < ms_rng.Next(10, 51); i++)
                {
                    keyIn.Add(nextKey);
                }
            }
            else
            {
                labels[2] = "Use Up/Down/Left/Right keys to create image";
            }
            if (options.cleanMode)
            {
                cursor = RandomCursor();
                dst2.SetTo(slateColor);
            }
            foreach (string key in keyIn)
            {
                switch (key)
                {
                    case "Down":
                        cursor.Y += 1;
                        break;
                    case "Up":
                        cursor.Y -= 1;
                        break;
                    case "Left":
                        cursor.X -= 1;
                        break;
                    case "Right":
                        cursor.X += 1;
                        break;
                }
                cursor.X = Math.Max(0, Math.Min(cursor.X, src.Width - 1));
                cursor.Y = Math.Max(0, Math.Min(cursor.Y, src.Height - 1));
                dst2.Set<Vec3b>(cursor.Y, cursor.X, black);
            }
            if (options.demoMode)
            {
                lastCursor = cursor;
            }
        }
    }
    public class CS_Extrinsics_Basics : CS_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public CS_Extrinsics_Basics(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.SetDotSize(5);
            desc = "MatchShapes: Show the alignment of the BGR image to the left and right camera images.";
        }
        public void RunCS(Mat src)
        {
            dst2 = task.leftView;
            dst3 = task.rightView;
            Mat gray = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (task.drawRect.Width > 0)
            {
                dst2.Rectangle(task.drawRect, Scalar.White, task.lineWidth, task.lineType);
                addw.src2 = dst2[task.drawRect].Resize(dst2.Size());
                addw.Run(gray);
                dst1 = addw.dst2;
            }
            cv.Point pt = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            if (standaloneTest())
            {
                DrawCircle(dst2, pt, task.DotSize, Scalar.White);
                DrawCircle(dst3, pt, task.DotSize, Scalar.White);
                DrawCircle(dst2, pt, task.DotSize - 2, Scalar.Black);
                DrawCircle(dst3, pt, task.DotSize - 2, Scalar.Black);
                DrawCircle(task.color, pt, task.DotSize, Scalar.White);
            }
        }
    }
    public class CS_Extrinsics_Display : CS_Parent
    {
        Options_Extrinsics options = new Options_Extrinsics();
        Options_Translation optTrans = new Options_Translation();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public CS_Extrinsics_Display(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Left Image", "Right Image" };
            desc = "MatchShapes: Build overlays for the left and right images on the BGR image";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            optTrans.RunVB();
            Rect rectLeft = new Rect(options.leftCorner - optTrans.leftTrans, options.topCorner, dst2.Width - 2 * options.leftCorner, dst2.Height - 2 * options.topCorner);
            Rect rectRight = new Rect(options.rightCorner - optTrans.rightTrans, options.topCorner, dst2.Width - 2 * options.rightCorner, dst2.Height - 2 * options.topCorner);
            addw.src2 = task.leftView[rectLeft].Resize(dst2.Size());
            addw.Run(src);
            dst2 = addw.dst2.Clone();
            addw.src2 = task.rightView[rectRight].Resize(dst2.Size());
            addw.Run(src);
            dst3 = addw.dst2.Clone();
        }
    }


    public class CS_Face_Haar_LBP : CS_Parent
    {
        CascadeClassifier haarCascade;
        CascadeClassifier lbpCascade;
        public CS_Face_Haar_LBP(VBtask task) : base(task)
        {
            haarCascade = new CascadeClassifier(task.HomeDir + "Data/haarcascade_frontalface_default.xml");
            lbpCascade = new CascadeClassifier(task.HomeDir + "Data/lbpcascade_frontalface.xml");
            desc = "Detect faces in the video stream.";
            labels[2] = "Faces detected with Haar";
            labels[3] = "Faces detected with LBP";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            DetectFace(ref dst2, haarCascade);
            dst3 = src.Clone();
            DetectFace(ref dst3, lbpCascade);
        }
    }
    public class CS_Face_Haar_Alt : CS_Parent
    {
        CascadeClassifier haarCascade;
        public CS_Face_Haar_Alt(VBtask task) : base(task)
        {
            haarCascade = new CascadeClassifier(task.HomeDir + "Data/haarcascade_frontalface_alt.xml");
            desc = "Detect faces Haar_alt database.";
            labels[2] = "Faces detected with Haar_Alt";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            DetectFace(ref dst2, haarCascade);
        }
    }


    public class CS_Feature_Basics : CS_Parent
    {
        List<Mat> matList = new List<Mat>();
        List<Point2f> ptList = new List<Point2f>();
        KNN_Core knn = new KNN_Core();
        List<Point2f> ptLost = new List<Point2f>();
        Feature_Gather gather = new Feature_Gather();
        List<Mat> featureMat = new List<Mat>();
        public Options_Features options = new Options_Features();
        public CS_Feature_Basics(VBtask task) : base(task)
        {
            task.features.Clear(); // in case it was previously in use...
            desc = "Identify features with GoodFeaturesToTrack but manage them with MatchTemplate";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src.Clone();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            gather.Run(src);
            if (task.optionsChanged)
            {
                task.features.Clear();
                featureMat.Clear();
            }
            matList.Clear();
            ptList.Clear();
            Mat correlationMat = new Mat();
            for (int i = 0; i < Math.Min(featureMat.Count, task.features.Count); i++)
            {
                Point2f pt = task.features[i];
                Rect rect = ValidateRect(new Rect((int)(pt.X - options.templatePad), (int)(pt.Y - options.templatePad), featureMat[i].Width, featureMat[i].Height));
                if (!gather.ptList.Contains(new cv.Point((int)pt.X, (int)pt.Y)))
                {
                    Cv2.MatchTemplate(src.SubMat(rect), featureMat[i], correlationMat, TemplateMatchModes.CCoeffNormed);
                    if (correlationMat.Get<float>(0, 0) < options.correlationMin)
                    {
                        Point2f ptNew = new Point2f((int)pt.X, (int)pt.Y);
                        if (!ptLost.Contains(ptNew)) ptLost.Add(ptNew);
                        continue;
                    }
                }
                matList.Add(featureMat[i]);
                ptList.Add(pt);
            }
            featureMat = new List<Mat>(matList);
            task.features = new List<Point2f>(ptList);
            float extra = 1 + (1 - options.resyncThreshold);
            task.featureMotion = true;
            if (task.features.Count < gather.features.Count * options.resyncThreshold || task.features.Count > extra * gather.features.Count)
            {
                ptLost.Clear();
                featureMat.Clear();
                task.features.Clear();
                foreach (Point2f pt in gather.features)
                {
                    Rect rect = ValidateRect(new Rect((int)(pt.X - options.templatePad), (int)(pt.Y - options.templatePad), options.templateSize, options.templateSize));
                    featureMat.Add(src.SubMat(rect));
                    task.features.Add(pt);
                }
            }
            else
            {
                if (ptLost.Count > 0)
                {
                    knn.queries = ptLost;
                    knn.trainInput = gather.features;
                    knn.Run(null);
                    for (int i = 0; i < knn.queries.Count; i++)
                    {
                        Point2f pt = knn.queries[i];
                        Rect rect = ValidateRect(new Rect((int)(pt.X - options.templatePad), (int)(pt.Y - options.templatePad), options.templateSize, options.templateSize));
                        featureMat.Add(src.SubMat(rect));
                        task.features.Add(knn.trainInput[knn.result[i, 0]]);
                    }
                }
                else
                {
                    task.featureMotion = false;
                }
            }
            task.featurePoints.Clear();
            foreach (Point2f pt in task.features)
            {
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
                task.featurePoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            if (task.heartBeat)
            {
                labels[2] = $"{task.features.Count}/{matList.Count} features were matched to the previous frame using correlation and {ptLost.Count} features had to be relocated.";
            }
        }
    }
    public class CS_Feature_BasicsNoFrills : CS_Parent
    {
        public Options_Features options = new Options_Features();
        Feature_Gather gather = new Feature_Gather();
        public CS_Feature_BasicsNoFrills(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": Use 'Options_Features' to control output.");
            desc = "Find good features to track in a BGR image without using correlation coefficients which produce more consistent results.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src.Clone();
            gather.Run(src);
            task.features.Clear();
            task.featurePoints.Clear();
            foreach (Point2f pt in gather.features)
            {
                task.features.Add(pt);
                task.featurePoints.Add(new cv.Point((int)pt.X, (int)pt.X));
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
            }
            labels[2] = gather.labels[2];
        }
    }
    public class CS_Feature_KNN : CS_Parent
    {
        KNN_Core knn = new KNN_Core();
        public List<Point2f> featurePoints = new List<Point2f>();
        public Feature_Basics feat = new Feature_Basics();
        public CS_Feature_KNN(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "Find good features to track in a BGR image but use the same point if closer than a threshold";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            knn.queries = new List<Point2f>(task.features);
            if (task.FirstPass) knn.trainInput = new List<Point2f>(knn.queries);
            knn.Run(null);
            for (int i = 0; i < knn.neighbors.Count; i++)
            {
                int trainIndex = knn.neighbors[i][0]; // index of the matched train input
                Point2f pt = knn.trainInput[trainIndex];
                Point2f qPt = task.features[i];
                if (pt.DistanceTo(qPt) > feat.options.minDistance) knn.trainInput[trainIndex] = task.features[i];
            }
            featurePoints = new List<Point2f>(knn.trainInput);
            src.CopyTo(dst2);
            dst3.SetTo(0);
            foreach (Point2f pt in featurePoints)
            {
                DrawCircle(dst2, pt, task.DotSize + 2, Scalar.White);
                DrawCircle(dst3, pt, task.DotSize + 2, Scalar.White);
            }
            labels[2] = feat.labels[2];
            labels[3] = feat.labels[2];
        }
    }
    public class CS_Feature_Reduction : CS_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Feature_Basics feat = new Feature_Basics();
        public CS_Feature_Reduction(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Good features", "History of good features" };
            desc = "Get the features in a reduction grayscale image.";
        }
        public void RunCS(Mat src)
        {
            reduction.Run(src);
            dst2 = src;
            feat.Run(reduction.dst2);
            if (task.heartBeat) dst3.SetTo(0);
            foreach (Point2f pt in task.features)
            {
                DrawCircle(dst2, pt, task.DotSize, Scalar.White);
                DrawCircle(dst3, pt, task.DotSize, Scalar.White);
            }
        }
    }
    public class CS_Feature_MultiPass : CS_Parent
    {
        Feature_Basics feat = new Feature_Basics();
        public List<Point2f> featurePoints = new List<Point2f>();
        PhotoShop_SharpenDetail sharpen = new PhotoShop_SharpenDetail();
        public CS_Feature_MultiPass(VBtask task) : base(task)
        {
            task.gOptions.setRGBFilterActive(true);
            task.gOptions.setRGBFilterSelection("Filter_Laplacian");
            desc = "Run Feature_Basics twice and compare results.";
        }
        public void RunCS(Mat src)
        {
            feat.Run(task.color);
            dst2 = src.Clone();
            featurePoints = new List<Point2f>(task.features);
            string passCounts = $"{featurePoints.Count}/";
            feat.Run(src);
            foreach (var pt in task.features)
            {
                featurePoints.Add(pt);
            }
            passCounts += $"{task.features.Count}/";
            sharpen.Run(task.color);
            feat.Run(sharpen.dst2);
            foreach (var pt in task.features)
            {
                featurePoints.Add(pt);
            }
            passCounts += $"{task.features.Count}";
            foreach (var pt in featurePoints)
            {
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
            }
            if (task.heartBeat)
            {
                labels[2] = $"Total features = {featurePoints.Count}, pass counts = {passCounts}";
            }
        }
    }
    public class CS_Feature_PointTracker : CS_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        public Feature_Basics feat = new Feature_Basics();
        Match_Points mPoints = new Match_Points();
        Options_Features options = new Options_Features();
        public CS_Feature_PointTracker(VBtask task) : base(task)
        {
            flow.parentData = this;
            flow.dst = RESULT_DST3;
            labels[3] = "Correlation coefficients for each remaining cell";
            desc = "Use the top X goodFeatures and then use matchTemplate to find track them.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            double correlationMin = options.correlationMin;
            int templatePad = options.templatePad;
            int templateSize = options.templateSize;
            strOut = "";
            if (mPoints.ptx.Count <= 3)
            {
                mPoints.ptx.Clear();
                feat.Run(src);
                foreach (var pt in task.features)
                {
                    mPoints.ptx.Add(pt);
                    Rect rect = ValidateRect(new Rect((int)(pt.X - templatePad), (int)(pt.Y - templatePad), templateSize, templateSize));
                }
                strOut = "Restart tracking -----------------------------------------------------------------------------\n";
            }
            mPoints.Run(src);
            dst2 = src.Clone();
            for (int i = mPoints.ptx.Count - 1; i >= 0; i--)
            {
                if (mPoints.correlation[i] > correlationMin)
                {
                    DrawCircle(dst2, mPoints.ptx[i], task.DotSize, task.HighlightColor);
                    strOut += $"{mPoints.correlation[i]:F3}, ";
                }
                else
                {
                    mPoints.ptx.RemoveAt(i);
                }
            }
            if (standaloneTest())
            {
                flow.nextMsg = strOut;
                flow.Run(empty);
            }
            labels[2] = $"Of the {task.features.Count} input points, {mPoints.ptx.Count} points were tracked with correlation above {correlationMin:F2}";
        }
    }
    public class CS_Feature_Delaunay : CS_Parent
    {
        Delaunay_Contours facet = new Delaunay_Contours();
        Feature_Basics feat = new Feature_Basics();
        public CS_Feature_Delaunay(VBtask task) : base(task)
        {
            FindSlider("Min Distance to next").Value = 10;
            desc = "Divide the image into contours with Delaunay using features";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
            facet.inputPoints.Clear();
            foreach (var pt in task.features)
            {
                facet.inputPoints.Add(pt);
            }
            facet.Run(src);
            dst3 = facet.dst2;
            foreach (var pt in task.features)
            {
                DrawCircle(dst3, pt, task.DotSize, Scalar.White);
            }
            labels[3] = $"There were {task.features.Count} Delaunay contours";
        }
    }
    public class CS_Feature_LucasKanade : CS_Parent
    {
        FeatureFlow_LucasKanade pyr = new FeatureFlow_LucasKanade();
        public List<cv.Point> ptList = new List<cv.Point>();
        public List<cv.Point> ptLast = new List<cv.Point>();
        List<List<cv.Point>> ptHist = new List<List<cv.Point>>();
        public CS_Feature_LucasKanade(VBtask task) : base(task)
        {
            desc = "Provide a trace of the tracked features";
        }
        public void RunCS(Mat src)
        {
            pyr.Run(src);
            dst2 = src;
            labels[2] = pyr.labels[2];
            if (task.heartBeat) dst3.SetTo(0);
            ptList.Clear();
            int stationary = 0, motion = 0;
            for (int i = 0; i < pyr.features.Count; i++)
            {
                cv.Point pt = new cv.Point((int)pyr.features[i].X, (int)pyr.features[i].Y);
                ptList.Add(pt);
                if (ptLast.Contains(pt))
                {
                    Cv2.Circle(dst3, pt, task.DotSize, task.HighlightColor);
                    stationary++;
                }
                else
                {
                    DrawLine(dst3, pyr.lastFeatures[i], pyr.features[i], Scalar.White, task.lineWidth);
                    motion++;
                }
            }
            if (task.heartBeat) labels[3] = $"{stationary} features were stationary and {motion} features had some motion.";
            ptLast = new List<cv.Point>(ptList);
        }
    }
    public class CS_Feature_NearestCell : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        FeatureLeftRight_Basics feat = new FeatureLeftRight_Basics();
        KNN_Core knn = new KNN_Core();
        public CS_Feature_NearestCell(VBtask task) : base(task)
        {
            desc = "Find the nearest feature to every cell in task.redCells";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            redC.Run(src);
            dst2 = redC.dst2;
            dst3 = redC.dst2.Clone();
            labels[2] = redC.labels[2];
            knn.queries.Clear();
            foreach (var rc in task.redCells)
            {
                knn.queries.Add(rc.maxDStable);
            }
            knn.trainInput.Clear();
            foreach (var mp in feat.mpList)
            {
                knn.trainInput.Add(new Point2f(mp.p1.X, mp.p1.Y));
            }
            knn.Run(null);
            for (int i = 0; i < task.redCells.Count; i++)
            {
                var rc = task.redCells[i];
                rc.nearestFeature = knn.trainInput[knn.result[i, 0]];
                DrawLine(dst3, rc.nearestFeature, rc.maxDStable, task.HighlightColor, task.lineWidth);
            }
        }
    }
    public class CS_Feature_Points : CS_Parent
    {
        public Feature_Basics feat = new Feature_Basics();
        public CS_Feature_Points(VBtask task) : base(task)
        {
            labels[3] = "Features found in the image";
            desc = "Use the sorted list of Delaunay regions to find the top X points to track.";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            if (task.heartBeat) dst3.SetTo(0);
            foreach (var pt in task.features)
            {
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
                DrawCircle(dst3, pt, task.DotSize, task.HighlightColor);
            }
            labels[2] = $"{task.features.Count} targets were present with {feat.options.featurePoints} requested.";
        }
    }
    public class CS_Feature_Trace : CS_Parent
    {
        RedTrack_Features track = new RedTrack_Features();
        public CS_Feature_Trace(VBtask task) : base(task)
        {
            desc = "Placeholder to help find RedTrack_Features";
        }
        public void RunCS(Mat src)
        {
            track.Run(src);
            dst2 = track.dst2;
            labels = track.labels;
        }
    }
    public class CS_Feature_TraceDelaunay : CS_Parent
    {
        Feature_Delaunay features = new Feature_Delaunay();
        public List<List<Point2f>> goodList = new List<List<Point2f>>(); // stable points only
        public CS_Feature_TraceDelaunay(VBtask task) : base(task)
        {
            labels = new string[] { "Stable points highlighted", "", "", "Delaunay map of regions defined by the feature points" };
            desc = "Trace the GoodFeatures points using only Delaunay - no KNN or RedCloud or Matching.";
        }
        public void RunCS(Mat src)
        {
            features.Run(src);
            dst3 = features.dst2;
            if (task.optionsChanged)
                goodList.Clear();
            List<Point2f> ptList = new List<Point2f>(task.features);
            goodList.Add(ptList);
            if (goodList.Count >= task.frameHistoryCount)
                goodList.RemoveAt(0);
            dst2.SetTo(0);
            foreach (var pt_List in goodList)
            {
                foreach (var pt in pt_List)
                {
                    DrawCircle(task.color, pt, task.DotSize, task.HighlightColor);
                    Vec3b c = dst3.Get<Vec3b>((int)pt.Y, (int)pt.X);
                    DrawCircle(dst2, pt, task.DotSize + 1, vecToScalar(c));
                }
            }
            labels[2] = $"{task.features.Count} features were identified in the image.";
        }
    }
    public class CS_Feature_ShiTomasi : CS_Parent
    {
        Corners_HarrisDetector harris = new Corners_HarrisDetector();
        Corners_ShiTomasi_CPP shiTomasi = new Corners_ShiTomasi_CPP();
        Options_ShiTomasi options = new Options_ShiTomasi();
        public CS_Feature_ShiTomasi(VBtask task) : base(task)
        {
            FindSlider("Corner normalize threshold").Value = 15;
            labels = new string[] { "", "", "Features in the left camera image", "Features in the right camera image" };
            desc = "Identify feature points in the left and right views";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (options.useShiTomasi)
            {
                dst2 = task.leftView;
                dst3 = task.rightView;
                shiTomasi.Run(task.leftView);
                dst2.SetTo(Scalar.White, shiTomasi.dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
                shiTomasi.Run(task.rightView);
                dst3.SetTo(task.HighlightColor, shiTomasi.dst3.CvtColor(ColorConversionCodes.BGR2GRAY));
            }
            else
            {
                harris.Run(task.leftView);
                dst2 = harris.dst2.Clone();
                harris.Run(task.rightView);
                dst3 = harris.dst2;
            }
        }
    }
    public class CS_Feature_Generations : CS_Parent
    {
        Feature_Basics feat = new Feature_Basics();
        List<cv.Point> features = new List<cv.Point>();
        List<int> gens = new List<int>();
        public CS_Feature_Generations(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": Local options will determine how many features are present.");
            desc = "Find feature age maximum and average.";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            SortedList<int, cv.Point> newfeatures = new SortedList<int, cv.Point>(new compareAllowIdenticalIntegerInverted());
            foreach (var pt in task.featurePoints)
            {
                int index = features.IndexOf(pt);
                if (index >= 0)
                    newfeatures.Add(gens[index] + 1, pt);
                else
                    newfeatures.Add(1, pt);
            }
            if (task.heartBeat)
            {
                features.Clear();
                gens.Clear();
            }
            features = new List<cv.Point>(newfeatures.Values);
            gens = new List<int>(newfeatures.Keys);
            dst2 = src;
            for (int i = 0; i < features.Count; i++)
            {
                if (gens[i] == 1)
                    break;
                cv.Point pt = features[i];
                DrawCircle(dst2, pt, task.DotSize, Scalar.White);
            }
            if (task.heartBeat)
            {
                labels[2] = $"{features.Count} features found with max/average {gens[0]}/{gens.Average():F2} generations";
            }
        }
    }
    public class CS_Feature_History : CS_Parent
    {
        public List<cv.Point> features = new List<cv.Point>();
        public Feature_Basics feat = new Feature_Basics();
        List<List<cv.Point>> featureHistory = new List<List<cv.Point>>();
        List<int> gens = new List<int>();
        public CS_Feature_History(VBtask task) : base(task)
        {
            desc = "Find good features across multiple frames.";
        }
        public void RunCS(Mat src)
        {
            int histCount = task.frameHistoryCount;
            feat.Run(src);
            dst2 = src.Clone();
            featureHistory.Add(new List<cv.Point>(task.featurePoints));
            List<cv.Point> newFeatures = new List<cv.Point>();
            gens.Clear();
            foreach (var cList in featureHistory)
            {
                foreach (var pt in cList)
                {
                    int index = newFeatures.IndexOf(pt);
                    if (index >= 0)
                    {
                        gens[index]++;
                    }
                    else
                    {
                        newFeatures.Add(pt);
                        gens.Add(1);
                    }
                }
            }
            int threshold = histCount == 1 ? 0 : 1;
            features.Clear();
            int whiteCount = 0;
            for (int i = 0; i < newFeatures.Count; i++)
            {
                if (gens[i] > threshold)
                {
                    cv.Point pt = newFeatures[i];
                    features.Add(pt);
                    if (gens[i] < histCount)
                    {
                        DrawCircle(dst2, pt, task.DotSize + 2, Scalar.Red);
                    }
                    else
                    {
                        whiteCount++;
                        DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
                    }
                }
            }
            if (featureHistory.Count > histCount)
                featureHistory.RemoveAt(0);
            if (task.heartBeat)
            {
                labels[2] = $"{features.Count}/{whiteCount} present/present on every frame" +
                            $" Red is a recent addition, yellow is present on previous {histCount} frames";
            }
        }
    }
    public class CS_Feature_GridPopulation : CS_Parent
    {
        Feature_Basics feat = new Feature_Basics();
        public CS_Feature_GridPopulation(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            labels[3] = "Click 'Show grid mask overlay' to see grid boundaries.";
            desc = "Find the feature population for each cell.";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
            dst3.SetTo(0);
            foreach (var pt in task.featurePoints)
            {
                dst3.Set<byte>((int)pt.Y, (int)pt.X, 255);
            }
            foreach (var roi in task.gridList)
            {
                Mat test = dst3.SubMat(roi).FindNonZero();
                SetTrueText(test.Rows.ToString(), roi.TopLeft, 3);
            }
        }
    }
    public class CS_Feature_Compare : CS_Parent
    {
        Feature_Basics feat = new Feature_Basics();
        Feature_BasicsNoFrills noFrill = new Feature_BasicsNoFrills();
        List<Point2f> saveLFeatures = new List<Point2f>();
        List<Point2f> saveRFeatures = new List<Point2f>();
        public CS_Feature_Compare(VBtask task) : base(task)
        {
            desc = "Prepare features for the left and right views";
        }
        public void RunCS(Mat src)
        {
            task.features = new List<Point2f>(saveLFeatures);
            feat.Run(src.Clone());
            dst2 = feat.dst2;
            labels[2] = feat.labels[2];
            saveLFeatures = new List<Point2f>(task.features);
            task.features = new List<Point2f>(saveRFeatures);
            noFrill.Run(src.Clone());
            dst3 = noFrill.dst2;
            labels[3] = "With no correlation coefficients " + noFrill.labels[2];
            saveRFeatures = new List<Point2f>(task.features);
        }
    }
    public class CS_Feature_Gather : CS_Parent
    {
        Corners_HarrisDetector harris = new Corners_HarrisDetector();
        Corners_Basics FAST = new Corners_Basics();
        Options_FeatureGather myOptions = new Options_FeatureGather();
        public List<Point2f> features = new List<Point2f>();
        public List<cv.Point> ptList = new List<cv.Point>();
        BRISK_Basics brisk = new BRISK_Basics();
        public Options_Features options = new Options_Features();
        public CS_Feature_Gather(VBtask task) : base(task)
        {
            FindSlider("Feature Sample Size").Value = 400;
            cPtr = Agast_Open();
            desc = "Gather features from a list of sources - GoodFeatures, Agast, Brisk.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            myOptions.RunVB();

            if (src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            switch (myOptions.featureSource)
            {
                case FeatureSrc.goodFeaturesFull:
                    features = new List<Point2f>(Cv2.GoodFeaturesToTrack(src, options.featurePoints, options.quality, options.minDistance, null,
                                                          options.blockSize, true, options.k));
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case FeatureSrc.goodFeaturesGrid:
                    options.featurePoints = 4;
                    features.Clear();
                    for (int i = 0; i < task.gridList.Count; i++)
                    {
                        var roi = task.gridList[i];
                        var tmpFeatures = new List<Point2f>(Cv2.GoodFeaturesToTrack(src.SubMat(roi), options.featurePoints, options.quality, options.minDistance, null,
                                                                     options.blockSize, true, options.k));
                        for (int j = 0; j < tmpFeatures.Count; j++)
                        {
                            features.Add(new Point2f(tmpFeatures[j].X + roi.X, tmpFeatures[j].Y + roi.Y));
                        }
                    }
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case FeatureSrc.Agast:
                    src = task.color.Clone();
                    byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
                    Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
                    GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
                    IntPtr imagePtr = Agast_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.agastThreshold);
                    handleSrc.Free();
                    Mat ptMat = new Mat(Agast_Count(cPtr), 1, MatType.CV_32FC2, imagePtr).Clone();
                    features.Clear();
                    if (standaloneTest())
                        dst2 = src;
                    for (int i = 0; i < ptMat.Rows; i++)
                    {
                        Point2f pt = ptMat.Get<Point2f>(i, 0);
                        features.Add(pt);
                        if (standaloneTest())
                            DrawCircle(dst2, pt, task.DotSize, Scalar.White);
                    }
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case FeatureSrc.BRISK:
                    brisk.Run(src);
                    features = brisk.features;
                    labels[2] = $"GoodFeatures produced {features.Count} features";
                    break;
                case FeatureSrc.Harris:
                    harris.Run(src);
                    features = harris.features;
                    labels[2] = $"Harris Detector produced {features.Count} features";
                    break;
                case FeatureSrc.FAST:
                    FAST.Run(src);
                    features = FAST.features;
                    labels[2] = $"FAST produced {features.Count} features";
                    break;
            }
            ptList.Clear();
            foreach (var pt in features)
            {
                ptList.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            if (standaloneTest())
            {
                dst2 = task.color.Clone();
                foreach (var pt in features)
                {
                    DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
                }
            }
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Agast_Close(cPtr);
        }
    }


    public class CS_FeatureFlow_Basics : CS_Parent
    {
        public Feature_Basics feat = new Feature_Basics();
        public List<PointPair> mpList = new List<PointPair>();
        public List<float> mpCorrelation = new List<float>();
        public CS_FeatureFlow_Basics(VBtask task) : base(task)
        {
            task.gOptions.setMaxDepth(20);
            if (standalone) task.gOptions.setDisplay1();
            labels[1] = "NOTE: matching right point is always to the left of the left point";
            desc = "Identify which feature in the left image corresponds to the feature in the right image.";
        }
        public void buildCorrelations(List<cv.Point> prevFeatures, List<cv.Point> currFeatures)
        {
            float correlationMin = feat.options.correlationMin;
            Mat correlationmat = new Mat();
            mpList.Clear();
            mpCorrelation.Clear();
            int pad = feat.options.templatePad, size = feat.options.templateSize;
            foreach (cv.Point p1 in prevFeatures)
            {
                Rect rect = ValidateRect(new Rect(p1.X - pad, p1.Y - pad, size, size));
                List<float> correlations = new List<float>();
                foreach (cv.Point p2 in currFeatures)
                {
                    Rect r = ValidateRect(new Rect(p2.X - pad, p2.Y - pad, Math.Min(rect.Width, size), Math.Min(size, rect.Height)));
                    Cv2.MatchTemplate(dst2[rect], dst3[r], correlationmat, TemplateMatchModes.CCoeffNormed);
                    correlations.Add(correlationmat.Get<float>(0, 0));
                }
                float maxCorrelation = correlations.Max();
                if (maxCorrelation >= correlationMin)
                {
                    int index = correlations.IndexOf(maxCorrelation);
                    mpList.Add(new PointPair(p1, currFeatures[index]));
                    mpCorrelation.Add(maxCorrelation);
                }
            }
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            labels = feat.labels;
            dst3 = task.FirstPass ? src.Clone() : dst2.Clone();
            List<cv.Point> prevFeatures = new List<cv.Point>(task.featurePoints);
            buildCorrelations(prevFeatures, task.featurePoints);
            SetTrueText("Click near any feature to find the corresponding pair of features.", 1);
            dst2 = src.Clone();
            foreach (cv.Point pt in task.featurePoints)
            {
                DrawCircle(dst2, pt, task.DotSize, task.HighlightColor);
            }
            prevFeatures = new List<cv.Point>(task.featurePoints);
        }
    }
    public class CS_FeatureFlow_Dense : CS_Parent
    {
        public Options_OpticalFlow options = new Options_OpticalFlow();
        public CS_FeatureFlow_Dense(VBtask task) : base(task)
        {
            desc = "Use dense optical flow algorithm";
        }
        public Mat opticalFlow_Dense(Mat oldGray, Mat gray, float pyrScale, int levels, int winSize, int iterations,
                   float polyN, float polySigma, OpticalFlowFlags OpticalFlowFlags)
        {
            Mat flow = new Mat();
            if (pyrScale >= 1) pyrScale = 0.99f;

            if (oldGray.Size() != gray.Size()) oldGray = gray.Clone();

            Cv2.CalcOpticalFlowFarneback(oldGray, gray, flow, pyrScale, levels, winSize, iterations, (int)polyN, polySigma, OpticalFlowFlags);
            Mat[] flowVec = flow.Split();

            Mat hsv = new Mat();
            Mat hsv0 = new Mat();
            Mat hsv1 = new Mat(gray.Rows, gray.Cols, MatType.CV_8UC1, new Scalar(255));
            Mat hsv2 = new Mat();

            Mat magnitude = new Mat();
            Mat angle = new Mat();
            Cv2.CartToPolar(flowVec[0], flowVec[1], magnitude, angle);
            angle.ConvertTo(hsv0, MatType.CV_8UC1, 180 / Math.PI / 2);
            Cv2.Normalize(magnitude, hsv2, 0, 255, NormTypes.MinMax, MatType.CV_8UC1);

            Mat[] hsvVec = { hsv0, hsv1, hsv2 };
            Cv2.Merge(hsvVec, hsv);
            return hsv;
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            options.RunVB();
            Mat lastGray = src.Clone();
            Mat hsv = opticalFlow_Dense(lastGray, src, options.pyrScale, options.levels, options.winSize, options.iterations, options.polyN,
                                        options.polySigma, options.OpticalFlowFlags);
            dst2 = hsv.CvtColor(ColorConversionCodes.HSV2RGB);
            dst2 = dst2.ConvertScaleAbs(options.outputScaling);
            dst3 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            lastGray = src.Clone();
        }
    }
    public class CS_FeatureFlow_LucasKanade : CS_Parent
    {
        public List<Point2f> features = new List<Point2f>();
        public List<Point2f> lastFeatures = new List<Point2f>();
        public Feature_Basics feat = new Feature_Basics();
        public Options_OpticalFlowSparse options = new Options_OpticalFlowSparse();
        public CS_FeatureFlow_LucasKanade(VBtask task) : base(task)
        {
            desc = "Show the optical flow of a sparse matrix.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src.Clone();
            dst3 = src.Clone();
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat lastGray = src.Clone();
            feat.Run(src);
            features = task.features.ToList();
            Mat features1 = new Mat(features.Count, 1, MatType.CV_32FC2, features.ToArray());
            Mat features2 = new Mat();
            Mat status = new Mat();
            Mat err = new Mat();
            cv.Size winSize = new cv.Size(3, 3);
            cv.TermCriteria term = new cv.TermCriteria((cv.CriteriaTypes)((int)cv.CriteriaTypes.Eps + (int)cv.CriteriaTypes.Count), 10, 1.0);
            Cv2.CalcOpticalFlowPyrLK(src, lastGray, features1, features2, status, err, winSize, 3, term, options.OpticalFlowFlag);
            features = new List<Point2f>();
            lastFeatures.Clear();
            for (int i = 0; i < status.Rows; i++)
            {
                if (status.Get<byte>(i, 0) != 0)
                {
                    Point2f pt1 = features1.Get<Point2f>(i, 0);
                    Point2f pt2 = features2.Get<Point2f>(i, 0);
                    float length = (float)Math.Sqrt((pt1.X - pt2.X) * (pt1.X - pt2.X) + (pt1.Y - pt2.Y) * (pt1.Y - pt2.Y));
                    if (length < 30)
                    {
                        features.Add(pt1);
                        lastFeatures.Add(pt2);
                        DrawLine(dst2, pt1, pt2, task.HighlightColor, task.lineWidth + task.lineWidth);
                        DrawCircle(dst3, pt1, task.DotSize + 3, Scalar.White, -1);
                        DrawCircle(dst3, pt2, task.DotSize + 1, Scalar.Red, -1);
                    }
                }
            }
            labels[2] = "Matched " + features.Count + " points";
            if (task.heartBeat) lastGray = src.Clone();
            lastGray = src.Clone();
        }
    }
    public class CS_FeatureFlow_LeftRight1 : CS_Parent
    {
        public FeatureFlow_LucasKanade pyrLeft = new FeatureFlow_LucasKanade();
        public FeatureFlow_LucasKanade pyrRight = new FeatureFlow_LucasKanade();
        public List<cv.Point> ptLeft = new List<cv.Point>();
        public List<cv.Point> ptRight = new List<cv.Point>();
        public List<cv.Point> ptlist = new List<cv.Point>();
        public CS_FeatureFlow_LeftRight1(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            desc = "Find features using optical flow in both the left and right images.";
        }
        public void RunCS(Mat src)
        {
            pyrLeft.Run(task.leftView);
            pyrRight.Run(task.rightView);
            List<int> leftY = new List<int>();
            ptLeft.Clear();
            dst2 = task.leftView.Clone();
            for (int i = 0; i < pyrLeft.features.Count; i++)
            {
                cv.Point pt = new cv.Point((int)pyrLeft.features[i].X, (int)pyrLeft.features[i].Y);
                ptLeft.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst2, pt, task.DotSize, task.HighlightColor, -1, task.lineType, 0);
                leftY.Add(pt.Y);
                pt = new cv.Point((int)pyrLeft.lastFeatures[i].X, (int)pyrLeft.lastFeatures[i].Y);
                ptLeft.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst2, pt, task.DotSize, task.HighlightColor, -1, task.lineType, 0);
                leftY.Add(pt.Y);
            }
            List<int> rightY = new List<int>();
            ptRight.Clear();
            dst3 = task.rightView.Clone();
            for (int i = 0; i < pyrRight.features.Count; i++)
            {
                cv.Point pt = new cv.Point((int)pyrRight.features[i].X, (int)pyrRight.features[i].Y); 
                ptRight.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst3, pt, task.DotSize, task.HighlightColor, -1, task.lineType, 0);
                rightY.Add(pt.Y);
                pt = new cv.Point((int)pyrRight.lastFeatures[i].X, (int)pyrRight.lastFeatures[i].Y); 
                ptRight.Add(new cv.Point(pt.X, pt.Y));
                Cv2.Circle(dst3, pt, task.DotSize, task.HighlightColor, -1, task.lineType, 0);
                rightY.Add(pt.Y);
            }
            List<PointPair> mpList = new List<PointPair>();
            ptlist.Clear();
            for (int i = 0; i < leftY.Count; i++)
            {
                int index = rightY.IndexOf(leftY[i]);
                if (index != -1) mpList.Add(new PointPair(ptLeft[i], ptRight[index]));
            }
            if (task.heartBeat)
            {
                labels[2] = ptLeft.Count + " features found in the left image, " + ptRight.Count + " features in the right and " +
                            ptlist.Count + " features are matched.";
            }
        }
    }
    public class CS_FeatureFlow_LeftRightHist : CS_Parent
    {
        public FeatureFlow_LucasKanade pyrLeft = new FeatureFlow_LucasKanade();
        public FeatureFlow_LucasKanade pyrRight = new FeatureFlow_LucasKanade();
        public List<cv.Point> leftFeatures = new List<cv.Point>();
        public List<cv.Point> rightFeatures = new List<cv.Point>();
        public CS_FeatureFlow_LeftRightHist(VBtask task) : base(task)
        {
            desc = "Keep only the features that have been around for the specified number of frames.";
        }
        public Mat displayFeatures(Mat dst, List<cv.Point> features)
        {
            foreach (cv.Point pt in features)
            {
                Cv2.Circle(dst, pt, task.DotSize, task.HighlightColor, -1, task.lineType, 0);
            }
            return dst;
        }
        public void RunCS(Mat src)
        {
            pyrLeft.Run(task.leftView);
            List<cv.Point> tmpLeft = new List<cv.Point>();
            for (int i = 0; i < pyrLeft.features.Count; i++)
            {
                cv.Point pt = new cv.Point(pyrLeft.features[i].X, pyrLeft.features[i].Y);
                tmpLeft.Add(new cv.Point(pt.X, pt.Y));
                pt = new cv.Point(pyrLeft.lastFeatures[i].X, pyrLeft.lastFeatures[i].Y);
                tmpLeft.Add(new cv.Point(pt.X, pt.Y));
            }
            pyrRight.Run(task.rightView);
            List<cv.Point> tmpRight = new List<cv.Point>();
            for (int i = 0; i < pyrRight.features.Count; i++)
            {
                cv.Point pt = new cv.Point(pyrRight.features[i].X, pyrRight.features[i].Y);
                tmpRight.Add(new cv.Point(pt.X, pt.Y));
                pt = new cv.Point(pyrRight.lastFeatures[i].X, pyrRight.lastFeatures[i].Y);
                tmpRight.Add(new cv.Point(pt.X, pt.Y));
            }
            List<List<cv.Point>> leftHist = new List<List<cv.Point>> { tmpLeft };
            List<List<cv.Point>> rightHist = new List<List<cv.Point>> { tmpRight };
            if (task.optionsChanged)
            {
                leftHist = new List<List<cv.Point>> { tmpLeft };
                rightHist = new List<List<cv.Point>> { tmpRight };
            }
            leftFeatures.Clear();
            foreach (cv.Point pt in tmpLeft)
            {
                int count = 0;
                foreach (List<cv.Point> hist in leftHist)
                {
                    if (hist.Contains(pt)) count++;
                    else break;
                }
                if (count == leftHist.Count) leftFeatures.Add(pt);
            }
            rightFeatures.Clear();
            foreach (cv.Point pt in tmpRight)
            {
                int count = 0;
                foreach (List<cv.Point> hist in rightHist)
                {
                    if (hist.Contains(pt)) count++;
                    else break;
                }
                if (count == rightHist.Count) rightFeatures.Add(pt);
            }
            int minPoints = 10; // just a guess - trying to keep things current.
            if (leftFeatures.Count < minPoints)
            {
                leftFeatures = tmpLeft;
                leftHist = new List<List<cv.Point>> { tmpLeft };
            }
            if (rightFeatures.Count < minPoints)
            {
                rightFeatures = tmpRight;
                rightHist = new List<List<cv.Point>> { tmpRight };
            }
            dst2 = displayFeatures(task.leftView.Clone(), leftFeatures);
            dst3 = displayFeatures(task.rightView.Clone(), rightFeatures);
            leftHist.Add(tmpLeft);
            rightHist.Add(tmpRight);
            int threshold = Math.Min(task.frameHistoryCount, leftHist.Count);
            if (leftHist.Count >= task.frameHistoryCount) leftHist.RemoveAt(0);
            if (rightHist.Count >= task.frameHistoryCount) rightHist.RemoveAt(0);
            if (task.heartBeat)
            {
                labels[2] = leftFeatures.Count + " detected in the left image that have matches in " + threshold + " previous left images";
                labels[3] = rightFeatures.Count + " detected in the right image that have matches in " + threshold + " previous right images";
            }
        }
    }
    public class CS_FeatureFlow_LeftRight : CS_Parent
    {
        CS_FeatureFlow_LeftRightHist flowHist;
        public List<List<cv.Point>> leftFeatures = new List<List<cv.Point>>();
        public List<List<cv.Point>> rightFeatures = new List<List<cv.Point>>();
        public CS_FeatureFlow_LeftRight(VBtask task) : base(task)
        {
            flowHist = new CS_FeatureFlow_LeftRightHist(task);
            desc = "Match features in the left and right images";
        }
        public Mat DisplayFeatures(Mat dst, List<List<cv.Point>> features)
        {
            foreach (var ptlist in features)
            {
                foreach (var pt in ptlist)
                {
                    Cv2.Circle(dst, pt, task.DotSize, task.HighlightColor);
                }
            }
            return dst;
        }
        public void RunCS(Mat src)
        {
            flowHist.RunAndMeasure(src, flowHist);
            var tmpLeft = new SortedList<int, List<cv.Point>>();
            var tmpRight = new SortedList<int, List<cv.Point>>();
            ProcessFeatures(flowHist.leftFeatures, tmpLeft);
            ProcessFeatures(flowHist.rightFeatures, tmpRight);
            leftFeatures.Clear();
            rightFeatures.Clear();
            foreach (var ele in tmpLeft)
            {
                int index = tmpRight.Keys.ToList().IndexOf(ele.Key);
                if (index >= 0)
                {
                    leftFeatures.Add(ele.Value);
                    rightFeatures.Add(tmpRight.ElementAt(index).Value);
                }
            }
            dst2 = DisplayFeatures(task.leftView.Clone(), leftFeatures);
            dst3 = DisplayFeatures(task.rightView.Clone(), rightFeatures);
            if (task.heartBeat)
            {
                labels[2] = $"{leftFeatures.Count} detected in the left image that match one or more Y-coordinates found in the right image";
                labels[3] = $"{rightFeatures.Count} detected in the right image that match one or more Y-coordinates found in the left image";
            }
        }
        void ProcessFeatures(List<cv.Point> features, SortedList<int, List<cv.Point>> tmp)
        {
            foreach (var pt in features)
            {
                if (tmp.ContainsKey(pt.Y))
                {
                    var index = tmp.Keys.ToList().IndexOf(pt.Y);
                    var ptlist = tmp.ElementAt(index).Value;
                    ptlist.Add(pt);
                    tmp.RemoveAt(index);
                    tmp.Add(pt.Y, ptlist);
                }
                else
                {
                    tmp.Add(pt.Y, new List<cv.Point> { pt });
                }
            }
        }
    }

    public class CS_FeatureLeftRight_Basics : CS_Parent
    {
        public FeatureLeftRight_LeftRightPrep prep = new FeatureLeftRight_LeftRightPrep();
        public List<PointPair> mpList = new List<PointPair>();
        public List<float> mpCorrelation = new List<float>();
        public cv.Point selectedPoint;
        public int mpIndex;
        public cv.Point ClickPoint;
        public int picTag;
        public Options_Features options = new Options_Features();
        public KNN_Core knn = new KNN_Core();
        public CS_FeatureLeftRight_Basics(VBtask task) : base(task)
        {
            labels[1] = "NOTE: matching right point is always to the left of the left point";
            if (standalone) task.gOptions.setDisplay1();
            FindSlider("Feature Correlation Threshold").Value = 75;
            FindSlider("Min Distance to next").Value = 1;
            task.gOptions.setMaxDepth(20); // up to 20 meters...
            labels[3] = "Click near any feature to get more details on the matched pair of points.";
            desc = "Match the left and right features and allow the user to select a point to get more details.";
        }
        public void setClickPoint(Point2f pt, int _pictag)
        {
            ClickPoint = new cv.Point((int)pt.X, (int)pt.Y);
            picTag = _pictag;
            task.drawRect = new Rect(ClickPoint.X - options.templatePad, ClickPoint.Y - options.templatePad, options.templateSize, options.templateSize);
            task.drawRectUpdated = true;
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            dst2 = task.leftView.Clone();
            dst3 = task.rightView.Clone();
            prep.Run(src);
            List<PointPair> prepList = new List<PointPair>();
            foreach (cv.Point p1 in prep.leftFeatures)
            {
                foreach (cv.Point p2 in prep.rightFeatures)
                {
                    if (p1.Y == p2.Y) prepList.Add(new PointPair(p1, p2));
                }
            }
            Mat correlationmat = new Mat();
            mpList.Clear();
            mpCorrelation.Clear();
            for (int i = 0; i < prepList.Count; i++)
            {
                PointPair mpBase = prepList[i];
                List<float> correlations = new List<float>();
                List<PointPair> tmpList = new List<PointPair>();
                for (int j = i; j < prepList.Count; j++)
                {
                    PointPair mp = prepList[j];
                    if (mp.p1.Y != mpBase.p1.Y)
                    {
                        i = j;
                        break;
                    }
                    Rect r1 = ValidateRect(new Rect((int)(mp.p1.X - options.templatePad), (int)(mp.p1.Y - options.templatePad), options.templateSize, options.templateSize));
                    Rect r2 = ValidateRect(new Rect((int)(mp.p2.X - options.templatePad), (int)(mp.p2.Y - options.templatePad), options.templateSize, options.templateSize));
                    Cv2.MatchTemplate(task.leftView[r1], task.rightView[r2], correlationmat, TemplateMatchModes.CCoeffNormed);
                    correlations.Add(correlationmat.Get<float>(0, 0));
                    tmpList.Add(mp);
                }
                float maxCorrelation = correlations.Max();
                if (maxCorrelation >= options.correlationMin)
                {
                    mpList.Add(tmpList[correlations.IndexOf(maxCorrelation)]);
                    mpCorrelation.Add(maxCorrelation);
                }
            }
            foreach (PointPair mp in mpList)
            {
                DrawCircle(dst2, mp.p1, task.DotSize, task.HighlightColor, -1);
                DrawCircle(dst3, mp.p2, task.DotSize, task.HighlightColor, -1);
            }
            if (task.mouseClickFlag) setClickPoint(task.ClickPoint, task.mousePicTag);
            SetTrueText("Click near any feature to find the corresponding pair of features." + "\n" +
                        "The correlation values in the lower left for the correlation of the left to the right views." + "\n" +
                        "The dst2 shows features for the left view, dst3 shows features for the right view.", 1);
            if (ClickPoint == new cv.Point() && mpList.Count > 0) setClickPoint(mpList[0].p1, 2);
            if (mpList.Count > 0)
            {
                knn.queries.Clear();
                knn.queries.Add(task.ClickPoint);
                PointPair mp;
                knn.trainInput.Clear();
                foreach (PointPair mpX in mpList)
                {
                    Point2f pt = (picTag == 2) ? mpX.p1 : mpX.p2;
                    knn.trainInput.Add(pt);
                }
                knn.Run(null);
                dst1.SetTo(Scalar.All(0));
                int mpIndex = knn.result[0, 0];
                mp = mpList[mpIndex];
                DrawCircle(dst2, mp.p1, task.DotSize + 4, Scalar.Red, -1);
                DrawCircle(dst3, mp.p2, task.DotSize + 4, Scalar.Red, -1);
                float dspDistance = task.pcSplit[2].Get<float>((int)mp.p1.Y, (int)mp.p1.X);
                int offset = (int)(mp.p1.X - mp.p2.X);
                string strOut = string.Format(fmt3, mpCorrelation[mpIndex]) + "\n" +
                                string.Format(fmt3, dspDistance) + "m (from camera)" + "\n" +
                                offset.ToString() + " Pixel difference";
                for (int i = 0; i < mpList.Count; i++)
                {
                    Point2f pt = mpList[i].p1;
                    SetTrueText(string.Format("{0:0%}", mpCorrelation[i]), new cv.Point((int)pt.X, (int)pt.Y));
                }
                if (task.heartBeat) dst1.SetTo(Scalar.All(0));
                DrawCircle(dst1, mp.p1, task.DotSize, task.HighlightColor, -1);
                DrawCircle(dst1, mp.p2, task.DotSize, task.HighlightColor, -1);
                selectedPoint = new cv.Point(mp.p1.X, mpList[mpIndex].p1.Y + 10);
                SetTrueText(strOut, selectedPoint, 1);
                if (task.heartBeat)
                {
                    labels[2] = mpList.Count + " features matched and confirmed with left/right image correlation coefficients";
                }
            }
            labels[2] = mpList.Count + " features were matched using correlation coefficients in the left and right images. White box is cell around click point.";
        }
    }
    public class CS_FeatureLeftRight_LeftRightPrep : CS_Parent
    {
        public Feature_Basics lFeat = new Feature_Basics();
        public Feature_Basics rFeat = new Feature_Basics();
        public List<cv.Point> leftFeatures = new List<cv.Point>();
        public List<cv.Point> rightFeatures = new List<cv.Point>();
        public List<Point2f> saveLFeatures = new List<Point2f>();
        public List<Point2f> saveRFeatures = new List<Point2f>();
        public CS_FeatureLeftRight_LeftRightPrep(VBtask task) : base(task)
        {
            desc = "Prepare features for the left and right views";
        }
        public void RunCS(Mat src)
        {
            task.features = new List<cv.Point2f> (saveLFeatures);
            lFeat.Run(task.leftView);
            dst2 = lFeat.dst2;
            labels[2] = lFeat.labels[2];
            leftFeatures = task.featurePoints.ToList();
            saveLFeatures = task.features.ToList();
            task.features = new List<cv.Point2f>(saveRFeatures);
            rFeat.Run(task.rightView);
            dst3 = rFeat.dst2;
            labels[3] = rFeat.labels[2];
            rightFeatures = task.featurePoints.ToList();
            saveRFeatures = task.features.ToList();
        }
    }
    public class CS_FeatureLeftRight_Grid : CS_Parent
    {
        public FeatureLeftRight_Basics match = new FeatureLeftRight_Basics();
        public CS_FeatureLeftRight_Grid(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            FindRadio("GoodFeatures (ShiTomasi) grid").Checked = true;
            desc = "Run FeatureLeftRight_Basics but with 'GoodFeatures grid' instead of 'GoodFeatures full image'";
        }
        public void RunCS(Mat src)
        {
            match.Run(src);
            if (match.mpList.Count() == 0) return;
            dst1 = match.dst1.Clone();
            dst2 = match.dst2.Clone();
            dst3 = match.dst3.Clone();
            if (task.FirstPass) match.setClickPoint(match.mpList[0].p1, 2);
            SetTrueText(match.strOut, match.selectedPoint, 1);
            if (task.heartBeat) labels = match.labels;
        }
    }
    public class CS_FeatureLeftRight_Input : CS_Parent
    {
        public List<cv.Point> ptLeft = new List<cv.Point>();
        public List<cv.Point> ptRight = new List<cv.Point>();
        public List<PointPair> mpList = new List<PointPair>();
        public List<float> mpCorrelation = new List<float>();
        public cv.Point selectedPoint;
        public cv.Point ClickPoint;
        public int picTag;
        public Options_Features options = new Options_Features();
        public KNN_Core knn = new KNN_Core();
        public CS_FeatureLeftRight_Input(VBtask task) : base(task)
        {
            labels[1] = "NOTE: matching right point is always to the left of the left point";
            if (standalone) task.gOptions.setDisplay1();
            FindSlider("Feature Correlation Threshold").Value = 75;
            FindSlider("Min Distance to next").Value = 1;
            task.gOptions.setMaxDepth(20); // up to 20 meters...
            labels[3] = "Click near any feature to get more details on the matched pair of points.";
            desc = "Match the left and right features and allow the user to select a point to get more details.";
        }
        public void setClickPoint(Point2f pt, int _pictag)
        {
            ClickPoint = new cv.Point(pt.X, pt.Y);
            picTag = _pictag;
            task.drawRect = new Rect(ClickPoint.X - options.templatePad, ClickPoint.Y - options.templatePad, options.templateSize, options.templateSize);
            task.drawRectUpdated = true;
        }
        public void RunCS(Mat src)
        {
            if (ptLeft.Count == 0 || ptRight.Count == 0)
            {
                SetTrueText("Caller provides the ptLeft/ptRight points to use.", 1);
                return;
            }
            options.RunVB();
            List<PointPair> prepList = new List<PointPair>();
            foreach (cv.Point p1 in ptLeft)
            {
                foreach (cv.Point p2 in ptRight)
                {
                    if (p1.Y == p2.Y) prepList.Add(new PointPair(p1, p2));
                }
            }
            Mat correlationmat = new Mat();
            mpList.Clear();
            mpCorrelation.Clear();
            for (int i = 0; i < prepList.Count; i++)
            {
                PointPair mpBase = prepList[i];
                List<float> correlations = new List<float>();
                List<PointPair> tmpList = new List<PointPair>();
                for (int j = i; j < prepList.Count; j++)
                {
                    PointPair mp = prepList[j];
                    if (mp.p1.Y != mpBase.p1.Y)
                    {
                        i = j;
                        break;
                    }
                    Rect r1 = ValidateRect(new Rect((int)(mp.p1.X - options.templatePad), (int)(mp.p1.Y - options.templatePad), options.templateSize, options.templateSize));
                    Rect r2 = ValidateRect(new Rect((int)(mp.p2.X - options.templatePad), (int)(mp.p2.Y - options.templatePad), options.templateSize, options.templateSize));
                    Cv2.MatchTemplate(task.leftView[r1], task.rightView[r2], correlationmat, TemplateMatchModes.CCoeffNormed);
                    correlations.Add(correlationmat.Get<float>(0, 0));
                    tmpList.Add(mp);
                }
                float maxCorrelation = correlations.Max();
                if (maxCorrelation >= options.correlationMin)
                {
                    mpList.Add(tmpList[correlations.IndexOf(maxCorrelation)]);
                    mpCorrelation.Add(maxCorrelation);
                }
            }
            foreach (PointPair mp in mpList)
            {
                DrawCircle(dst2, mp.p1, task.DotSize, task.HighlightColor, -1);
                DrawCircle(dst3, mp.p2, task.DotSize, task.HighlightColor, -1);
            }
            if (task.mouseClickFlag) setClickPoint(task.ClickPoint, task.mousePicTag);
            SetTrueText("Click near any feature to find the corresponding pair of features." + "\n" +
                        "The correlation values in the lower left for the correlation of the left to the right views." + "\n" +
                        "The dst2 shows features for the left view, dst3 shows features for the right view.", 1);
            if (ClickPoint == new cv.Point() && mpList.Count > 0) setClickPoint(mpList[0].p1, 2);
            if (mpList.Count > 0)
            {
                knn.queries.Clear();
                knn.queries.Add(task.ClickPoint);
                PointPair mp;
                knn.trainInput.Clear();
                foreach (PointPair  mpX in mpList)
                {
                    cv.Point2f pt = (picTag == 2) ? mpX.p1 : mpX.p2;
                    knn.trainInput.Add(new Point2f(pt.X, pt.Y));
                }
                knn.Run(null);
                dst1.SetTo(Scalar.All(0));
                int mpIndex = knn.result[0, 0];
                mp = mpList[mpIndex];
                DrawCircle(dst2, mp.p1, task.DotSize + 4, Scalar.Red, -1);
                DrawCircle(dst3, mp.p2, task.DotSize + 4, Scalar.Red, -1);
                float dspDistance = task.pcSplit[2].Get<float>((int)mp.p1.Y, (int)mp.p1.X);
                int offset = (int)(mp.p1.X - mp.p2.X);
                string strOut = string.Format(fmt3, mpCorrelation[mpIndex]) + "\n" +
                                string.Format(fmt3, dspDistance) + "m (from camera)" + "\n" +
                                offset.ToString() + " Pixel difference";
                for (int i = 0; i < mpList.Count; i++)
                {
                    Point2f pt = mpList[i].p1;
                    SetTrueText(string.Format("{0:0%}", mpCorrelation[i]), new cv.Point((int)pt.X, (int)pt.Y));
                }
                if (task.heartBeat) dst1.SetTo(Scalar.All(0));
                DrawCircle(dst1, mp.p1, task.DotSize, task.HighlightColor, -1);
                DrawCircle(dst1, mp.p2, task.DotSize, task.HighlightColor, -1);
                selectedPoint = new cv.Point(mp.p1.X, mpList[mpIndex].p1.Y + 10);
                SetTrueText(strOut, selectedPoint, 1);
                if (task.heartBeat)
                {
                    labels[2] = mpList.Count + " features matched and confirmed with left/right image correlation coefficients";
                }
            }
            labels[2] = mpList.Count + " features were matched using correlation coefficients in the left and right images. White box is cell around click point.";
        }
    }


    public class CS_FeatureLess_Basics : CS_Parent
    {
        EdgeDraw_Basics edgeD = new EdgeDraw_Basics();
        public int classCount = 2;
        public CS_FeatureLess_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "EdgeDraw_Basics output", "" };
            desc = "Access the EdgeDraw_Basics algorithm directly rather than through the CPP_Basics interface - more efficient";
        }
        public void RunCS(Mat src)
        {
            edgeD.Run(src);
            dst2 = edgeD.dst2;
            if (standaloneTest())
            {
                dst3 = src.Clone();
                dst3.SetTo(Scalar.Yellow, dst2);
            }
        }
    }
    public class CS_FeatureLess_Canny : CS_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        Options_Sobel options = new Options_Sobel();
        public CS_FeatureLess_Canny(VBtask task) : base(task)
        {
            desc = "Use Canny edges to define featureless regions.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            edges.Run(src);
            dst2 = ~edges.dst2.Threshold(options.distanceThreshold, 255, ThresholdTypes.Binary);
        }
    }
    public class CS_FeatureLess_Sobel : CS_Parent
    {
        Edge_Sobel_Old edges = new Edge_Sobel_Old();
        Options_Sobel options = new Options_Sobel();
        public CS_FeatureLess_Sobel(VBtask task) : base(task)
        {
            desc = "Use Sobel edges to define featureless regions.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            edges.Run(src);
            dst2 = ~edges.dst2.Threshold(options.distanceThreshold, 255, ThresholdTypes.Binary);
        }
    }
    public class CS_FeatureLess_UniquePixels : CS_Parent
    {
        Hough_FeatureLessTopX fless = new Hough_FeatureLessTopX();
        Sort_1Channel sort = new Sort_1Channel();
        public CS_FeatureLess_UniquePixels(VBtask task) : base(task)
        {
            if (standaloneTest())
                FindSlider("Threshold for sort input").Value = 0;
            labels = new string[] { "", "Gray scale input to sort/remove dups", "Unique pixels", "" };
            desc = "Find the unique gray pixels for the featureless regions";
        }
        public void RunCS(Mat src)
        {
            fless.Run(src);
            dst2 = fless.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            sort.Run(dst2);
            dst3 = sort.dst2;
        }
    }
    public class CS_FeatureLess_Unique3Pixels : CS_Parent
    {
        Hough_FeatureLessTopX fless = new Hough_FeatureLessTopX();
        Sort_3Channel sort3 = new Sort_3Channel();
        public CS_FeatureLess_Unique3Pixels(VBtask task) : base(task)
        {
            desc = "Find the unique 3-channel pixels for the featureless regions";
        }
        public void RunCS(Mat src)
        {
            fless.Run(src);
            dst2 = fless.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            sort3.Run(fless.dst2);
            dst3 = sort3.dst2;
        }
    }
    public class CS_FeatureLess_Histogram : CS_Parent
    {
        BackProject_FeatureLess backP = new BackProject_FeatureLess();
        public CS_FeatureLess_Histogram(VBtask task) : base(task)
        {
            desc = "Create a histogram of the featureless regions";
        }
        public void RunCS(Mat src)
        {
            backP.Run(src);
            dst2 = backP.dst2;
            dst3 = backP.dst3;
            labels = backP.labels;
        }
    }
    public class CS_FeatureLess_DCT : CS_Parent
    {
        DCT_FeatureLess dct = new DCT_FeatureLess();
        public CS_FeatureLess_DCT(VBtask task) : base(task)
        {
            labels[3] = "Largest FeatureLess Region";
            desc = "Use DCT to find featureless regions.";
        }
        public void RunCS(Mat src)
        {
            dct.Run(src);
            dst2 = dct.dst2;
            dst3 = dct.dst3;
            Mat mask = dst2.Clone();
            List<int> objectSize = new List<int>();
            int regionCount = 1;
            for (int y = 0; y < mask.Rows; y++)
            {
                for (int x = 0; x < mask.Cols; x++)
                {
                    if (mask.Get<byte>(y, x) == 255)
                    {
                        cv.Point pt = new cv.Point(x, y);
                        int floodCount = mask.FloodFill(pt, regionCount);
                        objectSize.Add(floodCount);
                        regionCount++;
                    }
                }
            }
            int maxSize = 0, maxIndex = 0;
            for (int i = 0; i < objectSize.Count; i++)
            {
                if (maxSize < objectSize[i])
                {
                    maxSize = objectSize[i];
                    maxIndex = i;
                }
            }
            Mat label = mask.InRange(maxIndex + 1, maxIndex + 1);
            int nonZ = Cv2.CountNonZero(label);
            labels[3] = $"Largest FeatureLess Region ({nonZ} {(double)nonZ / label.Total():P1} pixels)";
            dst3.SetTo(Scalar.White, label);
        }
    }
    public class CS_FeatureLess_LeftRight : CS_Parent
    {
        FeatureLess_Basics fLess = new FeatureLess_Basics();
        public CS_FeatureLess_LeftRight(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "FeatureLess Left mask", "FeatureLess Right mask" };
            desc = "Find the featureless regions of the left and right images";
        }
        public void RunCS(Mat src)
        {
            fLess.Run(task.leftView);
            dst2 = fLess.dst2.Clone();
            fLess.Run(task.rightView);
            dst3 = fLess.dst2;
        }
    }

    public class CS_FeatureLess_History : CS_Parent
    {
        FeatureLess_Basics fLess = new FeatureLess_Basics();
        History_Basics frames = new History_Basics();
        public CS_FeatureLess_History(VBtask task) : base(task)
        {
            desc = "Accumulate the edges over a span of X images.";
        }
        public void RunCS(Mat src)
        {
            fLess.Run(src);
            dst2 = fLess.dst2;
            frames.Run(dst2);
            dst3 = frames.dst2;
        }
    }
    public class CS_FeatureLess_RedCloud : CS_Parent
    {
        public RedCloud_Basics redC = new RedCloud_Basics();
        FeatureLess_Basics fless = new FeatureLess_Basics();
        public CS_FeatureLess_RedCloud(VBtask task) : base(task)
        {
            desc = "Floodfill the FeatureLess output so each cell can be tracked.";
        }
        public void RunCS(Mat src)
        {
            fless.Run(src);
            redC.Run(fless.dst2);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
        }
    }
    public class CS_FeatureLess_Groups : CS_Parent
    {
        RedCloud_CPP redCPP = new RedCloud_CPP();
        FeatureLess_Basics fless = new FeatureLess_Basics();
        public int classCount;
        public CS_FeatureLess_Groups(VBtask task) : base(task)
        {
            desc = "Group RedCloud cells by the value of their featureless maxDist";
        }
        public void RunCS(Mat src)
        {
            fless.Run(src);
            dst2 = fless.dst2;
            labels[2] = fless.labels[2];
            redCPP.Run(dst2);
            classCount = redCPP.classCount;
            dst3 = redCPP.dst2;
            labels[3] = $"{classCount} featureless regions were found.";
        }
    }


   
    public class CS_FeatureLine_Basics : CS_Parent
    {
        Line_SubsetRect lines = new Line_SubsetRect();
        Line_DisplayInfo lineDisp = new Line_DisplayInfo();
        Options_Features options = new Options_Features();
        Match_tCell match = new Match_tCell();
        public List<tCell> tcells;
        public CS_FeatureLine_Basics(VBtask task) : base(task)
        {
            tCell tc = new tCell();
            tcells = new List<tCell> { tc, tc };
            labels = new string[] { "", "", "Longest line present.", "" };
            desc = "Find and track a line using the end points";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int distanceThreshold = 50; // pixels - arbitrary but realistically needs some value
            double linePercentThreshold = 0.7; // if less than 70% of the pixels in the line are edges, then find a better line.  Again, arbitrary but realistic.
            double correlationMin = options.correlationMin;
            bool correlationTest = tcells[0].correlation <= correlationMin || tcells[1].correlation <= correlationMin;
            lineDisp.distance = (int)tcells[0].center.DistanceTo(tcells[1].center);
            if (task.optionsChanged || correlationTest || lineDisp.maskCount / lineDisp.distance < linePercentThreshold || lineDisp.distance < distanceThreshold)
            {
                int templatePad = options.templatePad;
                lines.subsetRect = new Rect(templatePad * 3, templatePad * 3, src.Width - templatePad * 6, src.Height - templatePad * 6);
                lines.Run(src.Clone());
                if (lines.mpList.Count == 0)
                {
                    SetTrueText("No lines found.", 3);
                    return;
                }
                var lp = lines.sortByLen.ElementAt(0).Value;
                tcells[0] = match.createCell(src, 0, lp.p1);
                tcells[1] = match.createCell(src, 0, lp.p2);
            }
            dst2 = src.Clone();
            for (int i = 0; i < tcells.Count; i++)
            {
                match.tCells[0] = tcells[i];
                match.Run(src);
                tcells[i] = match.tCells[0];
                SetTrueText(tcells[i].strOut, new cv.Point(tcells[i].rect.X, tcells[i].rect.Y));
                SetTrueText(tcells[i].strOut, new cv.Point(tcells[i].rect.X, tcells[i].rect.Y), 3);
            }
            lineDisp.tcells = new List<tCell>(tcells);
            lineDisp.Run(src);
            dst2 = lineDisp.dst2;
            SetTrueText(lineDisp.strOut, new cv.Point(10, 40), 3);
        }
    }
    public class CS_FeatureLine_VerticalVerify : CS_Parent
    {
        FeatureLine_VH linesVH = new FeatureLine_VH();
        public IMU_VerticalVerify verify = new IMU_VerticalVerify();
        public CS_FeatureLine_VerticalVerify(VBtask task) : base(task)
        {
            desc = "Select a line or group of lines and track the result";
        }
        public void RunCS(Mat src)
        {
            linesVH.Run(src);
            verify.gCells = new List<gravityLine>(linesVH.gCells);
            verify.Run(src);
            dst2 = verify.dst2;
        }
    }
    public class CS_FeatureLine_VH : CS_Parent
    {
        public List<gravityLine> gCells = new List<gravityLine>();
        Match_tCell match = new Match_tCell();
        Line_GCloud gLines = new Line_GCloud();
        Options_Features options = new Options_Features();
        public CS_FeatureLine_VH(VBtask task) : base(task)
        {
            labels[3] = "More readable than dst1 - index, correlation, length (meters), and ArcY";
            desc = "Find and track all the horizontal or vertical lines";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            int templatePad = options.templatePad;
            // gLines.lines.subsetRect = new Rect(templatePad * 3, templatePad * 3, src.Width - templatePad * 6, src.Height - templatePad * 6);
            gLines.Run(src);
            var vertRadio = FindRadio("Vertical lines");
            var sortedLines = vertRadio.Checked ? gLines.sortedVerticals : gLines.sortedHorizontals;
            if (sortedLines.Count == 0)
            {
                SetTrueText("There were no vertical lines found.", 3);
                return;
            }
            gCells.Clear();
            match.tCells.Clear();
            for (int i = 0; i < sortedLines.Count; i++)
            {
                var gc = sortedLines.ElementAt(i).Value;
                if (i == 0)
                {
                    dst1.SetTo(0);
                    gc.tc1.template.CopyTo(dst1[gc.tc1.rect]);
                    gc.tc2.template.CopyTo(dst1[gc.tc2.rect]);
                }
                match.tCells.Clear();
                match.tCells.Add(gc.tc1);
                match.tCells.Add(gc.tc2);
                match.Run(src);
                double correlationMin = options.correlationMin;
                if (match.tCells[0].correlation >= correlationMin && match.tCells[1].correlation >= correlationMin)
                {
                    gc.tc1 = match.tCells[0];
                    gc.tc2 = match.tCells[1];
                    cv.Point gc1 = new cv.Point(gc.tc1.center.X, gc.tc1.center.Y);
                    cv.Point gc2 = new cv.Point(gc.tc2.center.X, gc.tc2.center.Y);
                    gc = gLines.updateGLine(src, gc, gc1, gc2);
                    if (gc.len3D > 0) gCells.Add(gc);
                }
            }
            dst2 = src;
            dst3.SetTo(0);
            for (int i = 0; i < gCells.Count; i++)
            {
                var gc = gCells[i];
                Point2f p1 = gc.tc1.center, p2 = gc.tc2.center;
                SetTrueText($"{i}\n{gc.tc1.strOut}\n{gc.arcY.ToString(fmt1)}", gc.tc1.center, 2);
                SetTrueText($"{i}\n{gc.tc1.strOut}\n{gc.arcY.ToString(fmt1)}", gc.tc1.center, 3);
                DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
                DrawLine(dst3, p1, p2, task.HighlightColor, task.lineWidth);
            }
        }
    }
    public class CS_FeatureLine_Tutorial1 : CS_Parent
    {
        Line_Basics lines = new Line_Basics();
        public CS_FeatureLine_Tutorial1(VBtask task) : base(task)
        {
            labels[3] = "The highlighted lines are also lines in 3D.";
            desc = "Find all the lines in the image and determine which are in the depth data.";
        }
        public void RunCS(Mat src)
        {
            lines.Run(src);
            dst2 = lines.dst2;
            var raw2D = new List<PointPair>();
            var raw3D = new List<Point3f>();
            foreach (var lp in lines.lpList)
            {
                if (task.pcSplit[2].Get<float>((int)lp.p1.Y, (int)lp.p1.X) > 0 && task.pcSplit[2].Get<float>((int)lp.p2.Y, (int)lp.p2.X) > 0)
                {
                    raw2D.Add(lp);
                    raw3D.Add(task.pointCloud.Get<Point3f>((int)lp.p1.Y, (int)lp.p1.X));
                    raw3D.Add(task.pointCloud.Get<Point3f>((int)lp.p2.Y, (int)lp.p2.X));
                }
            }
            dst3 = src.Clone();
            for (int i = 0; i < raw2D.Count - 1; i += 2)
            {
                DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, task.HighlightColor, task.lineWidth);
            }
            if (task.heartBeat)
            {
                labels[2] = $"Starting with {lines.lpList.Count:000} lines, there are {raw3D.Count / 2:000} with depth data.";
            }
        }
    }
    public class CS_FeatureLine_Tutorial2 : CS_Parent
    {
        Line_Basics lines = new Line_Basics();
        IMU_GMatrix gMat = new IMU_GMatrix();
        Options_LineFinder options = new Options_LineFinder();
        public CS_FeatureLine_Tutorial2(VBtask task) : base(task)
        {
            desc = "Find all the lines in the image and determine which are vertical and horizontal";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            lines.Run(src);
            dst2 = lines.dst2;
            var raw2D = new List<PointPair>();
            var raw3D = new List<Point3f>();
            foreach (var lp in lines.lpList)
            {
                Point3f pt1 = new cv.Point3f(), pt2 = new cv.Point3f();
                for (int j = 0; j < 2; j++)
                {
                    cv.Point pt = (j == 0) ? new cv.Point(lp.p1.X, lp.p1.Y) : new cv.Point(lp.p2.X, lp.p2.Y);
                    Rect rect = ValidateRect(new Rect(pt.X - options.kSize, pt.Y - options.kSize, options.kernelSize, options.kernelSize));
                    Scalar val = task.pointCloud.SubMat(rect).Mean(task.depthMask.SubMat(rect));
                    if (j == 0)
                        pt1 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                    else
                        pt2 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                }
                if (pt1.Z > 0 && pt2.Z > 0)
                {
                    raw2D.Add(lp);
                    raw3D.Add(task.pointCloud.Get<Point3f>((int)lp.p1.Y, (int)lp.p1.X));
                    raw3D.Add(task.pointCloud.Get<Point3f>((int)lp.p2.Y, (int)lp.p2.X));
                }
            }
            dst3 = src.Clone();
            for (int i = 0; i < raw2D.Count - 1; i += 2)
            {
                DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, task.HighlightColor, task.lineWidth);
            }
            if (task.heartBeat)
            {
                labels[2] = $"Starting with {lines.lpList.Count:000} lines, there are {raw3D.Count:000} with depth data.";
            }
            if (raw3D.Count == 0)
            {
                SetTrueText("No vertical or horizontal lines were found");
            }
            else
            {
                gMat.Run(empty);
                task.gMatrix = gMat.gMatrix;
                Mat matLines3D = new Mat(raw3D.Count, 3, MatType.CV_32F, raw3D.ToArray()) * task.gMatrix;
            }
        }
    }
    public class CS_FeatureLine_LongestVerticalKNN : CS_Parent
    {
        Line_GCloud gLines = new Line_GCloud();
        FeatureLine_Longest longest = new FeatureLine_Longest();
        public CS_FeatureLine_LongestVerticalKNN(VBtask task) : base(task)
        {
            labels[3] = "All vertical lines.  The numbers: index and Arc-Y for the longest X vertical lines.";
            desc = "Find all the vertical lines and then track the longest one with a lightweight KNN.";
        }
        bool testLastPair(PointPair lastPair, gravityLine gc)
        {
            var distance1 = lastPair.p1.DistanceTo(lastPair.p2);
            var p1 = gc.tc1.center;
            var p2 = gc.tc2.center;
            if (distance1 < 0.75 * p1.DistanceTo(p2)) return true; // it the longest vertical * 0.75 > current lastPair, then use the longest vertical...
            return false;
        }
        public void RunCS(Mat src)
        {
            gLines.Run(src);
            if (gLines.sortedVerticals.Count == 0)
            {
                SetTrueText("No vertical lines were present", 3);
                return;
            }
            dst3 = src.Clone();
            var index = 0;
            if (testLastPair(longest.knn.lastPair, gLines.sortedVerticals.ElementAt(0).Value)) longest.knn.lastPair = new PointPair();
            foreach (var gc in gLines.sortedVerticals.Values)
            {
                if (index >= 10) break;
                var p1 = gc.tc1.center;
                var p2 = gc.tc2.center;
                if (longest.knn.lastPair.compare(new PointPair())) longest.knn.lastPair = new PointPair(p1, p2);
                var pt = new cv.Point((p1.X + p2.X) / 2, (p1.Y + p2.Y) / 2);
                SetTrueText($"{index}\n{gc.arcY.ToString(fmt1)}", pt, 3); 
                index++;
                DrawLine(dst3, p1, p2, task.HighlightColor, task.lineWidth);
                longest.knn.trainInput.Add(p1);
                longest.knn.trainInput.Add(p2);
            }
            longest.Run(src);
            dst2 = longest.dst2;
        }
    }
    public class CS_FeatureLine_LongestV_Tutorial1 : CS_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        public CS_FeatureLine_LongestV_Tutorial1(VBtask task) : base(task)
        {
            desc = "Use FeatureLine_Finder to find all the vertical lines and show the longest.";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            lines.Run(src);
            if (lines.sortedVerticals.Count == 0)
            {
                SetTrueText("No vertical lines were found", 3);
                return;
            }
            var index = lines.sortedVerticals.ElementAt(0).Value;
            var p1 = lines.lines2D[index];
            var p2 = lines.lines2D[index + 1];
            DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
            dst3.SetTo(0);
            DrawLine(dst3, p1, p2, task.HighlightColor, task.lineWidth);
        }
    }
    public class CS_FeatureLine_LongestV_Tutorial2 : CS_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        KNN_Core4D knn = new KNN_Core4D();
        public cv.Point3f pt1 = new cv.Point3f();
        public cv.Point3f pt2 = new cv.Point3f();
        int lengthReject;
        public CS_FeatureLine_LongestV_Tutorial2(VBtask task) : base(task)
        {
            desc = "Use FeatureLine_Finder to find all the vertical lines.  Use KNN_Core4D to track each line.";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            lines.Run(src);
            dst1 = lines.dst3;
            if (lines.sortedVerticals.Count == 0)
            {
                SetTrueText("No vertical lines were found", 3);
                return;
            }
            var match3D = new List<cv.Point3f>();
            knn.trainInput.Clear();
            for (var i = 0; i < lines.sortedVerticals.Count; i++)
            {
                var sIndex = lines.sortedVerticals.ElementAt(i).Value;
                var x1 = lines.lines2D[sIndex];
                var x2 = lines.lines2D[sIndex + 1];
                var vec = x1.Y < x2.Y ? new cv.Vec4f(x1.X, x1.Y, x2.X, x2.Y) : new cv.Vec4f(x2.X, x2.Y, x1.X, x1.Y);
                if (knn.queries.Count == 0) knn.queries.Add(vec);
                knn.trainInput.Add(vec);
                match3D.Add(lines.lines3D[sIndex]);
                match3D.Add(lines.lines3D[sIndex + 1]);
            }
            var saveVec = knn.queries[0];
            knn.Run(empty);
            var index = knn.result[0, 0];
            var p1 = new cv.Point2f(knn.trainInput[index][0], knn.trainInput[index][1]);
            var p2 = new cv.Point2f(knn.trainInput[index][2], knn.trainInput[index][3]);
            pt1 = match3D[index * 2];
            pt2 = match3D[index * 2 + 1];
            DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
            dst3.SetTo(0);
            DrawLine(dst3, p1, p2, task.HighlightColor, task.lineWidth);
            var lastLength = lines.sorted2DV.ElementAt(0).Key;
            var bestLength = lines.sorted2DV.ElementAt(0).Key;
            knn.queries.Clear();
            if (lastLength > 0.5 * bestLength)
            {
                knn.queries.Add(new cv.Vec4f(p1.X, p1.Y, p2.X, p2.Y));
                lastLength = (float)p1.DistanceTo(p2);
            }
            else
            {
                lengthReject++;
                lastLength = bestLength;
            }
            labels[3] = "Length rejects = " + (lengthReject / (task.frameCount + 1)).ToString("P0");
        }
    }




    public class CS_FeatureLine_Finder : CS_Parent
    {
        Line_Basics lines = new Line_Basics();
        public List<Point2f> lines2D = new List<Point2f>();
        public List<Point3f> lines3D = new List<Point3f>();
        public SortedList<float, int> sorted2DV = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
        public SortedList<float, int> sortedVerticals = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
        public SortedList<float, int> sortedHorizontals = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
        Options_LineFinder options = new Options_LineFinder();
        public CS_FeatureLine_Finder(VBtask task) : base(task)
        {
            desc = "Find all the lines in the image and determine which are vertical and horizontal";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            dst3 = src.Clone();
            lines2D.Clear();
            lines3D.Clear();
            sorted2DV.Clear();
            sortedVerticals.Clear();
            sortedHorizontals.Clear();
            lines.Run(src);
            dst2 = lines.dst2;
            List<PointPair> raw2D = new List<PointPair>();
            List<Point3f> raw3D = new List<Point3f>();
            foreach (var lp in lines.lpList)
            {
                Point3f pt1 = new Point3f(), pt2 = new Point3f();
                for (int j = 0; j < 2; j++)
                {
                    cv.Point2f pt = (j == 0) ? lp.p1 : lp.p2;
                    Rect rect = ValidateRect(new Rect((int)(pt.X - options.kSize), (int)(pt.Y - options.kSize), options.kernelSize, options.kernelSize));
                    Scalar val = task.pointCloud[rect].Mean(task.depthMask[rect]);
                    if (j == 0)
                        pt1 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                    else
                        pt2 = new Point3f((float)val[0], (float)val[1], (float)val[2]);
                }
                if (pt1.Z > 0 && pt2.Z > 0 && pt1.Z < 4 && pt2.Z < 4)
                {
                    raw2D.Add(lp);
                    raw3D.Add(pt1);
                    raw3D.Add(pt2);
                }
            }
            if (raw3D.Count == 0)
            {
                SetTrueText("No vertical or horizontal lines were found");
            }
            else
            {
                Mat matLines3D = new Mat(raw3D.Count, 3, MatType.CV_32F, raw3D.ToArray()) * task.gMatrix;
                for (int i = 0; i < raw2D.Count - 1; i += 2)
                {
                    Point3f pt1 = matLines3D.Get<Point3f>(i, 0);
                    Point3f pt2 = matLines3D.Get<Point3f>(i + 1, 0);
                    float len3D = distance3D(pt1, pt2);
                    double arcY = Math.Abs(Math.Asin((pt1.Y - pt2.Y) / len3D) * 57.2958);
                    if (Math.Abs(arcY - 90) < options.tolerance)
                    {
                        DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, Scalar.Blue, task.lineWidth);
                        sortedVerticals.Add(len3D, lines3D.Count);
                        sorted2DV.Add((float)raw2D[i].p1.DistanceTo(raw2D[i].p2), lines2D.Count);
                        if (pt1.Y > pt2.Y)
                        {
                            lines3D.Add(pt1);
                            lines3D.Add(pt2);
                            lines2D.Add(raw2D[i].p1);
                            lines2D.Add(raw2D[i].p2);
                        }
                        else
                        {
                            lines3D.Add(pt2);
                            lines3D.Add(pt1);
                            lines2D.Add(raw2D[i].p2);
                            lines2D.Add(raw2D[i].p1);
                        }
                    }
                    if (Math.Abs(arcY) < options.tolerance)
                    {
                        DrawLine(dst3, raw2D[i].p1, raw2D[i].p2, Scalar.Yellow, task.lineWidth);
                        sortedHorizontals.Add(len3D, lines3D.Count);
                        if (pt1.X < pt2.X)
                        {
                            lines3D.Add(pt1);
                            lines3D.Add(pt2);
                            lines2D.Add(raw2D[i].p1);
                            lines2D.Add(raw2D[i].p2);
                        }
                        else
                        {
                            lines3D.Add(pt2);
                            lines3D.Add(pt1);
                            lines2D.Add(raw2D[i].p2);
                            lines2D.Add(raw2D[i].p1);
                        }
                    }
                }
            }
            labels[2] = $"Starting with {lines.lpList.Count:000} lines, there are {lines3D.Count / 2:000} with depth data.";
            labels[3] = $"There were {sortedVerticals.Count} vertical lines (blue) and {sortedHorizontals.Count} horizontal lines (yellow)";
        }
    }

    public class CS_FeatureLine_VerticalLongLine : CS_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        public CS_FeatureLine_VerticalLongLine(VBtask task) : base(task)
        {
            desc = "Use FeatureLine_Finder data to identify the longest lines and show its angle.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                dst2 = src.Clone();
                lines.Run(src);
                if (lines.sortedVerticals.Count == 0)
                {
                    SetTrueText("No vertical lines were found", 3);
                    return;
                }
            }
            if (lines.sortedVerticals.Count == 0) return; // nothing found...
            var index = lines.sortedVerticals.ElementAt(0).Value;
            var p1 = lines.lines2D[index];
            var p2 = lines.lines2D[index + 1];
            DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
            dst3.SetTo(0);
            DrawLine(dst3, p1, p2, task.HighlightColor, task.lineWidth);
            var pt1 = lines.lines3D[index];
            var pt2 = lines.lines3D[index + 1];
            var len3D = distance3D(pt1, pt2);
            var arcY = Math.Abs(Math.Asin((pt1.Y - pt2.Y) / len3D) * 57.2958);
            SetTrueText($"{arcY.ToString(fmt3)}\n{len3D.ToString(fmt3)}m len\n{pt1.Z.ToString(fmt1)}m dist", new cv.Point(p1.X, p1.Y));
            SetTrueText($"{arcY.ToString(fmt3)}\n{len3D.ToString(fmt3)}m len\n{pt1.Z.ToString(fmt1)}m distant", new cv.Point(p1.X, p1.Y), 3);
        }
    }
    public class CS_FeatureLine_DetailsAll : CS_Parent
    {
        FeatureLine_Finder lines = new FeatureLine_Finder();
        Font_FlowText flow = new Font_FlowText();
        List<float> arcList = new List<float>();
        List<float> arcLongAverage = new List<float>();
        List<float> firstAverage = new List<float>();
        int firstBest;
        public CS_FeatureLine_DetailsAll(VBtask task) : base(task)
        {
            flow.parentData = this;
            flow.dst = 3;
            desc = "Use FeatureLine_Finder data to collect vertical lines and measure accuracy of each.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                dst2 = src.Clone();
                lines.Run(src);
                if (lines.sortedVerticals.Count == 0)
                {
                    SetTrueText("No vertical lines were found", 3);
                    return;
                }
                dst3.SetTo(0);
                arcList.Clear();
                flow.flowText.Clear();
                flow.flowText.Add("ID\tlength\tdistance");
                for (int i = 0; i < Math.Min(10, lines.sortedVerticals.Count); i++)
                {
                    int index = lines.sortedVerticals.ElementAt(i).Value;
                    cv.Point2f p1 = lines.lines2D[index];
                    cv.Point2f p2 = lines.lines2D[index + 1];
                    DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
                    SetTrueText(i.ToString(), i % 2 == 1 ? new cv.Point(p1.X, p1.Y) : new cv.Point(p2.X, p2.Y), 2);
                    DrawLine(dst3, p1, p2, task.HighlightColor, task.lineWidth);
                    Point3f pt1 = lines.lines3D[index];
                    Point3f pt2 = lines.lines3D[index + 1];
                    float len3D = distance3D(pt1, pt2);
                    if (len3D > 0)
                    {
                        float arcY = Math.Abs((float)(Math.Asin((pt1.Y - pt2.Y) / len3D) * 57.2958));
                        arcList.Add(arcY);
                        flow.flowText.Add($"{arcY:F3}\t{len3D:F3}m\t{pt1.Z:F1}m");
                    }
                }
            }
            flow.Run(empty);
            if (arcList.Count == 0) return;
            float mostAccurate = arcList[0];
            firstAverage.Add(mostAccurate);
            foreach (float arc in arcList)
            {
                if (arc > mostAccurate)
                {
                    mostAccurate = arc;
                    break;
                }
            }
            if (mostAccurate == arcList[0]) firstBest++;
            float avg = arcList.Average();
            arcLongAverage.Add(avg);
            labels[3] = $"arcY avg = {avg:F1}, long term average = {arcLongAverage.Average():F1}, " +
                        $"first was best {(float)firstBest / task.frameCount:P0} of the time, " +
                        $"Avg of longest line {firstAverage.Average():F1}";
            if (arcLongAverage.Count > 1000)
            {
                arcLongAverage.RemoveAt(0);
                firstAverage.RemoveAt(0);
            }
        }
    }
    public class CS_FeatureLine_LongestKNN : CS_Parent
    {
        Line_GCloud glines = new Line_GCloud();
        public KNN_ClosestTracker knn = new KNN_ClosestTracker();
        public Options_Features options = new Options_Features();
        public gravityLine gline;
        public Match_Basics match = new Match_Basics();
        cv.Point2f p1, p2;
        public CS_FeatureLine_LongestKNN(VBtask task) : base(task)
        {
            desc = "Find and track the longest line in the BGR image with a lightweight KNN.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src;
            knn.Run(src.Clone());
            p1 = knn.lastPair.p1;
            p2 = knn.lastPair.p2;
            gline = glines.updateGLine(src, gline, new cv.Point(p1.X, p1.Y), new cv.Point(p2.X, p2.Y));
            Rect rect = ValidateRect(new Rect((int)Math.Min(p1.X, p2.X), (int)Math.Min(p1.Y, p2.Y), (int)Math.Abs(p1.X - p2.X) + 2, (int)Math.Abs(p1.Y - p2.Y)));
            match.template = new Mat(src, rect);
            match.Run(src);
            if (match.correlation >= options.correlationMin)
            {
                dst3 = match.dst0.Resize(dst3.Size());
                DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
                DrawCircle(dst2, p1, task.DotSize, task.HighlightColor);
                DrawCircle(dst2, p2, task.DotSize, task.HighlightColor);
                rect = ValidateRect(new Rect((int)(Math.Min(p1.X, p2.X)), (int)(Math.Min(p1.Y, p2.Y)), (int)(Math.Abs(p1.X - p2.X) + 2), (int)(Math.Abs(p1.Y - p2.Y))));
                match.template = new Mat(src, rect).Clone();
            }
            else
            {
                task.HighlightColor = task.HighlightColor == Scalar.Yellow ? Scalar.Blue : Scalar.Yellow;
                knn.lastPair = new PointPair(new Point2f(), new Point2f());
            }
            labels[2] = $"Longest line end points had correlation of {match.correlation:F3} with the original longest line.";
        }
    }
    public class CS_FeatureLine_Longest : CS_Parent
    {
        Line_GCloud glines = new Line_GCloud();
        public KNN_ClosestTracker knn = new KNN_ClosestTracker();
        public Options_Features options = new Options_Features();
        public gravityLine gline;
        public Match_Basics match1 = new Match_Basics();
        public Match_Basics match2 = new Match_Basics();
        public CS_FeatureLine_Longest(VBtask task) : base(task)
        {
            labels[2] = "Longest line end points are highlighted ";
            desc = "Find and track the longest line in the BGR image with a lightweight KNN.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src.Clone();
            float correlationMin = match1.options.correlationMin;
            int templatePad = match1.options.templatePad;
            int templateSize = match1.options.templateSize;
            cv.Point2f p1 = new cv.Point(), p2 = new cv.Point();
            if (task.heartBeat || (match1.correlation < correlationMin && match2.correlation < correlationMin))
            {
                knn.Run(src.Clone());
                p1 = knn.lastPair.p1;
                Rect r1 = ValidateRect(new Rect((int)(p1.X - templatePad), (int)(p1.Y - templatePad), templateSize, templateSize));
                match1.template = new Mat(src, r1).Clone();
                p2 = knn.lastPair.p2;
                Rect r2 = ValidateRect(new Rect((int)(p2.X - templatePad), (int)(p2.Y - templatePad), templateSize, templateSize));
                match2.template = new Mat(src, r2).Clone();
            }
            match1.Run(src);
            p1 = match1.matchCenter;
            match2.Run(src);
            p2 = match2.matchCenter;
            gline = glines.updateGLine(src, gline, new cv.Point(p1.X, p1.Y), new cv.Point(p2.X, p2.Y));
            DrawLine(dst2, p1, p2, task.HighlightColor, task.lineWidth);
            DrawCircle(dst2, p1, task.DotSize, task.HighlightColor);
            DrawCircle(dst2, p2, task.DotSize, task.HighlightColor);
            SetTrueText($"{match1.correlation:F3}", new cv.Point(p1.X, p1.Y));
            SetTrueText($"{match2.correlation:F3}", new cv.Point(p2.X, p2.Y));
        }
    }



    public class CS_FeaturePoly_Basics : CS_Parent
    {
        public bool resync;
        public string resyncCause;
        public int resyncFrames;
        public float maskChangePercent;
        FeaturePoly_TopFeatures topFeatures = new FeaturePoly_TopFeatures();
        public FeaturePoly_Sides sides = new FeaturePoly_Sides();
        public CS_FeaturePoly_Basics(VBtask task) : base(task)
        {
            FindSlider("Feature Sample Size").Value = 30;
            if (dst2.Width >= 640) FindSlider("Resync if feature moves > X pixels").Value = 15;
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature Polygon with perpendicular lines for center of rotation.", "Feature polygon created by highest generation counts",
                  "Ordered Feature polygons of best features - white is original, yellow latest" };
            desc = "Build a Feature polygon with the top generation counts of the good features";
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) sides.prevImage = src.Clone();
            sides.options.RunVB();

            topFeatures.Run(src);
            dst2 = topFeatures.dst2;
            sides.currPoly = new List<Point2f>(topFeatures.poly);
            if (sides.currPoly.Count < task.polyCount) return;
            sides.Run(src);
            dst3 = sides.dst2;
            for (int i = 0; i < sides.currPoly.Count; i++)
            {
                SetTrueText(i.ToString(), sides.currPoly[i], 3);
            }
            SetTrueText("Rotate center", new Point2f(sides.rotateCenter.X + 10, sides.rotateCenter.Y), 3);
            string causes = "";
            if (Math.Abs(sides.rotateAngle * 57.2958) > 10)
            {
                resync = true;
                causes += " - Rotation angle exceeded threshold.";
                sides.rotateAngle = 0;
            }
            causes += "\n";
            if (task.optionsChanged)
            {
                resync = true;
                causes += " - Options changed";
            }
            causes += "\n";
            if (resyncFrames > sides.options.autoResyncAfterX)
            {
                resync = true;
                causes += $" - More than {sides.options.autoResyncAfterX} frames without resync";
            }
            causes += "\n";
            if (Math.Abs(sides.currLengths.Sum() - sides.prevLengths.Sum()) > sides.options.removeThreshold * task.polyCount)
            {
                resync = true;
                causes += $" - The top {task.polyCount} vertices have moved because of the generation counts";
            }
            else
            {
                if (Math.Abs(sides.prevFLineLen - sides.currFLineLen) > sides.options.removeThreshold)
                {
                    resync = true;
                    causes += $" - The Feature polygon's longest side (FLine) changed more than the threshold of {sides.options.removeThreshold} pixels";
                }
            }
            causes += "\n";
            if (resync || sides.prevPoly.Count != task.polyCount || task.optionsChanged)
            {
                sides.prevPoly = new List<Point2f>(sides.currPoly);
                sides.prevLengths = new List<float>(sides.currLengths);
                sides.prevSideIndex = sides.prevLengths.IndexOf(sides.prevLengths.Max());
                sides.prevImage = src.Clone();
                resyncFrames = 0;
                resyncCause = causes;
            }
            resyncFrames++;
            strOut = $"Rotation: {sides.rotateAngle * 57.2958:F1} degrees{"\n"}";
            strOut += $"Translation: {(int)sides.centerShift.X}, {(int)sides.centerShift.Y}{"\n"}";
            strOut += $"Rotate center: {sides.rotateCenter.X:F0}, {sides.rotateCenter.Y:F0}{"\n"}";
            strOut += $"Frames since last resync: {resyncFrames:000}{"\n"}{"\n"}";
            strOut += $"Resync last caused by: {"\n"}{resyncCause}";
            foreach (var keyval in topFeatures.stable.goodCounts)
            {
                var ptmp = topFeatures.stable.basics.ptList[keyval.Value];
                var pt = new cv.Point((int)ptmp.X, (int)ptmp.Y);
                int g = topFeatures.stable.basics.facetGen.dst0.Get<int>(pt.Y, pt.X);
                SetTrueText(g.ToString(), pt);
            }
            SetTrueText(strOut, 1);
            resync = false;
        }
    }
    public class CS_FeaturePoly_Sides : CS_Parent
    {
        public List<Point2f> currPoly = new List<Point2f>();
        public int currSideIndex;
        public List<float> currLengths = new List<float>();
        public float currFLineLen;
        public PointPair mpCurr;
        public List<Point2f> prevPoly = new List<Point2f>();
        public int prevSideIndex;
        public List<float> prevLengths = new List<float>();
        public float prevFLineLen;
        public PointPair mpPrev;
        public Mat prevImage;
        public Point2f rotateCenter;
        public float rotateAngle;
        public Point2f centerShift;
        public Options_FPoly options = new Options_FPoly();
        Line_Nearest near = new Line_Nearest();
        public Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        List<Point2f> newPoly;
        Random_Basics random = new Random_Basics();
        public CS_FeaturePoly_Sides(VBtask task) : base(task)
        {
            labels[2] = "White is the original FPoly and yellow is the current FPoly.";
            desc = "Compute the lengths of each side in a polygon";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.FirstPass) prevImage = src.Clone();
            options.RunVB();
            if (standaloneTest() && task.heartBeat)
            {
                random.Run(empty);
                currPoly = new List<Point2f>(random.PointList);
            }
            dst2.SetTo(0);
            currLengths.Clear();
            for (int i = 0; i < currPoly.Count - 1; i++)
            {
                currLengths.Add(Distance(currPoly[i], currPoly[i + 1]));
            }
            currSideIndex = currLengths.IndexOf(currLengths.Max());
            if (task.FirstPass)
            {
                prevPoly = new List<Point2f>(currPoly);
                prevLengths = new List<float>(currLengths);
                prevSideIndex = prevLengths.IndexOf(prevLengths.Max());
            }
            if (prevPoly.Count == 0) return;
            mpPrev = new PointPair(prevPoly[prevSideIndex], prevPoly[(prevSideIndex + 1) % task.polyCount]);
            mpCurr = new PointPair(currPoly[currSideIndex], currPoly[(currSideIndex + 1) % task.polyCount]);
            prevFLineLen = Distance(mpPrev.p1, mpPrev.p2);
            currFLineLen = Distance(mpCurr.p1, mpCurr.p2);
            float d1 = Distance(mpPrev.p1, mpCurr.p1);
            float d2 = Distance(mpPrev.p2, mpCurr.p2);
            PointPair newNear;
            if (d1 < d2)
            {
                centerShift = new Point2f(mpPrev.p1.X - mpCurr.p1.X, mpPrev.p1.Y - mpCurr.p1.Y);
                rotateCenter = mpPrev.p1;
                newNear = new PointPair(mpPrev.p2, mpCurr.p2);
            }
            else
            {
                centerShift = new Point2f(mpPrev.p2.X - mpCurr.p2.X, mpPrev.p2.Y - mpCurr.p2.Y);
                rotateCenter = mpPrev.p2;
                newNear = new PointPair(mpPrev.p1, mpCurr.p1);
            }
            List<Point2f> transPoly = new List<Point2f>();
            for (int i = 0; i < currPoly.Count; i++)
            {
                transPoly.Add(new Point2f(currPoly[i].X - centerShift.X, currPoly[i].Y - centerShift.Y));
            }
            newNear.p1 = new Point2f(newNear.p1.X - centerShift.X, newNear.p1.Y - centerShift.Y);
            newNear.p2 = new Point2f(newNear.p2.X - centerShift.X, newNear.p2.Y - centerShift.Y);
            rotateCenter = new Point2f(rotateCenter.X - centerShift.X, rotateCenter.Y - centerShift.Y);
            strOut = "No rotation" + "\n";
            rotateAngle = 0;
            if (d1 != d2)
            {
                if (Distance(newNear.p1, newNear.p2) > options.removeThreshold)
                {
                    near.lp = mpPrev;
                    near.pt = newNear.p1;
                    near.Run(empty);
                    DrawLine(dst1, near.pt, near.nearPoint, Scalar.Red, task.lineWidth + 5);
                    float hypotenuse = Distance(rotateCenter, near.pt);
                    rotateAngle = -(float)Math.Asin(Distance(near.nearPoint, near.pt) / hypotenuse);
                    if (float.IsNaN(rotateAngle)) rotateAngle = 0;
                    strOut = $"Angle is {rotateAngle * 57.2958:F1} degrees{"\n"}";
                }
            }
            strOut += $"Translation (shift) is {-centerShift.X:F0}, {-centerShift.Y:F0}";
            if (Math.Abs(rotateAngle) > 0)
            {
                rotatePoly.rotateCenter = rotateCenter;
                rotatePoly.rotateAngle = rotateAngle;
                rotatePoly.poly.Clear();
                rotatePoly.poly.Add(newNear.p1);
                rotatePoly.Run(empty);
                if (Distance(near.nearPoint, rotatePoly.poly[0]) > Distance(newNear.p1, rotatePoly.poly[0])) rotateAngle *= -1;
                rotatePoly.rotateAngle = rotateAngle;
                rotatePoly.poly = new List<Point2f>(transPoly);
                rotatePoly.Run(empty);
                newPoly = new List<Point2f>(rotatePoly.poly);
            }
            DrawFPoly(ref dst2, prevPoly, Scalar.White);
            DrawFPoly(ref dst2, currPoly, Scalar.Yellow);
            DrawFatLine(mpPrev.p1, mpPrev.p2, dst2, Scalar.White);
            DrawFatLine(mpCurr.p1, mpCurr.p2, dst2, Scalar.Yellow);
        }
        float Distance(Point2f p1, Point2f p2)
        {
            return (float)Math.Sqrt(Math.Pow(p2.X - p1.X, 2) + Math.Pow(p2.Y - p1.Y, 2));
        }
    }
    public class CS_FeaturePoly_BasicsOriginal : CS_Parent
    {
        public fPolyData fPD = new fPolyData();
        public Mat resyncImage;
        public bool resync;
        public string resyncCause;
        public int resyncFrames;
        public float maskChangePercent;
        FeaturePoly_TopFeatures topFeatures = new FeaturePoly_TopFeatures();
        public Options_FPoly options = new Options_FPoly();
        public object center;
        public CS_FeaturePoly_BasicsOriginal(VBtask task) : base(task)
        {
            center = new FeaturePoly_Center(); // FeaturePoly_PerpendicularsTest can be used to test the perpendicular method of finding the rotate center.
            FindSlider("Feature Sample Size").Value = 30;
            if (dst2.Width >= 640) FindSlider("Resync if feature moves > X pixels").Value = 15;
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature Polygon with perpendicular lines for center of rotation.", "Feature polygon created by highest generation counts",
                  "Ordered Feature polygons of best features - white is original, yellow latest" };
            desc = "Build a Feature polygon with the top generation counts of the good features";
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) resyncImage = src.Clone();
            options.RunVB();
            topFeatures.Run(src);
            dst2 = topFeatures.dst2;
            dst1 = topFeatures.dst3;
            fPD.currPoly = new List<Point2f>(topFeatures.poly);
            if (task.optionsChanged) fPD = new fPolyData(fPD.currPoly);
            if (fPD.currPoly.Count < task.polyCount) return;
            fPD.computeCurrLengths();
            for (int i = 0; i < fPD.currPoly.Count; i++)
            {
                SetTrueText(i.ToString(), fPD.currPoly[i], 1);
            }
            if (task.FirstPass) fPD.lengthPrevious = new List<float>(fPD.currLength);
            ((dynamic)center).fPD = fPD;
            ((dynamic)center).Run(src);
            fPD = ((dynamic)center).fPD;
            dst1 = (dst1 | ((dynamic)center).dst2).ToMat();
            dst0 = ((dynamic)center).dst3;
            fPD.jitterTest(dst2, this); // the feature line has not really moved.
            string causes = "";
            if (Math.Abs(fPD.rotateAngle * 57.2958) > 10)
            {
                resync = true;
                causes += " - Rotation angle exceeded threshold.";
                fPD.rotateAngle = 0;
            }
            causes += "\n";
            if (maskChangePercent > 0.2)
            {
                resync = true;
                causes += " - Difference of startFrame and current frame exceeded 20% of image size";
            }
            causes += "\n";
            if (task.optionsChanged)
            {
                resync = true;
                causes += " - Options changed";
            }
            causes += "\n";
            if (resyncFrames > options.autoResyncAfterX)
            {
                resync = true;
                causes += $" - More than {options.autoResyncAfterX} frames without resync";
            }
            causes += "\n";
            if (Math.Abs(fPD.currLength.Sum() - fPD.lengthPrevious.Sum()) > options.removeThreshold * task.polyCount)
            {
                resync = true;
                causes += $" - The top {task.polyCount} vertices have moved because of the generation counts";
            }
            else
            {
                if (fPD.computeFLineLength() > options.removeThreshold)
                {
                    resync = true;
                    causes += $" - The Feature polygon's longest side (FLine) changed more than the threshold of {options.removeThreshold} pixels";
                }
            }
            causes += "\n";
            if (resync || fPD.prevPoly.Count != task.polyCount || task.optionsChanged)
            {
                fPD.resync();
                resyncImage = src.Clone();
                resyncFrames = 0;
                resyncCause = causes;
            }
            resyncFrames++;
            DrawFPoly(ref dst2, fPD.currPoly, Scalar.White);
            fPD.DrawPolys(dst1, fPD.currPoly, this);
            for (int i = 0; i < fPD.prevPoly.Count; i++)
            {
                SetTrueText(i.ToString(), fPD.currPoly[i], 1);
                SetTrueText(i.ToString(), fPD.currPoly[i], 1);
            }
            strOut = $"Rotation: {fPD.rotateAngle * 57.2958:F1} degrees{"\n"}";
            strOut += $"Translation: {(int)fPD.centerShift.X}, {(int)fPD.centerShift.Y}{"\n"}";
            strOut += $"Rotate center: {fPD.rotateCenter.X:F0}, {fPD.rotateCenter.Y:F0}{"\n"}";
            strOut += $"Frames since last resync: {resyncFrames:000}{"\n"}";
            strOut += $"Last resync cause(s): {"\n"}{resyncCause}";
            foreach (var keyval in topFeatures.stable.goodCounts)
            {
                var pt = topFeatures.stable.basics.ptList[keyval.Value];
                int g = topFeatures.stable.basics.facetGen.dst0.At<int>((int)pt.Y, (int)pt.X);
                SetTrueText(g.ToString(), pt);
            }
            SetTrueText(strOut, 1);
            dst3 = ((dynamic)center).dst3;
            labels[3] = ((dynamic)center).labels[3];
            resync = false;
        }
    }
    public class CS_FeaturePoly_Plot : CS_Parent
    {
        public FeaturePoly_Core fGrid = new FeaturePoly_Core();
        Plot_Histogram plot = new Plot_Histogram();
        public float[] hist;
        public List<float> distDiff = new List<float>();
        public CS_FeaturePoly_Plot(VBtask task) : base(task)
        {
            plot.minRange = 0;
            plot.removeZeroEntry = false;
            labels = new string[] { "", "", "", "anchor and companions - input to distance difference" };
            desc = "Feature Grid: compute distances between good features from frame to frame and plot the distribution";
        }
        public void RunCS(Mat src)
        {
            Mat lastDistance = fGrid.dst0.Clone();
            fGrid.Run(src);
            dst3 = fGrid.dst3;
            dst3 = src.Clone();
            hist = new float[fGrid.threshold + 2];
            distDiff.Clear();
            for (int i = 0; i < fGrid.stable.basics.facetGen.facet.facetList.Count; i++)
            {
                var pt = fGrid.stable.basics.ptList[i];
                float d = (float)fGrid.anchor.DistanceTo(pt);
                float lastd = lastDistance.At<float>((int)pt.Y, (int)pt.X);
                float absDiff = Math.Abs(lastd - d);
                if (absDiff >= hist.Length) absDiff = hist.Length - 1;
                if (absDiff < fGrid.threshold)
                {
                    hist[(int)absDiff]++;
                    DrawLine(dst3, fGrid.anchor, pt, task.HighlightColor, task.lineWidth);
                    distDiff.Add(absDiff);
                }
                else
                {
                    hist[fGrid.threshold]++;
                }
            }
            var hlist = hist.ToList();
            float peak = hlist.Max();
            int peakIndex = hlist.IndexOf(peak);
            Mat histMat = new Mat(hist.Length, 1, MatType.CV_32F, hist);
            plot.maxValue = fGrid.stable.basics.ptList.Count;
            plot.Run(histMat);
            dst2 = plot.dst2;
            float avg = distDiff.Count > 0 ? distDiff.Average() : 0;
            labels[2] = $"Average distance change (after threshholding) = {avg:F3}, peak at {peakIndex} with {peak:F1} occurances";
        }
    }
    public class CS_FeaturePoly_PlotWeighted : CS_Parent
    {
        public FeaturePoly_Plot fPlot = new FeaturePoly_Plot();
        Plot_Histogram plot = new Plot_Histogram();
        AddWeighted_Basics addw = new AddWeighted_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        public CS_FeaturePoly_PlotWeighted(VBtask task) : base(task)
        {
            plot.minRange = 0;
            plot.removeZeroEntry = false;
            labels = new string[] { "", "Distance change from previous frame", "", "anchor and companions - input to distance difference" };
            desc = "Feature Grid: compute distances between good features from frame to frame and plot with weighting and Kalman to smooth results";
        }
        public void RunCS(Mat src)
        {
            fPlot.Run(src);
            dst3 = fPlot.dst3;
            Mat lastPlot = plot.dst2.Clone();
            if (task.optionsChanged) kalman.kInput = new float[fPlot.hist.Length];
            kalman.kInput = fPlot.hist;
            kalman.Run(new Mat());
            fPlot.hist = kalman.kOutput;
            var hlist = fPlot.hist.ToList();
            float peak = hlist.Max();
            int peakIndex = hlist.IndexOf(peak);
            Mat histMat = new Mat(fPlot.hist.Length, 1, MatType.CV_32F, fPlot.hist);
            plot.maxValue = fPlot.fGrid.stable.basics.ptList.Count;
            plot.Run(histMat);
            addw.src2 = plot.dst2;
            addw.Run(lastPlot);
            dst2 = addw.dst2;
            if (task.heartBeat)
            {
                float avg = fPlot.distDiff.Count > 0 ? fPlot.distDiff.Average() : 0;
                labels[2] = $"Average distance change (after threshholding) = {avg:F3}, peak at {peakIndex} with {peak:F1} occurances";
            }
        }
    }
    public class CS_FeaturePoly_Stablizer : CS_Parent
    {
        public FeaturePoly_Core fGrid;
        public CS_FeaturePoly_Stablizer(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Movement amount - dot is current anchor point", "SyncImage aligned to current image - slide camera left or right",
                  "current image with distance map" };
            desc = "Feature Grid: show the accumulated camera movement in X and Y (no rotation)";
            fGrid = new FeaturePoly_Core();
        }
        public void RunCS(Mat src)
        {
            fGrid.Run(src.Clone());
            dst3 = fGrid.dst3;
            labels[3] = fGrid.labels[2];
            Mat syncImage = src.Clone();
            if (fGrid.startAnchor == fGrid.anchor) syncImage = src.Clone();
            cv.Point shift = new cv.Point(fGrid.startAnchor.X - fGrid.anchor.X, fGrid.startAnchor.Y - fGrid.anchor.Y);
            Rect rect = new Rect();
            if (shift.X < 0) rect.X = 0; else rect.X = shift.X;
            if (shift.Y < 0) rect.Y = 0; else rect.Y = shift.Y;
            rect.Width = dst1.Width - Math.Abs(shift.X);
            rect.Height = dst1.Height - Math.Abs(shift.Y);

            dst1.SetTo(0);
            dst1[rect] = syncImage[rect];
            DrawLine(dst1, fGrid.startAnchor, fGrid.anchor, new cv.Scalar(255), 2);
            DrawCircle(dst1, fGrid.anchor, 5, new cv.Scalar(255), -1);
            Rect r = new Rect(0, 0, rect.Width, rect.Height);
            if (fGrid.anchor.X > fGrid.startAnchor.X) r.X = (int)(fGrid.anchor.X - fGrid.startAnchor.X);
            if (fGrid.anchor.Y > fGrid.startAnchor.Y) r.Y = (int)(fGrid.anchor.Y - fGrid.startAnchor.Y);

            dst2.SetTo(0);
            dst2[r] = syncImage[rect];
        }
    }
    public class CS_FeaturePoly_StartPoints : CS_Parent
    {
        public List<Point> startPoints;
        public List<Point> goodPoints;
        public FeaturePoly_Core fGrid = new FeaturePoly_Core();
        System.Windows.Forms.TrackBar resyncSlider;
        public CS_FeaturePoly_StartPoints(VBtask task) : base(task)
        {
            resyncSlider = FindSlider("Resync if feature moves > X pixels");

            dst0 = new Mat(dst0.Rows, dst0.Cols, MatType.CV_8U, 1);
            dst0.SetTo(new cv.Scalar(255));
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Track the feature grid points back to the last sync point";
        }
        public void RunCS(Mat src)
        {
            int threshold = resyncSlider.Value;
            double maxShift = fGrid.anchor.DistanceTo(fGrid.startAnchor) + threshold;
            fGrid.Run(src);
            dst2 = fGrid.dst3;
            List<List<Point>> facets = new List<List<Point>>();
            Mat lastPoints = dst0.Clone();
            if (fGrid.startAnchor == fGrid.anchor || goodPoints.Count < 5)
            {
                startPoints = new List<cv.Point>();
                foreach (var pt in fGrid.goodPoints)
                {
                    startPoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
                }
                facets = new List<List<Point>>(fGrid.goodFacets);
            }
            dst0.SetTo(new cv.Scalar(255));
            if (standaloneTest()) dst1.SetTo(new cv.Scalar(0));
            List<PointPair> mpList = new List<PointPair>();
            goodPoints = new List<Point>();
            foreach (var pt in fGrid.goodPoints)
            {
                goodPoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            List<Point> facet = new List<Point>();
            List<int> usedGood = new List<int>();
            for (int i = 0; i < goodPoints.Count; i++)
            {
                cv.Point pt = goodPoints[i];
                byte startPoint = lastPoints.Get<byte>(pt.Y, pt.X);
                if (startPoint == 255 && i < 256) startPoint = (byte)i;
                if (startPoint < startPoints.Count && !usedGood.Contains(startPoint))
                {
                    usedGood.Add(startPoint);
                    facet = facets[startPoint];
                    dst0.FillConvexPoly(facet.ToArray(), startPoint, cv.LineTypes.Link4);
                    if (standaloneTest()) dst1.FillConvexPoly(facet.ToArray(), task.scalarColors[startPoint], task.lineType);
                    mpList.Add(new PointPair(startPoints[startPoint], pt));
                }
            }
            // dst3.SetTo(new cv.Scalar(0));
            foreach (PointPair mp in mpList)
            {
                if (mp.p1.DistanceTo(mp.p2) <= maxShift) DrawLine(dst1, mp.p1, mp.p2, new cv.Scalar(255, 255, 0), 2);
                DrawCircle(dst1, mp.p1, task.DotSize, new cv.Scalar(255, 255, 0), -1);
            }
            DrawLine(dst1, fGrid.anchor, fGrid.startAnchor, new cv.Scalar(255), task.lineWidth + 1);
        }
    }
    public class CS_FeaturePoly_Triangle : CS_Parent
    {
        Area_MinTriangle_CPP triangle = new Area_MinTriangle_CPP();
        FeaturePoly_Core fGrid = new FeaturePoly_Core();
        public CS_FeaturePoly_Triangle(VBtask task) : base(task)
        {
            desc = "Find the minimum triangle that contains the feature grid";
        }
        public void RunCS(Mat src)
        {
            fGrid.Run(src);
            dst2 = fGrid.dst2;
            triangle.srcPoints = new List<Point2f>();
            foreach (var pt in fGrid.goodPoints)
            {
                triangle.srcPoints.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            triangle.Run(null);
            dst3 = triangle.dst2;
        }
    }
    public class CS_FeaturePoly_TopFeatures : CS_Parent
    {
        Stable_BasicsCount stable = new Stable_BasicsCount();
        List<Point2f> poly = new List<Point2f>();
        Options_FPoly options = new Options_FPoly();
        public CS_FeaturePoly_TopFeatures(VBtask task) : base(task)
        {
            desc = "Get the top features and validate them";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            stable.Run(src);
            dst2 = stable.dst2;
            poly.Clear();
            foreach (KeyValuePair<int, int> keyVal in stable.goodCounts)
            {
                var ptmp = stable.basics.ptList[keyVal.Value];
                var pt = new cv.Point((int)ptmp.X, (int)ptmp.Y);
                int g = stable.basics.facetGen.dst0.Get<int>(pt.Y, pt.X);
                SetTrueText(g.ToString(), pt);
                if (poly.Count < task.polyCount) poly.Add(pt);
            }
            for (int i = 0; i < poly.Count - 1; i++)
            {
                DrawLine(dst2, poly[i], poly[i + 1], new cv.Scalar(255), 2);
            }
        }
    }
    public class CS_FeaturePoly_WarpAffinePoly : CS_Parent
    {
        Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        WarpAffine_BasicsQT warp = new WarpAffine_BasicsQT();
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        public CS_FeaturePoly_WarpAffinePoly(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Feature polygon after just rotation - white (original), yellow (current)",
                  "Feature polygon with rotation and shift - should be aligned" };
            desc = "Rotate and shift just the Feature polygon as indicated by FeaturePoly_Basics";
        }
        public void RunCS(Mat src)
        {
            fPoly.Run(src);
            List<Point2f> polyPrev = fPoly.fPD.prevPoly;
            List<Point2f> poly = new List<Point2f>(fPoly.fPD.currPoly);
            dst2.SetTo(new cv.Scalar(0));
            dst3.SetTo(new cv.Scalar(0));
            DrawFPoly(ref dst2, polyPrev, new cv.Scalar(255));
            warp.rotateCenter = fPoly.fPD.rotateCenter;
            warp.rotateAngle = fPoly.fPD.rotateAngle;
            warp.Run(dst2);
            dst3 = warp.dst2;
            rotatePoly.rotateAngle = fPoly.fPD.rotateAngle;
            rotatePoly.rotateCenter = fPoly.fPD.rotateCenter;
            rotatePoly.poly = new List<Point2f>(poly);
            rotatePoly.Run(null);
            if (fPoly.fPD.polyPrevSideIndex >= rotatePoly.poly.Count) fPoly.fPD.polyPrevSideIndex = 0;
            cv.Point offset = new cv.Point(rotatePoly.poly[fPoly.fPD.polyPrevSideIndex].X - polyPrev[fPoly.fPD.polyPrevSideIndex].X,
                                     rotatePoly.poly[fPoly.fPD.polyPrevSideIndex].Y - polyPrev[fPoly.fPD.polyPrevSideIndex].Y);
            Rect r1 = new Rect(offset.X, offset.Y, dst2.Width - Math.Abs(offset.X), dst2.Height - Math.Abs(offset.Y));
            if (offset.X < 0) r1.X = 0;
            if (offset.Y < 0) r1.Y = 0;
            Rect r2 = new Rect(Math.Abs(offset.X), Math.Abs(offset.Y), r1.Width, r1.Height);
            if (offset.X > 0) r2.X = 0;
            if (offset.Y > 0) r2.Y = 0;

            dst3[r1] = dst2[r1];
            dst3 -= dst2;

            DrawFPoly(ref dst3, rotatePoly.poly, new cv.Scalar(255, 255, 0));
            DrawFPoly(ref dst2, rotatePoly.poly, new cv.Scalar(255, 255, 0));
            SetTrueText(fPoly.strOut, 3);
        }
    }
    public class CS_FeaturePoly_RotatePoints : CS_Parent
    {
        Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        public List<Point> poly;
        public List<Point2f> polyPrev;
        public float rotateAngle;
        public cv.Point rotateCenter;
        public int polyPrevSideIndex;
        public cv.Point centerShift;
        public CS_FeaturePoly_RotatePoints(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Feature polygon after just rotation - white (original), yellow (current)",
                  "Feature polygons with rotation and shift - should be aligned" };
            desc = "Rotate and shift just the Feature polygon as indicated by FeaturePoly_Basics";
        }
        public cv.Point shiftPoly(List<Point2f> polyPrev, List<Point> poly)
        {
            rotatePoly.rotateAngle = rotateAngle;
            rotatePoly.rotateCenter = rotateCenter;
            rotatePoly.poly = new List<Point2f>();
            foreach (var pt in poly)
            {
                rotatePoly.poly.Add(new cv.Point2f(pt.X, pt.Y));
            }
            rotatePoly.Run(null);
            int totalX = (int)(rotatePoly.poly[polyPrevSideIndex].X - polyPrev[polyPrevSideIndex].X);
            int totalY = (int)(rotatePoly.poly[polyPrevSideIndex].Y - polyPrev[polyPrevSideIndex].Y);
            return new cv.Point(totalX, totalY);
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText(traceName + " is meant only to run with FeaturePoly_Basics to validate the translation", 3);
                return;
            }
            dst2.SetTo(new cv.Scalar(0));
            dst3.SetTo(new cv.Scalar(0));
            List<Point2f> rotateAndShift = new List<Point2f>();
            centerShift = shiftPoly(polyPrev, poly);
            DrawFPoly(ref dst2, polyPrev, new cv.Scalar(255));
            DrawFPoly(ref dst2, rotatePoly.poly, new cv.Scalar(255, 255, 0));
            for (int i = 0; i < polyPrev.Count; i++)
            {
                cv.Point2f p1 = new cv.Point(rotatePoly.poly[i].X - centerShift.X, rotatePoly.poly[i].Y - centerShift.Y);
                cv.Point p2 = new cv.Point(rotatePoly.poly[(i + 1) % task.polyCount].X - centerShift.X, rotatePoly.poly[(i + 1) % task.polyCount].Y - centerShift.Y);
                rotateAndShift.Add(p1);
                SetTrueText(i.ToString(), rotatePoly.poly[i], 2);
                SetTrueText(i.ToString(), polyPrev[i], 2);
            }
            DrawFPoly(ref dst3, polyPrev, new cv.Scalar(255));
            DrawFPoly(ref dst3, rotateAndShift, new cv.Scalar(255, 255, 0));
            strOut = "After Rotation: " + rotatePoly.rotateAngle.ToString("F2") + " degrees " +
                     "After Translation (shift) of: " + centerShift.X.ToString("F2") + ", " + centerShift.Y.ToString("F2") + "\r\n" +
                     "Center of Rotation: " + rotateCenter.X.ToString("F2") + ", " + rotateCenter.Y.ToString("F2") + "\r\n" +
                     "If the algorithm is working properly, the white and yellow Feature polygons below " + "\r\n" +
                     "should match in size and location.";
            SetTrueText(strOut, 3);
        }
    }
    public class CS_FeaturePoly_WarpAffineImage : CS_Parent
    {
        WarpAffine_BasicsQT warp = new WarpAffine_BasicsQT();
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        public CS_FeaturePoly_WarpAffineImage(VBtask task) : base(task)
        {
            if (standaloneTest())
                task.gOptions.setDisplay1();
            desc = "Use OpenCV's WarpAffine to rotate and translate the starting image.";
        }
        public void RunCS(Mat src)
        {
            fPoly.Run(src);
            warp.rotateCenter = fPoly.fPD.rotateCenter;
            warp.rotateAngle = fPoly.fPD.rotateAngle;
            warp.Run(fPoly.resyncImage.Clone());
            dst2 = warp.dst2;
            dst1 = fPoly.dst1;
            cv.Point2f offset = fPoly.fPD.centerShift;
            Rect r1 = new Rect((int)offset.X, (int)offset.Y, (int)(dst2.Width - Math.Abs(offset.X)), (int)(dst2.Height - Math.Abs(offset.Y)));
            if (offset.X < 0) r1.X = 0;
            if (offset.Y < 0) r1.Y = 0;
            Rect r2 = new Rect((int)Math.Abs(offset.X), (int)Math.Abs(offset.Y), r1.Width, r1.Height);
            if (offset.X > 0) r2.X = 0;
            if (offset.Y > 0) r2.Y = 0;
            dst3[r1] = dst2[r2];
            dst3 = src - dst2;
            Mat tmp = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            Mat changed = tmp.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            int diffCount = changed.CountNonZero();
            strOut = fPoly.strOut;
            strOut += "\n" + string.Format("{0:N0}k pixels differ or {1:P0}", diffCount / 1000.0, (double)diffCount / dst3.Total());
            SetTrueText(strOut, 1);
        }
    }
    public class CS_FeaturePoly_Perpendiculars : CS_Parent
    {
        public Point2f altCenterShift;
        public fPolyData fPD;
        public FeaturePoly_RotatePoints rotatePoints = new FeaturePoly_RotatePoints();
        Line_Nearest near = new Line_Nearest();
        public CS_FeaturePoly_Perpendiculars(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Output of FeaturePoly_Basics", "Center of rotation is where the extended lines intersect" };
            desc = "Find the center of rotation using the perpendicular lines from polymp and FLine (feature line) in FeaturePoly_Basics";
        }
        float findrotateAngle(Point2f p1, Point2f p2, Point2f pt)
        {
            near.lp = new PointPair(p1, p2);
            near.pt = pt;
            near.Run(empty);
            DrawLine(dst2, pt, near.nearPoint, Scalar.Red, task.lineWidth);
            double d1 = fPD.rotateCenter.DistanceTo(pt);
            double d2 = fPD.rotateCenter.DistanceTo(near.nearPoint);
            double angle = Math.Asin(near.nearPoint.DistanceTo(pt) / (d1 > d2 ? d1 : d2));
            if (double.IsNaN(angle)) return 0;
            return (float)angle;
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().");
                return;
            }
            Kalman_Basics kalman = new Kalman_Basics();
            Line_Perpendicular perp1 = new Line_Perpendicular();
            Line_Perpendicular perp2 = new Line_Perpendicular();
            dst2.SetTo(0);
            perp1.p1 = fPD.currPoly[fPD.polyPrevSideIndex];
            perp1.p2 = fPD.currPoly[(fPD.polyPrevSideIndex + 1) % task.polyCount];
            perp1.Run(empty);
            DrawLine(dst2, perp1.r1, perp1.r2, Scalar.Yellow, task.lineWidth);
            perp2.p1 = fPD.prevPoly[fPD.polyPrevSideIndex];
            perp2.p2 = fPD.prevPoly[(fPD.polyPrevSideIndex + 1) % task.polyCount];
            perp2.Run(empty);
            DrawLine(dst2, perp2.r1, perp2.r2, Scalar.White, task.lineWidth);
            fPD.rotateCenter = IntersectTest(perp2.r1, perp2.r2, perp1.r1, perp1.r2, new Rect(0, 0, src.Width, src.Height));
            if (fPD.rotateCenter == new Point2f())
            {
                fPD.rotateAngle = 0;
            }
            else
            {
                DrawCircle(dst2, fPD.rotateCenter, task.DotSize + 2, Scalar.Red);
                fPD.rotateAngle = findrotateAngle(perp2.r1, perp2.r2, perp1.r1);
            }
            if (fPD.rotateAngle == 0) fPD.rotateCenter = new Point2f();
            altCenterShift = new Point2f(fPD.currPoly[fPD.polyPrevSideIndex].X - fPD.prevPoly[fPD.polyPrevSideIndex].X,
                                         fPD.currPoly[fPD.polyPrevSideIndex].Y - fPD.prevPoly[fPD.polyPrevSideIndex].Y);
            kalman.kInput = new float[] { fPD.rotateAngle };
            kalman.Run(empty);
            fPD.rotateAngle = kalman.kOutput[0];
            rotatePoints.poly = fPD.currPoly;
            rotatePoints.polyPrev = fPD.prevPoly;
            rotatePoints.polyPrevSideIndex = fPD.polyPrevSideIndex;
            rotatePoints.rotateAngle = fPD.rotateAngle;
            rotatePoints.Run(src);
            fPD.centerShift = rotatePoints.centerShift;
            dst3 = rotatePoints.dst3;
        }
    }
    public class CS_FeaturePoly_PerpendicularsTest : CS_Parent
    {
        FeaturePoly_Perpendiculars center = new FeaturePoly_Perpendiculars();
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        public CS_FeaturePoly_PerpendicularsTest(VBtask task) : base(task)
        {
            fPoly.center = center;
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Test the perpendicular method of finding the rotate center of the Feature Polygon";
        }
        public void RunCS(Mat src)
        {
            fPoly.Run(src);
            dst1 = fPoly.dst1;
            dst2 = fPoly.dst2;
            dst3 = fPoly.dst3;
        }
    }
    public class CS_FeaturePoly_PerpendicularsImage : CS_Parent
    {
        FeaturePoly_Perpendiculars center = new FeaturePoly_Perpendiculars();
        FeaturePoly_Image fImage = new FeaturePoly_Image();
        public CS_FeaturePoly_PerpendicularsImage(VBtask task) : base(task)
        {
            fImage.fpoly.center = center;
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Rotate the image using the perpendicular method of finding the rotate center";
        }
        public void RunCS(Mat src)
        {
            fImage.Run(src);
            dst1 = fImage.dst1;
            dst2 = fImage.dst2;
            dst3 = fImage.dst3;
        }
    }
    public class CS_FeaturePoly_Image : CS_Parent
    {
        public FeaturePoly_BasicsOriginal fpoly = new FeaturePoly_BasicsOriginal();
        Rotate_BasicsQT rotate = new Rotate_BasicsQT();
        public bool resync;
        public CS_FeaturePoly_Image(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature polygon alignment, White is original, Yellow is current, Red Dot (if present) is center of rotation",
                                "Resync Image after rotation and translation", "Difference between current image and dst2" };
            desc = "Rotate and shift the image as indicated by FeaturePoly_Basics";
        }
        public void RunCS(Mat src)
        {
            Mat input = src.Clone();
            fpoly.Run(src);
            dst1 = fpoly.dst1;
            if (!fpoly.resync)
            {
                if (!fpoly.fPD.featureLineChanged)
                {
                    dst2.SetTo(0);
                    dst3.SetTo(0);
                    rotate.rotateAngle = fpoly.fPD.rotateAngle;
                    rotate.rotateCenter = fpoly.fPD.rotateCenter;
                    rotate.Run(fpoly.resyncImage);
                    dst0 = rotate.dst2;
                    Point2f offset = fpoly.fPD.centerShift;
                    Rect r1 = new Rect((int)offset.X, (int)offset.Y, dst2.Width - Math.Abs((int)offset.X), dst2.Height - Math.Abs((int)offset.Y));
                    r1 = ValidateRect(r1);
                    if (offset.X < 0) r1.X = 0;
                    if (offset.Y < 0) r1.Y = 0;
                    Rect r2 = new Rect(Math.Abs((int)offset.X), Math.Abs((int)offset.Y), r1.Width, r1.Height);
                    r2.Width = r1.Width;
                    r2.Height = r1.Height;
                    if (r2.X < 0 || r2.X >= dst2.Width) return; // wedged...
                    if (r2.Y < 0 || r2.Y >= dst2.Height) return; // wedged...
                    if (offset.X > 0) r2.X = 0;
                    if (offset.Y > 0) r2.Y = 0;
                    Mat mask2 = new Mat(dst2.Size(), MatType.CV_8U, 255);
                    rotate.Run(mask2);
                    mask2 = rotate.dst2;
                    Mat mask = new Mat(dst2.Size(), MatType.CV_8U, 0);
                    mask[r1].SetTo(255);
                    mask[r1] = mask2[r2];
                    mask = ~mask;
                    dst2[r1] = dst0[r2];
                    dst3 = input - dst2;
                    dst3.SetTo(0, mask);
                }
                Mat tmp = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
                Mat changed = tmp.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
                int diffCount = changed.CountNonZero();
                resync = fpoly.resync;
                fpoly.maskChangePercent = (float)diffCount / dst3.Total();
                strOut = fpoly.strOut;
                strOut += "\n" + string.Format("{0:N0}k pixels differ or {1:P0}", diffCount / 1000.0, fpoly.maskChangePercent);
            }
            else
            {
                dst2 = fpoly.resyncImage.Clone();
                dst3.SetTo(0);
            }
            SetTrueText(strOut, 1);
        }
    }
    public class CS_FeaturePoly_ImageMask : CS_Parent
    {
        public FeaturePoly_Image fImage = new FeaturePoly_Image();
        public CS_FeaturePoly_ImageMask(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.gOptions.pixelDiffThreshold = 10;
            desc = "Build the image mask of the differences between the current frame and resync image";
        }
        public void RunCS(Mat src)
        {
            fImage.Run(src);
            dst2 = fImage.dst3;
            dst0 = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            dst3 = dst0.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
            labels = fImage.labels;
            dst1 = fImage.fpoly.dst1;
            SetTrueText(fImage.strOut, 1);
        }
    }
    public class CS_FeaturePoly_PointCloud : CS_Parent
    {
        public FeaturePoly_ImageMask fMask = new FeaturePoly_ImageMask();
        public Mat fPolyCloud;
        public CS_FeaturePoly_PointCloud(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Update changed point cloud pixels as indicated by the FeaturePoly_ImageMask";
        }
        public void RunCS(Mat src)
        {
            fMask.Run(src);
            if (fMask.fImage.fpoly.resync || task.FirstPass) fPolyCloud = task.pointCloud.Clone();
            dst1 = fMask.dst1;
            dst2 = fMask.dst2;
            dst3 = fMask.dst3;
            task.pointCloud.CopyTo(fPolyCloud, dst3);
            SetTrueText(fMask.fImage.strOut, 1);
        }
    }
    public class CS_FeaturePoly_ResyncCheck : CS_Parent
    {
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        int lastPixelCount = 0;
        public CS_FeaturePoly_ResyncCheck(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "If there was no resync, check the longest side of the feature polygon (Feature Line) for unnecessary jitter.";
        }
        public void RunCS(Mat src)
        {
            fPoly.Run(src);
            dst2 = fPoly.dst1;
            SetTrueText(fPoly.strOut, 2);
            if (fPoly.resync)
            {
                dst3.SetTo(0);
                lastPixelCount = 0;
            }
            if (fPoly.fPD.currPoly.Count < 2) return; // polygon not found...
            var polymp = fPoly.fPD.currmp();
            DrawLine(dst3, polymp.p1, polymp.p2, new Scalar(255), 1);
            int pixelCount = Cv2.CountNonZero(dst3);
            SetTrueText($"{Math.Abs(lastPixelCount - pixelCount)} pixels ", 3);
            lastPixelCount = pixelCount;
        }
    }
    public class CS_FeaturePoly_Center : CS_Parent
    {
        public Rotate_PolyQT rotatePoly = new Rotate_PolyQT();
        Line_Nearest near = new Line_Nearest();
        public fPolyData fPD;
        List<Point2f> newPoly;
        public CS_FeaturePoly_Center(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Layout of feature polygons after just translation - red line is used in sine computation",
                      "Layout of the starting (white) and current (yellow) feature polygons",
                      "Layout of feature polygons after rotation and translation" };
            desc = "Manually rotate and translate the current feature polygon to a previous feature polygon.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText(traceName + " is called by FeaturePoly_Basics to get the rotate center and angle." + "\n" +
                            "It does not produce any output when run standaloneTest().");
                return;
            }
            var thresholdSlider = FindSlider("Resync if feature moves > X pixels");
            float threshold = thresholdSlider.Value;
            int sindex1 = fPD.polyPrevSideIndex;
            int sIndex2 = (sindex1 + 1) % task.polyCount;
            var mp1 = fPD.currmp();
            var mp2 = fPD.prevmp();
            float d1 = (float) mp1.p1.DistanceTo(mp2.p1);
            float d2 = (float) mp1.p2.DistanceTo(mp2.p2);
            PointPair newNear;
            if (d1 < d2)
            {
                fPD.centerShift = new Point2f(mp1.p1.X - mp2.p1.X, mp1.p1.Y - mp2.p1.Y);
                fPD.rotateCenter = mp1.p1;
                newNear = new PointPair(mp1.p2, mp2.p2);
            }
            else
            {
                fPD.centerShift = new Point2f(mp1.p2.X - mp2.p2.X, mp1.p2.Y - mp2.p2.Y);
                fPD.rotateCenter = mp1.p2;
                newNear = new PointPair(mp1.p1, mp2.p1);
            }
            var transPoly = new List<Point2f>();
            foreach (var point in fPD.currPoly)
            {
                transPoly.Add(new Point2f(point.X - fPD.centerShift.X, point.Y - fPD.centerShift.Y));
            }
            newNear.p1 = new Point2f(newNear.p1.X - fPD.centerShift.X, newNear.p1.Y - fPD.centerShift.Y);
            newNear.p2 = new Point2f(newNear.p2.X - fPD.centerShift.X, newNear.p2.Y - fPD.centerShift.Y);
            fPD.rotateCenter = new Point2f(fPD.rotateCenter.X - fPD.centerShift.X, fPD.rotateCenter.Y - fPD.centerShift.Y);
            dst1.SetTo(0);
            fPD.DrawPolys(dst1, transPoly, this);
            SetTrueText("Rotate center", fPD.rotateCenter, 1);
            strOut = "No rotation" + "\n";
            fPD.rotateAngle = 0;
            if (d1 != d2)
            {
                if (newNear.p1.DistanceTo(newNear.p2) > threshold)
                {
                    near.lp = new PointPair(fPD.prevPoly[sindex1], fPD.prevPoly[sIndex2]);
                    near.pt = newNear.p1;
                    near.Run(new Mat());
                    DrawLine(dst1, near.pt, near.nearPoint, new Scalar(0, 0, 255), task.lineWidth + 5);
                    float hypotenuse = (float) fPD.rotateCenter.DistanceTo(near.pt);
                    fPD.rotateAngle = -(float)Math.Asin(near.nearPoint.DistanceTo(near.pt) / hypotenuse);
                    if (float.IsNaN(fPD.rotateAngle)) fPD.rotateAngle = 0;
                    strOut = $"Angle is {fPD.rotateAngle * 57.2958:F1} degrees" + "\n";
                }
            }
            strOut += $"Translation (shift) is {-fPD.centerShift.X:F0}, {-fPD.centerShift.Y:F0}";
            if (Math.Abs(fPD.rotateAngle) > 0)
            {
                rotatePoly.rotateCenter = fPD.rotateCenter;
                rotatePoly.rotateAngle = fPD.rotateAngle;
                rotatePoly.poly.Clear();
                rotatePoly.poly.Add(newNear.p1);
                rotatePoly.Run(new Mat());
                if (near.nearPoint.DistanceTo(rotatePoly.poly[0]) > newNear.p1.DistanceTo(rotatePoly.poly[0])) fPD.rotateAngle *= -1;
                rotatePoly.rotateAngle = fPD.rotateAngle;
                rotatePoly.poly = new List<Point2f>(transPoly);
                rotatePoly.Run(new Mat());
                newPoly = new List<Point2f>(rotatePoly.poly);
            }
            dst3.SetTo(0);
            fPD.DrawPolys(dst3, fPD.currPoly, this);
            SetTrueText(strOut, 2);
        }
    }
    public class CS_FeaturePoly_EdgeRemoval : CS_Parent
    {
        FeaturePoly_ImageMask fMask = new FeaturePoly_ImageMask();
        Edge_All edges = new Edge_All();
        public CS_FeaturePoly_EdgeRemoval(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Remove edges from the FeaturePoly_ImageMask";
        }
        public void RunCS(Mat src)
        {
            fMask.Run(src);
            dst2 = fMask.dst3;
            edges.Run(src);
            dst1 = edges.dst2;
            dst3 = dst2 & ~dst1;
        }
    }
    public class CS_FeaturePoly_ImageNew : CS_Parent
    {
        public FeaturePoly_Basics fpoly = new FeaturePoly_Basics();
        Rotate_BasicsQT rotate = new Rotate_BasicsQT();
        public bool resync;
        public CS_FeaturePoly_ImageNew(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Feature polygon alignment, White is original, Yellow is current, Red Dot (if present) is center of rotation",
                  "Resync Image after rotation and translation", "Difference between current image and dst2" };
            desc = "Rotate and shift the image as indicated by FeaturePoly_Basics";
        }
        public void RunCS(Mat src)
        {
            Mat input = src.Clone();
            fpoly.Run(src);
            dst1 = fpoly.dst3;
            if (!fpoly.resync)
            {
                dst2.SetTo(0);
                dst3.SetTo(0);
                rotate.rotateAngle = fpoly.sides.rotateAngle;
                rotate.rotateCenter = fpoly.sides.rotateCenter;
                rotate.Run(fpoly.sides.prevImage);
                dst0 = rotate.dst2;
                Point2f offset = fpoly.sides.centerShift;
                Rect r1 = new Rect((int)offset.X, (int)offset.Y, dst2.Width - Math.Abs((int)offset.X), dst2.Height - Math.Abs((int)offset.Y));
                if (offset.X < 0) r1.X = 0;
                if (offset.Y < 0) r1.Y = 0;
                Rect r2 = new Rect(Math.Abs((int)offset.X), Math.Abs((int)offset.Y), r1.Width, r1.Height);
                if (offset.X > 0) r2.X = 0;
                if (offset.Y > 0) r2.Y = 0;
                Mat mask2 = new Mat(dst2.Size(), MatType.CV_8U, 255);
                rotate.Run(mask2);
                mask2 = rotate.dst2;
                Mat mask = new Mat(dst2.Size(), MatType.CV_8U, 0);
                mask[r1].SetTo(255);
                mask[r1] = mask2[r2];
                Cv2.BitwiseNot(mask, mask);
                dst0[r2].CopyTo(dst2[r1]);
                Cv2.Subtract(input, dst2, dst3);
                dst3.SetTo(0, mask);
                Mat tmp = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
                Mat changed = tmp.Threshold(task.gOptions.pixelDiffThreshold, 255, ThresholdTypes.Binary);
                int diffCount = Cv2.CountNonZero(changed);
                resync = fpoly.resync;
                fpoly.maskChangePercent = (float)diffCount / dst3.Total();
                strOut = fpoly.strOut;
                strOut += "\n" + string.Format("{0:N0}k pixels differ or {1:P0}", diffCount / 1000.0, fpoly.maskChangePercent);
            }
            else
            {
                dst2 = fpoly.sides.prevImage.Clone();
                dst3.SetTo(0);
            }
            SetTrueText(strOut, 1);
        }
    }
    public class CS_FeaturePoly_LeftRight : CS_Parent
    {
        FeaturePoly_Basics leftPoly = new FeaturePoly_Basics();
        FeaturePoly_Basics rightPoly = new FeaturePoly_Basics();
        public CS_FeaturePoly_LeftRight(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "Left image", "Right image", "FPoly output for left image", "FPoly output for right image" };
            desc = "Measure camera motion through the left and right images using FPoly";
        }
        public void RunCS(Mat src)
        {
            dst0 = task.leftView;
            dst1 = task.rightView;
            leftPoly.Run(task.leftView);
            dst2 = leftPoly.dst3;
            SetTrueText(leftPoly.strOut, 2);
            rightPoly.Run(task.rightView);
            dst3 = rightPoly.dst3;
            SetTrueText(rightPoly.strOut, 3);
        }
    }


    public class CS_FeaturePoly_Core : CS_Parent
    {
        public Stable_GoodFeatures stable = new Stable_GoodFeatures();
        public Point2f anchor;
        public Point2f startAnchor;
        public List<Point2f> goodPoints = new List<Point2f>();
        public List<List<Point>> goodFacets = new List<List<Point>>();
        Options_FPoly options = new Options_FPoly();
        Options_FPolyCore optionsCore = new Options_FPolyCore();
        public CS_FeaturePoly_Core(VBtask task) : base(task)
        {
            dst0 = new Mat(dst0.Size(), MatType.CV_32F, 0);
            FindSlider("Feature Sample Size").Value = 20;
            labels = new string[] { "", "Distance change from previous frame", "", "Feature Grid with anchor" };
            desc = "Feature Grid: compute distances between good features from frame to frame";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            optionsCore.RunVB();

            stable.Run(src);
            dst3 = stable.basics.dst3;
            Mat lastDistance = dst0.Clone();
            anchor = stable.basics.anchorPoint;
            Point2f lastAnchor = anchor;
            if (lastAnchor.DistanceTo(anchor) > optionsCore.anchorMovement)
                lastDistance.SetTo(0);
            dst0.SetTo(0);
            goodPoints.Clear();
            goodFacets.Clear();
            dst2.SetTo(0);
            cv.Vec3b white = new cv.Vec3b(255, 255, 255);
            for (int i = 0; i < stable.basics.facetGen.facet.facetList.Count; i++)
            {
                List<Point> facet = stable.basics.facetGen.facet.facetList[i];
                Point2f pt = stable.basics.ptList[i];
                double d = anchor.DistanceTo(pt);
                dst0.FillConvexPoly(facet, d, task.lineType);
                float lastd = lastDistance.Get<float>((int)pt.Y, (int)pt.X);
                double absDiff = Math.Abs(lastd - d);
                if (absDiff < optionsCore.resyncThreshold)
                {
                    goodPoints.Add(pt);
                    goodFacets.Add(facet);
                    SetTrueText(pt.ToString(), pt, 2);
                    Cv2.Line(dst3, anchor.ToPoint(), pt.ToPoint(), task.HighlightColor);
                    dst2.Set<Vec3b>((int)pt.Y, (int)pt.X, white);
                }
            }
            Point2f shift = new Point2f(startAnchor.X - anchor.X, startAnchor.Y - anchor.Y);
            if (goodPoints.Count == 0 || Math.Abs(shift.X) > optionsCore.maxShift || Math.Abs(shift.Y) > optionsCore.maxShift)
                startAnchor = anchor;
            labels[2] = "Distance change (after threshholding) since last reset = " + shift.ToString();
            lastAnchor = anchor;
        }
    }



    public class CS_FeatureROI_Basics : CS_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public List<Rect> rects = new List<Rect>();
        public List<float> meanList = new List<float>();
        public List<float> stdevList = new List<float>();
        public float stdevAverage;
        public CS_FeatureROI_Basics(VBtask task) : base(task)
        {
            task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "Use roi's to compute the stdev for each roi.  If small (<10), mark as featureLess (white).";
        }
        public void RunCS(Mat src)
        {
            dst1 = src.Channels() != 1 ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            stdevList.Clear();
            meanList.Clear();
            Scalar mean, stdev;
            foreach (var roi in task.gridList)
            {
                Cv2.MeanStdDev(dst1[roi], out mean, out stdev);
                stdevList.Add((float)stdev.Val0);
                meanList.Add((float)mean.Val0);
            }
            stdevAverage = stdevList.Average();
            dst3.SetTo(0);
            rects.Clear();
            for (int i = 0; i < stdevList.Count; i++)
            {
                var roi = task.gridList[i];
                var depthCheck = task.noDepthMask[roi];
                if (stdevList[i] < stdevAverage || depthCheck.CountNonZero() / depthCheck.Total() > 0.5)
                {
                    dst3.Rectangle(roi, Scalar.White, -1);
                }
                else
                {
                    rects.Add(roi);
                }
            }
            if (task.heartBeat)
            {
                labels[2] = $"{rects.Count} of {task.gridList.Count} roi's had above average standard deviation (average = {stdevList.Average().ToString(fmt1)})";
            }
            addw.src2 = dst3;
            addw.Run(dst1);
            dst2 = addw.dst2;
        }
    }
    public class CS_FeatureROI_Color : CS_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public CS_FeatureROI_Color(VBtask task) : base(task)
        {
            FindSlider("Add Weighted %").Value = 70;
            task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "Use roi's to compute the stdev for each roi.  If small (<10), mark as featureLess (white).";
        }
        public void RunCS(Mat src)
        {
            var stdevList0 = new List<float>();
            var stdevList1 = new List<float>();
            var stdevList2 = new List<float>();
            Scalar mean, stdev;
            foreach (var roi in task.gridList)
            {
                Cv2.MeanStdDev(src[roi], out mean, out stdev);
                stdevList0.Add((float)stdev.Val0);
                stdevList1.Add((float)stdev.Val1);
                stdevList2.Add((float)stdev.Val2);
            }
            float avg0 = stdevList0.Average();
            float avg1 = stdevList1.Average();
            float avg2 = stdevList2.Average();
            dst3.SetTo(0);
            for (int i = 0; i < stdevList0.Count; i++)
            {
                var roi = task.gridList[i];
                if (stdevList0[i] < avg0 && stdevList1[i] < avg1 && stdevList2[i] < avg2)
                {
                    dst3.Rectangle(roi, Scalar.White, -1);
                }
            }
            labels[3] = $"Stdev average X/Y/Z = {(int)stdevList0.Average()}, {(int)stdevList1.Average()}, {(int)stdevList2.Average()}";
            addw.src2 = dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            addw.Run(src);
            dst2 = addw.dst2;
        }
    }
    public class CS_FeatureROI_Canny : CS_Parent
    {
        Edge_Canny canny = new Edge_Canny();
        FeatureROI_Basics devGrid = new FeatureROI_Basics();
        public CS_FeatureROI_Canny(VBtask task) : base(task)
        {
            task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            desc = "Create the stdev grid with the input image, then create the stdev grid for the canny output, then combine them.";
        }
        public void RunCS(Mat src)
        {
            canny.Run(src);
            dst3 = canny.dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
            devGrid.Run(src | dst3);
            dst2 = devGrid.dst2;
        }
    }
    public class CS_FeatureROI_Sorted : CS_Parent
    {
        AddWeighted_Basics addw = new AddWeighted_Basics();
        public SortedList<float, Rect> sortedStd = new SortedList<float, Rect>(new compareAllowIdenticalSingle());
        public List<Vec3b> bgrList = new List<Vec3b>();
        public List<Rect> roiList = new List<Rect>();
        public int[] categories;
        public Options_StdevGrid options = new Options_StdevGrid();
        public int maskVal = 255;
        public CS_FeatureROI_Sorted(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            if (!standalone) maskVal = 1;
            labels[2] = "Use the AddWeighted slider to observe where stdev is above average.";
            desc = "Sort the roi's by the sum of their bgr stdev's to find the least volatile regions";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Scalar meanS, stdev;
            sortedStd.Clear();
            bgrList.Clear();
            roiList.Clear();
            categories = new int[10];
            foreach (var roi in task.gridList)
            {
                Cv2.MeanStdDev(src[roi], out meanS, out stdev);
                sortedStd.Add((float)(stdev.Val0 + stdev.Val1 + stdev.Val2), roi);
                int colorIndex = 1;
                Vec3i mean = new Vec3i((int)meanS.Val0, (int)meanS.Val1, (int)meanS.Val2);
                if (mean.Item0 < options.minThreshold && mean.Item1 < options.minThreshold && mean.Item2 < options.minThreshold)
                    colorIndex = 1;
                else if (mean.Item0 > options.maxThreshold && mean.Item1 > options.maxThreshold && mean.Item2 > options.maxThreshold)
                    colorIndex = 2;
                else if (Math.Abs(mean.Item0 - mean.Item1) < options.diffThreshold && Math.Abs(mean.Item1 - mean.Item2) < options.diffThreshold)
                    colorIndex = 3;
                else if (Math.Abs(mean.Item1 - mean.Item2) < options.diffThreshold)
                    colorIndex = 4;
                else if (Math.Abs(mean.Item0 - mean.Item2) < options.diffThreshold)
                    colorIndex = 5;
                else if (Math.Abs(mean.Item0 - mean.Item1) < options.diffThreshold)
                    colorIndex = 6;
                else if (Math.Abs(mean.Item0 - mean.Item1) > options.diffThreshold && Math.Abs(mean.Item0 - mean.Item2) > options.diffThreshold)
                    colorIndex = 7;
                else if (Math.Abs(mean.Item1 - mean.Item0) > options.diffThreshold && Math.Abs(mean.Item1 - mean.Item2) > options.diffThreshold)
                    colorIndex = 8;
                else if (Math.Abs(mean.Item2 - mean.Item0) > options.diffThreshold && Math.Abs(mean.Item2 - mean.Item1) > options.diffThreshold)
                    colorIndex = 9;

                Vec3b color = black;
                if (colorIndex == 1) color = black;
                if (colorIndex == 2) color = white;
                if (colorIndex == 3) color = grayColor;
                if (colorIndex == 4) color = yellow;
                if (colorIndex == 5) color = purple;
                if (colorIndex == 6) color = teal;
                if (colorIndex == 7) color = blue;
                if (colorIndex == 8) color = green;
                if (colorIndex == 9) color = red;

                categories[colorIndex]++;
                bgrList.Add(color);
                roiList.Add(roi);
            }
            float avg = sortedStd.Keys.Average();
            int count = 0;
            dst2.SetTo(0);
            for (int i = 0; i < sortedStd.Count; i++)
            {
                float nextStdev = sortedStd.ElementAt(i).Key;
                if (nextStdev < avg)
                {
                    Rect roi = sortedStd.ElementAt(i).Value;
                    dst2[roi].SetTo(maskVal);
                    count++;
                }
            }
            if (standaloneTest())
            {
                addw.src2 = dst2.CvtColor(ColorConversionCodes.GRAY2BGR);
                addw.Run(src);
                dst3 = addw.dst2;
            }
            labels[3] = $"{count} roi's or {(float)count / sortedStd.Count:P0} have an average stdev sum of {avg.ToString(fmt1)} or less";
        }
    }
    public class CS_FeatureROI_ColorSplit : CS_Parent
    {
        FeatureROI_Sorted devGrid = new FeatureROI_Sorted();
        public CS_FeatureROI_ColorSplit(VBtask task) : base(task)
        {
            devGrid.maskVal = 255;
            task.gOptions.setGridSize((int)(dst2.Width / 40)); // arbitrary but the goal is to get a reasonable (< 500) number of roi's.
            desc = "Split each roi into one of 9 categories - black, white, gray, yellow, purple, teal, blue, green, or red - based on the stdev for the roi";
        }
        public void RunCS(Mat src)
        {
            devGrid.Run(src);
            for (int i = 0; i < devGrid.bgrList.Count; i++)
            {
                Rect roi = devGrid.roiList[i];
                Vec3b color = devGrid.bgrList[i];
                dst2[roi].SetTo(color);
            }
            dst2.SetTo(0, ~devGrid.dst2);
            string strOut = "Categories:\n";
            for (int i = 1; i < devGrid.categories.Length; i++)
            {
                string colorName ="black";
                if (i == 1) colorName = "black";
                if (i == 2) colorName = "white";
                if (i == 3) colorName = "gray";
                if (i == 4) colorName = "yellow";
                if (i == 5) colorName = "purple";
                if (i == 6) colorName = "blue";
                if (i == 7) colorName = "red";

                strOut += $"{colorName}\t{devGrid.categories[i]}\n";
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_FeatureROI_Correlation : CS_Parent
    {
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public Plot_OverTimeSingle plot = new Plot_OverTimeSingle();
        public Options_Features options = new Options_Features();
        Mat lastImage;
        public CS_FeatureROI_Correlation(VBtask task) : base(task)
        {
            FindSlider("Feature Correlation Threshold").Value = 90;
            desc = "Use the grid-based correlations with the previous image to determine if there was camera motion";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst1 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            gather.Run(dst1);
            dst2 = gather.dst2;
            if (task.FirstPass) lastImage = dst1.Clone();
            Mat correlationMat = new Mat();
            int motionCount = 0;
            for (int i = 0; i < gather.stdevList.Count; i++)
            {
                Rect roi = task.gridList[i];
                if (gather.stdevList[i] >= gather.stdevAverage)
                {
                    Cv2.MatchTemplate(dst1[roi], lastImage[roi], correlationMat, TemplateMatchModes.CCoeffNormed);
                    float corr = correlationMat.Get<float>(0, 0);
                    if (corr < options.correlationMin) SetTrueText(corr.ToString("F3"), roi.TopLeft);
                    if (corr < options.correlationMin) motionCount++;
                }
            }
            plot.plotData = motionCount;
            plot.min = -1;
            plot.Run(empty);
            dst3 = plot.dst2;
            labels[2] = gather.rects.Count + " of " + task.gridList.Count + " roi's had above average standard deviation.";
            lastImage = dst1.Clone();
        }
    }
    public class CS_FeatureROI_LowStdev : CS_Parent
    {
        public List<Rect> rects = new List<Rect>();
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public CS_FeatureROI_LowStdev(VBtask task) : base(task)
        {
            desc = "Isolate the roi's with low stdev";
        }
        public void RunCS(Mat src)
        {
            dst1 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            gather.Run(dst1);
            dst2 = gather.dst2;
            rects.Clear();
            for (int i = 0; i < gather.stdevList.Count; i++)
            {
                Rect roi = task.gridList[i];
                if (gather.stdevList[i] < gather.stdevAverage)
                {
                    rects.Add(roi);
                    SetTrueText(gather.stdevList[i].ToString("F3"), roi.TopLeft, 3);
                }
            }
            if (task.heartBeat) labels = new string[] { "", "", (task.gridList.Count - gather.rects.Count).ToString() + " roi's had low standard deviation ", "Stdev average = " + gather.stdevList.Average().ToString("F3") };
        }
    }
    public class CS_FeatureROI_LowStdevCorrelation : CS_Parent
    {
        public FeatureROI_LowStdev gather = new FeatureROI_LowStdev();
        public List<float> correlations = new List<float>();
        public Options_Features options = new Options_Features();
        public List<float> saveStdev = new List<float>();
        Mat lastImage;
        List<float> saveCorrs;
        List<Rect> saveRects;
        public CS_FeatureROI_LowStdevCorrelation(VBtask task) : base(task)
        {
            FindSlider("Feature Correlation Threshold").Value = 50;
            desc = "Display the correlation coefficients for roi's with low standard deviation.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst1 = (src.Channels() != 1) ? src.CvtColor(ColorConversionCodes.BGR2GRAY) : src.Clone();
            gather.Run(dst1);
            dst2 = gather.dst2;
            if (task.FirstPass) lastImage = dst1.Clone();
            Mat correlationMat = new Mat();
            correlations.Clear();
            foreach (Rect roi in gather.rects)
            {
                Cv2.MatchTemplate(dst1[roi], lastImage[roi], correlationMat, TemplateMatchModes.CCoeffNormed);
                float corr = correlationMat.Get<float>(0, 0);
                correlations.Add(corr);
            }
            if (task.heartBeat)
            {
                saveCorrs = new List<float>(correlations);
                saveRects = new List<Rect>(gather.rects);
                saveStdev.Clear();
                Scalar mean, stdev;
                for (int i = 0; i < saveRects.Count; i++)
                {
                    Cv2.MeanStdDev(dst1[saveRects[i]], out mean, out stdev);
                    saveStdev.Add((float)stdev[0]);
                }
            }
            for (int i = 0; i < saveRects.Count; i++)
            {
                if (saveCorrs[i] < options.correlationMin) SetTrueText(saveCorrs[i].ToString("F3"), saveRects[i].TopLeft);
                if (saveCorrs[i] < options.correlationMin) SetTrueText(saveStdev[i].ToString("F3"), saveRects[i].TopLeft, 3);
            }
            lastImage = dst1.Clone();
        }
    }
    public class CS_FeatureROI_LR : CS_Parent
    {
        public FeatureROI_Basics gLeft = new FeatureROI_Basics();
        public FeatureROI_Basics gRight = new FeatureROI_Basics();
        public CS_FeatureROI_LR(VBtask task) : base(task)
        {
            desc = "Capture the above average standard deviation roi's for the left and right images.";
        }
        public void RunCS(Mat src)
        {
            gLeft.Run(task.leftView);
            dst2 = gLeft.dst2;
            labels[2] = gLeft.rects.Count + " roi's had above average standard deviation in the left image";
            gRight.Run(task.rightView);
            dst3 = gRight.dst2;
            labels[3] = gRight.rects.Count + " roi's had above average standard deviation in the right image";
        }
    }
    public class CS_FeatureROI_LRClick : CS_Parent
    {
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public cv.Point ClickPoint = new cv.Point();
        public int picTag = 0;
        public Options_Features options = new Options_Features();
        public CS_FeatureROI_LRClick(VBtask task) : base(task)
        {
            task.gOptions.setGridSize(16);
            FindSlider("Feature Correlation Threshold").Value = 80;
            if (standalone) task.gOptions.setDisplay1();
            if (standalone) task.gOptions.setDisplay1();
            labels[2] = "Click the above average stdev roi's (the darker regions) to find corresponding roi in the right image.";
            desc = "Capture the above average standard deviation roi's for the left and right images.";
        }
        public void setClickPoint(Point pt, int _pictag)
        {
            ClickPoint = pt;
            picTag = _pictag;
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            dst0 = src.Clone();
            dst3 = (task.rightView.Channels() != 3) ? task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : task.rightView.Clone();

            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (task.rightView.Channels() != 1) task.rightView = task.rightView.CvtColor(ColorConversionCodes.BGR2GRAY);

            gather.Run(src);
            dst2 = gather.dst2;
            labels = gather.labels;
            if (gather.rects.Count == 0) return;
            if (task.mouseClickFlag) setClickPoint(task.ClickPoint, task.mousePicTag);
            if (ClickPoint == new cv.Point()) setClickPoint(gather.rects[gather.rects.Count / 2].TopLeft, 2);

            int gridIndex = task.gridMap.Get<int>(ClickPoint.Y, ClickPoint.X);
            Rect roi = task.gridList[gridIndex];
            dst2.Rectangle(roi, Scalar.White, task.lineWidth);

            Mat correlationMat = new Mat();
            List<float> corr = new List<float>();
            for (int j = 0; j < roi.X; j++)
            {
                Rect r = new Rect(j, roi.Y, roi.Width, roi.Height);
                Cv2.MatchTemplate(src[roi], task.rightView[r], correlationMat, TemplateMatchModes.CCoeffNormed);
                corr.Add(correlationMat.Get<float>(0, 0));
            }
            if (corr.Count == 0)
            {
                SetTrueText("No corresponding roi found", 2);
            }
            else
            {
                float maxCorr = corr.Max();
                if (maxCorr < options.correlationMin)
                {
                    SetTrueText("Correlation " + maxCorr.ToString("F3") + " is less than " + options.correlationMin.ToString("F3"), 1);
                }
                else
                {
                    int index = corr.IndexOf(maxCorr);
                    Rect rectRight = new Rect(index, roi.Y, roi.Width, roi.Height);
                    int offset = roi.TopLeft.X - rectRight.TopLeft.X;
                    if (task.heartBeat)
                    {
                        strOut = "CoeffNormed max correlation = " + maxCorr.ToString("F3") + "\n";
                        strOut += "Left Mean = " + gather.meanList[gridIndex].ToString("F3") + " Left stdev = " + gather.stdevList[gridIndex].ToString("F3") + "\n";
                        Scalar mean, stdev;
                        Cv2.MeanStdDev(dst3[rectRight], out mean, out stdev);
                        strOut += "Right Mean = " + mean[0].ToString("F3") + " Right stdev = " + stdev[0].ToString("F3") + "\n";
                        strOut += "Right rectangle is offset " + offset.ToString() + " pixels from the left image rectangle";
                    }
                    dst3.Rectangle(rectRight, task.HighlightColor, task.lineWidth);
                    dst0.Rectangle(roi, task.HighlightColor, task.lineWidth);
                    dst1 = Mat.Zeros(src.Size(), src.Type());
                    Cv2.Circle(dst1, roi.TopLeft, task.DotSize, task.HighlightColor, -1);
                    Cv2.Circle(dst1, new cv.Point(rectRight.X, roi.Y + 5), task.DotSize + 2, task.HighlightColor, -1);
                    cv.Point pt = new cv.Point(rectRight.X, roi.Y + 5);
                    SetTrueText((offset + " pixel offset" + "\n" + "Larger = Right").ToString(), pt, 1);
                    SetTrueText(strOut, 1);
                    labels[3] = "Corresponding roi highlighted in yellow.  Average stdev = " + gather.stdevAverage.ToString("F3");
                }
            }
        }
    }
    public class CS_FeatureROI_LRAll : CS_Parent
    {
        public FeatureROI_Basics gather = new FeatureROI_Basics();
        public Options_Features options = new Options_Features();
        public SortedList<float, Rect> sortedRects = new SortedList<float, Rect>(new compareAllowIdenticalSingleInverted());
        public CS_FeatureROI_LRAll(VBtask task) : base(task)
        {
            task.gOptions.setGridSize(16);
            FindSlider("Feature Correlation Threshold").Value = 95;
            labels[3] = "The highlighted roi's are those high stdev roi's with the highest correlation between left and right images.";
            desc = "Find all the roi's with high stdev and high correlation between left and right images.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst3 = (task.rightView.Channels() != 3) ? task.rightView.CvtColor(ColorConversionCodes.GRAY2BGR) : task.rightView.Clone();
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (task.rightView.Channels() != 1) task.rightView = task.rightView.CvtColor(ColorConversionCodes.BGR2GRAY);
            gather.Run(src);
            dst2 = gather.dst2;
            if (gather.rects.Count == 0) return;
            Mat correlationMat = new Mat();
            sortedRects.Clear();
            foreach (Rect roi in gather.rects)
            {
                if (roi.X == 0) continue;
                Rect r = new Rect(0, roi.Y, roi.X, roi.Height);
                Cv2.MatchTemplate(src[roi], task.rightView[r], correlationMat, TemplateMatchModes.CCoeffNormed);
                mmData mm = GetMinMax(correlationMat);
                if (mm.maxVal >= options.correlationMin) sortedRects.Add((float)mm.maxVal, new Rect(mm.maxLoc.X, roi.Y, roi.Width, roi.Height));
            }
            labels[2] = sortedRects.Count + " roi's had left/right correlation higher than " + options.correlationMin.ToString("F3");
            foreach (Rect roi in sortedRects.Values)
            {
                dst3.Rectangle(roi, task.HighlightColor, task.lineWidth);
            }
        }
    }



    public class CS_Fibonacci_Basics : CS_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        double a = 0, b = 1;
        public CS_Fibonacci_Basics(VBtask task) : base(task)
        {
            flow.parentData = this;
            desc = "Generate the fibonacci sequence using conventional code";
        }
        public void RunCS(Mat src)
        {
            if (a == 1134903170)
            {
                a = 0;
                b = 1;
            }
            double t = a + b;
            a = b;
            b = t;
            flow.nextMsg = t.ToString();
            flow.Run(empty);
        }
    }
    public class CS_Fibonacci_Yield : CS_Parent
    {
        Font_FlowText flow = new Font_FlowText();
        public CS_Fibonacci_Yield(VBtask task) : base(task)
        {
            flow.parentData = this;
            desc = "Generate the fibonacci sequence using ienumerable's";
        }
        IEnumerable<double> NextFib()
        {
            double a = 0;
            double b = 1;
            double t;
            while (true)
            {
                yield return a;
                t = a + b;
                if (a == 806515533049393) // start to lose precision after this...
                {
                    a = 0;
                    b = 1;
                    t = a + b;
                }
                a = b;
                b = t;
            }
        }
        public void RunCS(Mat src)
        {
            IEnumerable<double> fibs = NextFib();
            flow.nextMsg = $"{task.frameCount % 74:00} fibonacci number {fibs.ElementAt(task.frameCount):###,##0}";
            flow.Run(empty);
        }
    }


    public class CS_Filter_Laplacian : CS_Parent
    {
        public CS_Filter_Laplacian(VBtask task) : base(task)
        {
            labels[2] = "Sharpened image using Filter2D output";
            labels[3] = "Output of Filter2D (approximated Laplacian)";
            desc = "Use a filter to approximate the Laplacian derivative.";
        }
        public void RunCS(Mat src)
        {
            Mat imgLaplacian = src.Filter2D(MatType.CV_32F,
                new Mat(3, 3, MatType.CV_32FC1, new float[] { 1, 1, 1, 1, -8, 1, 1, 1, 1 }));
            src.ConvertTo(dst1, MatType.CV_32F);
            dst0 = (dst1 - imgLaplacian).ToMat();
            dst0.ConvertTo(dst2, src.Type());
            imgLaplacian.ConvertTo(dst3, src.Type());
        }
    }
    public class CS_Filter_NormalizedKernel : CS_Parent
    {
        Options_FilterNorm options = new Options_FilterNorm();
        public CS_Filter_NormalizedKernel(VBtask task) : base(task)
        {
            desc = "Create a normalized kernel and use it.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            double sum = 0;
            for (int i = 0; i < options.kernel.Width; i++)
            {
                sum += Math.Abs(options.kernel.Get<float>(0, i));
            }
            labels[2] = $"kernel sum = {sum:F3}";
            Mat dst32f = src.Filter2D(MatType.CV_32FC1, options.kernel, anchor: new cv.Point(0, 0));
            dst32f.ConvertTo(dst2, MatType.CV_8UC3);
        }
    }
    public class CS_Filter_Normalized2D : CS_Parent
    {
        Options_Filter options = new Options_Filter();
        public CS_Filter_Normalized2D(VBtask task) : base(task)
        {
            desc = "Create and apply a normalized kernel.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int kernelSize = standaloneTest() ? (task.frameCount % 20) + 1 : options.kernelSize;
            Mat kernel = new Mat(kernelSize, kernelSize, MatType.CV_32F).SetTo(1.0 / (kernelSize * kernelSize));
            dst2 = src.Filter2D(-1, kernel);
            labels[2] = $"Normalized KernelSize = {kernelSize}";
        }
    }
    public class CS_Filter_SepFilter2D : CS_Parent
    {
        Options_SepFilter2D options = new Options_SepFilter2D();
        public CS_Filter_SepFilter2D(VBtask task) : base(task)
        {
            labels[2] = "Gaussian Blur result";
            desc = "Apply kernel X then kernel Y with OpenCV's SepFilter2D and compare to Gaussian blur";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat kernel = Cv2.GetGaussianKernel(options.xDim, options.sigma);
            dst2 = src.GaussianBlur(new cv.Size(options.xDim, options.yDim), options.sigma);
            dst3 = src.SepFilter2D(MatType.CV_8UC3, kernel, kernel);
            if (options.diffCheck)
            {
                Mat graySep = dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
                Mat grayGauss = dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
                dst3 = (graySep - grayGauss).ToMat().Threshold(0, 255, ThresholdTypes.Binary);
                labels[3] = $"Gaussian - SepFilter2D {dst3.CountNonZero()} pixels different.";
            }
            else
            {
                labels[3] = "SepFilter2D Result";
            }
        }
    }
    public class CS_Filter_Minimum : CS_Parent
    {
        Options_Filter options = new Options_Filter();
        public CS_Filter_Minimum(VBtask task) : base(task)
        {
            desc = "Implement the Minimum Filter - use minimum value in kernel";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int kernelSize = standaloneTest() ? (task.frameCount % 20) + 1 : options.kernelSize;
            Mat element = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(kernelSize, kernelSize));
            dst2 = src.Erode(element);
        }
    }
    public class CS_Filter_Maximum : CS_Parent
    {
        Options_Filter options = new Options_Filter();
        public CS_Filter_Maximum(VBtask task) : base(task)
        {
            desc = "Implement the Maximum Filter - use maximum value in kernel";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int kernelSize = standaloneTest() ? (task.frameCount % 20) + 1 : options.kernelSize;
            Mat element = Cv2.GetStructuringElement(MorphShapes.Rect, new cv.Size(kernelSize, kernelSize));
            dst2 = src.Dilate(element);
        }
    }
    public class CS_Filter_Mean : CS_Parent
    {
        Options_Filter options = new Options_Filter();
        public CS_Filter_Mean(VBtask task) : base(task)
        {
            desc = "Implement the Mean Filter - use mean value in kernel";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int kernelSize = standaloneTest() ? (task.frameCount % 20) + 1 : options.kernelSize;
            Mat kernel = (Mat.Ones(MatType.CV_32FC1, kernelSize, kernelSize) / (kernelSize * kernelSize)).ToMat();
            dst2 = src.Filter2D(-1, kernel);
        }
    }
    public class CS_Filter_Median : CS_Parent
    {
        Options_Filter options = new Options_Filter();
        public CS_Filter_Median(VBtask task) : base(task)
        {
            desc = "Implement the Median Filter - use median value in kernel";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int kernelSize = standaloneTest() ? (task.frameCount % 20) + 1 : options.kernelSize;
            if (kernelSize % 2 == 0) kernelSize += 1;
            dst2 = src.MedianBlur(kernelSize);
        }
    }


    public class CS_FitEllipse_Basics : CS_Parent
    {
        Options_MinArea options = new Options_MinArea();
        public List<Point2f> inputPoints = new List<Point2f>();
        public RotatedRect box;
        public Point2f[] vertices;
        public CS_FitEllipse_Basics(VBtask task) : base(task)
        {
            desc = "Use FitEllipse OpenCV API to draw around a set of points";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            if (standaloneTest())
            {
                options.RunVB();
                inputPoints = options.srcPoints;
            }
            dst2.SetTo(0);
            foreach (var pt in inputPoints)
            {
                DrawCircle(dst2, pt, task.DotSize, Scalar.White, -1);
            }
            if (inputPoints.Count > 4)
            {
                box = Cv2.FitEllipse(inputPoints);
                vertices = box.Points();
                if (standaloneTest())
                {
                    for (int j = 0; j < vertices.Length; j++)
                    {
                        DrawLine(dst2, vertices[j], vertices[(j + 1) % 4], Scalar.Green, task.lineWidth);
                    }
                    Cv2.Ellipse(dst2, box, Scalar.Green, task.lineWidth, task.lineType);
                }
            }
        }
    }
    public class CS_FitEllipse_AMS_CPP : CS_Parent
    {
        Options_MinArea options = new Options_MinArea();
        public List<Point2f> inputPoints = new List<Point2f>();
        public CS_FitEllipse_AMS_CPP(VBtask task) : base(task)
        {
            labels[2] = "CS_FitEllipse_AMS_CPP C++ ";
            desc = "Use FitEllipse_AMS to draw around a set of points";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            if (standaloneTest())
            {
                options.RunVB();
                inputPoints = options.srcPoints;
            }
            dst2.SetTo(0);
            foreach (var pt in inputPoints)
            {
                DrawCircle(dst2, pt, task.DotSize, Scalar.White, -1);
            }
            Mat input = new Mat(inputPoints.Count, 1, MatType.CV_32FC2, inputPoints.ToArray());
            float[] dataSrc = new float[inputPoints.Count * 2];
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            GCHandle srcHandle = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr boxPtr = FitEllipse_AMS(srcHandle.AddrOfPinnedObject(), inputPoints.Count);
            srcHandle.Free();
            float[] ellipse = new float[5];
            Marshal.Copy(boxPtr, ellipse, 0, ellipse.Length);
            float angle = ellipse[0];
            Point2f center = new Point2f(ellipse[1], ellipse[2]);
            Size2f size = new Size2f(ellipse[3], ellipse[4]);
            if (size.Width < task.lineWidth + 1 || size.Height < task.lineWidth + 1) return;
            RotatedRect box = new RotatedRect(center, size, angle);
            Cv2.Ellipse(dst2, box, Scalar.Yellow, task.lineWidth, task.lineType);
        }
    }
    public class CS_FitEllipse_Direct_CPP : CS_Parent
    {
        Options_MinArea options = new Options_MinArea();
        public CS_FitEllipse_Direct_CPP(VBtask task) : base(task)
        {
            labels[2] = "The FitEllipse_Direct C++ ";
            desc = "Use FitEllipse to draw around a set of points";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            options.RunVB();
            float[] dataSrc = new float[options.srcPoints.Count * 2];
            dst2.SetTo(0);
            foreach (var pt in options.srcPoints)
            {
                DrawCircle(dst2, pt, task.DotSize, Scalar.White, -1);
            }
            Mat input = new Mat(options.srcPoints.Count, 1, MatType.CV_32FC2, options.srcPoints.ToArray());
            Marshal.Copy(input.Data, dataSrc, 0, dataSrc.Length);
            GCHandle srcHandle = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr boxPtr = FitEllipse_Direct(srcHandle.AddrOfPinnedObject(), options.srcPoints.Count);
            srcHandle.Free();
            float[] ellipse = new float[5];
            Marshal.Copy(boxPtr, ellipse, 0, ellipse.Length);
            float angle = ellipse[0];
            Point2f center = new Point2f(ellipse[1], ellipse[2]);
            Size2f size = new Size2f(ellipse[3], ellipse[4]);
            if (size.Width < task.lineWidth + 1 || size.Height < task.lineWidth + 1) return;
            RotatedRect box = new RotatedRect(center, size, angle);
            Cv2.Ellipse(dst2, box, Scalar.Yellow, task.lineWidth, task.lineType);
        }
    }
    public class CS_FitEllipse_RedCloud : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        FitEllipse_Basics fitE = new FitEllipse_Basics();
        public CS_FitEllipse_RedCloud(VBtask task) : base(task)
        {
            desc = "Create an ellipse from a contour";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            redC.Run(src);
            dst2 = redC.dst2;
            if (task.rc.contour == null) return;
            fitE.inputPoints.Clear();
            foreach (var pt in task.rc.contour)
            {
                fitE.inputPoints.Add(new Point2f(pt.X, pt.Y));
            }
            fitE.Run(new Mat());
            dst3.SetTo(0);
            dst3[task.rc.rect].SetTo(Scalar.White, task.rc.mask);
            Cv2.Rectangle(dst3, task.rc.rect, Scalar.White, task.lineWidth, task.lineType);
            Cv2.Ellipse(dst3[task.rc.rect], fitE.box, Scalar.Yellow, task.lineWidth, task.lineType);
        }
    }


    public class CS_FitLine_Basics : CS_Parent
    {
        Options_FitLine options = new Options_FitLine();
        public Draw_Lines draw = new Draw_Lines();
        public List<Point> lines = new List<Point>(); // there are always an even number - 2 points define the line.
        public CS_FitLine_Basics(VBtask task) : base(task)
        {
            FindSlider("DrawCount").Value = 2;
            labels[3] = "CS_FitLine_Basics input";
            desc = "Show how Fitline API works. When the lines overlap the image has a single contour and the lines are occasionally not found.";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            options.RunVB();
            if (standaloneTest())
            {
                draw.Run(src);
                dst3 = draw.dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(1, 255, ThresholdTypes.Binary);
                dst2 = dst3.CvtColor(ColorConversionCodes.GRAY2BGR);
            }
            else
            {
                lines.Clear();
            }
            Point[][] contours = Cv2.FindContoursAsArray(dst3, RetrievalModes.Tree, ContourApproximationModes.ApproxSimple);
            for (int i = 0; i < contours.Length; i++)
            {
                Point[] tour = contours[i];
                Line2D line2d = Cv2.FitLine(tour, DistanceTypes.L2, 0, options.radiusAccuracy, options.angleAccuracy);
                double slope = line2d.Vy / line2d.Vx;
                int leftY = (int)Math.Round(-line2d.X1 * slope + line2d.Y1);
                int rightY = (int)Math.Round((src.Cols - line2d.X1) * slope + line2d.Y1);
                cv.Point p1 = new cv.Point(0, leftY);
                cv.Point p2 = new cv.Point(src.Cols - 1, rightY);
                if (standaloneTest())
                {
                    lines.Add(p1);
                    lines.Add(p2);
                }
                DrawLine(dst2, p1, p2, Scalar.Red, task.lineWidth);
            }
        }
    }
    public class CS_FitLine_Basics3D : CS_Parent
    {
        Hough_Lines_MT hlines = new Hough_Lines_MT();
        public CS_FitLine_Basics3D(VBtask task) : base(task)
        {
            desc = "Use visual lines to find 3D lines.  This algorithm is NOT working.";
            labels[3] = "White is featureless RGB, blue depth shadow";
        }
        public void houghShowLines3D(Mat dst, Line3D segment)
        {
            double x = segment.X1 * dst.Cols;
            double y = segment.Y1 * dst.Rows;
            double m = segment.Vx < 0.001 ? 0 : segment.Vy / segment.Vx; // vertical slope a no-no.
            double b = y - m * x;
            cv.Point pt1 = new cv.Point(x, y);
            cv.Point pt2 = m == 0 ? new cv.Point(x, dst.Rows) : new cv.Point((dst.Rows - b) / m, dst.Rows);
            DrawLine(dst, pt1, pt2, Scalar.Red, task.lineWidth + 2);
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            hlines.Run(src);
            dst3 = hlines.dst3;
            Mat mask = dst3.CvtColor(ColorConversionCodes.BGR2GRAY).Threshold(1, 255, ThresholdTypes.Binary);
            dst3 = mask.CvtColor(ColorConversionCodes.GRAY2BGR);
            src.CopyTo(dst2);
            List<Line3D> lines = new List<Line3D>();
            Line3D nullLine = new Line3D(0, 0, 0, 0, 0, 0);
            Parallel.ForEach(task.gridList, roi =>
            {
                Mat depth = task.pcSplit[2][roi];
                Mat fMask = mask[roi];
                List<Point3f> points = new List<Point3f>();
                int rows = src.Rows, cols = src.Cols;
                for (int y = 0; y < roi.Height; y++)
                {
                    for (int x = 0; x < roi.Width; x++)
                    {
                        if (fMask.Get<byte>(y, x) > 0)
                        {
                            float d = depth.Get<float>(y, x);
                            if (d > 0 && d < 10000)
                            {
                                points.Add(new Point3f(x / (float)rows, y / (float)cols, d / 10000f));
                            }
                        }
                    }
                }
                Line3D line = nullLine;
                if (points.Count == 0)
                {
                    // save the average color for this roi
                    Scalar mean = task.depthRGB[roi].Mean();
                    mean[0] = 255 - mean[0];
                    Cv2.Rectangle(dst3, roi, mean);
                }
                else
                {
                    line = Cv2.FitLine(points.ToArray(), DistanceTypes.L2, 0, 0, 0.01);
                }
                lock (lines)
                {
                    lines.Add(line);
                }
            });
            // putting this in the parallel for above causes a memory leak - could not find it...
            for (int i = 0; i < task.gridList.Count; i++)
            {
                cv.Rect roi = task.gridList[i];
                houghShowLines3D(dst2[roi], lines[i]);
            }
        }
    }


    public class CS_FLANN_Test : CS_Parent
    {
        public CS_FLANN_Test(VBtask task) : base(task)
        {
            desc = "Test basics of FLANN - Fast Library for Approximate Nearest Neighbor. ";
            labels[2] = "FLANN Basics";
        }
        public void RunCS(Mat src)
        {
            // creates data set
            using (var features = new Mat(10000, 2, MatType.CV_32FC1))
            {
                Cv2.Randu(features, 0, new Random().Next(9900, 10000));
                var queryPoint = new Point2f(new Random().Next(0, 10000), new Random().Next(0, 10000));
                var queries = new Mat(1, 2, MatType.CV_32FC1);
                queries.Set<float>(0, 0, queryPoint.X);
                queries.Set<float>(0, 1, queryPoint.Y);
                // knnSearch
                using (var nnIndex = new cv.Flann.Index(features, new cv.Flann.KDTreeIndexParams(4)))
                {
                    int knn = 1;
                    int[] indices;
                    float[] dists;
                    nnIndex.KnnSearch(queries, out indices, out dists, knn, new cv.Flann.SearchParams(32));
                    var output = "";
                    for (int i = 0; i < knn; i++)
                    {
                        int index = indices[i];
                        float dist = dists[i];
                        var pt = new Point2f(features.Get<float>(index, 0), features.Get<float>(index, 1));
                        output += $"No.{i}\t\n";
                        output += $"index:{index}\n";
                        output += $"distance:{dist}\n";
                        output += $"data:({pt.X}, {pt.Y})\n";
                    }
                    SetTrueText(output);
                }
            }
        }
    }
    public class CS_FLANN_Basics : CS_Parent
    {
        Random_Basics random = new Random_Basics();
        Point2f[] qArray;
        Distance_Point3D dist = new Distance_Point3D();
        Options_FLANN options = new Options_FLANN();
        public CS_FLANN_Basics(VBtask task) : base(task)
        {
            FindSlider("Random Pixel Count").Value = 5;
            desc = "FLANN - Fast Library for Approximate Nearest Neighbor.  Find nearest neighbor";
            labels[2] = "Red is query, Nearest points blue";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (options.reuseData == false || task.frameCount < 2 || task.mouseClickFlag)
                random.Run(empty); // fill result1 with random points in x and y range of the image.
            var features = new Mat(random.PointList.Count, 2, MatType.CV_32F, random.PointList.ToArray());
            int matchCount = Math.Min(options.matchCount, random.PointList.Count - 1);
            dst2.SetTo(Scalar.White);
            for (int i = 0; i < features.Rows; i++)
            {
                var pt = random.PointList[i];
                DrawCircle(dst2, pt, task.DotSize, Scalar.Blue);
            }
            if (options.reuseData == false || task.optionsChanged || task.mouseClickFlag)
            {
                qArray = new Point2f[options.queryCount];
                for (int i = 0; i < options.queryCount; i++)
                {
                    qArray[i] = new Point2f(new Random().Next(0, src.Width), new Random().Next(0, src.Height));
                }
            }
            var queries = new Mat(options.queryCount, 2, MatType.CV_32F, qArray);
            using (var nnIndex = new cv.Flann.Index(features, new cv.Flann.KDTreeIndexParams(matchCount)))
            {
                int[] indices;
                float[] distances;
                for (int i = 0; i < options.queryCount; i++)
                {
                    var pt1 = queries.Get<Point2f>(i);
                    var query = new Mat(1, 2, MatType.CV_32F);
                    query.Set<float>(0, 0, pt1.X);
                    query.Set<float>(0, 1, pt1.Y);
                    nnIndex.KnnSearch(query, out indices, out distances, matchCount, new cv.Flann.SearchParams(options.searchCheck, options.eps, options.sorted));
                    for (int j = 0; j < matchCount; j++)
                    {
                        int index = indices[j];
                        if (index >= 0 && index < random.PointList.Count)
                        {
                            var pt2 = random.PointList[index];
                            DrawLine(dst2, pt1, pt2, Scalar.Red, task.lineWidth);
                        }
                    }
                    DrawCircle(dst2, pt1, task.DotSize, Scalar.Red);
                }
            }
            string output = "FLANN does not appear to be working (most likely, it is my problem) but to show this:\n";
            output += "Set query count to 1 and set to reuse the same data (defaults.)\n";
            output += "The query (in red) is often not picking the nearest blue point.\n";
            output += "To try different inputs, click anywhere in the image.";
            output += "To test further, set the match count to a higher value and observe it will often switch blue dots.\n";
            output += "Play with the EPS and searchparams check count to see if that helps.\n\n";
            output += "If the 'Search check' is set to 25 and the 'Match count' is set to 4, it does appear to return to the top 4.\n";
            output += "Perhaps FLANN is only good enough to find a group of neighbors.  Use with caution.";
            SetTrueText(output, new cv.Point(10, 50), 3);
        }
    }


    public class CS_Flood_Basics : CS_Parent
    {
        RedCloud_CPP redCPP = new RedCloud_CPP();
        public Cell_Generate genCells = new Cell_Generate();
        Color8U_Basics color;
        public CS_Flood_Basics(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            desc = "Build the RedCloud cells with the grayscale input.";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1)
            {
                if (color == null) color = new Color8U_Basics();
                color.Run(src);
                src = color.dst2;
            }
            else
            {
                redCPP.inputMask = src;
            }
            redCPP.Run(src);
            if (redCPP.classCount == 0) return; // no data to process.
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.rectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.removeContour = false;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            task.setSelectedContour();
            labels[2] = genCells.labels[2];
        }
    }
    public class CS_Flood_CellStatsPlot : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Cell_BasicsPlot stats = new Cell_BasicsPlot();
        public CS_Flood_CellStatsPlot(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.gOptions.setHistogramBins(1000);
            labels[1] = "Histogram of the depth for the selected cell.  Click any cell in the lower left.";
            desc = "Provide cell stats on the flood_basics cells.  Identical to Cell_Floodfill";
        }
        public void RunCS(Mat src)
        {
            flood.Run(src);
            stats.Run(src);
            dst1 = stats.dst1;
            dst2 = flood.dst2;
            SetTrueText(stats.strOut, 3);
            if (task.ClickPoint == new cv.Point())
            {
                if (task.redCells.Count > 1)
                {
                    task.rc = task.redCells[1];
                    task.ClickPoint = task.rc.maxDist;
                }
            }
        }
    }
    public class CS_Flood_ContainedCells : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        public CS_Flood_ContainedCells(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            desc = "Find cells that have only one neighbor.  They are likely to be completely contained in another cell.";
        }
        public void RunCS(Mat src)
        {
            if (standalone)
            {
                flood.Run(src);
                dst2 = flood.dst2;
                labels = flood.labels;
            }
            List<int> removeCells = new List<int>();
            for (int i = task.redCells.Count - 1; i >= task.redOptions.identifyCount; i--)
            {
                var rc = task.redCells[i];
                List<int> nabs = new List<int>();
                List<int> contains = new List<int>();
                int count = Math.Min(task.redOptions.identifyCount, task.redCells.Count);
                for (int j = 0; j < count; j++)
                {
                    var rcBig = task.redCells[j];
                    if (rcBig.rect.IntersectsWith(rc.rect)) nabs.Add(rcBig.index);
                    if (rcBig.rect.Contains(rc.rect)) contains.Add(rcBig.index);
                }
                if (contains.Count == 1) removeCells.Add(rc.index);
            }
            dst3.SetTo(0);
            foreach (int index in removeCells)
            {
                var rc = task.redCells[index];
                dst3[rc.rect].SetTo(rc.color, rc.mask);
            }
            if (task.heartBeat) labels[3] = $"{removeCells.Count} cells were completely contained in exactly one other cell's rect";
        }
    }
    public class CS_Flood_BasicsMask : CS_Parent
    {
        public Mat binarizedImage;
        public Mat inputMask;
        public Cell_Generate genCells = new Cell_Generate();
        RedCloud_CPP redCPP = new RedCloud_CPP();
        public bool buildInputMask;
        public bool showSelected = true;
        Color8U_Basics cvt = new Color8U_Basics();
        public CS_Flood_BasicsMask(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            labels[3] = "The inputMask used to limit how much of the image is processed.";
            desc = "Floodfill by color as usual but this is run repeatedly with the different tiers.";
        }
        public void RunCS(Mat src)
        {
            if (standalone || buildInputMask)
            {
                cvt.Run(src);
                inputMask = task.pcSplit[2].InRange(task.MaxZmeters, task.MaxZmeters).ConvertScaleAbs();
                src = cvt.dst2;
            }
            dst3 = inputMask;
            redCPP.inputMask = inputMask;
            redCPP.Run(src);
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.rectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            int cellCount = Math.Min(task.redOptions.identifyCount, task.redCells.Count);
            if (task.heartBeat) labels[2] = $"{task.redCells.Count} cells identified and the largest {cellCount} are numbered below.";
            if (showSelected) task.setSelectedContour();
        }
    }
    public class CS_Flood_Tiers : CS_Parent
    {
        Flood_BasicsMask flood = new Flood_BasicsMask();
        Depth_TiersZ tiers = new Depth_TiersZ();
        Color8U_Basics cvt = new Color8U_Basics();
        public CS_Flood_Tiers(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            desc = "Subdivide the Flood_Basics cells using depth tiers.";
        }
        public void RunCS(Mat src)
        {
            int tier = task.gOptions.DebugSliderValue;
            tiers.Run(src);
            if (tier >= tiers.classCount) tier = 0;
            if (tier == 0)
            {
                dst1 = ~tiers.dst2.InRange(0, 1);
            }
            else
            {
                dst1 = ~tiers.dst2.InRange(tier, tier);
            }
            labels[2] = tiers.labels[2] + " in tier " + tier.ToString() + ".  Use the global options 'DebugSlider' to select different tiers.";
            cvt.Run(src);
            flood.inputMask = dst1;
            flood.Run(cvt.dst2);
            dst2 = flood.dst2;
            dst3 = flood.dst3;
            task.setSelectedContour();
        }
    }
    public class CS_Flood_Motion : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        List<rcData> redCells = new List<rcData>();
        Mat cellMap = new Mat();
        List<Point2f> maxDists = new List<Point2f>();
        List<int> maxIndex = new List<int>();
        public CS_Flood_Motion(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            desc = "Create RedCloud cells every heartbeat and compare the results against RedCloud cells created with the current frame.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                flood.Run(src);
                redCells = new List<rcData>(task.redCells);
                cellMap = task.cellMap.Clone();
                dst2 = flood.dst2.Clone();
                dst3 = flood.dst2.Clone();
                labels[2] = flood.labels[2];
                labels[3] = flood.labels[2];
                maxDists.Clear();
                foreach (var rc in redCells)
                {
                    maxDists.Add(rc.maxDist);
                    maxIndex.Add(rc.index);
                }
            }
            else
            {
                flood.Run(src);
                dst1.SetTo(0);
                for (int i = 0; i < task.redCells.Count; i++)
                {
                    var rc = task.redCells[i];
                    if (maxDists.Contains(rc.maxDist))
                    {
                        var lrc = redCells[maxIndex[maxDists.IndexOf(rc.maxDist)]];
                        dst1[lrc.rect].SetTo(lrc.color, lrc.mask);
                    }
                }
                dst3 = flood.dst2;
                labels[3] = flood.labels[2];
            }
        }
    }
    public class CS_Flood_Motion1 : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        Motion_Basics motion = new Motion_Basics();
        List<rcData> redCells = new List<rcData>();
        List<Point2f> maxDists = new List<Point2f>();
        List<int> maxIndex = new List<int>();
        public CS_Flood_Motion1(VBtask task) : base(task)
        {
            desc = "Create RedCloud cells every heartbeat and compare the results against RedCloud cells created with the current frame.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                flood.Run(src);
                redCells = new List<rcData>(task.redCells);
                dst2 = flood.dst2.Clone();
                dst3 = flood.dst2.Clone();
                labels[2] = flood.labels[2];
                labels[3] = flood.labels[2];
                maxDists.Clear();
                foreach (var rc in redCells)
                {
                    maxDists.Add(rc.maxDist);
                    maxIndex.Add(rc.index);
                }
            }
            else
            {
                flood.Run(src);
                motion.Run(flood.dst2);
                for (int i = 0; i < task.redCells.Count; i++)
                {
                    var rc = task.redCells[i];
                    if (maxDists.Contains(rc.maxDist))
                    {
                        var lrc = redCells[maxIndex[maxDists.IndexOf(rc.maxDist)]];
                        dst1[lrc.rect].SetTo(lrc.color, lrc.mask);
                    }
                }
                dst3 = flood.dst2;
                labels[3] = flood.labels[2];
            }
        }
    }
    public class CS_Flood_LeftRight : CS_Parent
    {
        RedCloud_Basics redLeft = new RedCloud_Basics();
        RedCloud_Basics redRight = new RedCloud_Basics();
        public Mat mapLeft;
        public Mat mapRight;
        public List<rcData> cellsLeft = new List<rcData>();
        public List<rcData> cellsRight = new List<rcData>();
        public CS_Flood_LeftRight(VBtask task) : base(task)
        {
            mapLeft = new Mat(dst2.Size(), MatType.CV_8U, 0);
            mapRight = new Mat(dst2.Size(), MatType.CV_8U, 0);
            task.redOptions.setIdentifyCells(false);
            if (standalone) task.gOptions.setDisplay1();
            desc = "Floodfill left and right images.";
        }
        public void RunCS(Mat src)
        {
            task.redCells = new List<rcData>(cellsLeft);
            task.cellMap = mapLeft.Clone();
            redLeft.genCells.useLeftImage = true;
            redLeft.Run(task.leftView);
            labels[2] = redLeft.labels[2];
            dst2 = redLeft.dst2;
            cellsLeft = new List<rcData>(task.redCells);
            mapLeft = task.cellMap.Clone();
            task.redCells = new List<rcData>(cellsRight);
            task.cellMap = mapRight.Clone();
            redRight.genCells.useLeftImage = false;
            redRight.Run(task.rightView);
            labels[3] = redRight.labels[2];
            dst3 = redRight.dst2;
            cellsRight = new List<rcData>(task.redCells);
            mapRight = task.cellMap.Clone();
            if (task.redOptions.getIdentifyCells())
            {
                if (task.mousePicTag == 2)
                {
                    task.setSelectedContour(ref cellsLeft, ref mapLeft);
                    task.color[task.rc.rect].SetTo(Scalar.White, task.rc.mask);
                }
                else
                {
                    task.setSelectedContour(ref cellsRight, ref mapRight);
                    dst1 = task.rightView;
                    dst1[task.rc.rect].SetTo(Scalar.White, task.rc.mask);
                }
            }
        }
    }
    public class CS_Flood_MaxDistPoints : CS_Parent
    {
        Boundary_RemovedRects bounds = new Boundary_RemovedRects();
        RedCloud_MaxDist_CPP redCPP = new RedCloud_MaxDist_CPP();
        public Cell_Generate genCells = new Cell_Generate();
        Color8U_Basics cvt = new Color8U_Basics();
        public CS_Flood_MaxDistPoints(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            labels[3] = "Contour boundaries - input to RedCloud_Basics";
            desc = "Build the RedCloud cells by providing the maxDist floodpoints to the RedCell C++ code.";
        }
        public void RunCS(Mat src)
        {
            cvt.Run(src);
            redCPP.Run(cvt.dst2);
            if (redCPP.classCount == 0) return; // no data to process.
            genCells.classCount = redCPP.classCount;
            genCells.rectList = redCPP.RectList;
            genCells.floodPoints = redCPP.floodPoints;
            genCells.removeContour = false;
            genCells.Run(redCPP.dst2);
            dst2 = genCells.dst2;
            redCPP.maxList.Clear();
            for (int i = 1; i < task.redCells.Count; i++)
            {
                redCPP.maxList.Add(task.redCells[i].maxDist.X);
                redCPP.maxList.Add(task.redCells[i].maxDist.Y);
            }
            task.setSelectedContour();
            labels[2] = genCells.labels[2];
        }
    }



    public class CS_Font_OpenCV : CS_Parent
    {
        public CS_Font_OpenCV(VBtask task) : base(task)
        {
            desc = "Display different font options available in OpenCV";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            HersheyFonts hersheyFont = (HersheyFonts)((task.frameCount % 7) + 1);
            string hersheyName = new string[] { "HersheyComplex", "HersheyComplexSmall", "HersheyDuplex", "HersheyPlain", "HersheyScriptComplex",
                                            "HersheyScriptSimplex", "HersheySimplex", "HersheyTriplex", "Italic" }[task.frameCount % 7];
            labels[2] = hersheyName;
            labels[3] = "Italicized " + hersheyName;
            dst2.SetTo(0);
            dst3.SetTo(0);
            for (int i = 1; i <= 10; i++)
            {
                double size = 1.5 - i * 0.1;
                Cv2.PutText(dst2, $"{hersheyName} {size:F1}", new cv.Point(10, 30 + i * 30), hersheyFont, size, Scalar.White, task.lineWidth, task.lineType);
                HersheyFonts hersheyFontItalics = hersheyFont | HersheyFonts.Italic;
                Cv2.PutText(dst3, $"{hersheyName} {size:F1}", new cv.Point(10, 30 + i * 30), hersheyFontItalics, size, Scalar.White, task.lineWidth, task.lineType);
            }
        }
    }

    public class CS_Font_FlowTextOld : CS_Parent
    {
        public List<string> msgs = new List<string>();
        public int dst = RESULT_DST2;
        public CS_Font_FlowTextOld(VBtask task) : base(task)
        {
            desc = "Show TrueType text flowing through an image.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                msgs.Add("-------------------------------------------------------------------------------------------------------------------");
                msgs.Add("To get text to flow across an image in any algorithm, add 'flow = new Font_FlowText()' to the class constructor.");
                msgs.Add("Also optionally indicate if you want result1 or result2 for text (the default is result1.)");
                msgs.Add("Then in your Run method, add a line 'flow.msgs.add('your next line of text')' - for as many msgs as you need on each pass.");
                msgs.Add("Then at the end of your Run method, invoke flow.Run(empty)");
            }
            int maxLines = 31;
            if (task.WorkingRes.Height == 720 || task.WorkingRes.Height == 360 || task.WorkingRes.Height == 180) maxLines = 23;
            bool clearRequested = false;
            if (msgs.Count > maxLines)
            {
                if (msgs.Count < maxLines * 2)
                {
                    msgs.RemoveRange(0, msgs.Count - maxLines);
                }
                else
                {
                    clearRequested = true;
                }
            }
            string strOut = string.Join("\n", msgs.GetRange(0, Math.Min(maxLines, msgs.Count)));
            SetTrueText(strOut, dst);
            if (clearRequested) msgs.Clear();
        }
    }
    public class CS_Font_FlowText : CS_Parent
    {
        public List<string> flowText = new List<string>();
        public string nextMsg;
        public int maxLines = 23;
        public int dst = RESULT_DST2;
        public List<trueText> textResult = new List<trueText>();
        public object parentData;
        public CS_Font_FlowText(VBtask task) : base(task)
        {
            desc = "Show TrueType text flowing through an image.";
        }
        public void RunCS(Mat src)
        {
            string strOut;
            if (standaloneTest())
            {
                strOut = "-------------------------------------------------------------------------------------------------------------------\n" +
                         "To get text to flow across an image in any algorithm, add CS_Font_FlowText to your algorithm.\n" +
                         "Also optionally indicate if you want RESULT_DST2 or RESULT_DST3 for text (the default is RESULT_DST2.)\n" +
                         "NOTE: add 'flow.parentData = me to your constructor for the algorithm.\n" +
                         "Then in your Run method, add a line 'flow.nextMsg = 'your next line of text'\n" +
                         "Then at the end of your Run method, invoke flow.Run(empty)";
            }
            else
            {
                flowText.Add(nextMsg);
                if (flowText.Count > maxLines) flowText.RemoveAt(0);
                strOut = string.Join("\n", flowText);
            }
            SetTrueText(strOut, dst);
            if (!standalone) ((dynamic)parentData).trueData = trueData;
        }
    }


    public class CS_Foreground_Basics : CS_Parent
    {
        KMeans_Depth simK = new KMeans_Depth();
        public float fgDepth;
        public Mat fg = new Mat(), bg = new Mat();
        public int classCount;
        public CS_Foreground_Basics(VBtask task) : base(task)
        {
            labels[3] = "Foreground - all the KMeans classes up to and including the first class over 1 meter.";
            dst1 = new Mat(dst1.Size(), MatType.CV_8U, 0);
            desc = "Find the first KMeans class with depth over 1 meter and use it to define foreground";
        }
        public void RunCS(Mat src)
        {
            simK.Run(src);
            classCount = simK.classCount;
            // Order the KMeans classes from foreground to background using depth data.
            List<Mat> depthMats = new List<Mat>();
            SortedList<float, int> sortedMats = new SortedList<float, int>(new CompareAllowIdenticalSingle());
            for (int i = 0; i < classCount; i++)
            {
                Mat tmp = simK.dst2.InRange(i, i);
                depthMats.Add(tmp.Clone());
                float depth = (float)task.pcSplit[2].Mean(tmp)[0];
                sortedMats.Add(depth, i);
            }
            fgDepth = 0;
            foreach (float depth in sortedMats.Keys)
            {
                if (depth >= 1)
                {
                    fgDepth = depth;
                    break; // find all the regions closer than a meter (inclusive)
                }
            }
            foreach (int index in sortedMats.Values)
            {
                Mat tmp = depthMats[index];
                dst1.SetTo(index + 1, tmp);
            }
            dst2 = ShowPalette(dst1 * 255 / depthMats.Count);
            fg = task.pcSplit[2].Threshold(fgDepth, 255, ThresholdTypes.BinaryInv).ConvertScaleAbs();
            dst0 = fg;
            fg.SetTo(0, task.noDepthMask);
            bg = ~fg;
            dst3.SetTo(0);
            src.CopyTo(dst3, fg);
            SetTrueText("KMeans classes are in dst1 - ordered by depth\nfg = foreground mask", 3);
            labels[2] = $"KMeans output defining the {classCount} classes";
        }
    }
    public class CS_Foreground_KMeans2 : CS_Parent
    {
        KMeans_Image km = new KMeans_Image();
        public CS_Foreground_KMeans2(VBtask task) : base(task)
        {
            FindSlider("KMeans k").Value = 2;
            labels = new string[] { "", "", "Foreground Mask", "Background Mask" };
            dst2 = new Mat(task.WorkingRes, MatType.CV_8U, 0);
            dst3 = new Mat(task.WorkingRes, MatType.CV_8U, 0);
            desc = "Separate foreground and background using Kmeans with k=2.";
        }
        public void RunCS(Mat src)
        {
            km.Run(task.pcSplit[2]);
            float minDistance = float.MaxValue;
            int minIndex = 0;
            for (int i = 0; i < km.km.colors.Rows; i++)
            {
                float distance = km.km.colors.Get<float>(i, 0);
                if (minDistance > distance && distance > 0)
                {
                    minDistance = distance;
                    minIndex = i;
                }
            }
            dst2.SetTo(0);
            dst2.SetTo(255, km.masks[minIndex]);
            dst2.SetTo(0, task.noDepthMask);
            dst3 = ~dst2;
            dst3.SetTo(0, task.noDepthMask);
        }
    }
    public class CS_Foreground_Contours : CS_Parent
    {
        public Foreground_Hist3D fore = new Foreground_Hist3D();
        Contour_General contours = new Contour_General();
        public CS_Foreground_Contours(VBtask task) : base(task)
        {
            desc = "Create contours for the foreground mask";
        }
        public void RunCS(Mat src)
        {
            fore.Run(src);
            contours.Run(fore.dst2);
            dst2 = contours.dst2;
        }
    }
    public class CS_Foreground_Hist3D : CS_Parent
    {
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        public CS_Foreground_Hist3D(VBtask task) : base(task)
        {
            hcloud.maskInput = task.noDepthMask;
            labels = new string[] { "", "", "Foreground", "Background" };
            desc = "Use the first class of hist3Dcloud_Basics as the definition of foreground";
        }
        public void RunCS(Mat src)
        {
            hcloud.Run(src);
            dst2.SetTo(0);
            dst2 = hcloud.dst2.InRange(1, 1) | task.noDepthMask;
            dst3 = ~dst2;
        }
    }
    public class CS_Foreground_RedCloud : CS_Parent
    {
        Foreground_CellsFore fore = new Foreground_CellsFore();
        Foreground_CellsBack back = new Foreground_CellsBack();
        public CS_Foreground_RedCloud(VBtask task) : base(task)
        {
            desc = "Isolate foreground from background, then segment each with RedCloud";
        }
        public void RunCS(Mat src)
        {
            fore.Run(src);
            dst2 = fore.dst2;
            labels[2] = fore.labels[2];
            back.Run(src);
            dst3 = back.dst2;
            labels[3] = back.labels[2];
            if (task.redCells.Count > 0)
            {
                dst2[task.rc.rect].SetTo(Scalar.White, task.rc.mask);
            }
        }
    }
    public class CS_Foreground_CellsFore : CS_Parent
    {
        Foreground_Hist3D fore = new Foreground_Hist3D();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public List<rcData> redCells = new List<rcData>();
        public CS_Foreground_CellsFore(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(false);
            task.redOptions.setUseColorOnly(true);
            desc = "Get the foreground cells";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            fore.Run(src);
            dst3 = fore.dst2 & task.depthMask;
            dst2.SetTo(0);
            foreach (rcData rc in task.redCells)
            {
                Mat tmp = dst3[rc.rect] & rc.mask;
                if (Cv2.CountNonZero(tmp) > 0)
                    dst2[rc.rect].SetTo(rc.color, rc.mask);
            }
        }
    }
    public class CS_Foreground_CellsBack : CS_Parent
    {
        Foreground_Hist3D fore = new Foreground_Hist3D();
        public RedCloud_Basics redC = new RedCloud_Basics();
        public List<rcData> redCells = new List<rcData>();
        public CS_Foreground_CellsBack(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(false);
            task.redOptions.setUseColorOnly(true);
            desc = "Get the background cells";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            fore.Run(src);
            dst3 = ~fore.dst2 & task.depthMask;
            dst2.SetTo(0);
            foreach (rcData rc in task.redCells)
            {
                Mat tmp = dst3[rc.rect] & rc.mask;
                if (Cv2.CountNonZero(tmp) > 0)
                    dst2[rc.rect].SetTo(rc.color, rc.mask);
            }
        }
    }


    public class CS_Fractal_Mandelbrot : CS_Parent
    {
        public float startX = -2;
        public float endX = 2;
        public float startY = -1.5f;
        public float endY = 1.5f;
        float incrX;
        float incrY;
        public Options_Fractal options = new Options_Fractal();
        public CS_Fractal_Mandelbrot(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            labels[2] = "Use the iteration slider to see the impact of the number of iterations.";
            desc = "Run the classic Mandalbrot algorithm";
        }
        public void reset()
        {
            startX = -2;
            endX = 2;
            startY = -1.5f;
            endY = 1.5f;
            task.drawRectClear = true;
        }
        public void mandelbrotLoop(int y)
        {
            incrX = (endX - startX) / dst2.Width;
            incrY = (endY - startY) / dst2.Height;
            for (int x = 0; x < dst2.Width; x++)
            {
                var c = new Complex((double)(startX + x * incrX), (double)(startY + y * incrY));
                var z = new Complex(0, 0);
                int iter = 0;
                while (Complex.Abs(z) < 2 && iter < options.iterations)
                {
                    z = z * z + c;
                    iter++;
                }
                dst2.Set<byte>(y, x, (byte)(iter < options.iterations ? 255 * iter / (options.iterations - 1) : 0));
            }
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            for (int y = 0; y < src.Height; y++)
            {
                mandelbrotLoop(y);
            }
        }
    }
    public class CS_Fractal_MandelbrotZoom : CS_Parent
    {
        public Fractal_Mandelbrot mandel = new Fractal_Mandelbrot();
        Rect saveDrawRect = new Rect(1, 1, 1, 1);
        public CS_Fractal_MandelbrotZoom(VBtask task) : base(task)
        {
            desc = "Run the classic Mandalbrot algorithm and allow zooming in";
        }
        public void RunCS(Mat src)
        {
            if (task.drawRect.Width != 0)
            {
                float newStartX = mandel.startX + (mandel.endX - mandel.startX) * task.drawRect.X / src.Width;
                mandel.endX = mandel.startX + (mandel.endX - mandel.startX) * (task.drawRect.X + task.drawRect.Width) / src.Width;
                mandel.startX = newStartX;
                float newStartY = mandel.startY + (mandel.endY - mandel.startY) * task.drawRect.Y / src.Height;
                float height = task.drawRect.Width * src.Height / src.Width; // maintain aspect ratio across zooms...
                mandel.endY = mandel.startY + (mandel.endY - mandel.startY) * (task.drawRect.Y + height) / src.Height;
                mandel.startY = newStartY;
                task.drawRectClear = true;
            }
            if (mandel.options.resetCheck.Checked) mandel.reset();
            if (task.optionsChanged || saveDrawRect != task.drawRect)
            {
                saveDrawRect = task.drawRect;
                mandel.Run(src);
                mandel.options.resetCheck.Checked = false;
            }
            dst2 = mandel.dst2;
            labels[2] = mandel.endX - mandel.startX >= 3.999 ? "Mandelbrot Zoom - draw anywhere" : "Mandelbrot Zoom = ~" +
                string.Format("{0:###,###.0}X zoom", 4 / (mandel.endX - mandel.startX));
        }
    }
    public class CS_Fractal_MandelbrotZoomColor : CS_Parent
    {
        public Fractal_MandelbrotZoom zoom = new Fractal_MandelbrotZoom();
        public CS_Fractal_MandelbrotZoomColor(VBtask task) : base(task)
        {
            desc = "Classic Mandelbrot in color";
        }
        public void RunCS(Mat src)
        {
            if (zoom.mandel.options.resetCheck.Checked) zoom.mandel.reset();
            zoom.Run(src);
            dst2 = ShowPalette(zoom.dst2);
            labels[2] = zoom.labels[2];
        }
    }
    public class CS_Fractal_Julia : CS_Parent
    {
        Fractal_MandelbrotZoomColor mandel = new Fractal_MandelbrotZoomColor();
        double rt = 0.282;
        double mt = -0.58;
        cv.Point savedMouse = new cv.Point(-1, -1);
        System.Windows.Forms.CheckBox resetCheck;
        public CS_Fractal_Julia(VBtask task) : base(task)
        {
            resetCheck = FindCheckBox("Reset to original Mandelbrot");
            labels[3] = "Mouse selects different Julia Sets - zoom for detail";
            desc = "Build Julia set from any point in the Mandelbrot fractal";
        }
        int julia_point(float x, float y, int r, int depth, int max, Complex c, Complex z)
        {
            if (Complex.Abs(z) > r)
            {
                int mt = (int)((255 * Math.Pow(max - depth, 2) % (max * max)) % 256);
                dst2.Set<byte>((int)y, (int)x, (byte)(255 - mt));
                depth = 0;
            }
            if (Math.Sqrt(Math.Pow(x - dst2.Width / 2, 2) + Math.Pow(y - dst2.Height / 2, 2)) > dst2.Height / 2)
                dst2.Set<byte>((int)y, (int)x, 0);
            if (depth < max / 4) return 0;
            return julia_point(x, y, r, depth - 1, max, c, Complex.Pow(z, 2) + c);
        }
        public void RunCS(Mat src)
        {
            if (savedMouse != task.mouseMovePoint || resetCheck.Checked)
            {
                savedMouse = task.mouseMovePoint;
                mandel.Run(src);
                dst3 = mandel.dst2.Clone();
                int detail = 1;
                int depth = 100;
                int r = 2;
                dst2 = new Mat(src.Size(), MatType.CV_8U, 0);
                Fractal_Mandelbrot m = mandel.zoom.mandel;
                rt = m.startX + (m.endX - m.startX) * task.mouseMovePoint.X / src.Width;
                mt = m.startY + (m.endY - m.startY) * task.mouseMovePoint.Y / src.Height;
                Complex c = new Complex(rt, mt);
                Parallel.For((int)(src.Width / 2 - src.Height / 2), (int)(src.Width / 2 + src.Height / 2),
                    x =>
                    {
                        for (int y = 0; y < src.Height; y += detail)
                        {
                            Complex z = new Complex(2 * r * (x - src.Width / 2) / src.Height, 2 * r * (y - src.Height / 2) / src.Height);
                            julia_point(x, y, r, depth, depth, c, z);
                        }
                    });
                dst2 = ShowPalette(dst2);
            }
        }
    }
    public class CS_Fractal_Dimension : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Fractal_Dimension(VBtask task) : base(task)
        {
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            labels = new string[] { "", "", "RedCloud_Basics output - select any region.", "The selected region (as a square)" };
            desc = "Compute the fractal dimension of the provided (square) image.  Algorithm is incomplete.";
        }
        public double dimension(Mat Input)
        {
            Mat tmp64f = new Mat();
            Input.ConvertTo(tmp64f, MatType.CV_64F, 0, 0);
            int  G = 256;
            double d = 0;
            for (int j = 2; j < Input.Width / 2 - 1; j++)
            {
                int h = Math.Max(1, (int)Math.Floor(G / (Math.Floor((double)(Input.Width / j)))));
                double r = (double)j / Input.Width;
                for (int i = 0; i < Input.Width; i += j)
                {
                    //Dim boxes() As 
                }
            }
            //    For L in range(2, (M // 2) + 1)
            //    h = max(1, g // (M // L))  # minimum box height Is 1
            //    N_r = 0
            //        r = L / M
            //        For i in range(0, M, L)
            //        boxes = [[]] * ((G + h - 1) // h)  # create enough boxes with height h to fill the fractal space
            //        For row in image[i:i +L]:   # boxes that exceed bounds are shrunk to fit
            //            For pixel in row[i:i +L]
            //                height = (pixel - G_min) // h  # lowest box Is at G_min And Each Is h gray levels tall
            //                boxes[height].append(pixel)  # assign the pixel intensity to the correct box
            //        stddev = np.sqrt(np.var(boxes, axis = 1))  # calculate the standard deviation Of Each box
            //        stddev = stddev[~np.isnan(stddev)]  # remove boxes With NaN standard deviations (empty)
            //        nBox_r = 2 * (stddev // h) + 1
            //                    N_r += sum(nBox_r)
            //                    If N_r!= prev Then :
            //                          # check for plateauing
            //        r_Nr.append([r, N_r])
            //                        prev = N_r
            //                        x = np.array([np.log(1 / point[0]) For point In r_Nr])  # log(1/r)
            //y = np.array([np.log(point[1]) For point In r_Nr])  # log(Nr)
            //D = np.polyfit(x, y, 1)[0]  # D = lim r -> 0 log(Nr)/log(1/r)
            return d;
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            dst3.SetTo(0);
            cv.Rect rect = new Rect(0, 0, task.rc.rect.Width, task.rc.rect.Height);
            if (task.optionsChanged || task.mouseClickFlag)
            {
                rect = new Rect(0, 0, task.rc.rect.Width, task.rc.rect.Height);
            }
            if (task.rc.rect.Width == 0 || task.rc.rect.Height == 0) return;
            task.rc.mask.CopyTo(dst3[new Rect(0, 0, task.rc.rect.Width, task.rc.rect.Height)]);
            if (rect.Width < rect.Height) rect.Width = rect.Height; else rect.Height = rect.Width;
            dst3.Rectangle(rect, Scalar.White, task.lineWidth, task.lineType);
        }
    }

    public class CS_FrameRate_Basics : CS_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        int[] frameCounts = new int[4];
        Mat[] lastImages;
        public CS_FrameRate_Basics(VBtask task) : base(task)
        {
            desc = "Compare each frame to its last to figure out which frames really changed for each invocation.";
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) lastImages = new Mat[] { task.color.Clone(), task.leftView.Clone(), task.rightView.Clone(), task.depthRGB.Clone() };
            for (int i = 0; i < frameCounts.Length; i++)
            {
                mats.mat[i] = task.color.Clone();
                if (i == 1) mats.mat[i] = task.leftView.Clone();
                if (i == 2) mats.mat[i] = task.rightView.Clone();
                if (i == 3) mats.mat[i] = task.depthRGB.Clone();
                mats.mat[i] -= lastImages[i];
                var count = mats.mat[i].Sum();
                if (count[0] > 0 || count[1] > 0 || count[2] > 0) frameCounts[i]++;
                mats.mat[i] = mats.mat[i].Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            }
            if (task.heartBeat)
            {
                strOut = "";
                for (int i = 0; i < frameCounts.Length; i++)
                {
                    if (i == 0) strOut += "Color";
                    if (i == 1) strOut += "Left";
                    if (i == 2) strOut += "Right";
                    if (i == 3) strOut += "Depth";
                    strOut += "\t" + " image frameCount = " + "\t";
                    strOut += string.Format("{0}\t frameCount = {1}\n", frameCounts[i], task.frameCount);
                }
            }
            SetTrueText(strOut, 3);
            mats.Run(empty);
            dst2 = mats.dst2;
            lastImages = new Mat[] { task.color.Clone(), task.leftView.Clone(), task.rightView.Clone(), task.depthRGB.Clone() };
        }
    }
    public class CS_FrameRate_BasicsGray : CS_Parent
    {
        Mat_4to1 mats = new Mat_4to1();
        int[] frameCounts = new int[4];
        Mat[] lastImages;
        public CS_FrameRate_BasicsGray(VBtask task) : base(task)
        {
            desc = "Compare each frame to its last to figure out which frames really changed for each invocation.";
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) lastImages = new Mat[] { task.color.Clone(), task.leftView.Clone(), task.rightView.Clone(), task.depthRGB.Clone() };
            for (int i = 0; i < frameCounts.Length; i++)
            {
                mats.mat[i] = task.color.Clone();
                if (i == 1) mats.mat[i] = task.leftView.Clone();
                if (i == 2) mats.mat[i] = task.rightView.Clone();
                if (i == 3) mats.mat[i] = task.depthRGB.Clone();
                mats.mat[i] = mats.mat[i].CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                lastImages[i] = lastImages[i].CvtColor(cv.ColorConversionCodes.BGR2GRAY);
                mats.mat[i] -= lastImages[i];
                var count = mats.mat[i].CountNonZero();
                if (count > 0) frameCounts[i]++;
                mats.mat[i] = mats.mat[i].Threshold(0, 255, ThresholdTypes.Binary);
            }
            if (task.heartBeat)
            {
                strOut = "";
                for (int i = 0; i < frameCounts.Length; i++)
                {
                    if (i == 0) strOut += "Color";
                    if (i == 1) strOut += "Left";
                    if (i == 2) strOut += "Right";
                    if (i == 3) strOut += "Depth";
                    strOut += "\t" + " image frameCount = " + "\t";
                    strOut += string.Format("{0}\t frameCount = {1}\n", frameCounts[i], task.frameCount);
                }
            }
            SetTrueText(strOut, 3);
            mats.Run(empty);
            dst2 = mats.dst2;
            lastImages = new Mat[] { task.color.Clone(), task.leftView.Clone(), task.rightView.Clone(), task.depthRGB.Clone() };
        }
    }

    public class CS_FREAK_Basics : CS_Parent
    {
        ORB_Basics orb = new ORB_Basics();
        public CS_FREAK_Basics(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setDisplay1();
            desc = "Find keypoints using FREAK algorithm";
        }
        public void RunCS(Mat src)
        {
            orb.Run(src);
            dst1 = orb.dst2;
            var freak = cv.XFeatures2D.FREAK.Create();
            Mat fdesc = new Mat();
            List<KeyPoint> keypoints = orb.keypoints.ToList();
            freak.Compute(src.CvtColor(ColorConversionCodes.BGR2GRAY), ref orb.keypoints, fdesc);
            dst2 = src.Clone();
            foreach (var kpt in keypoints)
            {
                var r = kpt.Size / 8;
                DrawCircle(dst2, kpt.Pt, (int)r, Scalar.Green);
                DrawLine(dst2, new cv.Point(kpt.Pt.X + r, kpt.Pt.Y + r), new cv.Point(kpt.Pt.X - r, kpt.Pt.Y - r), Scalar.Green, task.lineWidth);
                DrawLine(dst2, new cv.Point(kpt.Pt.X + r, kpt.Pt.Y - r), new cv.Point(kpt.Pt.X - r, kpt.Pt.Y + r), Scalar.Green, task.lineWidth);
            }
            labels[2] = orb.keypoints.Count().ToString() + " key points were identified";
            labels[3] = orb.keypoints.Count().ToString() + " FREAK Descriptors (resized) One row = keypoint";
            if (fdesc.Width > 0 && fdesc.Height > 0)
                dst3 = fdesc.Resize(dst3.Size());
        }
    }
    public class CS_Fuzzy_Basics : CS_Parent
    {
        Reduction_Basics reduction = new Reduction_Basics();
        Options_Contours options = new Options_Contours();
        public Point[][] contours;
        public SortedList<int, Vec2i> sortContours = new SortedList<int, Vec2i>(new compareAllowIdenticalIntegerInverted());
        public CS_Fuzzy_Basics(VBtask task) : base(task)
        {
            var floodRadio = FindRadio("FloodFill");
            if (floodRadio.Enabled) floodRadio.Enabled = false; // too much special handling - cv_32SC1 image 
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.redOptions.setSimpleReductionBar(32);
            cPtr = Fuzzy_Open();
            FindRadio("CComp").Checked = true;
            labels = new[] { "", "Solid regions", "8-Bit output of CS_Fuzzy_Basics", "Fuzzy edges" };
            desc = "That which is not solid is fuzzy";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            reduction.Run(src);
            dst0 = reduction.dst2;
            if (dst0.Channels() != 1) dst0 = dst0.CvtColor(ColorConversionCodes.BGR2GRAY);
            var dataSrc = new byte[dst0.Total()];
            Marshal.Copy(dst0.Data, dataSrc, 0, dataSrc.Length);
            var handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            var imagePtr = Fuzzy_Run(cPtr, handleSrc.AddrOfPinnedObject(), dst0.Rows, dst0.Cols);
            handleSrc.Free();
            dst2 = new Mat(dst0.Rows, dst0.Cols, MatType.CV_8UC1, imagePtr).Clone();
            dst3 = dst2.Threshold(0, 255, ThresholdTypes.BinaryInv);
            Mat tmp = new Mat();
            if (options.retrievalMode == RetrievalModes.CComp || options.retrievalMode == RetrievalModes.FloodFill)
            {
                dst3.ConvertTo(tmp, MatType.CV_32S);
            }
            else
            {
                dst3.ConvertTo(tmp, MatType.CV_8U);
            }
            contours = Cv2.FindContoursAsArray(tmp, options.retrievalMode, options.ApproximationMode);
            sortContours.Clear();
            for (int i = 0; i < contours.Length; i++)
            {
                // get this region's ID
                int maskID = 0;
                var pt = contours[i][0];
                for (int y = pt.Y - 1; y <= pt.Y + 1; y++)
                {
                    for (int x = pt.X - 1; x <= pt.X + 1; x++)
                    {
                        if (x < src.Width && y < src.Height && x >= 0 && y >= 0)
                        {
                            var val = dst2.Get<byte>(y, x);
                            if (val != 0)
                            {
                                maskID = val;
                                break;
                            }
                        }
                    }
                    if (maskID != 0) break;
                }
                sortContours.Add(contours[i].Length, new cv.Point(i, maskID));
            }
            dst1 = ShowPalette(dst2 * 255 / reduction.classCount);
            dst1.SetTo(0, dst3);
            labels[1] = "There were " + sortContours.Count + " contour > 100 points.";
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = Fuzzy_Close(cPtr);
        }
    }
    public class CS_Fuzzy_Filter : CS_Parent
    {
        Mat kernel;
        Reduction_Basics reduction = new Reduction_Basics();
        public Point[][] contours;
        public SortedList<int, Vec2i> sortContours = new SortedList<int, Vec2i>(new compareAllowIdenticalIntegerInverted());
        Options_Contours options = new Options_Contours();
        public CS_Fuzzy_Filter(VBtask task) : base(task)
        {
            float[] array = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };
            kernel = new Mat(3, 3, MatType.CV_32F, array);
            kernel *= 1 / 9.0;
            desc = "Use a 2D filter to find smooth areas";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            reduction.Run(src);
            Mat src32f = new Mat();
            reduction.dst2.ConvertTo(src32f, MatType.CV_32F);
            dst2 = src32f.Filter2D(-1, kernel);
            dst3 = dst2.Subtract(src32f);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.BinaryInv);
            dst3.ConvertTo(dst3, MatType.CV_8U);
            dst3 = dst3.Threshold(0, 255, ThresholdTypes.BinaryInv);
            if (options.retrievalMode == RetrievalModes.FloodFill)
            {
                Mat tmp = new Mat();
                dst3.ConvertTo(tmp, MatType.CV_32S);
                contours = Cv2.FindContoursAsArray(tmp, options.retrievalMode, options.ApproximationMode);
            }
            else
            {
                contours = Cv2.FindContoursAsArray(dst3, options.retrievalMode, options.ApproximationMode);
            }
            sortContours.Clear();
            for (int i = 0; i < contours.Length; i++)
            {
                int maskID = 0;
                var pt = contours[i][0];
                for (int y = pt.Y - 1; y <= pt.Y + 1; y++)
                {
                    for (int x = pt.X - 1; x <= pt.X + 1; x++)
                    {
                        if (x < src.Width && y < src.Height && x >= 0 && y >= 0)
                        {
                            var val = reduction.dst2.Get<byte>(y, x);
                            if (val != 0)
                            {
                                maskID = val;
                                break;
                            }
                        }
                    }
                    if (maskID != 0) break;
                }
                sortContours.Add(contours[i].Length, new cv.Point(i, maskID));
            }
            dst2 = ShowPalette(reduction.dst2 * 255 / reduction.classCount);
            dst2.SetTo(0, dst3);
        }
    }
    public class CS_Fuzzy_ContoursDepth : CS_Parent
    {
        public Fuzzy_Basics fuzzyD = new Fuzzy_Basics();
        public CS_Fuzzy_ContoursDepth(VBtask task) : base(task)
        {
            desc = "Use contours to outline solids in the depth data";
        }
        public void RunCS(Mat src)
        {
            fuzzyD.Run(task.depthRGB);
            dst2 = fuzzyD.dst1;
        }
    }
    public class CS_Fuzzy_NeighborProof : CS_Parent
    {
        Fuzzy_Basics fuzzy = new Fuzzy_Basics();
        bool proofFailed = false;
        public CS_Fuzzy_NeighborProof(VBtask task) : base(task)
        {
            desc = "Prove that every contour point has at one and only one neighbor with the mask ID and that the rest are zero";
        }
        public void RunCS(Mat src)
        {
            if (proofFailed) return;
            fuzzy.Run(src);
            dst2 = fuzzy.dst1;
            for (int i = 0; i < fuzzy.contours.Length; i++)
            {
                int len = fuzzy.contours[i].Length;
                for (int j = 0; j < len; j++)
                {
                    var pt = fuzzy.contours[i][j];
                    int maskID = 0;
                    for (int y = Math.Max(0, pt.Y - 1); y <= pt.Y + 1; y++)
                    {
                        for (int x = Math.Max(0, pt.X - 1); x <= pt.X + 1; x++)
                        {
                            if (x < src.Width && y < src.Height)
                            {
                                var val = dst2.Get<byte>(y, x);
                                if (val != 0) maskID = val;
                                if (maskID != 0 && val != 0 && maskID != val)
                                {
                                    MessageBox.Show("Proof has failed!  There is more than one mask ID identified by this contour point.");
                                    proofFailed = true;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
            SetTrueText("Results are valid.\nMask ID's for all contour points in each region identified only one region.", new cv.Point(10, 50), 3);
        }
    }
    public class CS_Fuzzy_TrackerDepth : CS_Parent
    {
        public Fuzzy_Basics fuzzy = new Fuzzy_Basics();
        public List<Point> centroids = new List<Point>();
        public List<Rect> rects = new List<Rect>();
        public List<int> layoutColor = new List<int>();
        public cv.Point highlightPoint;
        public Rect highlightRect;
        public int highlightRegion = -1;
        Options_TrackerDepth options = new Options_TrackerDepth();
        public CS_Fuzzy_TrackerDepth(VBtask task) : base(task)
        {
            desc = "Create centroids and rect's for solid regions and track them - tracker";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            fuzzy.Run(task.depthRGB);
            dst2 = fuzzy.dst1;
            centroids.Clear();
            rects.Clear();
            layoutColor.Clear();
            double minX, maxX, minY, maxY;
            foreach (var vec in fuzzy.sortContours.Values)
            {
                var contours = fuzzy.contours[vec[0]];
                var points = new Mat(contours.Length, 1, MatType.CV_32SC2, contours);
                var center = points.Sum();
                points = new Mat(contours.Length, 2, MatType.CV_32S, contours);
                points.Col(0).MinMaxIdx(out minX, out maxX);
                points.Col(1).MinMaxIdx(out minY, out maxY);
                var rect = new Rect((int)minX, (int)minY, (int)(maxX - minX), (int)(maxY - minY));
                if (rect.Width * rect.Height > options.minRectSize)
                {
                    var centroid = new Point((int)(center[0] / contours.Length), (int)(center[1] / contours.Length));
                    centroids.Add(centroid);
                    rects.Add(rect);
                    layoutColor.Add(vec[1]);
                    if (options.displayRect)
                    {
                        DrawCircle(dst2, centroid, task.DotSize + 3, Scalar.Yellow);
                        DrawCircle(dst2, centroid, task.DotSize, Scalar.Red);
                        dst2.Rectangle(rect, Scalar.Yellow, 2);
                    }
                }
            }
            labels[2] = fuzzy.sortContours.Count + " regions were found in the image.";
        }
    }
    public class CS_Fuzzy_TrackerDepthClick : CS_Parent
    {
        public Fuzzy_TrackerDepth tracker = new Fuzzy_TrackerDepth();
        public cv.Point highlightPoint;
        public Rect highlightRect;
        public int highlightRegion = -1;
        public Mat regionMask;
        public CS_Fuzzy_TrackerDepthClick(VBtask task) : base(task)
        {
            desc = "Create centroids and rect's for solid regions and track them - tracker";
        }
        public void RunCS(Mat src)
        {
            tracker.Run(src);
            dst2 = tracker.dst2;
            if (highlightRegion < 0) SetTrueText("Click any color region to get more details and track it", new cv.Point(10, 50), 3);
            dst3 = tracker.fuzzy.dst1;
            if (task.mouseClickFlag)
            {
                highlightPoint = task.ClickPoint;
                highlightRegion = tracker.fuzzy.dst2.Get<byte>(highlightPoint.Y, highlightPoint.X);
            }
            if (highlightRegion >= 0)
            {
                regionMask = tracker.fuzzy.dst2.InRange(highlightRegion, highlightRegion + 1);
                dst3.SetTo(Scalar.Yellow, regionMask);
            }
            labels[2] = tracker.fuzzy.sortContours.Count + " regions were found in the image.";
        }
    }
    public class CS_Gabor_Basics : CS_Parent
    {
        public Options_Gabor options = new Options_Gabor();
        public CS_Gabor_Basics(VBtask task) : base(task)
        {
            desc = "Explore Gabor kernel";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src.Filter2D(MatType.CV_8UC3, options.gKernel);
        }
    }
    public class CS_GrabCut_Basics : CS_Parent
    {
        public Mat fgFineTune;
        public Mat bgFineTune;
        public Foreground_Basics fore = new Foreground_Basics();
        Mat bgModel = new Mat(1, 65, MatType.CV_64F, 0);
        Mat fgModel = new Mat(1, 65, MatType.CV_64F, 0);
        public CS_GrabCut_Basics(VBtask task) : base(task)
        {
            desc = "Use Foreground_Basics to define the foreground for use in GrabCut.";
        }
        public void RunCS(Mat src)
        {
            fore.Run(src);
            dst2 = fore.dst2;
            dst3 = fore.dst3;
            dst0 = new Mat(dst0.Size(), MatType.CV_8U, (double)GrabCutClasses.PR_BGD);
            dst0.SetTo((double)GrabCutClasses.FGD, fore.fg);
            dst0.SetTo((double)GrabCutClasses.BGD, fore.bg);
            // Cv2.GrabCut(src, dst0, new Rect(), bgModel, fgModel, 1, GrabCutModes.InitWithMask);
            fore.bg = ~fore.fg;
            if (Cv2.CountNonZero(fore.fg) > 0)
            {
                if (fgFineTune != null) dst0.SetTo((double)GrabCutClasses.FGD, fgFineTune);
                if (bgFineTune != null) dst0.SetTo((double)GrabCutClasses.BGD, bgFineTune);
                Cv2.GrabCut(src, dst0, new Rect(), bgModel, fgModel, 1, GrabCutModes.Eval);
            }
            dst3.SetTo(0);
            src.CopyTo(dst3, dst0);
            labels[2] = "KMeans output defining the " + fore.classCount.ToString() + " classes.";
        }
    }

    public class CS_GrabCut_ImageRect : CS_Parent
    {
        Mat image;
        Mat bgModel = new Mat();
        Mat fgModel = new Mat();
        Rect bgRect1 = new Rect(482, 0, 128, 640);
        Rect bgRect2 = new Rect(0, 0, 162, 320);
        Rect fgRect1 = new Rect(196, 134, 212, 344);
        Rect fgRect2 = new Rect(133, 420, 284, 60);
        public CS_GrabCut_ImageRect(VBtask task) : base(task)
        {
            var fileInputName = new FileInfo(task.HomeDir + "data/cat.jpg");
            image = Cv2.ImRead(fileInputName.FullName);
            desc = "Grabcut example using a single image.  Fix this.";
        }
        public void RunCS(Mat src)
        {
            dst2 = image;
            dst0 = new Mat(image.Size(), MatType.CV_8U, (double)GrabCutClasses.PR_BGD);
            dst0[bgRect1].SetTo((double)GrabCutClasses.BGD);
            dst0[bgRect2].SetTo((double)GrabCutClasses.BGD);
            dst0[fgRect1].SetTo((double)GrabCutClasses.FGD);
            dst0[fgRect2].SetTo((double)GrabCutClasses.FGD);
            if (task.FirstPass)
            {
                Cv2.GrabCut(dst2, dst0, bgRect1, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
                Cv2.GrabCut(dst2, dst0, bgRect2, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
                Cv2.GrabCut(dst2, dst0, fgRect1, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
                Cv2.GrabCut(dst2, dst0, fgRect2, bgModel, fgModel, 1, GrabCutModes.InitWithRect);
            }
            var rect = new Rect();
            Cv2.GrabCut(dst2, dst0, rect, bgModel, fgModel, 1, GrabCutModes.Eval);
            dst3.SetTo(0);
            dst2.CopyTo(dst3, dst0 + 1);
        }
    }
    public class CS_GrabCut_ImageMask : CS_Parent
    {
        Mat image;
        Mat bgModel = new Mat(), fgModel = new Mat();
        public CS_GrabCut_ImageMask(VBtask task) : base(task)
        {
            var fileInputName = new FileInfo(task.HomeDir + "data/cat.jpg");
            image = Cv2.ImRead(fileInputName.FullName);
            desc = "Grabcut example using a single image. ";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                dst2 = image;
                dst0 = dst2.CvtColor(cv.ColorConversionCodes.BGR2GRAY).Threshold(50, 255, ThresholdTypes.Binary);
                dst1 = new Mat(dst2.Size(), MatType.CV_8U, (double)GrabCutClasses.PR_BGD);
                dst1.SetTo((double)GrabCutClasses.FGD, dst0);
                Cv2.GrabCut(dst2, dst1, new Rect(), bgModel, fgModel, 1, GrabCutModes.InitWithMask);
            }
            else
            {
                Cv2.GrabCut(dst2, dst1, new Rect(), bgModel, fgModel, 5, GrabCutModes.Eval);
            }
            dst3.SetTo(0);
            dst2.CopyTo(dst3, dst1 + 1);
        }
    }

    public class CS_GrabCut_FineTune : CS_Parent
    {
        GrabCut_Basics basics = new GrabCut_Basics();
        Mat_4to1 mats = new Mat_4to1();
        Options_GrabCut options = new Options_GrabCut();
        bool saveRadio = true;
        public CS_GrabCut_FineTune(VBtask task) : base(task)
        {
            labels[2] = "Foreground Mask, fg fine tuning, bg fine tuning, blank";
            labels[3] = "Grabcut results after adding fine tuning selections";
            desc = "There are probably mistakes in the initial Grabcut_Basics.  Use the checkbox to fine tune what is background and foreground";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (options.clearAll || basics.fgFineTune == null)
            {
                basics.fgFineTune = new Mat(src.Size(), MatType.CV_8U, 0);
                basics.bgFineTune = new Mat(src.Size(), MatType.CV_8U, 0);
            }
            if (saveRadio != options.fineTuning)
            {
                saveRadio = options.fineTuning;
                task.drawRectClear = true;
                return;
            }
            if (task.drawRect.Width != 0)
            {
                if (options.fineTuning)
                {
                    basics.fgFineTune[task.drawRect].SetTo(255);
                }
                else
                {
                    basics.bgFineTune[task.drawRect].SetTo(255);
                }
            }
            basics.Run(src);
            mats.mat[0] = basics.dst2;
            mats.mat[1] = basics.fgFineTune;
            mats.mat[2] = basics.bgFineTune;
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = basics.dst3;
        }
    }

    public class CS_Gradient_Basics : CS_Parent
    {
        public Edge_Sobel_Old sobel = new Edge_Sobel_Old();
        public CS_Gradient_Basics(VBtask task) : base(task)
        {
            dst3 = new Mat(dst2.Size(), MatType.CV_32F, 0);
            labels = new string[] { "", "", "CS_Gradient_Basics - Sobel output", "Phase Output" };
            desc = "Use phase to compute gradient";
        }
        public void RunCS(Mat src)
        {
            sobel.Run(src);
            Cv2.Phase(sobel.dst0, sobel.dst1, dst3);
            dst2 = sobel.dst0;
        }
    }
    public class CS_Gradient_Depth : CS_Parent
    {
        Edge_Sobel_Old sobel = new Edge_Sobel_Old();
        public CS_Gradient_Depth(VBtask task) : base(task)
        {
            labels[3] = "Phase Output";
            desc = "Use phase to compute gradient on depth image";
        }
        public void RunCS(Mat src)
        {
            sobel.Run(task.pcSplit[2]);
            Cv2.Phase(sobel.dst0, sobel.dst1, dst3);
            dst2 = sobel.dst0;
        }
    }

    public class CS_Gradient_Color : CS_Parent
    {
        public Scalar color1 = Scalar.Blue;
        public Scalar color2 = Scalar.Yellow;
        public int gradientWidth;
        public Mat gradient;
        public CS_Gradient_Color(VBtask task) : base(task)
        {
            desc = "Provide a spectrum that is a gradient from one color to another.";
        }
        public void RunCS(Mat src)
        {
            gradientWidth = dst2.Width;
            double f = 1.0;
            Mat gradientColors = new Mat(1, gradientWidth, MatType.CV_64FC3);
            for (int i = 0; i < gradientWidth; i++)
            {
                gradientColors.Set(0, i, new Scalar(f * color2[0] + (1 - f) * color1[0], f * color2[1] + (1 - f) * color1[1],
                    f * color2[2] + (1 - f) * color1[2]));
                f -= 1.0 / gradientWidth;
            }
            gradient = new Mat(1, gradientWidth, MatType.CV_8UC3);
            for (int i = 0; i < gradientWidth; i++)
            {
                gradient.Col(i).SetTo(gradientColors.Get<Scalar>(0, i));
            }
            dst2 = gradient.Resize(dst2.Size());
        }
    }
    public class CS_Gradient_CartToPolar : CS_Parent
    {
        public Gradient_Basics basics = new Gradient_Basics();
        public Mat magnitude = new Mat();
        public Mat angle = new Mat();
        Options_Gradient options = new Options_Gradient();
        public CS_Gradient_CartToPolar(VBtask task) : base(task)
        {
            FindSlider("Sobel kernel Size").Value = 1;
            labels[2] = "CartToPolar Magnitude Output Normalized";
            labels[3] = "CartToPolar Angle Output";
            desc = "Compute the gradient and use CartToPolar to image the magnitude and angle";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Mat tmp = new Mat();
            src.ConvertTo(tmp, MatType.CV_32FC3, 1.0 / 255);
            basics.Run(tmp);
            basics.sobel.dst2.ConvertTo(dst2, MatType.CV_32F);
            basics.sobel.dst2.ConvertTo(dst3, MatType.CV_32F);
            magnitude = new Mat();
            angle = new Mat();
            Cv2.CartToPolar(dst2, dst3, magnitude, angle, true);
            magnitude = magnitude.Normalize();
            magnitude = magnitude.Pow(options.exponent);
            dst2 = magnitude;
        }
    }
    public class CS_Gravity_Basics : CS_Parent
    {
        public List<Point> points = new List<Point>();
        int resizeRatio = 1;
        public PointPair vec = new PointPair();
        public bool autoDisplay;
        public CS_Gravity_Basics(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Find all the points where depth X-component transitions from positive to negative";
        }
        public void displayResults(Point2f p1, cv.Point2f p2)
        {
            if (task.heartBeat)
            {
                if (p1.Y >= 1 && p1.Y <= dst2.Height - 1)
                    strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n";
            }
            dst2.SetTo(0);
            dst3.SetTo(0);
            foreach (var pt in points)
            {
                var newPt = new cv.Point(pt.X * resizeRatio, pt.Y * resizeRatio);
                DrawCircle(dst2, newPt, task.DotSize, Scalar.White);
            }
            DrawLine(dst2, vec.p1, vec.p2, Scalar.White, task.lineWidth);
            DrawLine(dst3, vec.p1, vec.p2, Scalar.White, task.lineWidth);
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F)
                dst0 = PrepareDepthInput(0);
            else
                dst0 = src;
            var resolution = task.quarterRes;
            if (dst0.Size() != resolution)
            {
                dst0 = dst0.Resize(resolution, 0, 0, InterpolationFlags.Nearest);
                resizeRatio = (int)(dst2.Height / resolution.Height);
            }
            dst0 = dst0.Abs();
            dst1 = dst0.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst0.SetTo(task.MaxZmeters, ~dst1);
            points.Clear();
            for (int i = dst0.Height / 3; i < dst0.Height * 2 / 3 - 1; i++)
            {
                var mm1 = GetMinMax(dst0.Row(i));
                if (mm1.minVal > 0 && mm1.minVal < 0.005)
                {
                    dst0.Row(i).Set<float>(mm1.minLoc.Y, mm1.minLoc.X, 10);
                    var mm2 = GetMinMax(dst0.Row(i));
                    if (mm2.minVal > 0 && Math.Abs(mm1.minLoc.X - mm2.minLoc.X) <= 1)
                        points.Add(new cv.Point(mm1.minLoc.X, i));
                }
            }
            labels[2] = points.Count.ToString() + " points found. ";
            cv.Point p1 = new cv.Point();
            cv.Point p2 = new cv.Point();
            if (points.Count >= 2)
            {
                p1 = new cv.Point(resizeRatio * points[points.Count - 1].X, resizeRatio * points[points.Count - 1].Y);
                p2 = new cv.Point(resizeRatio * points[0].X, resizeRatio * points[0].Y);
            }
            var distance = p1.DistanceTo(p2);
            if (distance < 10) // enough to get a line with some credibility
            {
                points.Clear();
                vec = new PointPair();
                strOut = "Gravity vector not found " + "\n" + "The distance of p1 to p2 is " + (int)distance + " pixels.";
            }
            else
            {
                var lp = new PointPair(p1, p2);
                vec = lp.edgeToEdgeLine(dst2.Size());
                if (standaloneTest() || autoDisplay)
                    displayResults(p1, p2);
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_Gravity_BasicsOriginal : CS_Parent
    {
        public PointPair vec = new PointPair();
        public CS_Gravity_BasicsOriginal(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Search for the transition from positive to negative to find the gravity vector.";
        }
        Point2f findTransition(int startRow, int stopRow, int stepRow)
        {
            float val = 0, lastVal = 0;
            var ptX = new List<float>();
            var ptY = new List<float>();
            for (int y = startRow; y <= stopRow; y += stepRow)
            {
                for (int x = 0; x < dst0.Cols; x++)
                {
                    lastVal = val;
                    val = dst0.Get<float>(y, x);
                    if (val > 0 && lastVal < 0)
                    {
                        // change to sub-pixel accuracy here 
                        var pt = new Point2f(x + Math.Abs(val) / Math.Abs(val - lastVal), y);
                        ptX.Add(pt.X);
                        ptY.Add(pt.Y);
                        if (ptX.Count >= task.frameHistoryCount)
                            return new Point2f(ptX.Average(), ptY.Average());
                    }
                }
            }
            return new cv.Point();
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F)
                dst0 = PrepareDepthInput(0);
            else
                dst0 = src;
            var p1 = findTransition(0, dst0.Height - 1, 1);
            var p2 = findTransition(dst0.Height - 1, 0, -1);
            var lp = new PointPair(p1, p2);
            vec = lp.edgeToEdgeLine(dst2.Size());
            if (p1.X >= 1)
            {
                strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n" + "      val =  " +
                          dst0.Get<float>((int)p1.Y, (int)p1.X).ToString() + "\n" + "lastVal = " + dst0.Get<float>((int)p1.Y, (int)p1.X - 1).ToString();
            }
            SetTrueText(strOut, 3);
            if (standaloneTest())
            {
                dst2.SetTo(0);
                DrawLine(dst2, vec.p1, vec.p2, 255, task.lineWidth);
            }
        }
    }
    public class CS_Gravity_HorizonCompare : CS_Parent
    {
        Gravity_Basics gravity = new Gravity_Basics();
        Horizon_Basics horizon = new Horizon_Basics();
        public CS_Gravity_HorizonCompare(VBtask task) : base(task)
        {
            gravity.autoDisplay = true;
            horizon.autoDisplay = true;
            desc = "Collect results from Horizon_Basics with Gravity_Basics";
        }
        public void RunCS(Mat src)
        {
            gravity.Run(src);
            var g1 = gravity.vec;
            var h1 = gravity.vec;
            horizon.Run(src);
            var g2 = horizon.vec;
            var h2 = horizon.vec;
            if (standaloneTest())
            {
                SetTrueText("Gravity vector (yellow):" + "\n" + gravity.strOut + "\n" + "\n" + "Horizon Vector (red): " + "\n" + horizon.strOut, 3);
                dst2.SetTo(0);
                DrawLine(dst2, g1.p1, g1.p2, task.HighlightColor, task.lineWidth);
                DrawLine(dst2, g2.p1, g2.p2, task.HighlightColor, task.lineWidth);
                DrawLine(dst2, h1.p1, h1.p2, Scalar.Red, task.lineWidth);
                DrawLine(dst2, h2.p1, h2.p2, Scalar.Red, task.lineWidth);
            }
        }
    }
    public class CS_Gravity_Horizon : CS_Parent
    {
        Gravity_Basics gravity = new Gravity_Basics();
        Horizon_Basics horizon = new Horizon_Basics();
        PointPair lastVec;
        public CS_Gravity_Horizon(VBtask task) : base(task)
        {
            gravity.autoDisplay = true;
            horizon.autoDisplay = true;
            labels[2] = "Gravity vector in yellow and Horizon vector in red.";
            desc = "Compute the gravity vector and the horizon vector separately";
        }
        public void RunCS(Mat src)
        {
            gravity.Run(src);
            if (gravity.vec.p2.Y > 0 || gravity.vec.p1.Y > 0)
                task.gravityVec = gravity.vec; // don't update if not found
            horizon.Run(src);
            if (task.FirstPass) lastVec = horizon.vec;
            if (horizon.vec.p1.Y > 0)
                lastVec = horizon.vec;
            if (horizon.vec.p1.Y == 0)
                horizon.vec = lastVec;
            task.horizonVec = horizon.vec;
            if (standaloneTest())
            {
                SetTrueText("Gravity vector (yellow):" + "\n" + gravity.strOut + "\n" + "\n" + "Horizon Vector (red): " + "\n" + horizon.strOut, 3);
                dst2.SetTo(0);
                DrawLine(dst2, task.gravityVec.p1, task.gravityVec.p2, task.HighlightColor, task.lineWidth);
                DrawLine(dst2, task.horizonVec.p1, task.horizonVec.p2, Scalar.Red, task.lineWidth);
            }
        }
    }
    public class CS_GrayToColor_Palette : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        public CS_GrayToColor_Palette(VBtask task) : base(task)
        {
            labels = new string[] { "", "Right View", "", "Grayscale left view after palette applied." };
            if (standalone) task.gOptions.setDisplay1();
            desc = "Identify the main colors in an image using RedCloud";
        }
        public void RunCS(Mat src)
        {
            flood.Run(src);
            dst2 = flood.dst2;
            labels[2] = flood.labels[2];
            byte[] indices = new byte[256];
            Vec3b[] colors = new Vec3b[256];
            SortedList<int, Vec3b> sorted = new SortedList<int, Vec3b>(new CompareAllowIdenticalInteger());
            foreach (var rc in task.redCells)
            {
                int index = rc.naturalGray;
                if (index == 0) continue;
                colors[index] = rc.naturalColor;
                indices[index] = (byte)index;
                sorted.Add(index, rc.naturalColor);
            }
            int firstIndex = sorted.Keys[0];
            Vec3b lastColor = colors[firstIndex];
            for (int i = 0; i < colors.Length; i++)
            {
                if (indices[i] == 0) colors[i] = lastColor;
                else lastColor = colors[i];
            }
            dst1 = task.rightView;
            Mat colorMap = new Mat(256, 1, MatType.CV_8UC3, colors);
            Cv2.ApplyColorMap(task.leftView, dst3, colorMap);
        }
    }
    public class CS_Grid_Basics : CS_Parent
    {
        public List<Rect> gridList = new List<Rect>();
        public bool updateTaskGridList = true;
        public CS_Grid_Basics(VBtask task) : base(task)
        {
            desc = "Create a grid of squares covering the entire image.";
        }
        public void RunCS(Mat src)
        {
            if (task.mouseClickFlag && !task.FirstPass)
            {
                task.gridROIclicked = task.gridMap.At<int>(task.ClickPoint.Y, task.ClickPoint.X);
            }
            if (task.optionsChanged)
            {
                task.gridSize = task.gOptions.getGridSize();
                task.gridMask = new Mat(src.Size(), MatType.CV_8U);
                task.gridMap = new Mat(src.Size(), MatType.CV_32S, 255);
                gridList.Clear();
                task.gridIndex.Clear();
                task.gridRows = 0;
                task.gridCols = 0;
                int index = 0;
                for (int y = 0; y < src.Height; y += task.gridSize)
                {
                    for (int x = 0; x < src.Width; x += task.gridSize)
                    {
                        var roi = ValidateRect(new Rect(x, y, task.gridSize, task.gridSize));
                        if (roi.Width > 0 && roi.Height > 0)
                        {
                            if (x == 0) task.gridRows += 1;
                            if (y == 0) task.gridCols += 1;
                            gridList.Add(roi);
                            task.gridIndex.Add(index);
                            index++;
                        }
                    }
                }
                task.subDivisionCount = 9;
                if (task.color == null) return; // startup condition.
                if (src.Size() == task.color.Size())
                {
                    task.gridMask.SetTo(0);
                    for (int x = task.gridSize; x < src.Width; x += task.gridSize)
                    {
                        var p1 = new cv.Point(x, 0);
                        var p2 = new cv.Point(x, src.Height);
                        task.gridMask.Line(p1, p2, 255, task.lineWidth);
                    }
                    for (int y = task.gridSize; y < src.Height; y += task.gridSize)
                    {
                        var p1 = new cv.Point(0, y);
                        var p2 = new cv.Point(src.Width, y);
                        task.gridMask.Line(p1, p2, 255, task.lineWidth);
                    }
                    for (int i = 0; i < gridList.Count; i++)
                    {
                        var roi = gridList[i];
                        task.gridMap.Rectangle(roi, i, -1);
                    }
                    task.gridNeighbors.Clear();
                    int xx = 0, yy = 0;
                    foreach (var roi in gridList)
                    {
                        task.gridNeighbors.Add(new List<int>());
                        for (int i = 0; i < 9; i++)
                        {
                            if (i == 0) xx = roi.X - 1;
                            if (i == 1) xx = roi.X;
                            if (i == 2) xx = roi.X + roi.Width + 1;
                            if (i == 3) xx = roi.X - 1;
                            if (i == 4) xx = roi.X;
                            if (i == 5) xx = roi.X + roi.Width + 1;
                            if (i == 6) xx = roi.X - 1;
                            if (i == 7) xx = roi.X;
                            if (i == 8) xx = roi.X + roi.Width + 1;
                                          
                            if (i == 0) yy = roi.Y - 1;
                            if (i == 1) yy = roi.Y - 1;
                            if (i == 2) yy = roi.Y - 1;
                            if (i == 3) yy = roi.Y;
                            if (i == 4) yy = roi.Y;
                            if (i == 5) yy = roi.Y;
                            if (i == 6) yy = roi.Y + roi.Height + 1;
                            if (i == 7) yy = roi.Y + roi.Height + 1;
                            if (i == 8) yy = roi.Y + roi.Height + 1;

                            if (xx >= 0 && xx < src.Width && yy >= 0 && yy < src.Height)
                            {
                                task.gridNeighbors.Last().Add(task.gridMap.At<int>(yy, xx));
                            }
                        }
                    }
                }
                foreach (var roi in gridList)
                {
                    int xSub = roi.X + roi.Width;
                    int ySub = roi.Y + roi.Height;
                    if (ySub <= dst2.Height / 3)
                    {
                        if (xSub <= dst2.Width / 3) task.subDivisions.Add(0);
                        if (xSub >= dst2.Width / 3 && xSub <= dst2.Width * 2 / 3) task.subDivisions.Add(1);
                        if (xSub > dst2.Width * 2 / 3) task.subDivisions.Add(2);
                    }
                    if (ySub > dst2.Height / 3 && ySub <= dst2.Height * 2 / 3)
                    {
                        if (xSub <= dst2.Width / 3) task.subDivisions.Add(3);
                        if (xSub >= dst2.Width / 3 && xSub <= dst2.Width * 2 / 3) task.subDivisions.Add(4);
                        if (xSub > dst2.Width * 2 / 3) task.subDivisions.Add(5);
                    }
                    if (ySub > dst2.Height * 2 / 3)
                    {
                        if (xSub <= dst2.Width / 3) task.subDivisions.Add(6);
                        if (xSub >= dst2.Width / 3 && xSub <= dst2.Width * 2 / 3) task.subDivisions.Add(7);
                        if (xSub > dst2.Width * 2 / 3) task.subDivisions.Add(8);
                    }
                }
            }
            if (standaloneTest())
            {
                dst2 = new Mat(src.Size(), MatType.CV_8U);
                task.color.CopyTo(dst2);
                dst2.SetTo(Scalar.White, task.gridMask);
                labels[2] = "CS_Grid_Basics " + gridList.Count + " (" + task.gridRows + "X" + task.gridCols + ") " +
                            task.gridSize + "X" + task.gridSize + " regions";
            }
            if (updateTaskGridList) task.gridList = gridList;
        }
    }
    public class CS_Grid_BasicsTest : CS_Parent
    {
        public CS_Grid_BasicsTest(VBtask task) : base(task)
        {
            labels = new[] { "", "", "Each grid element is assigned a value below", "The line is the diagonal for each roi.  Bottom might be a shortened roi." };
            if (standaloneTest()) desc = "Validation test for Grid_Basics algorithm";
        }
        public void RunCS(Mat src)
        {
            var mean = Cv2.Mean(src);
            dst2.SetTo(0);
            for (int i = 0; i < task.gridList.Count; i++)
            {
                var roi = task.gridList[i];
                Cv2.Subtract(mean, src[roi], dst2[roi]);
                SetTrueText(i.ToString(), new cv.Point(roi.X, roi.Y));
            }
            dst2.SetTo(Scalar.White, task.gridMask);
            dst3.SetTo(0);
            Parallel.For(0, task.gridList.Count, i =>
            {
                var roi = task.gridList[i];
                Cv2.Subtract(mean, src[roi], dst3[roi]);
                DrawLine(dst3[roi], new cv.Point(0, 0), new cv.Point(roi.Width, roi.Height), Scalar.White, task.lineWidth);
            });
        }
    }
    public class CS_Grid_List : CS_Parent
    {
        public CS_Grid_List(VBtask task) : base(task)
        {
            labels[2] = "Adjust grid width/height to increase thread count.";
            if (standaloneTest()) desc = "List the active threads";
        }
        public void RunCS(Mat src)
        {
            Parallel.ForEach(task.gridList, roi =>
            {
                dst3[roi].SetTo(0);
            });
            try
            {
                var currentProcess = Process.GetCurrentProcess();
                var myThreads = currentProcess.Threads;
                string str = "";
                int threadCount = 0;
                int notIdle = 0;
                foreach (ProcessThread thread in myThreads)
                {
                    str += thread.Id + " state = " + thread.ThreadState + ", ";
                    threadCount++;
                    if (threadCount % 5 == 0) str += "\n";
                    if (thread.ThreadState != ThreadState.Wait) notIdle++;
                }
                SetTrueText("There were " + threadCount + " threads in OpenCVB with " + notIdle + " of them not idle when traversing the gridList" + "\n" + str);
            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message);
            }
        }
    }
    public class CS_Grid_Rectangles : CS_Parent
    {
        public int tilesPerRow;
        public int tilesPerCol;
        Options_Grid options = new Options_Grid();
        public CS_Grid_Rectangles(VBtask task) : base(task)
        {
            task.gridMask = new Mat(dst2.Size(), MatType.CV_8U);
            task.gridMap = new Mat(dst2.Size(), MatType.CV_32S);
            if (standaloneTest()) desc = "Create a grid of rectangles (not necessarily squares) for use with parallel.For";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.mouseClickFlag) task.gridROIclicked = task.gridMap.At<int>(task.ClickPoint.Y, task.ClickPoint.X);
            if (task.optionsChanged)
            {
                task.gridList.Clear();
                for (int y = 0; y < dst2.Height; y += options.height)
                {
                    for (int x = 0; x < dst2.Width; x += options.width)
                    {
                        var roi = new Rect(x, y, options.width, options.height);
                        if (x + roi.Width >= dst2.Width) roi.Width = dst2.Width - x;
                        if (y + roi.Height >= dst2.Height) roi.Height = dst2.Height - y;
                        if (roi.Width > 0 && roi.Height > 0)
                        {
                            if (y == 0) tilesPerRow += 1;
                            if (x == 0) tilesPerCol += 1;
                            task.gridList.Add(roi);
                        }
                    }
                }
                task.gridMask.SetTo(0);
                for (int x = options.width; x < dst2.Width; x += options.width)
                {
                    var p1 = new cv.Point(x, 0);
                    var p2 = new cv.Point(x, dst2.Height);
                    task.gridMask.Line(p1, p2, 255, task.lineWidth);
                }
                for (int y = options.height; y < dst2.Height; y += options.height)
                {
                    var p1 = new cv.Point(0, y);
                    var p2 = new cv.Point(dst2.Width, y);
                    task.gridMask.Line(p1, p2, 255, task.lineWidth);
                }
                for (int i = 0; i < task.gridList.Count; i++)
                {
                    var roi = task.gridList[i];
                    task.gridMap.Rectangle(roi, i, -1);
                }
            }
            if (standaloneTest())
            {
                task.color.CopyTo(dst2);
                dst2.SetTo(Scalar.White, task.gridMask);
                labels[2] = "Grid_Basics " + task.gridList.Count + " (" + tilesPerRow + "X" + tilesPerCol + ") " +
                            options.width + "X" + options.height + " regions";
            }
        }
    }
    public class CS_Grid_FPS : CS_Parent
    {
        public bool heartBeat;
        public System.Windows.Forms.TrackBar fpsSlider;
        int skipCount;
        int saveSkip;
        Options_Grid options = new Options_Grid();
        public CS_Grid_FPS(VBtask task) : base(task)
        {
            fpsSlider = FindSlider("Desired FPS rate");
            desc = "Provide a service that lets any algorithm control its frame rate";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            int fps = (int)(task.fpsRate / options.desiredFPS);
            if (fps == 0) fps = 1;
            heartBeat = (task.frameCount % fps) == 0;
            if (heartBeat)
            {
                saveSkip = skipCount;
                skipCount = 0;
                if (standaloneTest()) dst2 = src;
            }
            else
            {
                skipCount++;
            }
            strOut = "Grid heartbeat set to " + fpsSlider.Value + " times per second.  " + saveSkip + " frames skipped";
        }
    }
    public class CS_Grid_Neighbors : CS_Parent
    {
        Mat mask = new Mat();
        public CS_Grid_Neighbors(VBtask task) : base(task)
        {
            labels = new[] { "", "", "Grid_Basics output", "" };
            desc = "Click any grid element to see its neighbors";
        }
        public void RunCS(Mat src)
        {
            if (task.gridRows != (int)(dst2.Height / 10))
            {
                task.gOptions.setGridSize((int)(dst2.Height / 10));
                task.gridRows = task.gridSize;
                task.grid.Run(src);
            }
            dst2 = src;
            if (standaloneTest())
            {
                if (task.heartBeat)
                {
                    task.mouseClickFlag = true;
                    task.ClickPoint = new cv.Point(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height));
                }
            }
            SetTrueText("Click any grid entry to see its neighbors", 3);
            if (task.optionsChanged) mask = task.gridMask.Clone();
            if (task.mouseClickFlag)
            {
                mask = task.gridMask.Clone();
                int roiIndex = task.gridMap.At<int>(task.ClickPoint.Y, task.ClickPoint.X);
                foreach (int index in task.gridNeighbors[roiIndex])
                {
                    var roi = task.gridList[index];
                    mask.Rectangle(roi, Scalar.White);
                }
            }
            dst2.SetTo(Scalar.White, mask);
        }
    }
    public class CS_Grid_Special : CS_Parent
    {
        public int gridWidth = 10;
        public int gridHeight = 10;
        public List<Rect> gridList = new List<Rect>();
        public int gridRows;
        public int gridCols;
        public Mat gridMask;
        public List<List<int>> gridNeighbors = new List<List<int>>();
        public Mat gridMap;
        public CS_Grid_Special(VBtask task) : base(task)
        {
            gridMask = new Mat(dst2.Size(), MatType.CV_8U);
            gridMap = new Mat(dst2.Size(), MatType.CV_32S);
            desc = "Grids are normally square.  CS_Grid_Special allows grid elements to be rectangles.  Specify the Y size.";
        }
        public void RunCS(Mat src)
        {
            if (task.optionsChanged)
            {
                gridWidth = task.gridSize;
                gridList.Clear();
                gridRows = 0;
                gridCols = 0;
                for (int y = 0; y < dst2.Height; y += gridHeight)
                {
                    for (int x = 0; x < dst2.Width; x += gridWidth)
                    {
                        var roi = new Rect(x, y, gridWidth, gridHeight);
                        if (x + roi.Width >= dst2.Width) roi.Width = dst2.Width - x;
                        if (y + roi.Height >= dst2.Height) roi.Height = dst2.Height - y;
                        if (roi.Width > 0 && roi.Height > 0)
                        {
                            if (x == 0) gridRows += 1;
                            if (y == 0) gridCols += 1;
                            gridList.Add(roi);
                        }
                    }
                }
                gridMask.SetTo(0);
                for (int x = gridWidth; x < dst2.Width; x += gridWidth)
                {
                    var p1 = new cv.Point(x, 0);
                    var p2 = new cv.Point(x, dst2.Height);
                    gridMask.Line(p1, p2, 255, task.lineWidth);
                }
                for (int y = gridHeight; y < dst2.Height; y += gridHeight)
                {
                    var p1 = new cv.Point(0, y);
                    var p2 = new cv.Point(dst2.Width, y);
                    gridMask.Line(p1, p2, 255, task.lineWidth);
                }
                for (int i = 0; i < task.gridList.Count; i++)
                {
                    var roi = gridList[i];
                    gridMap.Rectangle(roi, i, -1);
                }
                gridNeighbors.Clear();
                foreach (var roi in gridList)
                {
                    gridNeighbors.Add(new List<int>());
                    int x = 0, y = 0;
                    for (int i = 0; i < 9; i++)
                    {
                        if (i == 0) x = roi.X - 1;
                        if (i == 1) x = roi.X;
                        if (i == 2) x = roi.X + roi.Width + 1;
                        if (i == 3) x = roi.X - 1;
                        if (i == 4) x = roi.X;
                        if (i == 5) x = roi.X + roi.Width + 1;
                        if (i == 6) x = roi.X - 1;
                        if (i == 7) x = roi.X;
                        if (i == 8) x = roi.X + roi.Width + 1;

                        if (i == 0) x = roi.Y - 1;
                        if (i == 1) x = roi.Y - 1;
                        if (i == 2) x = roi.Y - 1;
                        if (i == 3) x = roi.Y;
                        if (i == 4) x = roi.Y;
                        if (i == 5) x = roi.Y;
                        if (i == 6) x = roi.Y + roi.Height + 1;
                        if (i == 7) x = roi.Y + roi.Height + 1;
                        if (i == 8) x = roi.Y + roi.Height + 1;

                        if (x >= 0 && x < dst2.Width && y >= 0 && y < dst2.Height)
                        {
                            gridNeighbors.Last().Add(gridMap.At<int>(y, x));
                        }
                    }
                }
            }
            if (standaloneTest())
            {
                task.color.CopyTo(dst2);
                dst2.SetTo(Scalar.White, gridMask);
                labels[2] = "Grid_Basics " + gridList.Count + " (" + gridRows + "X" + gridCols + ") " +
                            gridWidth + "X" + gridHeight + " regions";
            }
        }
    }
    public class CS_Grid_QuarterRes : CS_Parent
    {
        public List<Rect> gridList = new List<Rect>();
        Grid_Basics grid = new Grid_Basics();
        Mat inputSrc;
        public CS_Grid_QuarterRes(VBtask task) : base(task)
        {
            inputSrc = new Mat(task.quarterRes, MatType.CV_8U, 0);
            grid.updateTaskGridList = false;
            desc = "Provide the grid list for the lowest resolution of the current stream.";
        }
        public void RunCS(Mat src)
        {
            grid.Run(inputSrc);
            gridList = grid.gridList;
            if (standaloneTest()) dst2 = task.gridMask;
        }
    }

    public class CS_Grid_MinMaxDepth : CS_Parent
    {
        public PointPair[] minMaxLocs = new PointPair[1];
        public Vec2f[] minMaxVals = new Vec2f[1];
        public CS_Grid_MinMaxDepth(VBtask task) : base(task)
        {
            task.gOptions.setGridSize(8);
            UpdateAdvice(traceName + ": goptions 'Grid Square Size' has direct impact.");
            desc = "Find the min and max depth within each grid roi.";
        }
        public void RunCS(Mat src)
        {
            if (minMaxLocs.Length != task.gridList.Count) Array.Resize(ref minMaxLocs, task.gridList.Count);
            if (minMaxVals.Length != task.gridList.Count) Array.Resize(ref minMaxVals, task.gridList.Count);
            mmData mm = new mmData();
            for (int i = 0; i < minMaxLocs.Length; i++)
            {
                var roi = task.gridList[i];
                task.pcSplit[2][roi].MinMaxLoc(out mm.minVal, out mm.maxVal, out mm.minLoc, out mm.maxLoc, task.depthMask[roi]);
                minMaxLocs[i] = new PointPair(mm.minLoc, mm.maxLoc);
                minMaxVals[i] = new Vec2f((float) mm.minVal, (float) mm.maxVal);
            }
            if (standaloneTest())
            {
                dst2.SetTo(0);
                for (int i = 0; i < minMaxLocs.Length; i++)
                {
                    var lp = minMaxLocs[i];
                    DrawCircle(dst2[task.gridList[i]], lp.p2, task.DotSize, Scalar.Red);
                    DrawCircle(dst2[task.gridList[i]], lp.p1, task.DotSize, Scalar.White);
                }
                dst2.SetTo(Scalar.White, task.gridMask);
            }
        }
    }
    public class CS_Grid_TrackCenter : CS_Parent
    {
        public cv.Point center;
        Match_Basics match = new Match_Basics();
        public CS_Grid_TrackCenter(VBtask task) : base(task)
        {
            if (standalone) task.gOptions.setShowGrid(true);
            desc = "Track a cell near the center of the grid";
        }
        public void RunCS(Mat src)
        {
            if (match.correlation < match.options.correlationMin || task.gOptions.getDebugCheckBox())
            {
                task.gOptions.setDebugCheckBox(false);
                int index = task.gridMap.Get<int>(dst2.Height / 2, dst2.Width / 2);
                var roi = task.gridList[index];
                match.template = src[roi].Clone();
                center = new cv.Point(roi.X + roi.Width / 2, roi.Y + roi.Height / 2);
            }
            int templatePad = match.options.templatePad;
            int templateSize = match.options.templateSize;
            match.searchRect = ValidateRect(new Rect(center.X - templatePad, center.Y - templatePad, templateSize, templateSize));
            match.Run(src);
            center = match.matchCenter;
            if (standaloneTest())
            {
                dst2 = src;
                dst2.Rectangle(match.matchRect, task.HighlightColor, task.lineWidth + 1, task.lineType);
                DrawCircle(dst2, center, task.DotSize, Scalar.White);
                if (task.heartBeat) dst3.SetTo(0);
                DrawCircle(dst3, center, task.DotSize, task.HighlightColor);
                SetTrueText(match.correlation.ToString(fmt3), center, 3);
                labels[3] = "Match correlation = " + match.correlation.ToString(fmt3);
            }
        }
    }
    public class CS_Grid_ShowMap : CS_Parent
    {
        public CS_Grid_ShowMap(VBtask task) : base(task)
        {
            desc = "Verify that task.gridMap is laid out correctly";
        }
        public void RunCS(Mat src)
        {
            task.gridMap.ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2);
        }
    }
    public class CS_GuidedBP_Basics : CS_Parent
    {
        public GuidedBP_HotPoints ptHot = new GuidedBP_HotPoints();
        Mat topMap = new Mat();
        Mat sideMap = new Mat();
        public CS_GuidedBP_Basics(VBtask task) : base(task)
        {
            topMap = new Mat(dst2.Size(), MatType.CV_8U, 0);
            sideMap = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Correlate the hot points with the previous generation using a Map";
        }
        void runMap(List<Rect> rectList, int dstindex, Mat map)
        {
            var sortRects = new SortedList<int, Rect>(new compareAllowIdenticalIntegerInverted());
            foreach (var r in rectList)
            {
                sortRects.Add(r.Width * r.Height, r);
            }
            var ptList = new List<Point>();
            var indices = new List<int>();
            foreach (var r in sortRects.Values)
            {
                var pt = new cv.Point((int)(r.X + r.Width / 2), (int)(r.Y + r.Height / 2));
                int index = (int)map.At<byte>(pt.Y, pt.X);
                if (index == 0 || indices.Contains(index))
                {
                    index = (index == ptList.Count) ? ptList.Count + 1 : ptList.Count;
                }
                ptList.Add(pt);
                indices.Add(index);
            }
            map.SetTo(0);
            foreach (var r in sortRects.Values)
            {
                var pt = new cv.Point((int)(r.X + r.Width / 2), (int)(r.Y + r.Height / 2));
                var index = indices[ptList.IndexOf(pt)];
                map.Rectangle(r, index, -1);
                SetTrueText(index.ToString(), pt, dstindex);
            }
        }
        public void RunCS(Mat src)
        {
            ptHot.Run(src);
            dst2 = ptHot.dst2;
            dst3 = ptHot.dst3;
            runMap(ptHot.topRects, 2, topMap);
            runMap(ptHot.sideRects, 3, sideMap);
            labels[2] = ptHot.topRects.Count.ToString() + " objects found in the top view";
            labels[3] = ptHot.sideRects.Count.ToString() + " objects found in the Side view";
        }
    }
    public class CS_GuidedBP_HotPointsKNN : CS_Parent
    {
        GuidedBP_HotPoints ptHot = new GuidedBP_HotPoints();
        KNN_Core knnSide = new KNN_Core();
        KNN_Core knnTop = new KNN_Core();
        public CS_GuidedBP_HotPointsKNN(VBtask task) : base(task)
        {
            desc = "Correlate the hot points with the previous generation to ID each object";
        }
        void runKNN(KNN_Core knn, List<Rect> rectList, Mat dst, int dstindex)
        {
            knn.queries.Clear();
            foreach (var r in rectList)
            {
                knn.queries.Add(new Point2f((float)(r.X + r.Width / 2), (float)(r.Y + r.Height / 2)));
            }
            if (task.FirstPass) knn.trainInput = new List<Point2f>(knn.queries);
            knn.Run(empty);
            for (int i = 0; i < knn.queries.Count; i++)
            {
                var p1 = knn.queries[i];
                var index = knn.result[i, 0];
                var p2 = knn.trainInput[index];
                var dist = p1.DistanceTo(p2);
                var r = rectList[i];
                if (dist < r.Width / 2 && dist < r.Height / 2)
                {
                    dst.Rectangle(r, Scalar.White, task.lineWidth);
                    var pt = new cv.Point(r.X + r.Width, r.Y + r.Height);
                    SetTrueText(index.ToString(), pt, dstindex);
                }
            }
            knn.trainInput = new List<Point2f>(knn.queries);
        }
        public void RunCS(Mat src)
        {
            ptHot.Run(src);
            dst2 = ptHot.dst2;
            dst3 = ptHot.dst3;
            runKNN(knnTop, ptHot.topRects, dst2, 2);
            runKNN(knnSide, ptHot.sideRects, dst3, 3);
            labels[2] = ptHot.topRects.Count.ToString() + " objects found in the top view";
            labels[3] = ptHot.sideRects.Count.ToString() + " objects found in the Side view";
        }
    }
    public class CS_GuidedBP_HotPoints : CS_Parent
    {
        public Projection_HistTop histTop = new Projection_HistTop();
        public Projection_HistSide histSide = new Projection_HistSide();
        public List<Rect> topRects = new List<Rect>();
        public List<Rect> sideRects = new List<Rect>();
        Rect floodRect;
        Mat mask;
        public CS_GuidedBP_HotPoints(VBtask task) : base(task)
        {
            floodRect = new Rect(1, 1, dst2.Width - 2, dst2.Height - 2);
            mask = new Mat(new cv.Size(dst2.Width + 2, dst2.Height + 2), MatType.CV_8U);
            task.useXYRange = false;
            desc = "Use floodfill to identify all the objects in both the top and side views.";
        }
        List<Rect> hotPoints(ref Mat view)
        {
            Rect rect = new Rect();
            var points = view.FindNonZero();
            var viewList = new SortedList<int, Point>(new compareAllowIdenticalIntegerInverted());
            mask.SetTo(0);
            for (int i = 0; i < points.Rows; i++)
            {
                var pt = points.At<Point>(i, 0);
                int maskOnly = (int)FloodFillFlags.MaskOnly;
                int count = view.FloodFill(mask, pt, 0, out rect, 0, 0, (cv.FloodFillFlags)(4 | maskOnly | (255 << 8)));
                if (count > 0) viewList.Add(count, pt);
            }
            mask.SetTo(0);
            var rectList = new List<Rect>();
            for (int i = 0; i < Math.Min(viewList.Count, 10); i++)
            {
                var pt = viewList.ElementAt(i).Value;
                int fixedRange = (int)FloodFillFlags.FixedRange;
                view.FloodFill(mask, pt, 0, out rect, 0, 0, (cv.FloodFillFlags)(4 | fixedRange | ((i + 1) << 8)));
                rectList.Add(new Rect(rect.X - 1, rect.Y - 1, rect.Width, rect.Height));
            }
            mask[floodRect].CopyTo(view);
            return rectList;
        }
        public void RunCS(Mat src)
        {
            histTop.Run(src.Clone());
            topRects = hotPoints(ref histTop.dst3);
            dst2 = ShowPalette(histTop.dst3 * 255 / topRects.Count);
            histSide.Run(src);
            sideRects = hotPoints(ref histSide.dst3);
            dst3 = ShowPalette(histSide.dst3 * 255 / sideRects.Count);
            if (task.heartBeat) labels[2] = "Top " + topRects.Count.ToString() + " objects identified in the top view.";
            if (task.heartBeat) labels[3] = "Top " + sideRects.Count.ToString() + " objects identified in the side view.";
        }
    }
    public class CS_GuidedBP_PlanesPlot : CS_Parent
    {
        Projection_HistSide histSide = new Projection_HistSide();
        public CS_GuidedBP_PlanesPlot(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Side view", "Plot of nonzero rows in the side view" };
            desc = "Plot the likely floor or ceiling areas.";
        }
        public void RunCS(Mat src)
        {
            histSide.Run(src);
            dst2 = histSide.dst3;
            var sumList = new List<int>();
            dst3.SetTo(0);
            for (int i = 0; i < dst2.Rows; i++)
            {
                int x = dst2.Row(i).CountNonZero();
                sumList.Add(x);
                DrawLine(dst3, new cv.Point(0, i), new cv.Point(x, i), Scalar.White, task.lineWidth);
            }
            var flatSurfacesInRow = new List<int>();
            for (int i = 0; i < sumList.Count; i++)
            {
                if (sumList[i] > 5)
                {
                    int maxSpike = sumList[i];
                    int maxRow = i;
                    for (int j = i + 1; j < sumList.Count; j++)
                    {
                        if (maxSpike < sumList[j])
                        {
                            maxSpike = sumList[j];
                            maxRow = j;
                        }
                        if (sumList[j] == 0)
                        {
                            i = j;
                            flatSurfacesInRow.Add(maxRow);
                            break;
                        }
                    }
                }
            }
            labels[2] = "There were " + flatSurfacesInRow.Count.ToString() + " flat surface candidates found.";
        }
    }
    public class CS_GuidedBP_Points : CS_Parent
    {
        public GuidedBP_Basics hotPoints = new GuidedBP_Basics();
        public int classCount;
        public cv.Point selectedPoint;
        public List<Rect> topRects = new List<Rect>();
        public List<Rect> sideRects = new List<Rect>();
        public Mat histogramTop = new Mat();
        public Mat histogramSide = new Mat();
        public Mat backP = new Mat();
        public CS_GuidedBP_Points(VBtask task) : base(task)
        {
            desc = "Use floodfill to identify all the objects in the selected view then build a backprojection that identifies k objects in the image view.";
        }
        public void RunCS(Mat src)
        {
            hotPoints.Run(src);
            hotPoints.ptHot.histTop.dst3.ConvertTo(histogramTop, MatType.CV_32F);
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsTop, histogramTop, backP, task.rangesTop);
            topRects = new List<Rect>(hotPoints.ptHot.topRects);
            sideRects = new List<Rect>(hotPoints.ptHot.sideRects);
            dst2 = ShowPalette(backP * 255 / topRects.Count);
            hotPoints.ptHot.histSide.dst3.ConvertTo(histogramSide, MatType.CV_32F);
            Cv2.CalcBackProject(new Mat[] { task.pointCloud }, task.channelsSide, histogramSide, dst3, task.rangesSide);
            dst3 = ShowPalette(dst3 * 255 / sideRects.Count);
            classCount = topRects.Count + sideRects.Count;
            if (task.mouseClickFlag) selectedPoint = task.ClickPoint;
            if (task.heartBeat) labels[2] = topRects.Count.ToString() + " objects were identified in the top view.";
            if (task.heartBeat) labels[3] = sideRects.Count.ToString() + " objects were identified in the side view.";
        }
    }
    public class CS_GuidedBP_Lookup : CS_Parent
    {
        GuidedBP_Basics guided = new GuidedBP_Basics();
        public CS_GuidedBP_Lookup(VBtask task) : base(task)
        {
            task.ClickPoint = new cv.Point(dst2.Width / 2, dst2.Height / 2);
            desc = "Given a point cloud pixel, look up which object it is in.  Click in the Depth RGB image to test.";
        }
        public void RunCS(Mat src)
        {
            guided.Run(src);
            dst2 = guided.dst2;
            labels[2] = guided.labels[2];
        }
    }
    public class CS_GuidedBP_Depth : CS_Parent
    {
        public PointCloud_Histograms hist = new PointCloud_Histograms();
        Palette_Random myPalette = new Palette_Random();
        public int classCount;
        public CS_GuidedBP_Depth(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(16);
            desc = "Backproject the 2D histogram of depth for selected channels to discretize the depth data.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            hist.Run(src);
            float[] histArray = new float[hist.histogram.Total()];
            Marshal.Copy(hist.histogram.Data, histArray, 0, histArray.Length);
            var histList = histArray.ToList();
            histArray[histList.IndexOf(histList.Max())] = 0;
            var sortedHist = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
            for (int i = 0; i < histArray.Length; i++)
            {
                sortedHist.Add(histArray[i], i);
            }
            classCount = 0;
            int count = 0;
            float[] newSamples = new float[histArray.Length];
            for (int i = 0; i < sortedHist.Count; i++)
            {
                int index = sortedHist.ElementAt(i).Value;
                count += (int)sortedHist.ElementAt(i).Key;
                newSamples[index] = classCount;
                classCount++;
                if (classCount >= 255) break;
            }
            Marshal.Copy(newSamples, 0, hist.histogram.Data, newSamples.Length);
            Cv2.CalcBackProject(new Mat[] { src }, task.redOptions.channels, hist.histogram, dst2, task.redOptions.ranges);
            dst2.ConvertTo(dst2, MatType.CV_8U);
            if (standaloneTest())
            {
                labels[3] = "Note that colors are shifting because this is before any matching.";
                dst2 += 1;
                dst2.SetTo(0, task.noDepthMask);
                myPalette.Run(dst2);
                dst3 = myPalette.dst2;
            }
            int depthCount = task.depthMask.CountNonZero();
            labels[2] = classCount.ToString() + " regions detected in the backprojection - " + string.Format("{0:0%}", (float)count / depthCount);
        }
    }
    public class CS_HeatMap_Basics : CS_Parent
    {
        public History_Basics topframes = new History_Basics();
        public History_Basics sideframes = new History_Basics();
        public Mat histogramTop = new Mat();
        public Mat histogramSide = new Mat();
        Options_HeatMap options = new Options_HeatMap();
        public CS_HeatMap_Basics(VBtask task) : base(task)
        {
            desc = "Highlight concentrations of depth pixels in the side view";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, task.channelsTop, new Mat(), histogramTop, 2, task.bins2D, task.rangesTop);
            histogramTop.Row(0).SetTo(0);
            Cv2.CalcHist(new Mat[] { src }, task.channelsSide, new Mat(), histogramSide, 2, task.bins2D, task.rangesSide);
            histogramSide.Col(0).SetTo(0);
            topframes.Run(histogramTop);
            dst0 = topframes.dst2;
            sideframes.Run(histogramSide);
            dst1 = sideframes.dst2;
            dst2 = ShowPalette(dst0.ConvertScaleAbs());
            dst3 = ShowPalette(dst1.ConvertScaleAbs());
            labels[2] = "Top view of heat map with the last " + task.frameHistoryCount.ToString() + " frames";
            labels[3] = "Side view of heat map with the last " + task.frameHistoryCount.ToString() + " frames";
        }
    }
    public class CS_HeatMap_Grid : CS_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        public CS_HeatMap_Grid(VBtask task) : base(task)
        {
            task.gOptions.setGridSize(5);
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            dst3 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            labels = new string[] { "", "", "Histogram mask for top-down view - original histogram in dst0", "Histogram mask for side view - original histogram in dst1" };
            desc = "Apply a grid to the HeatMap_OverTime to isolate objects.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            heat.Run(src);
            dst2.SetTo(0);
            dst3.SetTo(0);
            int maxCount1 = 0, maxCount2 = 0;
            object sync1 = new object(), sync2 = new object();
            if (task.gOptions.getMultiThreading())
            {
                Parallel.ForEach(task.gridList, roi =>
                {
                    int count1 = heat.histogramTop[roi].CountNonZero();
                    dst2[roi].SetTo(count1);
                    if (count1 > maxCount1)
                    {
                        lock (sync1)
                        {
                            maxCount1 = count1;
                        }
                    }
                    int count2 = heat.histogramSide[roi].CountNonZero();
                    dst3[roi].SetTo(count2);
                    if (count2 > maxCount2)
                    {
                        lock (sync2)
                        {
                            maxCount2 = count2;
                        }
                    }
                });
            }
            else
            {
                foreach (var roi in task.gridList)
                {
                    int count1 = heat.histogramTop[roi].CountNonZero();
                    dst2[roi].SetTo(count1);
                    if (count1 > maxCount1) maxCount1 = count1;
                    int count2 = heat.histogramSide[roi].CountNonZero();
                    dst3[roi].SetTo(count2);
                    if (count2 > maxCount2) maxCount2 = count2;
                }
            }
            dst2 *= 255.0 / maxCount1;
            dst3 *= 255.0 / maxCount2;
        }
    }
    public class CS_HeatMap_HotNot : CS_Parent
    {
        HeatMap_Hot heat = new HeatMap_Hot();
        public CS_HeatMap_HotNot(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Mask of cool areas in the heat map - top view", "Mask of cool areas in the heat map - side view" };
            desc = "Isolate points with low histogram values in side and top views";
        }
        public void RunCS(Mat src)
        {
            heat.Run(src);
            dst0 = heat.dst2.ConvertScaleAbs();
            dst1 = heat.dst3.ConvertScaleAbs();
            dst2 = dst0.Threshold(task.redOptions.getProjection(), 255, ThresholdTypes.Binary);
            dst3 = dst1.Threshold(task.redOptions.getProjection(), 255, ThresholdTypes.Binary);
        }
    }
    public class CS_HeatMap_Hot : CS_Parent
    {
        Projection_HistTop histTop = new Projection_HistTop();
        Projection_HistSide histSide = new Projection_HistSide();
        public CS_HeatMap_Hot(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Mask of hotter areas for the Top View", "Mask of hotter areas for the Side View" };
            desc = "Isolate masks for just the hotspots in the heat map";
        }
        public void RunCS(Mat src)
        {
            histTop.Run(src);
            dst2 = histTop.histogram;
            histSide.Run(src);
            dst3 = histSide.histogram;
            var mmTop = GetMinMax(dst2);
            var mmSide = GetMinMax(dst3);
            if (task.heartBeat) labels[2] = mmTop.maxVal.ToString() + " max count " + dst2.CountNonZero() + " pixels in the top down view";
            if (task.heartBeat) labels[3] = mmSide.maxVal.ToString() + " max count " + dst3.CountNonZero() + " pixels in the side view";
        }
    }
    public class CS_HeatMap_Cell : CS_Parent
    {
        Flood_Basics flood = new Flood_Basics();
        HeatMap_Hot heat = new HeatMap_Hot();
        public CS_HeatMap_Cell(VBtask task) : base(task)
        {
            task.redOptions.setIdentifyCells(true);
            if (standalone) task.gOptions.setDisplay1();
            desc = "Display the heat map for the selected cell";
        }
        public void RunCS(Mat src)
        {
            flood.Run(src);
            dst2 = flood.dst2;
            labels[2] = flood.labels[2];
            dst0 = new Mat(dst2.Size(), MatType.CV_32FC3, 0);
            task.pointCloud[task.rc.rect].CopyTo(dst0[task.rc.rect], task.rc.mask);
            heat.Run(dst0);
            dst1 = heat.dst2;
            dst3 = heat.dst3;
            labels[1] = heat.labels[2];
            labels[3] = heat.labels[3];
        }
    }
    public class CS_HeatMap_GuidedBP : CS_Parent
    {
        GuidedBP_Basics guided = new GuidedBP_Basics();
        public CS_HeatMap_GuidedBP(VBtask task) : base(task)
        {
            task.redOptions.setProjection(1);
            desc = "This is just a placeholder to make it easy to find the GuidedBP_Basics which shows objects in top/side views.";
        }
        public void RunCS(Mat src)
        {
            guided.Run(src);
            dst2 = guided.dst2;
            dst3 = guided.dst3;
            labels = guided.labels;
        }
    }
    public class CS_Hist_Basics : CS_Parent
    {
        public Mat histogram = new Mat();
        public mmData mm;
        public Plot_Histogram plot = new Plot_Histogram();
        public Rangef[] ranges;
        public float[] histArray;
        public Mat inputMask = new Mat();
        public Rangef[] fixedRanges;
        public int bins;
        public bool removeMax;
        public bool autoDisplay;
        int splitIndex;
        public CS_Hist_Basics(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(255);
            desc = "Create a histogram (no Kalman)";
        }
        public void RunCS(Mat src)
        {
            if (standalone)
            {
                if (task.heartBeat) splitIndex = (splitIndex + 1) % 3;
                mm = GetMinMax(src.ExtractChannel(splitIndex));
                if (splitIndex == 0)
                    plot.backColor = Scalar.Blue;
                else if (splitIndex == 1)
                    plot.backColor = Scalar.Green;
                else
                    plot.backColor = Scalar.Red;

            }
            else
            {
                if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                mm = GetMinMax(src);
            }
            if (fixedRanges == null)
            {
                ranges = new Rangef[] { new Rangef((float)(mm.minVal - histDelta), (float)(mm.maxVal + histDelta)) };
            }
            else
            {
                ranges = fixedRanges;
            }
            // ranges are exclusive in OpenCV!!!
            if (bins == 0)
            {
                Cv2.CalcHist(new Mat[] { src }, new int[] { splitIndex }, inputMask, histogram, 1, new int[] { task.histogramBins }, ranges);
            }
            else
            {
                Cv2.CalcHist(new Mat[] { src }, new int[] { splitIndex }, inputMask, histogram, 1, new int[] { bins }, ranges);
            }
            if (removeMax)
            {
                var mmMax = GetMinMax(histogram);
                histogram.Set<float>(mmMax.maxLoc.Y, mmMax.maxLoc.X, 0);
            }
            histArray = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            plot.Run(histogram);
            histogram = plot.histogram; // reflect any updates to the 0 entry...  
            dst2 = plot.dst2;
            if (standalone)
            {
                string colorName;
                if (splitIndex == 0)
                    colorName = "Blue";
                else if (splitIndex == 1)
                    colorName = "Green";
                else
                    colorName = "Red";

                labels[2] = colorName + " histogram, bins = " +
                               task.histogramBins.ToString() + ", X ranges from " +
                               mm.minVal.ToString("0.0") + " to " +
                               mm.maxVal.ToString("0.0") + ", y is sample count";
            }
            else
            {
                labels[2] = "Range = " + ranges[0].Start.ToString(fmt3) + " To " + ranges[0].End.ToString(fmt3);
            }
        }
    }
    public class CS_Hist_Grayscale : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public CS_Hist_Grayscale(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(255);
            desc = "Create a histogram of the grayscale image";
        }
        public void RunCS(Mat src)
        {
            hist.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
            dst2 = hist.dst2;
            dst3 = hist.dst3;
            labels = hist.labels;
        }
    }
    public class CS_Hist_Graph : CS_Parent
    {
        public Mat[] histRaw = new Mat[3];
        public Mat[] histNormalized = new Mat[3];
        public float minRange = 0;
        public float maxRange = 255;
        public Scalar backColor = Scalar.Gray;
        public bool plotRequested;
        public Scalar[] plotColors = { Scalar.Blue, Scalar.Green, Scalar.Red };
        public float plotMaxValue;
        public CS_Hist_Graph(VBtask task) : base(task)
        {
            desc = "Plot histograms for up to 3 channels.";
        }
        public void RunCS(Mat src)
        {
            int[] dimensions = { task.histogramBins };
            Rangef[] ranges = new Rangef[] { new Rangef(minRange, maxRange) };
            float plotWidth = dst2.Width / task.histogramBins;
            mmData mm = new mmData();
            dst2.SetTo(backColor);
            for (int i = 0; i < src.Channels(); i++)
            {
                Mat hist = new Mat();
                Cv2.CalcHist(new Mat[] { src }, new int[] { i }, new Mat(), hist, 1, dimensions, ranges);
                histRaw[i] = hist.Clone();
                mm = GetMinMax(histRaw[i]);
                histNormalized[i] = hist.Normalize(0, hist.Rows, NormTypes.MinMax);
                if (standaloneTest() || plotRequested)
                {
                    List<Point> points = new List<Point>();
                    List<List<Point>> listOfPoints = new List<List<Point>>();
                    for (int j = 0; j < task.histogramBins; j++)
                    {
                        points.Add(new cv.Point((int)(j * plotWidth), dst2.Rows - dst2.Rows * histRaw[i].Get<float>(j, 0) / mm.maxVal));
                    }
                    listOfPoints.Add(points);
                    dst2.Polylines(listOfPoints, false, plotColors[i], task.lineWidth, task.lineType);
                }
            }
            if (standaloneTest() || plotRequested)
            {
                plotMaxValue = (float)Math.Round((float)(mm.maxVal / 1000), 0) * 1000 + 1000; // smooth things out a little for the scale below
                AddPlotScale(dst2, 0, plotMaxValue);
                labels[2] = "Histogram for src image (default color) - " + task.histogramBins.ToString() + " bins";
            }
        }
    }
    public class CS_Hist_NormalizeGray : CS_Parent
    {
        public Hist_Basics histogram = new Hist_Basics();
        private Options_Histogram options = new Options_Histogram();

        public CS_Hist_NormalizeGray(VBtask task) : base(task)
        {
            labels[2] = "Use sliders to adjust the image and create a histogram of the results";
            desc = "Create a histogram of a normalized image";
        }

        public void RunCS(Mat src)
        {
            options.RunVB();

            dst3 = src.Normalize(options.minGray, options.maxGray, NormTypes.MinMax); // only minMax is working...
            histogram.Run(dst3);
            dst2 = histogram.dst2;
        }
    }
    public class CS_Hist_EqualizeGray : CS_Parent
    {
        public Hist_Basics histogramEQ = new Hist_Basics();
        public Hist_Basics histogram = new Hist_Basics();
        Mat_4to1 mats = new Mat_4to1();
        public CS_Hist_EqualizeGray(VBtask task) : base(task)
        {
            histogramEQ.plot.addLabels = false;
            histogram.plot.addLabels = false;
            labels[2] = "Equalized image";
            labels[3] = "Orig. Hist, Eq. Hist, Orig. Image, Eq. Image";
            desc = "Create an equalized histogram of the grayscale image.";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            histogram.Run(src);
            Cv2.EqualizeHist(src, dst2);
            histogramEQ.Run(dst2);
            mats.mat[0] = histogram.dst2.Clone();
            mats.mat[1] = histogramEQ.dst2;
            mats.mat[2] = src;
            mats.mat[3] = dst2;
            mats.Run(empty);
            dst3 = mats.dst2;
        }
    }
    public class CS_Hist_Simple : CS_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        public CS_Hist_Simple(VBtask task) : base(task)
        {
            labels[2] = "Histogram of the grayscale video stream";
            desc = "Build a simple and reusable histogram for grayscale images.";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            Rangef[] ranges = new Rangef[] { new Rangef(plot.minRange, plot.maxRange) };
            Mat hist = new Mat();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), hist, 1, new int[] { task.histogramBins }, ranges);
            plot.Run(hist);
            dst2 = plot.dst2;
        }
    }
    public class CS_Hist_ColorsAndGray : CS_Parent
    {
        Hist_Basics histogram = new Hist_Basics();
        Mat_4Click mats = new Mat_4Click();
        public CS_Hist_ColorsAndGray(VBtask task) : base(task)
        {
            labels[2] = "Click any quadrant at right to view it below";
            desc = "Create a histogram of a normalized image";
        }
        public void RunCS(Mat src)
        {
            Mat[] split = src.Split();
            Array.Resize(ref split, 4);
            split[3] = src.CvtColor(ColorConversionCodes.BGR2GRAY); // add a 4th image - the grayscale image to the R G and B images.
            for (int i = 0; i < split.Length; i++)
            {
                Mat histSrc = split[i];
                if (i == 0)
                    histogram.plot.backColor = Scalar.Blue;
                else if (i == 1)
                    histogram.plot.backColor = Scalar.Green;
                else
                    histogram.plot.backColor = Scalar.Red;
                histogram.Run(histSrc);
                mats.mat[i] = histogram.plot.dst2.Clone();
            }
            mats.Run(empty);
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }
    public class CS_Hist_Frustrum : CS_Parent
    {
        HeatMap_Basics heat = new HeatMap_Basics();
        public CS_Hist_Frustrum(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.gOptions.setGravityUsage(false);
            desc = "Options for the side and top view.  See OptionCommon_Histogram to make settings permanent.";
        }
        public void RunCS(Mat src)
        {
            heat.Run(src);
            dst2 = heat.dst2;
            dst3 = heat.dst3;
            SetTrueText("This algorithm was created to tune the frustrum and camera locations." + "\n" +
                        "Without these tuning parameters the side and top views will look correct." + "\n" +
                        "To see how these adjustments work or to add a new camera, " + "\n" +
                        "use the HeatMap_Basics algorithm." + "\n" +
                        "For new cameras, make the adjustments needed, note the value, and update " + "\n" +
                        "the Select statement in the constructor for Options_CameraDetails.", new cv.Point(10, 80), 1);
        }
    }
    public class CS_Hist_PeakMax : CS_Parent
    {
        Hist_Basics hist;
        public CS_Hist_PeakMax(VBtask task) : base(task)
        {
            desc = "Create a histogram and back project into the image the grayscale color with the highest occurance.";
            labels[3] = "Grayscale Histogram";
            hist = new Hist_Basics();
        }
        public void RunCS(Mat src)
        {
            task.gOptions.SetUseKalman(false);
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst3 = hist.dst2;
            mmData mm = GetMinMax(hist.histogram);
            int brickWidth = dst2.Width / task.histogramBins;
            int brickRange = 255 / task.histogramBins;
            int histindex = mm.maxLoc.Y;
            int pixelMin = (int)(histindex * brickRange);
            int pixelMax = (int)((histindex + 1) * brickRange);
            Mat mask = src.InRange(pixelMin, pixelMax).Threshold(1, 255, ThresholdTypes.Binary);
            Mat tmp = new Mat(dst2.Size(), MatType.CV_8U, Scalar.All(0));
            src.CopyTo(tmp, mask);
            dst2 = tmp.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "BackProjection of most frequent gray pixel";
            Cv2.Rectangle(dst3, new Rect(brickWidth * histindex, 0, brickWidth, dst2.Height), Scalar.Yellow, 1);
        }
    }
    public class CS_Hist_PeakFinder : CS_Parent
    {
        public Hist_Basics hist;
        public int peakCount;
        public bool resetPeaks;
        public List<int> histogramPeaks = new List<int>();
        public float[] hCount;
        int saveHistBins;
        float[] peakCounts;
        List<int> allPCounts;
        List<int> maxList;
        public CS_Hist_PeakFinder(VBtask task) : base(task)
        {
            desc = "Find the peaks - columns taller that both neighbors - in the histogram";
            hist = new Hist_Basics();
            allPCounts = new List<int>();
            maxList = new List<int>();
            peakCounts = new float[task.histogramBins];
            saveHistBins = task.histogramBins;
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1) src = task.pcSplit[2];
            hist.Run(src);
            dst2 = hist.dst2;
            resetPeaks = false;
            if (saveHistBins != task.histogramBins)
            {
                resetPeaks = true;
                allPCounts.Clear();
                maxList.Clear();
                saveHistBins = task.histogramBins;
                Array.Resize(ref peakCounts, task.histogramBins);
            }
            hCount = new float[task.histogramBins];
            Mat histogram = hist.histogram;
            List<int> peaks = new List<int>();
            float maxPeak = float.MinValue;
            int maxIndex = 0;
            for (int i = 0; i < histogram.Rows; i++)
            {
                float prev = histogram.Get<float>(Math.Max(i - 1, 0), 0);
                float curr = histogram.Get<float>(i, 0);
                float nextVal = histogram.Get<float>(Math.Min(i + 1, histogram.Rows - 1), 0);
                hCount[i] = curr;
                if (i == 0)
                {
                    if (prev >= nextVal)
                    {
                        peaks.Add(i);
                        peakCounts[i] += 1;
                    }
                }
                else
                {
                    if (prev <= curr && curr > nextVal)
                    {
                        peaks.Add(i);
                        peakCounts[i] += 1;
                    }
                }
                if (curr > maxPeak)
                {
                    maxPeak = curr;
                    maxIndex = i;
                }
            }
            allPCounts.Add(peaks.Count);
            maxList.Add(maxIndex);

            peakCount = (int)allPCounts.Average();
            SetTrueText("/t" + "Avg peaks: " + peakCount + ".  Current: " + peaks.Count + " peaks.", new cv.Point(0, 10), 3);
            var sortedPeaks = new SortedDictionary<int, int>(new compareAllowIdenticalIntegerInverted());
            for (int i = 0; i < peakCounts.Length; i++)
            {
                sortedPeaks.Add((int)peakCounts[i], i);
            }
            mmData mm = GetMinMax(histogram);
            if (mm.maxVal == 0) return; // entries are all zero?  Likely camera trouble.
            int brickWidth = dst2.Width / histogram.Rows;
            histogramPeaks.Clear();
            for (int i = 0; i < Math.Min(sortedPeaks.Count, peakCount); i++)
            {
                int index = sortedPeaks.ElementAt(i).Value;
                histogramPeaks.Add(index);
                int h = (int)(hCount[index] * dst2.Height / mm.maxVal);
                Cv2.Rectangle(dst2, new Rect(index * brickWidth, dst2.Height - h, brickWidth, h), Scalar.Yellow, task.lineWidth);
            }
            if (allPCounts.Count > 100)
            {
                allPCounts.RemoveAt(0);
                maxList.RemoveAt(0);
            }
            if (Math.Abs(maxList.Average() - maxIndex) > saveHistBins / 10) saveHistBins = 0;
            labels[2] = "There were " + peakCount + " depth peaks (highlighted) up to " + task.MaxZmeters + " meters.  " +
                        "Use global option Histogram Bins to set the number of bins.";
        }
    }
    public class CS_Hist_PeaksDepth : CS_Parent
    {
        Hist_PeakFinder peaks;
        public CS_Hist_PeaksDepth(VBtask task) : base(task)
        {
            desc = "Find the peaks - columns taller that both neighbors - in the histogram";
            peaks = new Hist_PeakFinder();
        }
        public void RunCS(Mat src)
        {
            peaks.Run(task.pcSplit[2]);
            dst2 = peaks.dst2;
            labels[2] = peaks.labels[2];
        }
    }
    public class CS_Hist_PeaksRGB : CS_Parent
    {
        Mat_4Click mats;
        Hist_PeakFinder[] peaks;
        public CS_Hist_PeaksRGB(VBtask task) : base(task)
        {
            peaks = new Hist_PeakFinder[3];
            for (int i = 0; i < 3; i++)
            {
                peaks[i] = new Hist_PeakFinder();
            }
            labels[2] = "Upper left is Blue, upper right is Green, bottom left is Red";
            desc = "Find the peaks and valleys for each of the BGR channels.";
            mats = new Mat_4Click();
        }
        public void RunCS(Mat src)
        {
            Mat[] split = src.Split();
            for (int i = 0; i < 3; i++)
            {
                peaks[i].hist.plot.backColor = new Scalar(i == 0 ? 255 : 0, i == 1 ? 255 : 0, i == 2 ? 255 : 0);
                peaks[i].hist.plot.addLabels = false;
                peaks[i].Run(split[i]);
                mats.mat[i] = peaks[i].dst2.Clone();
            }
            if (task.optionsChanged)
            {
                task.mouseClickFlag = true;
                task.mousePicTag = RESULT_DST2;
            }
            mats.Run(new Mat());
            dst2 = mats.dst2;
            dst3 = mats.dst3;
        }
    }
    public class CS_Hist_Color : CS_Parent
    {
        Mat histogram = new cv.Mat();
        Plot_Histogram plot = new Plot_Histogram();
        Rangef[] ranges;
        public CS_Hist_Color(VBtask task) : base(task)
        {
            desc = "Create a histogram of green and red.";
        }
        public void RunCS(Mat src)
        {
            ranges = new Rangef[2] { new Rangef(0, 255), new Rangef(0, 255) };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 1, 2 }, new Mat(), histogram, 1, new int[] { task.histogramBins, task.histogramBins }, ranges);
            Mat test = histogram.Clone();
            test.Normalize(0, 255, NormTypes.MinMax);
            Mat input = new cv.Mat();
            src.ConvertTo(input, MatType.CV_32FC3);
            Mat mask = new Mat();
            Cv2.CalcBackProject(new Mat[] { input }, new int[] { 1, 2 }, histogram, mask, ranges);
            mmData mm = GetMinMax(mask);
            plot.Run(test);
            dst2 = plot.dst2;
        }
    }
    public class CS_Hist_KalmanAuto : CS_Parent
    {
        Mat histogram = new Mat();
        Kalman_Basics kalman = new Kalman_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        mmData mm;
        Rangef[] ranges;
        int splitIndex = 0;
        string colorName = "Gray";
        public CS_Hist_KalmanAuto(VBtask task) : base(task)
        {
            desc = "Create a histogram of the grayscale image and smooth the bar chart with a kalman filter.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (task.heartBeat) splitIndex = (splitIndex + 1) % 3;
                if (splitIndex == 0)
                    colorName = "Blue";
                else if (splitIndex == 1)
                    colorName = "Green";
                else
                    colorName = "Red";
                Mat[] split = src.Split();
                src = split[splitIndex];
            }
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            mm = GetMinMax(src);
            ranges = new Rangef[1] { new Rangef((float)mm.minVal, (float)mm.maxVal) };
            if (mm.minVal == mm.maxVal)
            {
                SetTrueText("The input image is empty - minVal and maxVal are both zero...");
                return;
            }
            int[] dimensions = { task.histogramBins };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), histogram, 1, dimensions, ranges);
            if (kalman.kInput.Length != task.histogramBins) Array.Resize(ref kalman.kInput, task.histogramBins);
            for (int i = 0; i < task.histogramBins; i++)
            {
                kalman.kInput[i] = histogram.Get<float>(i, 0);
            }
            kalman.Run(src);
            histogram = new Mat(kalman.kOutput.Length, 1, MatType.CV_32FC1, kalman.kOutput);
            if (standaloneTest())
            {
                if (splitIndex == 0) 
                    plot.backColor = Scalar.Blue;
                else if(splitIndex == 1) 
                    plot.backColor = Scalar.Green;
                else 
                    plot.backColor = Scalar.Red;
            }
            plot.Run(histogram);
            dst2 = plot.dst2;
            labels[2] = colorName + " histogram, bins = " + task.histogramBins + ", X ranges from " + mm.minVal + " to " + mm.maxVal + ", y is occurances";
        }
    }
    public class CS_Hist_EqualizeColor : CS_Parent
    {
        Hist_Basics kalmanEq = new Hist_Basics();
        Hist_Basics kalman = new Hist_Basics();
        Mat_2to1 mats = new Mat_2to1();
        public bool displayHist;
        public int channel;
        public CS_Hist_EqualizeColor(VBtask task) : base(task)
        {
            kalmanEq.plot.addLabels = false;
            kalman.plot.addLabels = false;
            desc = "Create an equalized histogram of the color image.";
            labels[2] = "Image Enhanced with Equalized Histogram";
        }
        public void RunCS(Mat src)
        {
            Mat[] rgb = src.Split();
            Mat[] rgbEq = src.Split();
            for (int i = 0; i < rgb.Length; i++)
            {
                Cv2.EqualizeHist(rgbEq[i], rgbEq[i]);
            }
            if (standaloneTest() || displayHist)
            {
                Cv2.Split(src, out rgb); // equalizehist alters the input...
                kalman.plot.backColor = Scalar.Red;
                kalman.Run(rgb[channel].Clone());
                mats.mat[0] = kalman.dst2.Clone();
                kalmanEq.Run(rgbEq[channel].Clone());
                mats.mat[1] = kalmanEq.dst2.Clone();
                mats.Run(new Mat());
                dst3 = mats.dst2;
                labels[3] = "Before (top) and After Red Histogram";
            }
            Cv2.Merge(rgbEq, dst2);
        }
    }
    public class CS_Hist_CompareGray : CS_Parent
    {
        Hist_Kalman histK = new Hist_Kalman();
        Options_HistCompare options = new Options_HistCompare();
        Mat histDiff;
        Mat histDiffAbs = new cv.Mat();
        Mat normHistDiff;
        Mat normHistDiffAbs = new cv.Mat();
        Mat lastHist;
        Mat lastHistNorm;
        public CS_Hist_CompareGray(VBtask task) : base(task)
        {
            labels[2] = "Kalman-smoothed current histogram";
            desc = "Compare grayscale histograms for successive frames";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            histK.Run(src);
            dst2 = histK.dst2.Clone();
            if (task.FirstPass) lastHist = histK.hist.histogram.Clone();
            Mat histNorm = histK.hist.histogram.Clone();
            histNorm.Normalize(0, 1, NormTypes.MinMax);
            if (task.FirstPass) lastHistNorm = histNorm.Clone();
            if (lastHistNorm.Size() == histK.hist.histogram.Size())
            {
                double Comparison = Cv2.CompareHist(histNorm, lastHistNorm, options.compareMethod);
                if (double.IsNaN(Comparison)) Comparison = 0;
                labels[3] = "CompareHist output = " + Comparison.ToString("F3") + " using " + options.compareName + " method";
                trueData = histK.hist.plot.trueData.ToList();
                SetTrueText(labels[3], 2);
            }
            else
            {
                lastHistNorm = histNorm.Clone();
            }
            if (histNorm.Size() == lastHistNorm.Size())
            {
                normHistDiff = histNorm - lastHistNorm;
                Cv2.Absdiff(histNorm, lastHistNorm, normHistDiffAbs);
            }
            lastHistNorm = histNorm.Clone();
            if (histK.hist.histogram.Size() == lastHist.Size())
            {
                histDiff = histK.hist.histogram - lastHist;
                Cv2.Absdiff(histK.hist.histogram, lastHist, histDiffAbs);
            }
            lastHist = histK.hist.histogram.Clone();
        }
    }
    public class CS_Hist_ComparePlot : CS_Parent
    {
        Hist_CompareGray comp = new Hist_CompareGray();
        List<trueText> ttLabels;
        public CS_Hist_ComparePlot(VBtask task) : base(task)
        {
            labels[3] = "Differences have been multiplied by 1000 to build scale at the left";
            desc = "Compare grayscale histograms for successive frames and plot the difference as a histogram.";
        }
        public void RunCS(Mat src)
        {
            comp.Run(src);
            dst2 = comp.dst2.Clone();
            if (task.heartBeat)
            {
                ttLabels = comp.trueData.ToList();
                Mat histX = comp.histDiffAbs;
                comp.histK.hist.plot.Run(histX);
                dst3 = comp.histK.hist.plot.dst2.Clone();
                mmData mm = GetMinMax(histX);
                AddPlotScale(dst2, 0, mm.maxVal);
            }
            trueData = ttLabels;
        }
    }
    public class CS_Hist_CompareNumber : CS_Parent
    {
        Hist_CompareGray comp = new Hist_CompareGray();
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public CS_Hist_CompareNumber(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            plot.plotCount = 2;
            labels = new string[] { "", "", "Kalman-smoothed normalized histogram output", "Plot of the sum of the differences between recent normalized histograms" };
            desc = "The idea is to reduce a comparison of 2 histograms to a single number";
        }
        public void RunCS(Mat src)
        {
            comp.Run(src);
            dst1 = comp.dst2.Clone();
            double sum = Cv2.Sum(comp.normHistDiff)[0] * 100;
            double sumAbs = Cv2.Sum(comp.normHistDiffAbs)[0] * 100;
            plot.plotData = new Scalar(sum, sumAbs, 0);
            plot.Run(new Mat());
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            SetTrueText("Upper left is the sum * 100 of the difference\nUpper right is the sum of the absolute values * 100", new cv.Point(0, dst2.Height / 2), 2);
        }
    }
    public class CS_Hist_CompareEMD_hsv : CS_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Mat lastHSV;
        public CS_Hist_CompareEMD_hsv(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Kalman-smoothed normalized histogram output", "Plot of the sum of the differences between recent normalized histograms" };
            desc = "Use OpenCV's Earth Mover Distance to compare 2 images.";
        }
        public void RunCS(Mat src)
        {
            Mat hsv = src.CvtColor(ColorConversionCodes.BGR2HSV);
            if (task.FirstPass) lastHSV = hsv.Clone();
            int hBins = 30, sBins = 32;
            Mat histA = new Mat(), histB = new Mat();
            Rangef[] ranges = new Rangef[2] { new Rangef(0, 180), new Rangef(0, 256) };
            Cv2.CalcHist(new Mat[] { hsv }, new int[] { 0, 1 }, new Mat(), histA, 2, new int[] { hBins, sBins }, ranges);
            Mat histNormA = histA.Clone();
            histNormA.Normalize(0, 1, NormTypes.MinMax);
            Cv2.CalcHist(new Mat[] { lastHSV }, new int[] { 0, 1 }, new Mat(), histB, 2, new int[] { hBins, sBins }, ranges);
            Mat histNormB = histB.Clone();
            histNormB.Normalize(0, 1, NormTypes.MinMax);
            Mat sig1 = new Mat(sBins * hBins, 3, MatType.CV_32F, Scalar.All(0));
            Mat sig2 = new Mat(sBins * hBins, 3, MatType.CV_32F, Scalar.All(0));
            for (int h = 0; h < hBins; h++)
            {
                for (int s = 0; s < sBins; s++)
                {
                    sig1.Set<float>(h * sBins + s, 0, histNormA.Get<float>(h, s));
                    sig1.Set<float>(h * sBins + s, 1, h);
                    sig1.Set<float>(h * sBins + s, 2, s);
                    sig2.Set<float>(h * sBins + s, 0, histNormB.Get<float>(h, s));
                    sig2.Set<float>(h * sBins + s, 1, h);
                    sig2.Set<float>(h * sBins + s, 2, s);
                }
            }
            double emd = Cv2.EMD(sig1, sig2, DistanceTypes.L2);
            SetTrueText("EMD similarity from the current image to the last is " + (1 - emd).ToString("F0%"), 2);
            lastHSV = hsv.Clone();
        }
    }
    public class CS_Hist_Peaks : CS_Parent
    {
        BackProject_Masks masks;
        public CS_Hist_Peaks(VBtask task) : base(task)
        {
            desc = "Interactive Histogram";
            masks = new BackProject_Masks();
        }
        public void RunCS(Mat src)
        {
            masks.Run(src);
            dst2 = masks.dst2;
            dst3 = masks.dst3;
        }
    }
    public class CS_Hist_Lab : CS_Parent
    {
        Hist_Basics hist;
        public CS_Hist_Lab(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "Lab Colors ", "Lab Channel 0", "Lab Channel 1", "Lab Channel 2" };
            desc = "Create a histogram from a BGR image converted to LAB.";
            hist = new Hist_Basics();
        }
        public void RunCS(Mat src)
        {
            dst0 = src.CvtColor(ColorConversionCodes.BGR2Lab);
            Mat[] split = dst0.Split();
            hist.Run(split[0]);
            dst1 = hist.dst2.Clone();
            hist.Run(split[1]);
            dst2 = hist.dst2.Clone();
            hist.Run(split[2]);
            dst3 = hist.dst2.Clone();
        }
    }
    public class CS_Hist_PointCloudXYZ : CS_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        List<List<trueText>> ttlists;
        public CS_Hist_PointCloudXYZ(VBtask task) : base(task)
        {
            plot.createHistogram = true;
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new string[] { "", "Histogram of the X channel", "Histogram of the Y channel", "Histogram of the Z channel" };
            desc = "Show individual channel of the point cloud data as a histogram.";
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) ttlists = new List<List<trueText>> { new List<trueText>(), new List<trueText>(), new List<trueText>() };
            for (int i = 0; i <= 2; i++)
            {
                dst0 = task.pcSplit[i];
                mmData mm = GetMinMax(dst0);
                switch (i)
                {
                    case 0:
                        plot.removeZeroEntry = false;
                        plot.minRange = -task.xRange;
                        plot.maxRange = task.xRange;
                        break;
                    case 1:
                        plot.removeZeroEntry = false;
                        plot.minRange = -task.yRange;
                        plot.maxRange = task.yRange;
                        break;
                    case 2:
                        plot.removeZeroEntry = true;
                        plot.minRange = 0;
                        plot.maxRange = task.MaxZmeters;
                        break;
                }
                plot.Run(dst0);
                switch (i)
                {
                    case 0:
                        dst1 = plot.dst2.Clone();
                        break;
                    case 1:
                        dst2 = plot.dst2.Clone();
                        break;
                    case 2:
                        dst3 = plot.dst2.Clone();
                        break;
                }
                string xyzStr = "X";
                if (i == 1) xyzStr = "Y";   
                if (i == 2) xyzStr = "Z";   
                if (task.heartBeat)
                {
                    labels[i + 1] = "Histogram " + xyzStr + " ranges from " + plot.minRange.ToString("0.0") + "m to " + plot.maxRange.ToString("0.0") + "m";
                }
            }
        }
    }
    public class CS_Hist_FlatSurfaces : CS_Parent
    {
        BackProject_Masks masks = new BackProject_Masks();
        float saveMinVal, saveMaxVal;
        public CS_Hist_FlatSurfaces(VBtask task) : base(task)
        {
            desc = "Find flat surfaces with the histogram";
        }
        public void RunCS(Mat src)
        {
            int maxRange = 4;
            Mat cloudY = task.pcSplit[1].Clone();
            mmData mm = GetMinMax(cloudY);
            cloudY = cloudY.Threshold(maxRange, mm.maxVal, ThresholdTypes.Trunc);
            if (task.FirstPass)
            {
                saveMinVal = (float)mm.minVal;
                saveMaxVal = (float)mm.maxVal;
            }
            if (task.heartBeat)
            {
                saveMinVal = (float)mm.minVal;
                saveMaxVal = (float)mm.maxVal;
            }
            if (saveMinVal > mm.minVal) saveMinVal = (float)mm.minVal;
            if (saveMaxVal < mm.maxVal) saveMaxVal = (float)mm.maxVal;
            cloudY.Set<float>(mm.minLoc.Y, mm.minLoc.X, -saveMinVal);
            cloudY.Set<float>(mm.maxLoc.Y, mm.maxLoc.X, saveMaxVal);
            cloudY -= saveMinVal;
            cloudY = cloudY.ConvertScaleAbs(255 / (-saveMinVal + saveMaxVal));
            mm = GetMinMax(cloudY);
            cloudY.SetTo(0, task.noDepthMask);
            masks.Run(cloudY);
            dst2 = masks.dst2;
            dst3 = src;
            dst3 = dst3.SetTo(new Scalar(255, 255, 255), masks.dst1);
            labels[2] = "Range for the histogram is from " + saveMinVal.ToString(fmt1) + " to " + saveMaxVal.ToString(fmt1);
        }
    }
    public class CS_Hist_ShapeSide : CS_Parent
    {
        public rcData rc = new rcData();
        public CS_Hist_ShapeSide(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(60);
            labels = new string[] { "", "", "ZY Side View", "ZY Side View Mask" };
            desc = "Create a 2D side view for ZY histogram of depth";
        }
        public void RunCS(Mat src)
        {
            if (rc.pixels == 0) src = task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, task.channelsSide, new Mat(), dst0, 2,
                          new int[] { task.histogramBins, task.histogramBins }, task.rangesSide);
            dst0.Col(0).SetTo(0); // too many zero depth points...
            dst0 = GetNormalize32f(dst0);
            dst0.ConvertTo(dst0, MatType.CV_8UC1);
            Rect r = new Rect(0, 0, dst2.Height, dst2.Height);
            dst2[r] = dst0.Resize(new cv.Size(dst2.Height, dst2.Height), 0, 0, InterpolationFlags.Nearest);
            dst3 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }
    public class CS_Hist_ShapeTop : CS_Parent
    {
        public rcData rc = new rcData();
        public CS_Hist_ShapeTop(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(60);
            labels = new string[] { "", "", "ZY Side View", "ZY Side View Mask" };
            desc = "Create a 2D top view for XZ histogram of depth";
        }
        public void RunCS(Mat src)
        {
            if (rc.pixels == 0) src = task.pointCloud;
            Cv2.CalcHist(new Mat[] { src }, task.channelsTop, new Mat(), dst0, 2,
                          new int[] { task.histogramBins, task.histogramBins }, task.rangesTop);
            dst0.Row(0).SetTo(0); // too many zero depth points...
            dst0 = GetNormalize32f(dst0);
            dst0.ConvertTo(dst0, MatType.CV_8UC1);
            Rect r = new Rect(0, 0, dst2.Height, dst2.Height);
            dst2[r] = dst0.Resize(new cv.Size(dst2.Height, dst2.Height), 0, 0, InterpolationFlags.Nearest);
            dst3 = dst2.Threshold(0, 255, ThresholdTypes.Binary);
        }
    }
    public class CS_Hist_Gotcha2D : CS_Parent
    {
        public Mat histogram = new Mat();
        public CS_Hist_Gotcha2D(VBtask task) : base(task)
        {
            labels[2] = "ZY (Side View)";
            desc = "Create a 2D side view for ZY histogram of depth using integer values.  Testing calcHist gotcha.";
        }
        public void RunCS(Mat src)
        {
            int expected = task.pcSplit[2].CountNonZero();
            Rangef[] ranges = task.rangesSide;
            if (task.toggleOnOff)
            {
                ranges = new Rangef[] { new Rangef(-10, +10), new Rangef(-1, 20) };
            }
            Cv2.CalcHist(new Mat[] { task.pointCloud }, task.channelsSide, new Mat(), histogram, 2, task.bins2D, task.rangesSide);
            var actual = histogram.Sum().Val0;
            if (task.heartBeat)
            {
                strOut = "Expected sample count:" + "\t" + expected + "\n" +
                         "Actual sample count:" + "\t" + actual + "\n" +
                         "The number of samples input is the expected value." + "\n" +
                         "The number of entries in the histogram is the 'actual' number of samples." + "\n" +
                         "How can the values not be equal?  The ranges of the histogram are exclusive." + "\n" +
                         "Another way that samples may be lost: X or Y range.  Use Y-Range slider to show impact." +
                         "A third way samples may not match: max depth can toss samples as well.";
            }
            SetTrueText(strOut, 3);
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
        }
    }
    public class CS_Hist_Gotcha : CS_Parent
    {
        public Mat histogram = new Mat();
        Hist_Basics hist = new Hist_Basics();
        public CS_Hist_Gotcha(VBtask task) : base(task)
        {
            labels[2] = "Grayscale histogram";
            desc = "Simple test: input samples should equal histogram samples.  What is wrong?  Exclusive ranges!";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            long expected = src.Total();
            hist.Run(src);
            double actual = hist.histogram.Sum().Val0;
            if (task.heartBeat)
            {
                strOut = "Expected sample count:" + "\t" + expected + "\n" +
                         "Actual sample count:" + "\t" + actual + "\n" +
                         "Difference:" + "\t" + Math.Abs(actual - expected) + "\n" +
                         "The number of samples input is the expected value." + "\n" +
                         "The number of entries in the histogram is the 'actual' number of samples." + "\n" +
                         "How can the values not be equal?  The ranges in the histogram are exclusive!";
            }
            SetTrueText(strOut, 2);
        }
    }
    public class CS_Hist_GotchaFixed_CPP : CS_Parent
    {
        public CS_Hist_GotchaFixed_CPP(VBtask task) : base(task)
        {
            cPtr = Hist_1D_Open();
            desc = "Testing the C++ CalcHist to investigate gotcha with sample counts";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Hist_1D_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, task.histogramBins);
            handleSrc.Free();
            if (task.heartBeat)
            {
                int actual = (int)Hist_1D_Sum(cPtr);
                strOut = "Expected sample count:" + "\t" + dst2.Total() + "\n" +
                         "Actual sample count:" + "\t" + actual + "\n" +
                         "Difference:" + "\t" + Math.Abs(actual - dst2.Total()) + "\n" +
                         "The number of samples input is the expected value." + "\n" +
                         "The number of entries in the histogram is the 'actual' number of samples." + "\n" +
                         "How can the values not be equal?  The ranges in the histogram are exclusive!";
            }
            SetTrueText(strOut, 2);
        }
        public void Close()
        {
            Hist_1D_Close(cPtr);
        }
    }
    public class CS_Hist_Byte_CPP : CS_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        public CS_Hist_Byte_CPP(VBtask task) : base(task)
        {
            cPtr = Hist_1D_Open();
            desc = "For Byte histograms, the C++ code works but the .Net interface doesn't honor exclusive ranges.";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Hist_1D_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, task.histogramBins);
            handleSrc.Free();
            Mat histogram = new Mat(task.histogramBins, 1, MatType.CV_32F, imagePtr);
            plot.Run(histogram);
            dst2 = plot.dst2;
            SetTrueText(strOut, 2);
        }
        public void Close()
        {
            Hist_1D_Close(cPtr);
        }
    }
    public class CS_Hist_Xdimension : CS_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public CS_Hist_Xdimension(VBtask task) : base(task)
        {
            desc = "Plot the histogram of the X layer of the point cloud";
        }
        public void RunCS(Mat src)
        {
            plot.Run(task.pcSplit[0]);
            dst2 = plot.dst2;
            SetTrueText("Chart left = " + string.Format(fmt0, plot.mm.minVal) + "\n" +
                        "Chart right = " + string.Format(fmt0, plot.mm.maxVal), 2);
        }
    }
    public class CS_Hist_Ydimension : CS_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public CS_Hist_Ydimension(VBtask task) : base(task)
        {
            desc = "Plot the histogram of the Y layer of the point cloud";
        }
        public void RunCS(Mat src)
        {
            plot.Run(task.pcSplit[1]);
            dst2 = plot.dst2;
            SetTrueText("Chart left = " + string.Format(fmt0, plot.mm.minVal) + "\n" +
                        "Chart right = " + string.Format(fmt0, plot.mm.maxVal), 2);
        }
    }
    public class CS_Hist_Zdimension : CS_Parent
    {
        Hist_Depth plot = new Hist_Depth();
        public CS_Hist_Zdimension(VBtask task) : base(task)
        {
            desc = "Plot the histogram of the Z layer of the point cloud";
        }
        public void RunCS(Mat src)
        {
            plot.Run(task.pcSplit[2]);
            dst2 = plot.dst2;
            SetTrueText("Chart left = " + string.Format(fmt0, plot.mm.minVal) + "\n" +
                        "Chart right = " + string.Format(fmt0, plot.mm.maxVal), 2);
        }
    }
    public class CS_Hist_Depth : CS_Parent
    {
        public Plot_Histogram plot = new Plot_Histogram();
        public rcData rc;
        public mmData mm;
        public Mat histogram = new Mat();
        public CS_Hist_Depth(VBtask task) : base(task)
        {
            desc = "Show depth data as a histogram.";
        }
        public void RunCS(Mat src)
        {
            if (src.Rows <= 0) return;
            plot.minRange = 0;
            plot.maxRange = task.MaxZmeters;
            if (rc != null)
            {
                if (rc.index == 0) return;
                src = task.pcSplit[2][rc.rect].Clone();
            }
            else
            {
                if (src.Type() != MatType.CV_32F) src = task.pcSplit[2];
                mm = GetMinMax(src);
                plot.minRange = (float)mm.minVal; // because OpenCV's histogram makes the ranges exclusive.
                plot.maxRange = (float)mm.maxVal;
            }
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0 }, new Mat(), histogram, 1, new int[] { task.histogramBins }, new Rangef[] { new Rangef(plot.minRange, plot.maxRange) });
            plot.histogram = histogram;
            plot.Run(plot.histogram);
            dst2 = plot.dst2;
            float stepsize = dst2.Width / task.MaxZmeters;
            for (int i = 1; i < (int)task.MaxZmeters; i++)
            {
                dst2.Line(new cv.Point(stepsize * i, 0), new cv.Point(stepsize * i, dst2.Height), Scalar.White, task.cvFontThickness);
            }
            if (standaloneTest())
            {
                int expected = src.CountNonZero();
                int actual = (int)plot.histogram.Sum().Val0;
                strOut = "Expected sample count (non-zero task.pcSplit[2]] entries):" + "\t" + expected + "\n";
                strOut += "Histogram sum (ranges can reduce):" + "\t\t\t" + actual + "\n";
                strOut += "Difference:" + "\t\t\t\t\t\t" + Math.Abs(actual - expected) + "\n";
            }
            SetTrueText(strOut, 3);
            labels[2] = "Histogram Depth to " + string.Format("0.0", task.MaxZmeters) + " m";
        }
    }
    public class CS_Hist_Cell : CS_Parent
    {
        Hist_Depth hist = new Hist_Depth();
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Hist_Cell(VBtask task) : base(task)
        {
            dst1 = new Mat(dst1.Size(), MatType.CV_32F, 0);
            labels = new string[] { "", "", "RedCloud cells", "Histogram of the depth for the selected cell." };
            desc = "Review depth data for a RedCloud Cell";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            hist.rc = task.rc;
            if (hist.rc.index == 0 || hist.rc.maxVec.Z == 0) return;
            dst1.SetTo(0);
            task.pcSplit[2][hist.rc.rect].CopyTo(dst1);
            hist.Run(dst1);
            dst3 = hist.dst2;
        }
    }
    public class CS_Hist_PointCloud : CS_Parent
    {
        public Rangef[] rangesX;
        public Rangef[] rangesY;
        public Options_HistPointCloud options = new Options_HistPointCloud();
        public CS_Hist_PointCloud(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Histogram of XZ - X on the Y-Axis and Z on the X-Axis", "Histogram of YZ with Y on the Y-Axis and Z on the X-Axis" };
            desc = "Create a 2D histogram for the pointcloud in XZ and YZ.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            rangesX = new Rangef[] { new Rangef(-task.xRange, task.xRange), new Rangef(0, task.MaxZmeters) };
            rangesY = new Rangef[] { new Rangef(-task.yRange, task.yRange), new Rangef(0, task.MaxZmeters) };
            int[] sizesX = new int[] { options.xBins, options.zBins };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 2 }, new Mat(), dst2, 2, sizesX, rangesX);
            dst2.Set<Point3f>(dst2.Height / 2, 0, new Point3f());
            int[] sizesY = new int[] { options.yBins, options.zBins };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 1, 2 }, new Mat(), dst3, 2, sizesY, rangesY);
            dst3.Set<Point3f>(dst3.Height / 2, 0, new Point3f());
        }
    }
    public class CS_Hist_Kalman : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        public CS_Hist_Kalman(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "With Kalman", "Without Kalman" };
            desc = "Use Kalman to smooth the histogram results.";
        }
        public void RunCS(Mat src)
        {
            hist.Run(src);
            dst3 = hist.dst2.Clone();
            if (hist.histogram.Rows == 0) hist.histogram = new Mat(task.histogramBins, 1, MatType.CV_32F, 0);
            if (kalman.kInput.Length != task.histogramBins) Array.Resize(ref kalman.kInput, task.histogramBins);
            for (int i = 0; i < task.histogramBins; i++)
            {
                kalman.kInput[i] = hist.histogram.Get<float>(i, 0);
            }
            kalman.Run(src);
            hist.histogram = new Mat(kalman.kOutput.Length, 1, MatType.CV_32FC1, kalman.kOutput);
            hist.plot.Run(hist.histogram);
            dst2 = hist.dst2;
        }
    }
    public class CS_Guess_Depth_CPP : CS_Parent
    {
        public CS_Guess_Depth_CPP(VBtask task) : base(task)
        {
            cPtr = Guess_Depth_Open();
            labels = new string[] { "", "", "Updated point cloud (holes filled)", "Original point cloud" };
            desc = "Fill single pixel holes in the point cloud.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Guess_Depth_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols);
            handleSrc.Free();
            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_32FC3, imagePtr).Clone();
            if (standaloneTest()) dst3 = task.pointCloud;
        }
        public void Close()
        {
            Guess_Depth_Close(cPtr);
        }
    }
    public class CS_Guess_ImageEdges_CPP : CS_Parent
    {
        Options_Guess options = new Options_Guess();
        public CS_Guess_ImageEdges_CPP(VBtask task) : base(task)
        {
            cPtr = Guess_ImageEdges_Open();
            labels = new string[] { "", "", "Updated point cloud - nearest depth to each edge is replicated to the image boundary", "Original point cloud" };
            desc = "Replicate the nearest depth measurement at all the image edges";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.cameraName == "Oak-D camera" || task.cameraName == "Azure Kinect 4K")
            {
                SetTrueText("Only RealSense cameras are likely to benefit from enhanced depth at the image edges.");
                return;
            }
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Guess_ImageEdges_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, options.MaxDistance);
            handleSrc.Free();
            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_32FC3, cppData).Clone();
            if (standaloneTest()) dst3 = task.pointCloud;
        }
        public void Close()
        {
            Guess_ImageEdges_Close(cPtr);
        }
    }
    public class CS_Hist2D_Basics : CS_Parent
    {
        public int[] histRowsCols;
        public Rangef[] ranges;
        public Mat histogram = new Mat();
        public int[] channels = { 0, 2 };
        public CS_Hist2D_Basics(VBtask task) : base(task)
        {
            histRowsCols = new int[] { dst2.Height, dst2.Width };
            labels = new string[] { "", "", "All non-zero entries in the 2D histogram", "" };
            desc = "Create a 2D histogram from the input.";
        }
        public void RunCS(Mat src)
        {
            ranges = GetHist2Dminmax(src, channels[0], channels[1]);
            Cv2.CalcHist(new Mat[] { src }, channels, new Mat(), histogram, 2, histRowsCols, ranges);
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary);
            dst2.ConvertTo(dst2, MatType.CV_8U);
        }
    }
    public class CS_Hist2D_Cloud : CS_Parent
    {
        Plot_Histogram2D plot1D = new Plot_Histogram2D();
        int[] channels;
        public Rangef[] ranges;
        public Mat histogram = new Mat();
        public CS_Hist2D_Cloud(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Plot of 2D histogram", "All non-zero entries in the 2D histogram" };
            desc = "Create a 2D histogram of the point cloud data - which 2D inputs is in options.";
        }
        public void RunCS(Mat src)
        {
            Vec2f r1 = new Vec2f(), r2 = new Vec2f();
            if (task.redOptions.channels[0] == 0 || task.redOptions.channels[0] == 1)
            {
                r1 = new Vec2f(-task.xRangeDefault, task.xRangeDefault);
            }
            if (task.redOptions.channels[1] == 1) r2 = new Vec2f(-task.yRangeDefault, task.yRangeDefault);
            if (task.redOptions.channels[1] == 2) r2 = new Vec2f(0, task.MaxZmeters);
            ranges = new Rangef[] { new Rangef(r1.Item0, r1.Item1), new Rangef(r2.Item0, r2.Item1) };
            Cv2.CalcHist(new Mat[] { task.pointCloud }, task.redOptions.channels, new Mat(),
                          histogram, 2, new int[] { task.histogramBins, task.histogramBins }, ranges);
            plot1D.Run(histogram);
            dst2 = plot1D.dst2;
            channels = task.redOptions.channels;
        }
    }
    public class CS_Hist2D_Depth : CS_Parent
    {
        Hist2D_Cloud hist2d = new Hist2D_Cloud();
        public int[] channels;
        public Rangef[] ranges;
        public Mat histogram = new Mat();
        public CS_Hist2D_Depth(VBtask task) : base(task)
        {
            desc = "Create 2D histogram from the 3D pointcloud - use options to select dimensions.";
        }
        public void RunCS(Mat src)
        {
            hist2d.Run(task.pointCloud);
            histogram = hist2d.histogram;
            ranges = hist2d.ranges;
            channels = task.redOptions.channels;
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst3 = histogram.Threshold(task.projectionThreshold, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            labels = new string[] { "", "", "Mask of the 2D histogram for selected channels", "Mask of 2D histogram after thresholding" };
        }
    }
    public class CS_Hist2D_Zoom : CS_Parent
    {
        Hist2D_Basics hist2d = new Hist2D_Basics();
        Magnify_Basics zoom = new Magnify_Basics();
        public CS_Hist2D_Zoom(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Mask of histogram", "DrawRect area from the histogram" };
            desc = "Draw a rectangle on an area to zoom in on...";
        }
        public void RunCS(Mat src)
        {
            hist2d.Run(src);
            dst2 = hist2d.dst2;
            zoom.Run(hist2d.histogram);
            dst3 = zoom.dst3;
        }
    }
    public class CS_Hist2D_HSV : CS_Parent
    {
        public Mat histogram01 = new Mat();
        public Mat histogram02 = new Mat();
        public CS_Hist2D_HSV(VBtask task) : base(task)
        {
            labels = new string[] { "", "HSV image", "", "" };
            desc = "Create a 2D histogram for Hue to Saturation and Hue to Value.";
        }
        public void RunCS(Mat src)
        {
            int[] histRowsCols = new int[] { dst2.Height, dst2.Width };
            src = src.CvtColor(ColorConversionCodes.BGR2HSV);
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 2 }, task.depthMask, histogram02, 2, histRowsCols, task.redOptions.rangesHSV);
            dst2 = histogram02.Threshold(0, 255, ThresholdTypes.Binary);
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1 }, task.depthMask, histogram01, 2, histRowsCols, task.redOptions.rangesHSV);
            dst3 = histogram01.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "Hue is on the X-Axis and Value is on the Y-Axis";
            labels[3] = "Hue is on the X-Axis and Saturation is on the Y-Axis";
        }
    }
    public class CS_Hist2D_BGR : CS_Parent
    {
        public Mat histogram01 = new Mat();
        public Mat histogram02 = new Mat();
        public CS_Hist2D_BGR(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(256);
            desc = "Create a 2D histogram for blue to red and blue to green.";
        }
        public void RunCS(Mat src)
        {
            int[] histRowsCols = new int[] { dst2.Height, dst2.Width };
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 2 }, task.depthMask, histogram02, 2, histRowsCols, task.redOptions.rangesBGR);
            dst2 = histogram02.Threshold(0, 255, ThresholdTypes.Binary);
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1 }, task.depthMask, histogram01, 2, histRowsCols, task.redOptions.rangesBGR);
            dst3 = histogram01.Threshold(0, 255, ThresholdTypes.Binary);
            labels[2] = "Blue is on the X-Axis and Red is on the Y-Axis";
            labels[3] = "Blue is on the X-Axis and Green is on the Y-Axis";
        }
    }
    public class CS_Hist2D_PlotHistogram1D : CS_Parent
    {
        Mat histogram = new Mat();
        Plot_Histogram plot = new Plot_Histogram();
        public float[] histArray;
        public CS_Hist2D_PlotHistogram1D(VBtask task) : base(task)
        {
            plot.removeZeroEntry = false;
            labels[2] = "CS_Hist2D_PlotHistogram1D output shown with plot_histogram";
            desc = "Create a 2D histogram for blue to red and blue to green.";
        }
        public void RunCS(Mat src)
        {
            Cv2.CalcHist(new Mat[] { src }, task.redOptions.channels, task.depthMask, histogram, 2, new int[] { task.histogramBins, task.histogramBins },
                          task.redOptions.rangesBGR);
            dst2 = histogram.Threshold(0, 255, ThresholdTypes.Binary);
            plot.Run(histogram);
            dst3 = plot.dst2;
            // histArray = new float[histogram.Total()];
            // Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
        }
    }
    public class CS_Hist3D_Basics : CS_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Hist3Dcloud_Basics hCloud = new Hist3Dcloud_Basics();
        public int classCount;
        Options_Hist3D options = new Options_Hist3D();
        public CS_Hist3D_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Sum of 8UC1 outputs of Hist3Dcolor_Basics and Hist3Dcloud_basics", "" };
            desc = "Build an 8UC1 image by adding Hist3Dcolor_Basics and Hist3Dcloud_Basics output";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            hColor.Run(src);
            dst2 = hColor.dst2;
            hCloud.Run(src);
            hCloud.dst2 += hColor.classCount + 1;
            hCloud.dst2.SetTo(0, task.noDepthMask);
            if (options.addCloud)
                dst2 += hCloud.dst2;
            else
                hCloud.dst2.CopyTo(dst2, task.depthMask);
            classCount = hColor.classCount + hCloud.classCount;
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[3] = classCount.ToString() + " classes ";
        }
    }


    public class CS_Hist3D_BuildHistogram : CS_Parent
        {
            public int threshold;
            public int classCount;
            public float[] histArray;
            Hist_Depth plot = new Hist_Depth();
            public CS_Hist3D_BuildHistogram(VBtask task) : base(task)
            {
                desc = "Build a guided 3D histogram from the 3D histogram supplied in src.";
            }
            public void RunCS(Mat src)
            {
                if (standaloneTest())
                {
                    task.gOptions.setHistogramBins(100);
                    plot.Run(src);
                    src = plot.histogram;
                }
                histArray = new float[src.Total() - 1];
                Marshal.Copy(src.Data, histArray, 0, histArray.Length);
                classCount = 1;
                int index = 0;
                for (int i = index; i < histArray.Length; i++)
                {
                    for (; index < histArray.Length; index++)
                    {
                        if (histArray[index] > threshold) break;
                        histArray[index] = classCount;
                    }
                    classCount++;
                    for (; index < histArray.Length; index++)
                    {
                        if (histArray[index] <= threshold) break;
                        histArray[index] = classCount;
                    }
                    if (index >= histArray.Length) break;
                }
                int minClass = (int)(histArray.Min() - 1);
                if (minClass != 0)
                {
                    src -= minClass;
                    for (int i = 0; i < histArray.Length; i++)
                    {
                        histArray[i] -= minClass;
                    }
                    classCount -= minClass;
                }
                dst2 = src.Clone();
                Marshal.Copy(histArray, 0, dst2.Data, histArray.Length);
                labels[2] = "Histogram entries vary from " + histArray.Min() + " to " + classCount + " inclusive";
            }
        }
        public class CS_Hist3D_RedCloud : CS_Parent
        {
            RedCloud_Basics redC = new RedCloud_Basics();
            Hist3D_Basics hist3D = new Hist3D_Basics();
            public CS_Hist3D_RedCloud(VBtask task) : base(task)
            {
                task.redOptions.setUseColorOnly(true);
                desc = "Run RedCloud_Basics on the combined Hist3D color/cloud output.";
            }
            public void RunCS(Mat src)
            {
                hist3D.Run(src);
                dst2 = hist3D.dst3;
                labels[2] = hist3D.labels[3];
                redC.Run(hist3D.dst2);
                dst3 = redC.dst2;
                labels[3] = redC.labels[2];
            }
        }
        public class CS_Hist3D_RedColor : CS_Parent
        {
            RedCloud_Basics redC = new RedCloud_Basics();
            Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
            public CS_Hist3D_RedColor(VBtask task) : base(task)
            {
                task.redOptions.setIdentifyCells(true);
                task.redOptions.setUseColorOnly(true);
                desc = "Use the Hist3D color classes to segment the image with RedCloud_Basics";
            }
            public void RunCS(Mat src)
            {
                hColor.Run(src);
                dst3 = hColor.dst3;
                labels[3] = hColor.labels[3];
                redC.Run(hColor.dst2);
                dst2 = redC.dst2;
                labels[2] = redC.labels[3];
                if (task.redCells.Count > 0)
                {
                    dst2[task.rc.rect].SetTo(Scalar.White, task.rc.mask);
                }
            }
        }
        public class CS_Hist3D_DepthWithMask : CS_Parent
        {
            Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
            public Mat depthMask = new Mat();
            Foreground_KMeans2 fore = new Foreground_KMeans2();
            public CS_Hist3D_DepthWithMask(VBtask task) : base(task)
            {
                desc = "Isolate the foreground and no depth in the image and run it through Hist3D_Basics";
            }
            public void RunCS(Mat src)
            {
                if (standaloneTest())
                {
                    fore.Run(src);
                    depthMask = fore.dst2 | task.noDepthMask;
                }
                hColor.inputMask = depthMask;
                dst0 = ~depthMask;
                src.SetTo(0, dst0);
                hColor.Run(src);
                dst2 = hColor.dst2;
                dst2.SetTo(0, dst0);
                dst3 = hColor.dst3;
                dst3.SetTo(0, dst0);
                labels = hColor.labels;
            }
        }
        public class CS_Hist3D_Pixel : CS_Parent
        {
            public Mat histogram = new Mat();
            public float[] histArray;
            public int classCount;
            public CS_Hist3D_Pixel(VBtask task) : base(task)
            {
                desc = "Classify each pixel using a 3D histogram backprojection.";
            }
            public void RunCS(Mat src)
            {
                if (src.Channels() != 3) src = task.color;
                var bins = task.redOptions.getHistBinBar3D();
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, new Mat(), histogram, 3, new int[] { bins, bins, bins }, task.redOptions.rangesBGR);
                histArray = new float[histogram.Total() - 1];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                for (int i = 0; i < histArray.Length; i++)
                {
                    histArray[i] = i + 1;
                }
                classCount = task.redOptions.histBins3D;
                Marshal.Copy(histArray, 0, histogram.Data, histArray.Length);
                Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, task.redOptions.rangesBGR);
                dst3 = classCount < 256 ? ShowPalette(dst2 * 255 / classCount) : ShowPalette(dst2);
            }
        }
        public class CS_Hist3D_PixelCells : CS_Parent
        {
            Hist3D_Pixel pixel = new Hist3D_Pixel();
            Flood_Basics redC = new Flood_Basics();
            public CS_Hist3D_PixelCells(VBtask task) : base(task)
            {
                dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
                labels = new string[] { "", "", "Cell-by-cell backprojection of the Hist3D_Pixel algorithm", "Palette version of dst2" };
                desc = "After classifying each pixel, backproject each redCell using the same 3D histogram.";
            }
            public void RunCS(Mat src)
            {
                redC.Run(src);
                pixel.Run(src);
                foreach (var cell in task.redCells)
                {
                    Cv2.CalcBackProject(new Mat[] { src[cell.rect] }, new int[] { 0, 1, 2 }, pixel.histogram, dst2[cell.rect], task.redOptions.rangesBGR);
                }
                dst3 = ShowPalette(dst2 * 255 / task.redOptions.histBins3D);
            }
        }
        public class CS_Hist3D_PixelClassify : CS_Parent
        {
            Hist3D_Pixel pixel = new Hist3D_Pixel();
            RedCloud_Basics redC = new RedCloud_Basics();
            public CS_Hist3D_PixelClassify(VBtask task) : base(task)
            {
                desc = "Classify each pixel with a 3D histogram backprojection and run RedCloud_Basics on the output.";
            }
            public void RunCS(Mat src)
            {
                pixel.Run(src);
                redC.Run(pixel.dst2);
                dst2 = redC.dst2;
                labels[2] = redC.labels[2];
                if (task.redCells.Count > 0)
                {
                    dst2[task.rc.rect].SetTo(Scalar.White, task.rc.mask);
                }
            }
        }
        public class CS_Hist3D_PixelDiffMask : CS_Parent
        {
            Hist3D_Pixel pixel = new Hist3D_Pixel();
            RedCloud_Basics redC = new RedCloud_Basics();
            Mat lastImage = new cv.Mat();
            public CS_Hist3D_PixelDiffMask(VBtask task) : base(task)
            {
                task.redOptions.setUseColorOnly(true);
                desc = "Build better image segmentation - remove unstable pixels from 3D color histogram backprojection";
            }
            public void RunCS(Mat src)
            {
                pixel.Run(src);
                if (task.FirstPass) lastImage = pixel.dst2.Clone();
                Cv2.Absdiff(lastImage, pixel.dst2, dst3);
                dst2 = dst3.Threshold(0, 255, ThresholdTypes.Binary);
                lastImage = pixel.dst2.Clone();
            }
        }
        public class CS_Hist3D_RedCloudGrid : CS_Parent
        {
            Pixel_Vectors pixels = new Pixel_Vectors();
            Hist3Dcolor_Vector hVector = new Hist3Dcolor_Vector();
            public CS_Hist3D_RedCloudGrid(VBtask task) : base(task)
            {
                task.gOptions.setGridSize(8);
                desc = "Build RedCloud pixel vectors and then measure each grid element's distance to those vectors.";
            }
            double distanceN(List<float> vec1, List<float> vec2)
            {
                double accum = 0;
                for (int i = 0; i < vec1.Count; i++)
                {
                    accum += (vec1[i] - vec2[i]) * (vec1[i] - vec2[i]);
                }
                return Math.Sqrt(accum);
            }
            double distanceN(float[] vec1, float[] vec2)
            {
                double accum = 0;
                for (int i = 0; i < vec1.Length; i++)
                {
                    accum += (vec1[i] - vec2[i]) * (vec1[i] - vec2[i]);
                }
                return Math.Sqrt(accum);
            }
            public void RunCS(Mat src)
            {
                pixels.Run(src);
                dst2 = task.cellMap;
                dst3 = dst2.InRange(0, 0);
                if (pixels.pixelVector.Count == 0) return;
                dst1.SetTo(0);
                dst0 = task.cellMap;
                foreach (var roi in task.gridList)
                {
                    if (dst3[roi].CountNonZero() > 0)
                    {
                        var candidates = new List<int>();
                        for (int y = 0; y < roi.Height; y++)
                        {
                            for (int x = 0; x < roi.Width; x++)
                            {
                                var val = dst0[roi].Get<byte>(y, x);
                                if (val == 0) continue;
                                if (!candidates.Contains(val)) candidates.Add(val);
                            }
                        }
                        if (candidates.Count > 1)
                        {
                            hVector.inputMask = dst3[roi];
                            hVector.Run(src[roi]);
                            var distances = new List<double>();
                            foreach (var index in candidates)
                            {
                                var vec = pixels.pixelVector[index - 1];
                                distances.Add(distanceN(vec, hVector.histArray));
                            }
                            var cell = pixels.redCells[candidates[distances.IndexOf(distances.Min())] - 1];
                            dst1[roi].SetTo(cell.color, dst3[roi]);
                        }
                        else if (candidates.Count == 1)
                        {
                            var cell = pixels.redCells[candidates[0] - 1];
                            dst1[roi].SetTo(cell.color, dst3[roi]);
                        }
                    }
                }
            }
        }
    public class CS_Hist3Dcloud_Basics : CS_Parent
    {
        public Mat histogram = new Mat();
        public Mat histogram1D = new Mat();
        public float[] histArray;
        public int classCount;
        public Mat maskInput = new Mat();
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public CS_Hist3Dcloud_Basics(VBtask task) : base(task)
        {
            labels[2] = "dst2 = backprojection of pointcloud (8UC1 format).";
            desc = "Build a 3D histogram from the pointcloud and backproject it to segment the image.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            int bins = task.redOptions.getHistBinBar3D();
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, maskInput, histogram, 3, new int[] { bins, bins, bins }, task.redOptions.rangesCloud);
            histArray = new float[task.redOptions.histBins3D];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            double threshold = src.Total() * 0.001;
            for (int i = 0; i < histArray.Length; i++)
            {
                if (histArray[i] > threshold) break;
                histArray[i] = 0;
            }
            histogram = new Mat(histArray.Length, 1, MatType.CV_32F, histArray);
            simK.Run(histogram);
            histogram = new Mat(histArray.Length, 1, MatType.CV_32F, simK.histArray);
            classCount = simK.classCount;
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 2 }, histogram, dst2, new Rangef[] { task.redOptions.rangesCloud[task.redOptions.rangesCloud.Count() - 1] });
            dst2 = dst2.ConvertScaleAbs();
            dst2.SetTo(0, task.noDepthMask);
            //dst2.SetTo(classCount, task.maxDepthMask);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = simK.labels[2] + " with " + task.redOptions.getHistBins3D().ToString() + " histogram bins";
            labels[3] = "LastClassCount/classCount = " + classCount.ToString() + "/" + classCount.ToString();
        }
    }
    public class CS_Hist3Dcloud_DepthSplit : CS_Parent
    {
        List<Hist_Kalman> hist;
        List<Hist2D_Cloud> hist2d;
        Mat_4Click mats1 = new Mat_4Click();
        Mat_4Click mats2 = new Mat_4Click();
        public CS_Hist3Dcloud_DepthSplit(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            hist = new List<Hist_Kalman> { new Hist_Kalman(), new Hist_Kalman(), new Hist_Kalman() };
            hist2d = new List<Hist2D_Cloud> { new Hist2D_Cloud(), new Hist2D_Cloud(), new Hist2D_Cloud() };
            labels[2] = "Histograms (Kalman) for X (upper left), Y (upper right) and Z.  UseZeroDepth removes 0 (no depth) entries.";
            labels[3] = "X to Y histogram (upper left), X to Z (upper right), and Y to Z (bottom).";
            desc = "Plot the 3 histograms of the depth data dimensions";
        }
        public void RunCS(Mat src)
        {
            for (int i = 0; i < 3; i++)
            {
                hist[i].Run(task.pcSplit[i]);
                mats1.mat[i] = hist[i].dst2.Clone();
                if (i == 0) task.redOptions.channels = new int[] { 0, 1 };
                if (i == 1) task.redOptions.channels = new int[] { 0, 2 };
                if (i == 2) task.redOptions.channels = new int[] { 1, 2 };
                hist2d[i].Run(task.pointCloud);
                mats2.mat[i] = hist2d[i].histogram.ConvertScaleAbs();
            }
            mats1.Run(empty);
            dst2 = mats1.dst2;
            dst3 = mats1.mat[mats1.quadrant];
            mats2.Run(empty);
            dst1 = mats2.dst2;
        }
    }
    public class CS_Hist3Dcloud_Highlights : CS_Parent
    {
        public Mat histogram = new Mat();
        public Rangef[] ranges;
        int maskval;
        public CS_Hist3Dcloud_Highlights(VBtask task) : base(task)
        {
            desc = "Plot the 3D histogram of the depth data";
        }
        public void RunCS(Mat src)
        {
            int bins = task.redOptions.getHistBinBar3D();
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            byte[] histInput = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, histInput, 0, histInput.Length);
            Vec2f rx = new Vec2f(-task.xRangeDefault, task.xRangeDefault);
            Vec2f ry = new Vec2f(-task.yRangeDefault, task.yRangeDefault);
            Vec2f rz = new Vec2f(0, task.MaxZmeters);
            GCHandle handleInput = GCHandle.Alloc(histInput, GCHandleType.Pinned);
            IntPtr dstPtr = Hist3Dcloud_Run(handleInput.AddrOfPinnedObject(), src.Rows, src.Cols, bins,
                                             rx[0], ry[0], rz[0], rx[1], ry[1], rz[1]);
            handleInput.Free();
            histogram = new Mat(task.redOptions.histBins3D, 1, MatType.CV_32F, dstPtr);
            ranges = new Rangef[] { new Rangef(rx[0], rx[1]), new Rangef(ry[0], ry[1]), new Rangef(rz[0], rz[1]) };
            float[] samples = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, samples, 0, samples.Length);
            SortedList<float, int> sortedHist = new SortedList<float, int>(new compareAllowIdenticalSingleInverted());
            for (int i = 0; i < samples.Length; i++)
            {
                sortedHist.Add(samples[i], i);
            }
            for (int i = 0; i < sortedHist.Count; i++)
            {
                var key = sortedHist.ElementAt(i);
                int val = key.Value;
                samples[val] = i + 1;
            }
            Marshal.Copy(samples, 0, histogram.Data, samples.Length);
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, ranges);
            if (task.heartBeat) maskval += 1;
            if (sortedHist.ElementAt(maskval).Key == 0) maskval = 0;
            int index = sortedHist.ElementAt(maskval).Value;
            dst3 = dst2.InRange(index, index);
            labels[3] = "There were " + sortedHist.ElementAt(maskval).Key + " samples in bin " + index;
        }
    }
    public class CS_Hist3Dcloud_BP_Filter : CS_Parent
    {
        public Mat histogram = new Mat();
        Options_HistXD options = new Options_HistXD();
        public CS_Hist3Dcloud_BP_Filter(VBtask task) : base(task)
        {
            task.redOptions.setHistBinBar3D(16);
            dst3 = new Mat(dst3.Size(), MatType.CV_32FC3, 0);
            labels[2] = "Mask of the pointcloud image after backprojection that removes 'blowback' pixels";
            desc = "Backproject a 3D pointcloud histogram after thresholding the bins with the small samples.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int bins = task.redOptions.getHistBinBar3D();
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            float[] histInput = new float[src.Total() * 3];
            Marshal.Copy(src.Data, histInput, 0, histInput.Length);
            Vec2f rx = new Vec2f(-task.xRangeDefault, task.xRangeDefault);
            Vec2f ry = new Vec2f(-task.yRangeDefault, task.yRangeDefault);
            Vec2f rz = new Vec2f(0, task.MaxZmeters);
            GCHandle handleInput = GCHandle.Alloc(histInput, GCHandleType.Pinned);
            IntPtr imagePtr = BackProjectCloud_Run(handleInput.AddrOfPinnedObject(), src.Rows, src.Cols, bins, options.threshold3D,
                                             rx[0], ry[0], rz[0], rx[1], ry[1], rz[1]);
            handleInput.Free();
            dst2 = new Mat(dst2.Height, dst2.Width, MatType.CV_8U, imagePtr);
            dst2.SetTo(0, task.noDepthMask);
            dst3.SetTo(0);
            task.pointCloud.CopyTo(dst3, dst2);
        }
    }
    public class CS_Hist3Dcloud_PlotHist1D : CS_Parent
    {
        Hist3Dcloud_Basics hcloud = new Hist3Dcloud_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        public Mat histogram;
        public float[] histArray;
        Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public CS_Hist3Dcloud_PlotHist1D(VBtask task) : base(task)
        {
            plot.removeZeroEntry = false;
            labels[2] = "The 3D histogram of the pointcloud data stream - note the number of gaps";
            desc = "Present the 3D histogram as a typical histogram bar chart.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            hcloud.Run(src);
            histArray = new float[hcloud.histogram.Total()];
            Marshal.Copy(hcloud.histogram.Data, histArray, 0, histArray.Length);
            histogram = new Mat(histArray.Length, 1, MatType.CV_32F, histArray);
            plot.Run(histogram);
            dst2 = plot.dst2;
            simK.Run(histogram);
            labels[3] = simK.labels[2];
        }
    }
    public class CS_Hist3Dcolor_Basics : CS_Parent
    {
        public Mat histogram = new Mat();
        public Mat histogram1D = new Mat();
        public int classCount;
        public Mat inputMask = new Mat();
        public float[] histArray;
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public bool alwaysRun;
        public CS_Hist3Dcolor_Basics(VBtask task) : base(task)
        {
            desc = "Capture a 3D color histogram, find the gaps, and backproject the clusters found.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_8UC3) src = task.color;
            if (task.heartBeat || alwaysRun)
            {
                int bins = task.redOptions.getHistBinBar3D();
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, inputMask, histogram, 3, new int[] { bins, bins, bins }, task.redOptions.rangesBGR);
                histArray = new float[histogram.Total()];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                histogram1D = new Mat((int)histogram.Total(), 1, MatType.CV_32F, histogram.Data);
                simK.Run(histogram1D);
                histogram = simK.dst2;
                classCount = simK.classCount;
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, task.redOptions.rangesBGR);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = simK.labels[2];
            labels[3] = "Backprojection of " + classCount.ToString() + " histogram entries.";
        }
    }
    public class CS_Hist3Dcolor_UniqueRGBPixels : CS_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public List<Point3f> pixels = new List<Point3f>();
        public List<int> counts = new List<int>();
        public CS_Hist3Dcolor_UniqueRGBPixels(VBtask task) : base(task)
        {
            desc = "Get the number of non-zero BGR elements in the 3D color histogram of the current image and their BGR values";
        }
        public void RunCS(Mat src)
        {
            hColor.Run(src);
            pixels.Clear();
            counts.Clear();
            int bins = task.redOptions.getHistBinBar3D();
            for (int z = 0; z < bins; z++)
            {
                for (int y = 0; y < bins; y++)
                {
                    for (int x = 0; x < bins; x++)
                    {
                        float val = hColor.histArray[x * bins * bins + y * bins + z];
                        if (val > 0)
                        {
                            pixels.Add(new Point3f((float)(255 * x / bins), (float)(255 * y / bins), (float)(255 * z / bins)));
                            counts.Add((int)val);
                        }
                    }
                }
            }
            SetTrueText("There are " + pixels.Count.ToString() + " non-zero entries in the 3D histogram " + "\n" + "See uniquePixels list in Hist3Dcolor_UniquePixels", 2);
        }
    }
    public class CS_Hist3Dcolor_TopXColors : CS_Parent
    {
        Hist3Dcolor_UniqueRGBPixels unique = new Hist3Dcolor_UniqueRGBPixels();
        public List<Point3i> topXPixels = new List<Point3i>();
        public int mapTopX = 16;
        public CS_Hist3Dcolor_TopXColors(VBtask task) : base(task)
        {
            desc = "Get the top 256 of non-zero BGR elements in the 3D color histogram of the current image and their BGR values";
        }
        public void RunCS(Mat src)
        {
            unique.Run(src);
            var sortedPixels = new SortedList<int, Point3f>(new CompareAllowIdenticalIntegerInverted());
            for (int i = 0; i < unique.pixels.Count; i++)
            {
                sortedPixels.Add(unique.counts[i], unique.pixels[i]);
            }
            topXPixels.Clear();
            for (int i = 0; i < sortedPixels.Count; i++)
            {
                topXPixels.Add(sortedPixels.ElementAt(i).Value.ToPoint3i());
                if (topXPixels.Count >= mapTopX) break;
            }
            SetTrueText("There are " + sortedPixels.Count.ToString() + " non-zero entries in the 3D histogram " + "\n" + "The top " + mapTopX.ToString() + " pixels are in topXPixels", 2);
        }
    }
    public class CS_Hist3Dcolor_Reduction : CS_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Reduction_BGR reduction = new Reduction_BGR();
        public int classCount;
        public CS_Hist3Dcolor_Reduction(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.redOptions.setSimpleReductionBar(45);
            desc = "Backproject the 3D histogram for RGB after reduction";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 3) src = task.color;
            reduction.Run(src);
            hColor.Run(reduction.dst2);
            dst1 = reduction.dst2;
            dst2 = hColor.dst2;
            dst3 = hColor.dst3;
            labels[2] = hColor.labels[2];
        }
    }
    public class CS_Hist3Dcolor_ZeroGroups : CS_Parent
    {
        public Mat maskInput = new Mat();
        public int classCount;
        public Mat histogram = new Mat();
        public CS_Hist3Dcolor_ZeroGroups(VBtask task) : base(task)
        {
            desc = "Breakdown the 3D histogram using the '0' entries as boundaries between clusters.";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 3) src = task.color;
            if (task.optionsChanged)
            {
                int bins = task.redOptions.getHistBinBar3D();
                int[] hBins = { bins, bins, bins };
                Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, maskInput, histogram, 3, hBins, task.redOptions.rangesBGR);
                float[] histArray = new float[histogram.Total()];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                List<int> boundaries = new List<int>();
                bool zeroMode = false;
                for (int i = 0; i < histArray.Length; i++)
                {
                    if (histArray[i] == 0 && !zeroMode)
                    {
                        boundaries.Add(i);
                        zeroMode = true;
                    }
                    if (histArray[i] != 0) zeroMode = false;
                }
                int lastIndex = 0;
                classCount = 1;
                foreach (int index in boundaries)
                {
                    for (int i = lastIndex; i <= index; i++)
                    {
                        histArray[i] = classCount;
                    }
                    lastIndex = index + 1;
                    classCount++;
                }
                for (int i = lastIndex; i < histArray.Length; i++)
                {
                    histArray[i] = classCount;
                }
                classCount++;
                Marshal.Copy(histArray, 0, histogram.Data, histArray.Length);
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, task.redOptions.rangesBGR);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = "CS_Hist3Dcolor_ZeroGroups classCount = " + classCount.ToString();
        }
    }
    public class CS_Hist3Dcolor_PlotHist1D : CS_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Plot_Histogram plot = new Plot_Histogram();
        public Mat histogram1D;
        public Mat histogram;
        public float[] histArray;
        public CS_Hist3Dcolor_PlotHist1D(VBtask task) : base(task)
        {
            hColor.alwaysRun = true;
            plot.removeZeroEntry = false;
            labels[2] = "The 3D histogram of the RGB image stream - note the number of gaps";
            desc = "Present the 3D histogram as a typical histogram bar chart.";
        }
        public void RunCS(Mat src)
        {
            hColor.Run(src);
            histogram1D = hColor.histogram1D;
            histArray = hColor.histArray;
            plot.Run(hColor.histogram1D);
            dst2 = plot.dst2;
        }
    }
    public class CS_Hist3Dcolor_Select : CS_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        public CS_Hist3Dcolor_Select(VBtask task) : base(task)
        {
            labels[3] = "The highlighted pixels are in the selected bin";
            desc = "Build a 3D histogram from the BGR image and backproject the 'Selected bin' (in options_HistXD sliders).";
        }
        public void RunCS(Mat src)
        {
            hColor.Run(src);
            int selection = task.gOptions.DebugSliderValue;
            dst2 = hColor.dst2.InRange(selection, selection);
            int saveCount = dst2.CountNonZero();
            dst3 = src.Clone();
            dst3.SetTo(Scalar.White, dst2);
            labels[2] = saveCount.ToString() + " pixels were found in bin " + selection.ToString();
        }
    }
    public class CS_Hist3Dcolor_Basics_CPP : CS_Parent
    {
        public Mat histogram = new Mat();
        public bool prepareImage = true;
        public Mat histogram1D = new Mat();
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public int classCount;
        public CS_Hist3Dcolor_Basics_CPP(VBtask task) : base(task)
        {
            desc = "Build a 3D histogram from the BGR image and sort it by histogram entry size.";
        }
        public void RunCS(Mat src)
        {
            byte[] histInput = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, histInput, 0, histInput.Length);
            GCHandle handleInput = GCHandle.Alloc(histInput, GCHandleType.Pinned);
            int bins = task.redOptions.getHistBinBar3D();
            IntPtr imagePtr = Hist3Dcolor_Run(handleInput.AddrOfPinnedObject(), src.Rows, src.Cols, bins);
            handleInput.Free();
            histogram = new Mat(task.redOptions.histBins3D, 1, MatType.CV_32F, imagePtr);
            if (prepareImage)
            {
                float[] histArray = new float[histogram.Total()];
                Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
                histogram1D = new Mat(histArray.Length, 1, MatType.CV_32F, histArray);
                simK.Run(histogram);
                histogram = simK.dst2;
                classCount = simK.classCount;
                Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst2, task.redOptions.rangesBGR);
                mmData mm = GetMinMax(dst2);
                dst3 = ShowPalette(dst2 * 255 / mm.maxVal);
                labels[2] = simK.labels[2];
                labels[3] = mm.maxVal.ToString() + " different levels in the backprojection.";
            }
        }
    }
    public class CS_Hist3Dcolor_Diff : CS_Parent
    {
        Hist3Dcolor_Basics hColor = new Hist3Dcolor_Basics();
        Diff_Basics diff = new Diff_Basics();
        public CS_Hist3Dcolor_Diff(VBtask task) : base(task)
        {
            task.gOptions.pixelDiffThreshold = 0;
            dst3 = new Mat(dst3.Size(), MatType.CV_8U, 0);
            desc = "Create a mask for the color pixels that are changing with every frame of the Hist3Dcolor_basics.";
        }
        public void RunCS(Mat src)
        {
            hColor.Run(src);
            dst2 = hColor.dst3;
            labels[2] = hColor.labels[3];
            diff.Run(hColor.dst2);
            if (task.heartBeat) dst3.SetTo(0);
            dst3 = dst3 | diff.dst2;
        }
    }
    public class CS_Hist3Dcolor_Vector : CS_Parent
    {
        public Mat histogram = new Mat();
        public Mat inputMask = new Mat();
        public float[] histArray;
        public Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        int[] binArray;
        public CS_Hist3Dcolor_Vector(VBtask task) : base(task)
        {
            int bins = task.redOptions.getHistBinBar3D();
            binArray = new int[] { bins, bins, bins };
            UpdateAdvice(traceName + ": redOptions '3D Histogram Bins'");
            desc = "Capture a 3D color histogram for input src - likely to be src(rect).";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() != 3) src = task.color;
            if (task.optionsChanged)
            {
                int bins = task.redOptions.getHistBinBar3D();
                binArray = new int[] { bins, bins, bins };
            }
            Cv2.CalcHist(new Mat[] { src }, new int[] { 0, 1, 2 }, inputMask, histogram, 3, binArray, task.redOptions.rangesBGR);
            histArray = new float[histogram.Total()];
            Marshal.Copy(histogram.Data, histArray, 0, histArray.Length);
            if (standaloneTest()) SetTrueText("Vector prepared in histArray");
        }
    }
    public class CS_History_Basics : CS_Parent
    {
        public List<Mat> saveFrames = new List<Mat>();
        public CS_History_Basics(VBtask task) : base(task)
        {
            desc = "Create a frame history to sum the last X frames";
        }
        public void RunCS(Mat src)
        {
            if (task.frameHistoryCount == 1)
            {
                dst2 = src;
                return;
            }
            if (src.Type() != MatType.CV_32F)
                src.ConvertTo(src, MatType.CV_32F);
            if (dst1.Type() != src.Type() || dst1.Channels() != src.Channels() || task.optionsChanged)
            {
                dst1 = src;
                saveFrames.Clear();
            }
            if (saveFrames.Count >= task.frameHistoryCount)
                saveFrames.RemoveAt(0);
            saveFrames.Add(src.Clone());
            foreach (var m in saveFrames)
            {
                dst1 += m;
            }
            dst1 *= 1.0 / (saveFrames.Count + 1);
            if (src.Channels() == 1)
            {
                dst1.ConvertTo(dst2, MatType.CV_8U);
            }
            else
            {
                dst1.ConvertTo(dst2, MatType.CV_8UC3);
            }
        }
    }
    public class CS_History_MotionRect : CS_Parent
    {
        public CS_History_MotionRect(VBtask task) : base(task)
        {
            desc = "Create an image that is the motionRect applied to the previous image.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
                dst2 = src.Clone();
            if (task.motionDetected)
            {
                src[task.motionRect].CopyTo(dst2[task.motionRect]);
            }
        }
    }
    public class CS_History_Cloud : CS_Parent
    {
        public History_BasicsNoSaturation frames = new History_BasicsNoSaturation();
        List<Mat> saveFrames = new List<Mat>();
        public CS_History_Cloud(VBtask task) : base(task)
        {
            desc = "Create a frame history and sum the last X task.pointcloud's";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3 || src.Channels() != 3)
                src = task.pointCloud;
            if (task.optionsChanged || dst3.Type() != MatType.CV_32FC3)
            {
                saveFrames.Clear();
                dst3 = new Mat(dst2.Size(), MatType.CV_32FC3, 0);
            }
            if (saveFrames.Count >= task.frameHistoryCount)
            {
                dst3 = dst3.Subtract(saveFrames[0]);
                saveFrames.RemoveAt(0);
            }
            saveFrames.Add(src.Clone());
            dst3 = src + dst3;
            dst2 = dst3 / saveFrames.Count;
            frames.Run(task.depthMask);
            dst2.SetTo(0, ~frames.dst2);
        }
    }
    public class CS_History_BasicsNoSaturation : CS_Parent
    {
        public List<Mat> saveFrames = new List<Mat>();
        public CS_History_BasicsNoSaturation(VBtask task) : base(task)
        {
            desc = "Create a frame history and sum the last X frames (without saturation!)";
        }
        public void RunCS(Mat src)
        {
            var input = src.Clone();
            if (input.Channels() != 1)
                input = input.CvtColor(cv.ColorConversionCodes.BGR2GRAY);
            if (input.Type() != MatType.CV_32F)
                input.ConvertTo(input, MatType.CV_32F);
            if (dst3.Type() != input.Type() || dst3.Channels() != input.Channels())
                dst3 = new Mat(input.Size(), input.Type(), 0);
            input /= 255; // input is all zeros or ones.
            if (task.optionsChanged)
            {
                saveFrames.Clear();
                dst3.SetTo(0);
            }
            if (saveFrames.Count >= task.frameHistoryCount)
            {
                dst3 = dst3.Subtract(saveFrames[0]);
                saveFrames.RemoveAt(0);
            }
            saveFrames.Add(input);
            dst3 += input;
            dst1 = 255 * dst3 / saveFrames.Count;
            dst1.ConvertTo(dst2, MatType.CV_8U);
        }
    }
    public class CS_History_BasicsDiff : CS_Parent
    {
        History_BasicsNoSaturation frames = new History_BasicsNoSaturation();
        Diff_Basics diff = new Diff_Basics();
        public CS_History_BasicsDiff(VBtask task) : base(task)
        {
            task.gOptions.pixelDiffThreshold = 0;
            desc = "Find the floodfill trouble spots.";
        }
        public void RunCS(Mat src)
        {
            frames.Run(src);
            dst2 = ShowPalette(frames.dst2);
            diff.Run(frames.dst2);
            dst3 = diff.dst2;
        }
    }
    public class CS_HistPeak2D_Basics : CS_Parent
    {
        public OpAuto_Peaks2DGrid auto = new OpAuto_Peaks2DGrid();
        Hist2D_BGR bgr = new Hist2D_BGR();
        Delaunay_ConsistentColor delaunay = new Delaunay_ConsistentColor();
        public Mat histogram = new Mat();
        public Rangef[] ranges;
        public CS_HistPeak2D_Basics(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Find the top X peaks in a 2D histogram and use Delaunay to setup the backprojection";
        }
        public void RunCS(Mat src)
        {
            // if standaloneTest(), go get a histogram for input.  Src is the 3-channel input to the histogram.
            if (standaloneTest())
            {
                bgr.Run(src);
                histogram = bgr.histogram02;
            }
            if (task.heartBeat)
            {
                auto.Run(histogram);
                delaunay.inputPoints = new List<Point2f>(auto.clusterPoints);
                delaunay.Run(src);
                dst1 = auto.dst2;
                dst3 = delaunay.dst2;
            }
            var mask = histogram.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            delaunay.dst1.ConvertTo(histogram, MatType.CV_32F);
            histogram.SetTo(0, ~mask);
            if (ranges == null || task.optionsChanged)
            {
                ranges = GetHist2Dminmax(src, task.redOptions.channels[0], task.redOptions.channels[1]);
            }
            var backProjection = new Mat();
            Cv2.CalcBackProject(new Mat[] { src }, task.redOptions.channels, histogram, backProjection, ranges);
            dst2 = ShowPalette(backProjection * 255 / delaunay.inputPoints.Count);
        }
    }
    public class CS_HistPeak2D_TopAndSide : CS_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistSide histSide = new Projection_HistSide();
        Projection_HistTop histTop = new Projection_HistTop();
        public CS_HistPeak2D_TopAndSide(VBtask task) : base(task)
        {
            desc = "Find the top X peaks in the 2D histogram of the top and side views and backproject them.";
        }
        public void RunCS(Mat src)
        {
            if (task.toggleOnOff)
            {
                histSide.Run(src);
                peak.ranges = task.rangesSide;
                task.redOptions.channels = task.channelsSide;
                peak.histogram = histSide.histogram;
            }
            else
            {
                histTop.Run(src);
                task.redOptions.channels = task.channelsTop;
                peak.ranges = task.rangesTop;
                peak.histogram = histTop.histogram;
            }
            peak.Run(task.pointCloud);
            dst1 = peak.dst2;
            dst2 = ShowPalette(dst1);
        }
    }
    public class CS_HistPeak2D_NotHotTop : CS_Parent
    {
        public Projection_HistTop histTop = new Projection_HistTop();
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        public CS_HistPeak2D_NotHotTop(VBtask task) : base(task)
        {
            desc = "Find the regions with the non-zero (low) samples in the top view";
        }
        public void RunCS(Mat src)
        {
            histTop.Run(src);
            dst1 = histTop.histogram.InRange(0, 0).ConvertScaleAbs();
            var mm = GetMinMax(histTop.histogram);
            dst3 = new Mat(dst3.Size(), MatType.CV_32F, mm.maxVal);
            dst3 -= histTop.histogram;
            dst3.SetTo(0, dst1);
            peak.histogram = histTop.histogram;
            peak.Run(task.pointCloud);
            dst2 = peak.dst2;
        }
    }
    public class CS_HistPeak2D_Edges : CS_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistTop histTop = new Projection_HistTop();
        Edge_Canny edges = new Edge_Canny();
        public CS_HistPeak2D_Edges(VBtask task) : base(task)
        {
            desc = "Display the HistPeak2D_Basics edges in the RGB image";
        }
        public void RunCS(Mat src)
        {
            histTop.Run(src);
            dst3 = histTop.histogram.Threshold(task.projectionThreshold, 255, ThresholdTypes.Binary);
            peak.histogram = histTop.histogram;
            peak.Run(task.pointCloud);
            dst2 = peak.dst2;
            edges.Run(dst2);
            dst3 = src;
            dst3.SetTo(Scalar.White, edges.dst2);
        }
    }
    public class CS_HistPeak2D_HSV : CS_Parent
    {
        Hist2D_HSV hsv = new Hist2D_HSV();
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        public CS_HistPeak2D_HSV(VBtask task) : base(task)
        {
            desc = "Find the peaks in the 2D plot of the HSV image";
        }
        public void RunCS(Mat src)
        {
            hsv.Run(src);
            peak.histogram = hsv.histogram01;
            peak.Run(hsv.dst1);
            dst2 = peak.dst2;
            dst3 = peak.auto.dst2;
            labels[3] = hsv.labels[2];
        }
    }
    public class CS_HistPeak2D_BGR : CS_Parent
    {
        Hist2D_BGR bgr = new Hist2D_BGR();
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        public CS_HistPeak2D_BGR(VBtask task) : base(task)
        {
            desc = "Find the peaks in the 2D plot of the BGR image";
        }
        public void RunCS(Mat src)
        {
            bgr.Run(src);
            peak.histogram = bgr.histogram02;
            peak.Run(src);
            dst2 = peak.dst2;
            dst3 = peak.auto.dst2;
            labels[3] = bgr.labels[2];
        }
    }
    public class CS_HistPeak2D_RGB : CS_Parent
    {
        HistPeak2D_BGR peak = new HistPeak2D_BGR();
        public CS_HistPeak2D_RGB(VBtask task) : base(task)
        {
            desc = "Find the peaks in the 2D plot of the BGR image";
        }
        public void RunCS(Mat src)
        {
            peak.Run(src);
            dst2 = peak.dst2;
            dst3 = peak.dst3;
            labels[3] = peak.labels[2];
        }
    }
    public class CS_HistPeak2D_HotSide : CS_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistSide histSide = new Projection_HistSide();
        public CS_HistPeak2D_HotSide(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Backprojection of Side View hotspots", "Side view with highlighted hot spots" };
            desc = "Find the top X peaks in the 2D histogram of the side view and backproject it.";
        }
        public void RunCS(Mat src)
        {
            histSide.Run(src);
            dst3 = histSide.histogram;
            for (int i = 0; i < peak.auto.clusterPoints.Count; i++)
            {
                var pt = peak.auto.clusterPoints[i];
                DrawCircle(dst3, pt, task.DotSize * 3, Scalar.White);
            }
            peak.histogram = histSide.histogram;
            peak.ranges = task.rangesSide;
            task.redOptions.channels = task.channelsSide;
            peak.Run(task.pointCloud);
            dst2 = peak.dst2;
            dst2.SetTo(0, task.noDepthMask);
        }
    }
    public class CS_HistPeak2D_HotTop : CS_Parent
    {
        HistPeak2D_Basics peak = new HistPeak2D_Basics();
        Projection_HistTop histTop = new Projection_HistTop();
        public CS_HistPeak2D_HotTop(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Backprojection of Top View hotspots", "Top view with highlighted hot spots" };
            desc = "Find the top X peaks in the 2D histogram of the top view and backproject it.";
        }
        public void RunCS(Mat src)
        {
            histTop.Run(src);
            dst3 = histTop.histogram;
            for (int i = 0; i < peak.auto.clusterPoints.Count; i++)
            {
                var pt = peak.auto.clusterPoints[i];
                DrawCircle(dst3, pt, task.DotSize * 3, Scalar.White);
            }
            peak.histogram = histTop.histogram;
            peak.ranges = task.rangesTop;
            task.redOptions.channels = task.channelsTop;
            peak.Run(task.pointCloud);
            dst2 = peak.dst2;
            dst2.SetTo(0, task.noDepthMask);
        }
    }
    public class CS_HistValley_Basics : CS_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        Options_Boundary options = new Options_Boundary();
        public int[] valleys = new int[4]; // grayscale values for low points in the histogram.
        List<float> scaleList = new List<float>();
        public CS_HistValley_Basics(VBtask task) : base(task)
        {
            task.frameHistoryCount = 30;
            task.gOptions.setHistogramBins(256);
            labels[2] = "Histogram of the grayscale image.  White lines mark local minimum above threshold.  Yellow horizontal = histogram mean.";
            desc = "Find the histogram valleys for a grayscale image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int vCount = options.desiredBoundaries;
            int minDistance = options.peakDistance;
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst2 = hist.dst2;
            var avg = hist.histogram.Mean();
            scaleList.Add((float)(dst2.Height - dst2.Height * avg[0] / hist.plot.mm.maxVal));
            float scale = scaleList.Average();
            SetTrueText("Mean", new cv.Point(5, scale), 3);
            dst2.Line(new cv.Point(0, scale), new cv.Point(dst2.Width, scale), Scalar.Yellow, task.lineWidth + 1);
            if (scaleList.Count > task.frameHistoryCount) scaleList.RemoveAt(0);
            var hArray = hist.histArray;
            int quartile = (int)Math.Floor(hArray.Count() / 4.0); // note we really just want quartiles 
            float threshold = (float)avg[0] / 2;
            Array.Clear(valleys, 0, valleys.Length);
            for (int i = 0; i < valleys.Length; i++)
            {
                valleys[i] = quartile * i;
                float minVal = (float) avg[0];
                for (int j = quartile * i; j < quartile * (i + 1); j++)
                {
                    float nextVal = hArray[j];
                    if (nextVal < minVal && nextVal > threshold && (j - valleys[i]) >= minDistance)
                    {
                        valleys[i] = j;
                        minVal = nextVal;
                    }
                }
            }
            float wPlot = (float)dst2.Width / task.histogramBins;
            for (int i = 0; i < valleys.Length; i++)
            {
                float col = valleys[i] * wPlot;
                dst2.Line(new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, task.lineWidth + 1);
            }
        }
    }
    public class CS_HistValley_FromPeaks : CS_Parent
    {
        public HistValley_Peaks peak = new HistValley_Peaks();
        public List<int> peaks = new List<int>();
        public List<int> valleyIndex = new List<int>();
        public float[] avgValley;
        public List<float> histList = new List<float>();
        public CS_HistValley_FromPeaks(VBtask task) : base(task)
        {
            FindSlider("Desired boundary count").Value = 10;
            desc = "Use the peaks identified in HistValley_Peaks to find the valleys between the peaks.";
        }
        public void updatePlot(cv.Mat dst, int bins)
        {
            foreach (var valley in valleyIndex)
            {
                float col = dst.Width * valley / bins;
                dst.Line(new cv.Point(col, dst.Height), new cv.Point(col, dst.Height * 9 / 10), Scalar.White, task.lineWidth);
            }
        }
        public void RunCS(Mat src)
        {
            peak.Run(src);
            dst2 = peak.hist.dst2;
            histList = peak.histArray.ToList();
            peaks = new List<int>(peak.peaks);
            valleyIndex.Clear();
            for (int i = 0; i < peaks.Count - 1; i++)
            {
                int start = peaks[i];
                int finish = peaks[i + 1];
                List<float> testList = new List<float>();
                for (int j = start; j <= finish; j++)
                {
                    testList.Add(histList[j]);
                }
                valleyIndex.Add(start + testList.IndexOf(testList.Min()));
            }
            if (task.optionsChanged) avgValley = new float[valleyIndex.Count];
            float depthPerBin = task.MaxZmeters / histList.Count;
            for (int i = 0; i < avgValley.Length; i++)
            {
                avgValley[i] = (avgValley[i] + valleyIndex[i] * depthPerBin) / 2;
            }
            if (standaloneTest())
            {
                updatePlot(dst2, task.histogramBins);
                SetTrueText("Input data used by default is the depth data", 3);
            }
            labels[2] = peak.labels[2] + " and " + valleyIndex.Count.ToString() + " valleys (marked at bottom)";
        }
    }
    public class CS_HistValley_Peaks : CS_Parent
    {
        public Hist_Basics hist = new Hist_Basics();
        public Options_Boundary options = new Options_Boundary();
        public List<int> peaks = new List<int>();
        public float[] histArray;
        public CS_HistValley_Peaks(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(100);
            FindSlider("Desired boundary count").Value = 5;
            labels[2] = "Histogram - white lines are peaks";
            desc = "Find the requested number of peaks in the histogram ";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int desiredBoundaries = options.desiredBoundaries;
            if (src.Type() != MatType.CV_32FC1 || standaloneTest())
            {
                src = task.pcSplit[2];
                hist.Run(src);
                dst2 = hist.dst2;
                histArray = new float[hist.histogram.Rows];
                Marshal.Copy(hist.histogram.Data, histArray, 0, histArray.Length);
            }
            else
            {
                histArray = new float[src.Rows];
                Marshal.Copy(src.Data, histArray, 0, histArray.Length);
            }
            var histList = histArray.ToList();
            var sortPeaks = new SortedList<int, int>(new compareAllowIdenticalInteger());
            for (int i = 0; i < histList.Count; i++)
            {
                if (histList[i] != 0)
                {
                    sortPeaks.Add(i, i);
                    break;
                }
            }
            for (int i = histList.Count - 1; i >= 0; i--)
            {
                if (histList[i] != 0)
                {
                    sortPeaks.Add(i, i);
                    break;
                }
            }
            for (int i = 0; i < desiredBoundaries; i++)
            {
                int index = histList.IndexOf(histList.Max());
                float lastCount = histList[index];
                sortPeaks.Add(index, index);
                for (int j = index - 1; j >= 0; j--)
                {
                    float count = histList[j];
                    if (lastCount > count) histList[j] = 0; else break;
                    lastCount = count;
                }
                lastCount = histList[index];
                histList[index] = 0;
                for (int j = index + 1; j < histList.Count; j++)
                {
                    float count = histList[j];
                    if (lastCount > count) histList[j] = 0; else break;
                    lastCount = count;
                }
            }
            mmData mm = GetMinMax(src);
            float incr = (float)(mm.maxVal - mm.minVal) / task.histogramBins;
            peaks.Clear();
            foreach (var index in sortPeaks.Keys)
            {
                float col = (float)dst2.Width * index / task.histogramBins;
                peaks.Add(index);
                DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height / 10), Scalar.White, task.lineWidth);
            }
            labels[2] = (peaks.Count - 2).ToString() + " peaks (marked at top) were found in the histogram";
        }
    }
    public class CS_HistValley_Depth : CS_Parent
    {
        public HistValley_FromPeaks valley = new HistValley_FromPeaks();
        Mat histogram;
        public CS_HistValley_Depth(VBtask task) : base(task)
        {
            labels[2] = "Top markers = peaks, bottom markers = valleys";
            desc = "Find the valleys in the depth histogram.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                valley.Run(src);
                dst2 = valley.dst2;
                List<int> vList = new List<int>(valley.valleyIndex);
                float[] histArray = new float[valley.histList.Count];
                for (int i = 0; i < vList.Count - 1; i++)
                {
                    int start = vList[i];
                    int finish = vList[i + 1];
                    for (int j = start; j <= finish; j++)
                    {
                        histArray[j] = i + 1;
                    }
                }
                histogram = valley.peak.hist.histogram;
                Marshal.Copy(histArray, 0, histogram.Data, histArray.Length);
                histogram += 1; // shift away from 0
            }
            if (standaloneTest()) valley.updatePlot(dst2, task.histogramBins);
        }
    }
    public class CS_HistValley_Depth1 : CS_Parent
    {
        public HistValley_OptionsAuto valley = new HistValley_OptionsAuto();
        public SortedList<int, int> valleyOrder = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public CS_HistValley_Depth1(VBtask task) : base(task)
        {
            desc = "Find the valleys in the depth histogram.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F) src = task.pcSplit[2];
            valley.Run(src);
            dst1 = valley.dst1;
            dst2 = valley.dst2;
            dst3 = valley.dst3;
            valleyOrder = valley.auto.valleyOrder;
        }
    }
    public class CS_HistValley_Test : CS_Parent
    {
        public SortedList<int, int> valleyOrder = new SortedList<int, int>(new compareAllowIdenticalInteger());
        public Options_Boundary options = new Options_Boundary();
        Hist_Kalman kalmanHist = new Hist_Kalman();
        public CS_HistValley_Test(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(256);
            desc = "Get the top X highest quality valley points in the histogram.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int desiredBoundaries = options.desiredBoundaries;
            // input should be a histogram.  If not, get one...
            if (standaloneTest())
            {
                kalmanHist.Run(src);
                dst2 = kalmanHist.dst2;
                src = kalmanHist.hist.histogram.Clone();
            }
            float[] histArray = new float[src.Total() - 1];
            Marshal.Copy(src.Data, histArray, 0, histArray.Length);
            var histList = histArray.ToList();
            List<float> valleys = new List<float>();
            float incr = histList.Count / desiredBoundaries;
            for (int i = 0; i < desiredBoundaries; i++)
            {
                List<float> nextList = new List<float>();
                for (int j = (int)(i * incr); j < (int)((i + 1) * incr); j++)
                {
                    if (i == 0 && j < 5)
                    {
                        nextList.Add(dst2.Total()); // there are typically some gaps near zero.
                    }
                    else
                    {
                        if (histList[j] == 0) nextList.Add(dst2.Total()); else nextList.Add(histList[j]);
                    }
                }
                int index = nextList.IndexOf(nextList.Min());
                valleys.Add(index + i * incr);
            }
            valleyOrder.Clear();
            int lastEntry = 0;
            for (int i = 0; i < desiredBoundaries; i++)
            {
                valleyOrder.Add(lastEntry, (int)(valleys[i] - 1));
                lastEntry = (int)valleys[i];
            }
            if (valleys[desiredBoundaries - 1] != histList.Count - 1)
            {
                valleyOrder.Add((int)valleys[desiredBoundaries - 1], 256);
            }
            if (standaloneTest())
            {
                foreach (var entry in valleyOrder)
                {
                    float col = (float)entry.Value * dst2.Width / task.histogramBins;
                    DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, task.lineWidth);
                }
                SetTrueText(valleys.Count.ToString() + " valleys in histogram", 3);
            }
        }
    }
    public class CS_HistValley_OptionsAuto : CS_Parent
    {
        Hist_Kalman kalman = new Hist_Kalman();
        public Mat histogram = new Mat();
        public OpAuto_Valley auto = new OpAuto_Valley();
        public CS_HistValley_OptionsAuto(VBtask task) : base(task)
        {
            task.gOptions.setHistogramBins(256);
            labels = new string[] { "", "", "Grayscale histogram - white lines are valleys", "" };
            desc = "Isolate the different levels of gray using the histogram valleys.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                kalman.Run(src);
                dst2 = kalman.dst2;
                histogram = kalman.hist.histogram.Clone();
                auto.Run(histogram);
                if (auto.valleyOrder.Count == 0) return;
                for (int i = 0; i < auto.valleyOrder.Count; i++)
                {
                    var entry = auto.valleyOrder.ElementAt(i);
                    float cClass = (float)(255 / (i + 1));
                    int index = (i % 2 == 0) ? (int)(255 - cClass) : (int)cClass;
                    for (int j = entry.Key; j <= entry.Value; j++)
                    {
                        histogram.Set<float>(j, 0, index);
                    }
                    int col = dst2.Width * entry.Value / task.histogramBins;
                    DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, task.lineWidth);
                }
            }
            if (src.Type() == MatType.CV_32F) histogram += 1;
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0 }, histogram, dst1, kalman.hist.ranges);
            if (dst1.Type() != MatType.CV_8U)
            {
                dst1.SetTo(0, task.noDepthMask);
                dst1.ConvertTo(dst1, MatType.CV_8U);
            }
            dst3 = ShowPalette(dst1);
            labels[3] = (auto.valleyOrder.Count + 1).ToString() + " colors in the back projection";
        }
    }
    public class CS_HistValley_Diff : CS_Parent
    {
        Diff_Basics diff = new Diff_Basics();
        HistValley_FromPeaks valley = new HistValley_FromPeaks();
        public CS_HistValley_Diff(VBtask task) : base(task)
        {
            desc = "Compare frame to frame what has changed";
        }
        public void RunCS(Mat src)
        {
            valley.Run(src);
            dst2 = valley.dst2;
            diff.Run(valley.dst2);
            dst3 = diff.dst2;
        }
    }
    public class CS_HistValley_EdgeDraw : CS_Parent
    {
        HistValley_FromPeaks valley = new HistValley_FromPeaks();
        EdgeDraw_Basics edges = new EdgeDraw_Basics();
        public CS_HistValley_EdgeDraw(VBtask task) : base(task)
        {
            desc = "Remove edge color in RGB before HistValley_FromPeaks";
        }
        public void RunCS(Mat src)
        {
            edges.Run(src);
            dst3 = src;
            dst3.SetTo(Scalar.Black, edges.dst2);
            valley.Run(dst3);
            dst2 = valley.dst2;
        }
    }
    public class CS_HistValley_Simple : CS_Parent
    {
        SLR_Trends trends = new SLR_Trends();
        public Kalman_Basics kalman = new Kalman_Basics();
        public List<int> depthRegions = new List<int>();
        public CS_HistValley_Simple(VBtask task) : base(task)
        {
            desc = "Identify ranges by marking the depth histogram entries from valley to valley";
        }
        public void RunCS(Mat src)
        {
            trends.Run(src);
            if (kalman.kInput.Length != task.histogramBins) Array.Resize(ref kalman.kInput, task.histogramBins);
            kalman.kInput = trends.resultingValues.ToArray();
            kalman.Run(src);
            dst2.SetTo(Scalar.Black);
            float barWidth = (float)dst2.Width / trends.resultingValues.Count;
            int colorIndex = 0;
            Scalar color = task.scalarColors[colorIndex % 256];
            int[] vals = { -1, -1, -1 };
            for (int i = 0; i < kalman.kOutput.Count(); i++)
            {
                int h = dst2.Height - (int)kalman.kOutput[i];
                vals[0] = vals[1];
                vals[1] = vals[2];
                vals[2] = h;
                if (vals[0] >= 0)
                {
                    if (vals[0] > vals[1] && vals[2] > vals[1])
                    {
                        colorIndex++;
                        color = task.scalarColors[colorIndex % 256];
                    }
                }
                Cv2.Rectangle(dst2, new Rect(i * (int)barWidth, dst2.Height - h, (int)barWidth, h), color, -1);
                depthRegions.Add(colorIndex);
            }
            cv.Point2f lastPoint = trends.resultingPoints[0];
            for (int i = 1; i < trends.resultingPoints.Count; i++)
            {
                cv.Point2f p1 = trends.resultingPoints[i];
                DrawLine(dst2, lastPoint, p1, Scalar.Yellow, task.lineWidth);
                lastPoint = p1;
            }
            labels[2] = "Depth regions between 0 and " + ((int)(task.MaxZmeters + 1)).ToString() + " meters";
        }
    }
    public class CS_HistValley_Tiers : CS_Parent
    {
        HistValley_FromPeaks valleys = new HistValley_FromPeaks();
        public CS_HistValley_Tiers(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "CV_8U tier map with values ranging from 0 to the desired valley count", "vbPalette output of dst2." };
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Display the depth as tiers defined by the depth valleys in the histogram of depth.";
        }
        public void RunCS(Mat src)
        {
            if (!task.heartBeat) return;
            valleys.Run(src);
            dst2.SetTo(0);
            var marks = valleys.avgValley;
            marks[0] = 0;
            for (int i = 1; i < marks.Count(); i++)
            {
                dst2.SetTo(i + 1, task.pcSplit[2].InRange(marks[i - 1], marks[i]));
            }
            dst2.SetTo(marks.Count(), task.pcSplit[2].InRange(marks[marks.Count() - 1], 100));
            dst3 = ShowPalette(dst2 * 255 / (marks.Count() + 1));
        }
    }
    public class CS_HistValley_Colors : CS_Parent
    {
        Hist_Kalman hist = new Hist_Kalman();
        OpAuto_Valley auto = new OpAuto_Valley();
        int splitIndex;
        public CS_HistValley_Colors(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(256);
            if (standaloneTest()) FindSlider("Desired boundary count").Value = 10;
            desc = "Find the histogram valleys for each of the colors.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat) splitIndex = (splitIndex + 1) % 3;
            src = src.ExtractChannel(splitIndex);
            if (splitIndex == 0)
                hist.hist.plot.backColor = Scalar.Blue;
            else if (splitIndex == 1)
                hist.hist.plot.backColor = Scalar.Green;
            else
                hist.hist.plot.backColor = Scalar.Red;
            hist.Run(src);
            dst2 = hist.dst2;
            auto.Run(hist.hist.histogram);
            for (int i = 0; i < auto.valleyOrder.Count; i++)
            {
                var entry = auto.valleyOrder.ElementAt(i);
                float cClass = (float)(255 / (i + 1));
                int index = (i % 2 == 0) ? (int)(255 - cClass) : (int)cClass;
                for (int j = entry.Key; j <= entry.Value; j++)
                {
                    hist.hist.histogram.Set<float>(j, 0, index);
                }
                int col = dst2.Width * entry.Value / task.histogramBins;
                DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, task.lineWidth);
            }
        }
    }
    public class CS_HistValley_GrayKalman : CS_Parent
    {
        Hist_Kalman hist = new Hist_Kalman();
        OpAuto_Valley auto = new OpAuto_Valley();
        Kalman_Basics kalman = new Kalman_Basics();
        public CS_HistValley_GrayKalman(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(256);
            if (standaloneTest()) FindSlider("Desired boundary count").Value = 4;
            desc = "Find the histogram valleys for a grayscale image.";
        }
        public void RunCS(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst2 = hist.dst2;
            auto.Run(hist.hist.histogram);
            Array.Resize(ref kalman.kInput, auto.valleyOrder.Count);
            for (int i = 0; i < auto.valleyOrder.Count; i++)
            {
                kalman.kInput[i] = auto.valleyOrder.ElementAt(i).Value;
            }
            kalman.Run(src);
            int lastEntry = 0;
            for (int i = 0; i < kalman.kOutput.Count(); i++)
            {
                int entry = auto.valleyOrder.ElementAt(i).Value;
                for (int j = lastEntry; j <= entry; j++)
                {
                    hist.hist.histogram.Set<float>(j, 0, i);
                }
                int col = dst2.Width * entry / task.histogramBins;
                DrawLine(dst2, new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, task.lineWidth);
                lastEntry = entry;
            }
        }
    }
    public class CS_HistValley_GrayScale1 : CS_Parent
    {
        Hist_Basics hist = new Hist_Basics();
        public CS_HistValley_GrayScale1(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setHistogramBins(256);
            desc = "Find the histogram valleys for a grayscale image.";
        }
        public void RunCS(Mat src)
        {
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            hist.Run(src);
            dst2 = hist.dst2;
            int wquartile = dst2.Width / 4;
            for (int i = 0; i < 3; i++)
            {
                int col = wquartile * (i + 1);
                dst2.Line(new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.Yellow, task.lineWidth + 2);
            }
            int start = 0;
            int lastentry = 0;
            int[] minEntries = new int[4];
            int quartile = (int)Math.Floor(hist.histogram.Rows / 4.0);
            for (int i = 0; i < hist.histArray.Count(); i++)
            {
                if (hist.histArray[i] != 0 && i > quartile / 4)
                {
                    lastentry = (int)hist.histArray[i];
                    minEntries[0] = i;
                    start = i;
                    break;
                }
            }
            for (int i = start; i < hist.histArray.Count(); i++)
            {
                if (hist.histArray[i] == 0) hist.histArray[i] = lastentry;
                lastentry = (int)hist.histArray[i];
            }
            for (int i = 0; i < minEntries.Length; i++)
            {
                minEntries[i] = quartile * i;
                for (int j = quartile * i; j < quartile * (i + 1); j++)
                {
                    if (hist.histArray[minEntries[i]] >= hist.histArray[j]) minEntries[i] = j;
                }
            }
            float wPlot = (float)dst2.Width / task.histogramBins;
            for (int i = 0; i < minEntries.Length; i++)
            {
                int col = minEntries[i] * (int)wPlot;
                dst2.Line(new cv.Point(col, 0), new cv.Point(col, dst2.Height), Scalar.White, task.lineWidth + 1);
            }
        }
    }
    public class CS_HMM_Example_CPP : CS_Parent
    {
        public CS_HMM_Example_CPP(VBtask task) : base(task)
        {
            if (!task.testAllRunning) cPtr = HMM_Open();
            labels[2] = "Text output with explanation will appear in the Visual Studio output.";
            desc = "Simple test of Hidden Markov Model - text output";
        }
        public void RunCS(Mat src)
        {
            if (task.testAllRunning)
            {
                SetTrueText("When CS_HMM_Example_CPP is run repeatedly as part of a 'Test All', it can run out of OpenCL memory.");
                return;
            }
            byte[] dataSrc = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, dataSrc, 0, dataSrc.Length);
            GCHandle handleSrc = GCHandle.Alloc(dataSrc, GCHandleType.Pinned);
            IntPtr imagePtr = HMM_Run(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, src.Channels());
            handleSrc.Free();
            if (imagePtr != IntPtr.Zero)
            {
                dst2 = new Mat(src.Rows, src.Cols, src.Channels() == 3 ? MatType.CV_8UC3 : MatType.CV_8UC1, imagePtr).Clone();
            }
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero) cPtr = HMM_Close(cPtr);
        }
        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr HMM_Open();

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr HMM_Close(IntPtr cPtr);

        [DllImport("CPP_Classes.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr HMM_Run(IntPtr HMMPtr, IntPtr bgrPtr, int rows, int cols, int channels);
    }
    public class CS_HOG_Basics : CS_Parent
    {
        Mat Image;
        bool ImageProcessed;
        Options_HOG options = new Options_HOG();
        public CS_HOG_Basics(VBtask task) : base(task)
        {
            desc = "Find people with Histogram of Gradients (HOG) 2D feature";
            if (Image == null) Image = Cv2.ImRead(task.HomeDir + "Data/Asahiyama.jpg", ImreadModes.Color);
            dst3 = Image.Resize(dst3.Size());
        }
        void drawFoundRectangles(cv.Mat dst2, Rect[] found)
        {
            foreach (Rect rect in found)
            {
                // the HOG detector returns slightly larger rectangles than the real objects.
                // so we slightly shrink the rectangles to get a nicer output.
                Rect r = new Rect
                {
                    X = rect.X + (int)Math.Truncate(Math.Round(rect.Width * 0.1)),
                    Y = rect.Y + (int)Math.Truncate(Math.Round(rect.Height * 0.1)),
                    Width = (int)Math.Truncate(Math.Round(rect.Width * 0.8)),
                    Height = (int)Math.Truncate(Math.Round(rect.Height * 0.8))
                };
                dst2.Rectangle(r.TopLeft, r.BottomRight, Scalar.Red, 3, LineTypes.Link8, 0);
            }
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            HOGDescriptor hog = new HOGDescriptor();
            hog.SetSVMDetector(HOGDescriptor.GetDefaultPeopleDetector());
            bool b = hog.CheckDetectorSize();
            b.ToString();
            // run the detector with default parameters. to get a higher hit-rate
            // (and more false alarms, respectively), decrease the hitThreshold and
            // groupThreshold (set groupThreshold to 0 to turn off the grouping completely).
            if (src.Height == 94) src = src.Resize(new cv.Size(src.Width * 2, src.Height * 2));
            Rect[] found = hog.DetectMultiScale(src, options.thresholdHOG, new cv.Size(options.strideHOG, options.strideHOG), new cv.Size(24, 16), options.scaleHOG, 2);
            labels[2] = string.Format("{0} region(s) found", found.Length);
            if (dst2.Height == 94) dst2 = src.Resize(dst2.Size()); else src.CopyTo(dst2);
            drawFoundRectangles(dst2, found);
            if (!ImageProcessed)
            {
                if (dst3.Height == 94) dst3 = dst3.Resize(new cv.Size(dst3.Width * 2, dst3.Height * 2));
                found = hog.DetectMultiScale(dst3, options.thresholdHOG, new cv.Size(options.strideHOG, options.strideHOG), new cv.Size(24, 16), options.scaleHOG, 2);
                drawFoundRectangles(dst3, found);
                if (found.Length > 0)
                {
                    ImageProcessed = true;
                    labels[3] = string.Format("{0} region(s) found", found.Length);
                }
                else
                {
                    labels[3] = "Try adjusting slider bars.";
                }
            }
        }
    }
    public class CS_Homography_Basics : CS_Parent
    {
        public List<Point2d> corners1 = new List<Point2d>();
        public List<Point2d> corners2 = new List<Point2d>();
        Random_Point2d random = new Random_Point2d();
        Options_Homography options = new Options_Homography();
        public CS_Homography_Basics(VBtask task) : base(task)
        {
            desc = "Build the homography matrix from 2 lists of corners and use it in a WarpPerspective call.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (standaloneTest() && task.heartBeat && (cv.HomographyMethods) options.hMethod == HomographyMethods.None)
            {
                random.Run(empty);
                corners1 = new List<Point2d>(random.PointList);
                random.Run(empty);
                corners2 = new List<Point2d>(random.PointList);
            }
            // cannot find a homography when less than 4...
            if (corners1.Count() >= 4 || corners2.Count() >= 4)
            {
                Mat H = Cv2.FindHomography(corners1, corners2, (cv.HomographyMethods)options.hMethod);
                if (H.Width > 0)
                    dst2 = src.WarpPerspective(H, src.Size());
            }
        }
    }
    public class CS_Homography_FPoly : CS_Parent
    {
        FeaturePoly_BasicsOriginal fPoly = new FeaturePoly_BasicsOriginal();
        Homography_Basics hGraph = new Homography_Basics();
        public CS_Homography_FPoly(VBtask task) : base(task)
        {
            desc = "Use the feature polygon to warp the current image to a previous image.  This is not useful but demonstrates how to use homography.";
        }
        public void RunCS(Mat src)
        {
            fPoly.Run(src);
            dst2 = fPoly.dst1;
            if (fPoly.fPD.currPoly == null || fPoly.fPD.prevPoly == null) return;
            if (fPoly.fPD.currPoly.Count() == 0 || fPoly.fPD.prevPoly.Count() == 0) return;
            if (fPoly.fPD.currPoly.Count() != fPoly.fPD.prevPoly.Count()) return;
            hGraph.corners1.Clear();
            hGraph.corners2.Clear();
            for (int i = 0; i < fPoly.fPD.currPoly.Count(); i++)
            {
                Point2f p1 = fPoly.fPD.currPoly[i];
                Point2f p2 = fPoly.fPD.prevPoly[i];
                hGraph.corners1.Add(new Point2d(p1.X, p1.Y));
                hGraph.corners2.Add(new Point2d(p2.X, p2.Y));
            }
            hGraph.Run(src);
            dst3 = hGraph.dst2;
        }
    }
    public class CS_Horizon_Basics : CS_Parent
    {
        public List<Point> points = new List<Point>();
        int resizeRatio = 1;
        public PointPair vec;
        public bool vecPresent;
        public bool autoDisplay;
        public CS_Horizon_Basics(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Find all the points where depth Y-component transitions from positive to negative";
        }
        public void displayResults(Point2f p1, Point2f p2)
        {
            if (task.heartBeat)
            {
                if (p1.Y >= 1 && p1.Y <= dst2.Height - 1) strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n";
            }
            dst2.SetTo(new cv.Scalar(0));
            foreach (Point pt in points)
            {
                cv.Point pX = new cv.Point(pt.X * resizeRatio, pt.Y * resizeRatio);
                DrawCircle(dst2, pX, task.DotSize, new cv.Scalar(255), -1);
            }
            DrawLine(dst2, vec.p1, vec.p2, new cv.Scalar(255), 255);
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32F) dst0 = PrepareDepthInput(1); else dst0 = src;
            Size resolution = task.quarterRes;
            if (dst0.Size() != resolution)
            {
                dst0 = dst0.Resize(resolution, 0, 0, cv.InterpolationFlags.Linear);
                resizeRatio = dst2.Height / (int)resolution.Height;
            }
            dst0 = dst0.Abs();
            dst1 = dst0.Threshold(0, 255, ThresholdTypes.Binary).ConvertScaleAbs();
            dst0.SetTo(task.MaxZmeters, ~dst1);
            points.Clear();
            for (int i = dst0.Width / 3; i < dst0.Width * 2 / 3; i++)
            {
                mmData mm1 = GetMinMax(dst0.Col(i));
                if (mm1.minVal > 0 && mm1.minVal < 0.005)
                {
                    dst0.Col(i).Set(mm1.minLoc.Y, mm1.minLoc.X, 10);
                    mmData mm2 = GetMinMax(dst0.Col(i));
                    if (mm2.minVal > 0 && Math.Abs(mm1.minLoc.Y - mm2.minLoc.Y) <= 1) points.Add(new cv.Point(i, mm1.minLoc.Y));
                }
            }
            labels[2] = points.Count() + " points found. ";
            cv.Point p1 = new cv.Point(), p2 = new cv.Point();
            if (points.Count() >= 2)
            {
                p1 = new cv.Point(resizeRatio * points[points.Count() - 1].X, resizeRatio * points[points.Count() - 1].Y);
                p2 = new cv.Point(resizeRatio * points[0].X, resizeRatio * points[0].Y);
            }
            double distance = p1.DistanceTo(p2);
            if (distance < 10) // enough to get a line with some credibility
            {
                points.Clear();
                vecPresent = false;
                vec = new PointPair();
                strOut = "Horizon not found \n" + "The distance of p1 to p2 is " + (int)distance + " pixels.";
            }
            else
            {
                PointPair lp = new PointPair(p1, p2);
                vec = lp.edgeToEdgeLine(dst2.Size());
                vecPresent = true;
                if (standaloneTest() || autoDisplay) displayResults(p1, p2);
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_Horizon_BasicsAlt : CS_Parent
    {
        public Mat cloudY;
        public CS_Horizon_BasicsAlt(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Search for the transition from positive to negative to find the horizon.";
        }
        Point2f findTransition(int startCol, int stopCol, int stepCol)
        {
            float val = 0, lastVal = 0;
            List<float> ptX = new List<float>();
            List<float> ptY = new List<float>();
            for (int x = startCol; x <= stopCol; x += stepCol)
            {
                for (int y = 0; y < cloudY.Rows; y++)
                {
                    lastVal = val;
                    val = cloudY.At<float>(y, x);
                    if (val > 0 && lastVal < 0)
                    {
                        // change sub-pixel accuracy here 
                        Point2f pt = new Point2f(x, y + Math.Abs(val) / Math.Abs(val - lastVal));
                        ptX.Add(pt.X);
                        ptY.Add(pt.Y);
                        if (ptX.Count() >= task.frameHistoryCount)
                            return new Point2f(ptX.Average(), ptY.Average());
                    }
                }
            }
            return new Point2f();
        }
        public void RunCS(Mat src)
        {
            if (task.useGravityPointcloud)
            {
                cloudY = task.pcSplit[1]; // already oriented to gravity
            }
            else
            {
                // rebuild the pointcloud so it is oriented to gravity.
                Mat pc = (task.pointCloud.Reshape(1, task.pointCloud.Rows * task.pointCloud.Cols) * task.gMatrix).ToMat().Reshape(3, task.pointCloud.Rows);
                Mat[] split = pc.Split();
                cloudY = split[1];
            }
            Point2f p1 = findTransition(0, cloudY.Width - 1, 1);
            Point2f p2 = findTransition(cloudY.Width - 1, cloudY.Width - 1, -1);
            PointPair lp = new PointPair(p1, p2);
            task.horizonVec = lp.edgeToEdgeLine(dst2.Size());
            if (p1.Y >= 1 && p1.Y <= dst2.Height - 1)
            {
                strOut = "p1 = " + p1.ToString() + "\n" + "p2 = " + p2.ToString() + "\n" + "      val =  " +
                          cloudY.At<float>((int)p1.Y, (int)p1.X).ToString() + "\n" + "lastVal = " + cloudY.At<float>((int)(p1.Y - 1), (int)p1.X).ToString();
            }
            SetTrueText(strOut, 3);
            if (standaloneTest())
            {
                dst2.SetTo(0);
                DrawLine(dst2, task.horizonVec.p1, task.horizonVec.p2, 255, task.lineWidth);
                DrawLine(dst2, task.gravityVec.p1, task.gravityVec.p2, 255, task.lineWidth);
            }
        }
    }

    public class CS_Horizon_FindNonZero : CS_Parent
    {
        public CS_Horizon_FindNonZero(VBtask task) : base(task)
        {
            task.redOptions.setYRangeSlider(3);
            if (standalone) task.gOptions.setDisplay1();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
            task.horizonVec = new PointPair(new Point2f(0, dst2.Height / 2), new Point2f(dst2.Width, dst2.Height / 2));
            labels = new string[] { "", "Horizon vector mask", "Crosshairs - gravityVec (vertical) and horizonVec (horizontal)", "Gravity vector mask" };
            desc = "Create lines for the gravity vector and horizon vector in the camera image";
        }
        public void RunCS(Mat src)
        {
            double xRatio = dst0.Width / task.quarterRes.Width;
            double yRatio = dst0.Height / task.quarterRes.Height;

            var pc = task.pointCloud.Resize(task.quarterRes);
            var split = pc.Split();
            split[2].SetTo(task.MaxZmeters);
            Cv2.Merge(split, pc);

            pc = (pc.Reshape(1, pc.Rows * pc.Cols) * task.gMatrix).ToMat().Reshape(3, pc.Rows);

            dst1 = split[1].InRange(-0.05, 0.05);
            var noDepth = task.noDepthMask.Resize(task.quarterRes);
            dst1.SetTo(0, noDepth);
            cv.Mat pointsMat = dst1.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                dst2.SetTo(new cv.Scalar(0));
                List<int> xVals = new List<int>();
                List<Point2f> points = new List<Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<Point>(i, 0);
                    xVals.Add(pt.X);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[xVals.IndexOf(xVals.Min())];
                Point2f p2 = points[xVals.IndexOf(xVals.Max())];
                PointPair lp = new PointPair(p1, p2);
                task.horizonVec = lp.edgeToEdgeLine(dst2.Size());
                DrawLine(dst2, task.horizonVec.p1, task.horizonVec.p2, new cv.Scalar(255), task.lineWidth);
            }
            dst3 = split[0].InRange(-0.01, 0.01);
            dst3.SetTo(new cv.Scalar(0), noDepth);
            pointsMat = new Mat();
            pointsMat = dst3.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                List<int> yVals = new List<int>();
                List<Point2f> points = new List<Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<Point>(i, 0);
                    yVals.Add(pt.Y);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[yVals.IndexOf(yVals.Min())];
                Point2f p2 = points[yVals.IndexOf(yVals.Max())];
                if (Math.Abs(p1.X - p2.X) < 2)
                {
                    task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
                }
                else
                {
                    PointPair lp = new PointPair(p1, p2);
                    task.gravityVec = lp.edgeToEdgeLine(dst2.Size());
                }
                DrawLine(dst2, task.gravityVec.p1, task.gravityVec.p2, new cv.Scalar(255), task.lineWidth);
            }
        }
    }
    public class CS_Horizon_UnstableResults : CS_Parent
    {
        Line_Basics lines = new Line_Basics();
        public CS_Horizon_UnstableResults(VBtask task) : base(task)
        {
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            desc = "Create lines for the gravity vector and horizon vector in the camera image";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != cv.MatType.CV_32FC3) src = task.pointCloud;
            dst1 = task.pcSplit[1].InRange(-0.05, 0.05);
            dst0.SetTo(new cv.Scalar(0));
            dst0.SetTo(new cv.Scalar(255), dst1);
            dst0.SetTo(new cv.Scalar(0), task.noDepthMask);
            lines.Run(dst0);
            dst2.SetTo(new cv.Scalar(0));
            if (lines.lpList.Count() > 0)
            {
                SortedList<float, PointPair> distances = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
                foreach (PointPair lp in lines.lpList)
                {
                    distances.Add((float)lp.p1.DistanceTo(lp.p2), lp);
                }
                PointPair lpBest = distances.Values[0];
                Point2f p1 = new Point2f(0, lpBest.yIntercept);
                Point2f p2 = new Point2f(dst2.Width, lpBest.slope * dst2.Width + lpBest.yIntercept);
                task.horizonVec = new PointPair(p1, p2);
                DrawLine(dst2, p1, p2, new cv.Scalar(255), 255);
                labels[2] = "horizonVec slope/intercept = " + lpBest.slope.ToString("F4") + "/" + lpBest.yIntercept.ToString("F4");
            }
            dst1 = task.pcSplit[0].InRange(-0.01, 0.01);
            dst0.SetTo(new cv.Scalar(0));
            dst0.SetTo(new cv.Scalar(255), dst1);
            dst0.SetTo(new cv.Scalar(0), task.noDepthMask);
            lines.Run(dst0);
            if (lines.lpList.Count() > 0)
            {
                SortedList<float, PointPair> distances = new SortedList<float, PointPair>(new compareAllowIdenticalSingleInverted());
                foreach (PointPair lp in lines.lpList)
                {
                    distances.Add((float)lp.p1.DistanceTo(lp.p2), lp);
                }
                PointPair lpBest = distances.Values[0];
                Point2f p1 = new Point2f(0, lpBest.yIntercept);
                Point2f p2 = new Point2f(dst2.Width, lpBest.slope * dst2.Width + lpBest.yIntercept);
                task.gravityVec = new PointPair(p1, p2);
                DrawLine(dst2, p1, p2, new cv.Scalar(255), 255);
                labels[3] = "gravityVec slope/intercept = " + lpBest.slope.ToString("F4") + "/" + lpBest.yIntercept.ToString("F4");
            }
        }
    }
    public class CS_Horizon_FindNonZeroOld : CS_Parent
    {
        public CS_Horizon_FindNonZeroOld(VBtask task) : base(task)
        {
            task.gOptions.setGravityUsage(false);
            task.redOptions.setYRangeSlider(3);
            if (standalone) task.gOptions.setDisplay1();
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
            task.horizonVec = new PointPair(new Point2f(0, dst2.Height / 2), new Point2f(dst2.Width, dst2.Height / 2));
            labels = new string[] { "", "Horizon vector mask", "Crosshairs - gravityVec (vertical) and horizonVec (horizontal)", "Gravity vector mask" };
            desc = "Create lines for the gravity vector and horizon vector in the camera image";
        }
        public void RunCS(Mat src)
        {
            double xRatio = dst0.Width / (double)task.quarterRes.Width;
            double yRatio = dst0.Height / (double)task.quarterRes.Height;
            Mat splitX = task.pcSplit[0];
            Mat splitY = task.pcSplit[1];
            Mat noDepth = task.noDepthMask;
            if (splitX.Size() != task.quarterRes)
            {
                splitX = splitX.Resize(task.quarterRes, 0, 0, cv.InterpolationFlags.Linear);
                splitY = splitY.Resize(task.quarterRes, 0, 0, cv.InterpolationFlags.Linear);
                noDepth = noDepth.Resize(task.quarterRes, 0, 0, cv.InterpolationFlags.Linear);
            }
            dst1 = splitY.InRange(-0.05, 0.05);
            dst1.SetTo(new cv.Scalar(0), noDepth);
            Mat pointsMat = new Mat();
            pointsMat = dst1.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                dst2.SetTo(new cv.Scalar(0));
                List<int> xVals = new List<int>();
                List<Point2f> points = new List<Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<Point>(i, 0);
                    xVals.Add(pt.X);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[xVals.IndexOf(xVals.Min())];
                Point2f p2 = points[xVals.IndexOf(xVals.Max())];
                PointPair lp = new PointPair(p1, p2);
                task.horizonVec = lp.edgeToEdgeLine(dst2.Size());
                DrawLine(dst2, task.horizonVec.p1, task.horizonVec.p2, new cv.Scalar(255), 255);
            }
            //If task.horizonVec.originalLength < dst2.Width / 2 And task.redOptions.YRangeSlider.Value < task.redOptions.YRangeSlider.Maximum Or pointsMat.Rows = 0 Then
            //    task.redOptions.YRangeSlider.Value += 1
            //End If
            dst3 = splitX.InRange(-0.01, 0.01);
            dst3.SetTo(new cv.Scalar(0), noDepth);
            pointsMat = new Mat();
            pointsMat = dst3.FindNonZero();
            if (pointsMat.Rows > 0)
            {
                List<int> yVals = new List<int>();
                List<Point2f> points = new List<Point2f>();
                for (int i = 0; i < pointsMat.Rows; i++)
                {
                    cv.Point pt = pointsMat.Get<Point>(i, 0);
                    yVals.Add(pt.Y);
                    points.Add(new Point2f((float)(pt.X * xRatio), (float)(pt.Y * yRatio)));
                }
                Point2f p1 = points[yVals.IndexOf(yVals.Min())];
                Point2f p2 = points[yVals.IndexOf(yVals.Max())];
                if (Math.Abs(p1.X - p2.X) < 2)
                {
                    task.gravityVec = new PointPair(new Point2f(dst2.Width / 2, 0), new Point2f(dst2.Width / 2, dst2.Height));
                }
                else
                {
                    PointPair lp = new PointPair(p1, p2);
                    task.gravityVec = lp.edgeToEdgeLine(dst2.Size());
                }
                DrawLine(dst2, task.gravityVec.p1, task.gravityVec.p2, new cv.Scalar(255), 255);
            }
            //If task.gravityVec.originalLength < dst2.Height / 2 And task.redOptions.XRangeSlider.Value < task.redOptions.XRangeSlider.Maximum Or pointsMat.Rows = 0 Then
            //    task.redOptions.XRangeSlider.Value += 1
            //End If
        }
    }
    public class CS_Horizon_Validate : CS_Parent
    {
        Match_Basics match = new Match_Basics();
        Point2f ptLeft, ptRight;
        Mat leftTemplate, rightTemplate;
        public CS_Horizon_Validate(VBtask task) : base(task)
        {
            desc = "Validate the horizon points using Match_Basics";
        }
        public void RunCS(Mat src)
        {
            int templatePad = match.options.templatePad;
            int templateSize = match.options.templateSize;
            src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (task.heartBeat)
            {
                ptLeft = task.gravityVec.p1;
                ptRight = task.gravityVec.p2;
                Rect r = ValidateRect(new Rect((int)(ptLeft.X - templatePad), (int)(ptLeft.Y - templatePad), templateSize, templateSize));
                leftTemplate = new Mat(src, r);
                r = ValidateRect(new Rect((int)(ptRight.X - templatePad), (int)(ptRight.Y - templatePad), templateSize, templateSize));
                rightTemplate = new Mat(src, r);
            }
            else
            {
                Rect r = ValidateRect(new Rect((int)(ptLeft.X - templatePad), (int)(ptLeft.Y - templatePad), templateSize, templateSize));
                match.template = leftTemplate;
                match.Run(src);
                ptLeft = match.matchCenter;
                r = ValidateRect(new Rect((int)(ptRight.X - templatePad), (int)(ptRight.Y - templatePad), templateSize, templateSize));
                match.template = leftTemplate;
                match.Run(src);
                ptLeft = match.matchCenter;
            }
        }
    }
    public class CS_Horizon_Regress : CS_Parent
    {
        Horizon_Basics horizon = new Horizon_Basics();
        LinearRegression_Basics regress = new LinearRegression_Basics();
        public CS_Horizon_Regress(VBtask task) : base(task)
        {
            desc = "Collect the horizon points and run a linear regression on all the points.";
        }
        public void RunCS(Mat src)
        {
            horizon.Run(src);
            foreach (Point point in horizon.points)
            {
                regress.x.Add(point.X);
                regress.y.Add(point.Y);
            }
            regress.Run(null);
            horizon.displayResults(regress.p1, regress.p2);
            dst2 = horizon.dst2;
        }
    }
    public class CS_Horizon_ExternalTest : CS_Parent
    {
        Horizon_Basics horizon = new Horizon_Basics();
        public CS_Horizon_ExternalTest(VBtask task) : base(task)
        {
            desc = "Supply the point cloud input to Horizon_Basics";
        }
        public void RunCS(Mat src)
        {
            dst0 = PrepareDepthInput(1);
            horizon.Run(dst0);
            dst2 = horizon.dst2;
        }
    }
    public class CS_Hough_Basics : CS_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        public LineSegmentPolar[] segments;
        public Options_Hough options = new Options_Hough();
        public CS_Hough_Basics(VBtask task) : base(task)
        {
            desc = "Use Houghlines to find lines in the image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            edges.Run(src);
            segments = Cv2.HoughLines(edges.dst2, options.rho, options.theta, options.threshold);
            labels[2] = "Found " + segments.Length + " Lines";
            if (standaloneTest())
            {
                src.CopyTo(dst2);
                dst2.SetTo(Scalar.White, edges.dst2);
                src.CopyTo(dst3);
                base.HoughShowLines(ref dst2, segments, options.lineCount);
                var probSegments = Cv2.HoughLinesP(edges.dst2, options.rho, options.theta, options.threshold);
                for (int i = 0; i < Math.Min(probSegments.Length, options.lineCount); i++)
                {
                    var line = probSegments[i];
                    dst3.Line(line.P1, line.P2, Scalar.Red, task.lineWidth + 2, task.lineType);
                }
                labels[3] = "Probablistic lines = " + probSegments.Length;
            }
        }
    }
    public class CS_Hough_Circles : CS_Parent
    {
        Draw_Circles circles = new Draw_Circles();
        int method = 3;
        public CS_Hough_Circles(VBtask task) : base(task)
        {
            FindSlider("DrawCount").Value = 3;
            labels[2] = "Input circles to Hough";
            labels[3] = "Hough Circles found";
            desc = "Find circles using HoughCircles.";
        }
        public void RunCS(Mat src)
        {
            circles.Run(src);
            dst2 = circles.dst2;
            Cv2.CvtColor(dst2, dst3, ColorConversionCodes.BGR2GRAY);
            var cFound = Cv2.HoughCircles(dst3, (cv.HoughModes) method, 1, dst2.Rows / 4, 100, 10, 1, 200);
            var foundColor = new Scalar(0, 0, 255);
            dst2.CopyTo(dst3);
            for (int i = 0; i < cFound.Length; i++)
            {
                cv.Point pt = new cv.Point((int)cFound[i].Center.X, (int)cFound[i].Center.Y);
                DrawCircle(dst3, pt, (int)cFound[i].Radius, foundColor, (int)task.lineType);
            }
            labels[3] = cFound.Length + " circles were identified";
        }
    }
    public class CS_Hough_Lines_MT : CS_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        Options_Hough options = new Options_Hough();
        public CS_Hough_Lines_MT(VBtask task) : base(task)
        {
            labels[2] = "Output of the Canny Edge algorithm (no Hough lines)";
            labels[3] = "Hough Lines for each threaded cell or if no lines, the featureless cell depth data.";
            desc = "Multithread Houghlines to find lines in image fragments.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            edges.Run(src);
            dst2 = edges.dst2;
            var depth8uC3 = task.depthRGB;
            Parallel.ForEach(task.gridList, roi =>
            {
                var segments = Cv2.HoughLines(dst2[roi], options.rho, options.theta, options.threshold);
                if (segments.Length == 0)
                {
                    dst3[roi] = depth8uC3[roi];
                    return;
                }
                dst3[roi].SetTo(0);
                Mat tmp = dst3[roi];
                HoughShowLines(ref tmp, segments, 1);
            });
            dst2.SetTo(Scalar.White, task.gridMask);
        }
    }
    public class CS_Hough_Featureless : CS_Parent
    {
        public Edge_Canny edges = new Edge_Canny();
        public int[] noDepthCount;
        public Options_Hough options = new Options_Hough();
        public Vec3b[] roiColor;
        public CS_Hough_Featureless(VBtask task) : base(task)
        {
            task.gOptions.setGridSize(10);
            labels[2] = "Featureless mask";
            desc = "Multithread Houghlines to find featureless regions in an image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            edges.Run(src);
            dst2 = new Mat(dst2.Size(), MatType.CV_8U, 0);
            int regionCount = 0;
            noDepthCount = new int[task.gridList.Count()];
            roiColor = new Vec3b[task.gridList.Count()];
            foreach (var roi in task.gridList)
            {
                var segments = Cv2.HoughLines(edges.dst2[roi], options.rho, options.theta, options.threshold);
                if (edges.dst2[roi].CountNonZero() == 0)
            {
                    regionCount++;
                    dst2[roi].SetTo(255);
                }
            }
            dst3.SetTo(0);
            src.CopyTo(dst3, dst2);
            labels[2] = "FeatureLess Regions = " + regionCount;
            labels[3] = "Of the " + task.gridList.Count() + " grid elements, " + regionCount + " had no edge or hough features present";
        }
    }
    public class CS_Hough_FeatureLessTopX : CS_Parent
    {
        public Edge_Canny edges = new Edge_Canny();
        public Options_Hough options = new Options_Hough();
        public Mat maskFless;
        public Mat maskFeat;
        public Mat maskPredict;
        public CS_Hough_FeatureLessTopX(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.gOptions.setGridSize(10);
            maskFless = new Mat(dst2.Size(), MatType.CV_8U);
            maskFeat = new Mat(dst2.Size(), MatType.CV_8U);
            maskPredict = new Mat(dst2.Size(), MatType.CV_8U);
            labels = new string[] { "", "", "Areas without features", "Areas with features" };
            desc = "Multithread Houghlines to find featureless regions in an image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            var segSlider = FindSlider("Minimum feature pixels");
            int minSegments = segSlider.Value;
            edges.Run(src);
            src.CopyTo(dst2);
            maskFless.SetTo(0);
            maskFeat.SetTo(0);
            Parallel.ForEach(task.gridList, roi =>
            {
            var segments = Cv2.HoughLines(edges.dst2[roi], options.rho, options.theta, options.threshold);
            if (segments.Length == 0) maskFless[roi].SetTo(255);
            if (edges.dst2[roi].CountNonZero() >= minSegments) maskFeat[roi].SetTo(255);
        });
        maskPredict.SetTo(255);
        maskPredict.SetTo(0, maskFless);
        maskPredict.SetTo(0, maskFeat);
        dst1.SetTo(0);
        src.CopyTo(dst1, maskPredict);
        int pCount = maskPredict.CountNonZero();
        labels[1] = string.Format("{0:0%} are inbetween feature and featureless", (double) pCount / dst1.Total());
        dst2.SetTo(0);
        src.CopyTo(dst2, maskFless);
        dst3.SetTo(0);
        src.CopyTo(dst3, maskFeat);
        }
    }
    public class CS_Hough_LaneFinder : CS_Parent
    {
        LaneFinder_HLSColor hls = new LaneFinder_HLSColor();
        public LineSegmentPoint[] segments;
        public Mat mask;
        public int laneLineMinY;
        public CS_Hough_LaneFinder(VBtask task) : base(task)
        {
            labels = new string[] { "Original video image", "Mask to isolate lane regions", "Combined yellow and white masks", "HoughLines output" };
            desc = "Use Hough to isolate features in the mask of the road.";
        }
        public void RunCS(Mat src)
        {
            hls.Run(empty);
            if (task.optionsChanged)
            {
                int w = hls.input.video.dst2.Width;
                int h = hls.input.video.dst2.Height;
                var bl = new cv.Point(w * 0.1, h * 0.95);
                var tl = new cv.Point(w * 0.4, h * 0.6);
                var br = new cv.Point(w * 0.95, h * 0.95);
                var tr = new cv.Point(w * 0.6, h * 0.6);
                var pList = new Point[] { bl, tl, tr, br };
                mask = new Mat(new cv.Size(w, h), MatType.CV_8U, 0);
                mask.FillConvexPoly(pList, Scalar.White, task.lineType);
            }
            dst1 = mask.Clone();
            dst0 = hls.dst0;
            dst2 = new Mat(mask.Size(), MatType.CV_8U, 0);
            hls.dst3.CopyTo(dst2, mask);
            int rho = 1;
            double theta = Cv2.PI / 180;
            int threshold = 20;
            int minLineLength = 20;
            int maxLineGap = 300;
            segments = Cv2.HoughLinesP(dst2.Clone(), rho, theta, threshold, minLineLength, maxLineGap);
            dst3 = new Mat(mask.Size(), MatType.CV_8UC3, 0);
            laneLineMinY = dst2.Height;
            for (int i = 0; i < segments.Length; i++)
            {
                if (laneLineMinY > segments[i].P1.Y) laneLineMinY = segments[i].P1.Y;
                if (laneLineMinY > segments[i].P2.Y) laneLineMinY = segments[i].P2.Y;
                DrawLine(dst3, segments[i].P1, segments[i].P2, task.HighlightColor, task.lineWidth);
            }
        }
    }
    public class CS_Hough_Sudoku : CS_Parent
    {
        Hough_Basics hough = new Hough_Basics();
        public CS_Hough_Sudoku(VBtask task) : base(task)
        {
            desc = "Successful use of Hough to find lines in Sudoku grid.";
        }
        public void RunCS(Mat src)
        {
            dst2 = Cv2.ImRead(task.HomeDir + "opencv/Samples/Data/sudoku.png").Resize(dst2.Size());
            dst3 = dst2.Clone();
            hough.Run(dst2);
            HoughShowLines(ref dst3, hough.segments, hough.options.lineCount);
        }
    }
    public class CS_Hull_Basics : CS_Parent
    {
        Random_Basics random = new Random_Basics();
        public List<Point2f> inputPoints = new List<Point2f>();
        public List<Point> hull = new List<Point>();
        public bool useRandomPoints;
        public CS_Hull_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Input Points - draw a rectangle anywhere.  Enclosing rectangle in yellow.", "" };
            if (standaloneTest()) random.range = new Rect(100, 100, 50, 50);
            desc = "Given a list of points, create a hull that encloses them.";
        }
        List<Point> vbFloat2Int(List<Point2f> ptList2f)
        {
            List<Point> ptList = new List<Point>();
            foreach (var pt in ptList2f)
            {
                ptList.Add(new cv.Point((int)pt.X, (int)pt.Y));
            }
            return ptList;
        }
        public void RunCS(Mat src)
        {
            if ((standaloneTest() && task.heartBeat) || (useRandomPoints && task.heartBeat))
            {
                random.Run(empty);
                dst2.SetTo(0);
                foreach (var pt in random.PointList)
                {
                    DrawCircle(dst2, pt, task.DotSize, Scalar.White);
                }
                inputPoints = new List<Point2f>(random.PointList);
            }
            var hull2f = Cv2.ConvexHull(inputPoints, true);
            hull = vbFloat2Int(hull2f.ToList());
            DrawContour(dst2, hull, Scalar.Yellow);
        }
    }
    public class CS_Hull_Contour : CS_Parent
    {
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_Hull_Contour(VBtask task) : base(task)
        {
            desc = "Compare the hull to the contour of a RedCloud cell";
        }
        public void RunCS(Mat src)
        {
            redC.Run(src);
            dst2 = redC.dst2;
            labels[2] = redC.labels[2];
            dst3.SetTo(0);
            var rc = task.rc;
            List<Point> jumpList = new List<Point>();
            for (int i = 1; i < rc.contour.Count(); i++)
            {
                var p1 = rc.contour[i - 1];
                var p2 = rc.contour[i];
                if (p1.DistanceTo(p2) > 1)
                {
                    if (!jumpList.Contains(p2)) jumpList.Add(p2);
                }
            }
            rc.hull = Cv2.ConvexHull(rc.contour.ToArray(), true).ToList();
            DrawContour(dst3, rc.contour, Scalar.LightBlue, task.lineWidth);
            if (rc.hull.Count() > 0) rc.hull.RemoveAt(rc.hull.Count() - 1);
            DrawContour(dst3, rc.hull, Scalar.White, task.lineWidth);
        }
    }
    public class CS_Image_Basics : CS_Parent
    {
        public string inputFileName;
        public Options_Images options = new Options_Images();
        public CS_Image_Basics(VBtask task) : base(task)
        {
            desc = "Load an image into OpenCVB";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            src = options.fullsizeImage;
            if (src.Width != dst2.Width || src.Height != dst2.Height)
            {
                var newSize = new cv.Size(dst2.Height * src.Width / src.Height, dst2.Height);
                if (newSize.Width > dst2.Width)
                {
                    newSize = new cv.Size(dst2.Width, dst2.Width * src.Height / src.Width);
                }
                dst2.SetTo(0);
                dst2[new Rect(0, 0, newSize.Width, newSize.Height)] = src.Resize(newSize);
            }
            else
            {
                dst2 = src;
            }
        }
    }
    public class CS_Image_Series : CS_Parent
    {
        public Image_Basics images = new Image_Basics();
        public CS_Image_Series(VBtask task) : base(task)
        {
            images.options.imageSeries = true;
            desc = "Display a new image from the directory every heartbeat";
        }
        public void RunCS(Mat src)
        {
            // to work on a specific file, specify it here.
            // options.fileInputName = new FileInfo(task.HomeDir + "Images/train/103041.jpg");
            images.Run(images.options.fullsizeImage);
            dst2 = images.dst2;
        }
    }
    public class CS_Image_RedCloudColor : CS_Parent
    {
        public Image_Series images = new Image_Series();
        public RedCloud_Cells redC = new RedCloud_Cells();
        public CS_Image_RedCloudColor(VBtask task) : base(task)
        {
            task.gOptions.setDisplay1();
            desc = "Use RedCloud on a photo instead of the video stream.";
        }
        public void RunCS(Mat src)
        {
            images.Run(empty);
            dst0 = images.dst2.Clone();
            dst1 = images.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            redC.Run(dst0);
            dst2 = redC.dst2;
            var mask = task.cellMap.InRange(0, 0);
            dst2.SetTo(Scalar.Black, mask);
            labels[2] = redC.labels[2];
        }
    }
    public class CS_Image_CellStats : CS_Parent
    {
        Image_RedCloudColor images = new Image_RedCloudColor();
        Cell_Basics stats = new Cell_Basics();
        public CS_Image_CellStats(VBtask task) : base(task)
        {
            images.images.images.options.imageSeries = false;
            if (standaloneTest()) task.gOptions.setDisplay0();
            if (standaloneTest()) task.gOptions.setDisplay1();
            task.redOptions.setUseColorOnly(true);
            desc = "Display the statistics for the selected cell";
        }
        public void RunCS(Mat src)
        {
            task.pointCloud.SetTo(0);
            task.pcSplit = task.pointCloud.Split();
            images.Run(empty);
            dst0 = images.dst0;
            dst1 = images.dst1;
            dst2 = images.dst2;
            stats.statsString();
            SetTrueText(stats.strOut, 3);
        }
    }
    public class CS_Image_MSER : CS_Parent
    {
        public Image_Series images = new Image_Series();
        MSER_Detect core = new MSER_Detect();
        Options_Images options = new Options_Images();
        public CS_Image_MSER(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            FindSlider("MSER Min Area").Value = 15;
            FindSlider("MSER Max Area").Value = 200000;
            desc = "Find the MSER (Maximally Stable Extermal Regions) in the still image.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            images.Run(options.fullsizeImage);
            dst1 = images.dst2;
            core.Run(dst1);
            dst2 = core.dst2;
        }
    }
    public class CS_ImShow_Basics : CS_Parent
    {
        public CS_ImShow_Basics(VBtask task) : base(task)
        {
            desc = "This is just a reminder that all HighGUI methods are available in OpenCVB";
        }
        public void RunCS(Mat src)
        {
            Cv2.ImShow("color", src);
        }
    }
    public class CS_ImShow_WaitKey : CS_Parent
    {
        Feature_Basics feat = new Feature_Basics();
        public CS_ImShow_WaitKey(VBtask task) : base(task)
        {
            desc = "You can use the HighGUI WaitKey call to pause an algorithm and review output one frame at a time.";
        }
        public void RunCS(Mat src)
        {
            feat.Run(src);
            Cv2.ImShow("Hit space bar to advance to the next frame", feat.dst2);
            Cv2.WaitKey(1000); // No need for waitkey with imshow in OpenCVB - finishing a buffer is the same thing so waitkey just delays by 1 second here.
            dst2 = feat.dst2;
        }
    }
    public class CS_ImShow_CV32FC3 : CS_Parent
    {
        public CS_ImShow_CV32FC3(VBtask task) : base(task)
        {
            desc = "Experimenting with how to show an 32fc3 Mat file.";
        }
        public void RunCS(Mat src)
        {
            Cv2.ImShow("Point cloud", task.pointCloud);
            dst2 = task.pointCloud.Clone();
        }
    }
    public class CS_IMU_Basics : CS_Parent
    {
        double lastTimeStamp;
        public CS_IMU_Basics(VBtask task) : base(task)
        {
            desc = "Read and display the IMU coordinates";
        }
        public void RunCS(Mat src)
        {
            Point3f gyroAngle;
            if (task.optionsChanged)
            {
                lastTimeStamp = task.IMU_TimeStamp;
            }
            else
            {
                gyroAngle = task.IMU_AngularVelocity;
                double dt_gyro = (task.IMU_TimeStamp - lastTimeStamp) / 1000;
                if (task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i") dt_gyro /= 1000; // different units in the timestamp?
                gyroAngle = gyroAngle * dt_gyro;
                task.theta += new Point3f(-gyroAngle.Z, -gyroAngle.Y, gyroAngle.X);
                lastTimeStamp = task.IMU_TimeStamp;
            }
            // NOTE: Initialize the angle around the y-axis to zero.
            cv.Point3f g = task.IMU_RawAcceleration;
            task.accRadians = new Point3f((float)Math.Atan2(g.X, Math.Sqrt(g.Y * g.Y + g.Z * g.Z)),
                                         (float)Math.Abs(Math.Atan2(g.X, g.Y)), (float)Math.Atan2(g.Y, g.Z));
            if (task.optionsChanged)
            {
                task.theta = task.accRadians;
            }
            else
            {
                // Apply the Complementary Filter:
                //  - high-pass filter = theta * alpha: allows short-duration signals to pass while filtering steady signals (trying to cancel drift)
                //  - low-pass filter = accel * (1 - alpha): lets the long-term changes through, filtering out short term fluctuations
                task.theta.X = task.theta.X * task.IMU_AlphaFilter + task.accRadians.X * (1 - task.IMU_AlphaFilter);
                task.theta.Y = task.accRadians.Y;
                task.theta.Z = task.theta.Z * task.IMU_AlphaFilter + task.accRadians.Z * (1 - task.IMU_AlphaFilter);
            }
            double x1 = -(90 + task.accRadians.X * 57.2958);
            double x2 = -(90 + task.theta.X * 57.2958);
            double y1 = task.accRadians.Y - Math.PI;
            if (task.accRadians.X < 0) y1 *= -1;
            strOut = "Angles in degree to gravity (before velocity filter)" + "\n" +
                     x1.ToString(fmt1) + "\t" + (y1 * 57.2958).ToString(fmt1) + "\t" + (task.accRadians.Z * 57.2958).ToString(fmt1) + 
                     x1.ToString(fmt1) + "\t" + (y1 * 57.2958).ToString(fmt1) + "\t" + (task.accRadians.Z * 57.2958).ToString(fmt1) + "\n" +
                     "Velocity-Filtered Angles to gravity in degrees" + "\n" +
                     x2.ToString(fmt1) + "\t" + (y1 * 57.2958).ToString(fmt1) + "\t" + (task.theta.Z * 57.2958).ToString(fmt1) + "\n";
            strOut += "cx = " + task.gMat.cx.ToString(fmt3) + " sx = " + task.gMat.sx.ToString(fmt3) + "\n" +
                      "cy = " + task.gMat.cy.ToString(fmt3) + " sy = " + task.gMat.sy.ToString(fmt3) + "\n" +
                      "cz = " + task.gMat.cz.ToString(fmt3) + " sz = " + task.gMat.sz.ToString(fmt3);
            task.accRadians = task.theta;
            if (task.accRadians.Y > Math.PI / 2) task.accRadians.Y -= (float)Math.PI / 2;
            task.accRadians.Z += (float)Math.PI / 2;
            SetTrueText(strOut);
        }
    }
    public class CS_IMU_BasicsKalman : CS_Parent
    {
        double lastTimeStamp;
        Kalman_Basics kalman = new Kalman_Basics();
        public CS_IMU_BasicsKalman(VBtask task) : base(task)
        {
            desc = "Read and display the IMU coordinates";
        }
        public void RunCS(Mat src)
        {
            Point3f gyroAngle;
            if (task.optionsChanged)
            {
                lastTimeStamp = task.IMU_TimeStamp;
            }
            else
            {
                gyroAngle = task.IMU_AngularVelocity;
                double dt_gyro = (task.IMU_TimeStamp - lastTimeStamp) / 1000;
                if (task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i") dt_gyro /= 1000; // different units in the timestamp?
                gyroAngle = gyroAngle * dt_gyro;
                lastTimeStamp = task.IMU_TimeStamp;
            }
            // NOTE: Initialize the angle around the y-axis to zero.
            cv.Point3f g = task.IMU_RawAcceleration;
            task.accRadians = new Point3f((float)Math.Atan2(g.X, Math.Sqrt(g.Y * g.Y + g.Z * g.Z)),
                                         (float)Math.Abs(Math.Atan2(g.X, g.Y)), (float)Math.Atan2(g.Y, g.Z));
            kalman.kInput = new float[] { task.accRadians.X, task.accRadians.Y, task.accRadians.Z };
            kalman.Run(null);
            task.accRadians = new Point3f(kalman.kOutput[0], kalman.kOutput[1], kalman.kOutput[2]);
            double x1 = -(90 + task.accRadians.X * 57.2958);
            double y1 = task.accRadians.Y - Math.PI;
            if (task.accRadians.X < 0) y1 *= -1;
            strOut = "Angles in degree to gravity (before velocity filter)" + "\n" +
                     x1.ToString(fmt1) + "\t" + (y1 * 57.2958).ToString(fmt1) + "\t" + (task.accRadians.Z * 57.2958).ToString(fmt1) + "\n";
            strOut += "cx = " + task.gMat.cx.ToString(fmt3) + " sx = " + task.gMat.sx.ToString(fmt3) + "\n" +
                      "cy = " + task.gMat.cy.ToString(fmt3) + " sy = " + task.gMat.sy.ToString(fmt3) + "\n" +
                      "cz = " + task.gMat.cz.ToString(fmt3) + " sz = " + task.gMat.sz.ToString(fmt3);
            if (task.accRadians.Y > Math.PI / 2) task.accRadians.Y -= (float)Math.PI / 2;
            task.accRadians.Z += (float)Math.PI / 2;
            SetTrueText(strOut);
        }
    }
    public class CS_IMU_BasicsWithOptions : CS_Parent
    {
        double lastTimeStamp;
        Options_IMU options = new Options_IMU();
        public CS_IMU_BasicsWithOptions(VBtask task) : base(task)
        {
            desc = "Read and display the IMU coordinates";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            Point3f gyroAngle;
            if (task.optionsChanged)
            {
                lastTimeStamp = task.IMU_TimeStamp;
            }
            else
            {
                gyroAngle = task.IMU_AngularVelocity;
                double dt_gyro = (task.IMU_TimeStamp - lastTimeStamp) / 1000;
                if (task.cameraName != "Intel(R) RealSense(TM) Depth Camera 435i") dt_gyro /= 1000; // different units in the timestamp?
                gyroAngle = gyroAngle * dt_gyro;
                task.theta += new Point3f(-gyroAngle.Z, -gyroAngle.Y, gyroAngle.X);
                lastTimeStamp = task.IMU_TimeStamp;
            }
            // NOTE: Initialize the angle around the y-axis to zero.
            cv.Point3f g = task.IMU_RawAcceleration;
            task.accRadians = new Point3f((float)Math.Atan2(g.X, Math.Sqrt(g.Y * g.Y + g.Z * g.Z)),
                                          (float)Math.Abs(Math.Atan2(g.X, g.Y)), (float)Math.Atan2(g.Y, g.Z));
            if (task.optionsChanged)
            {
                task.theta = task.accRadians;
            }
            else
            {
                // Apply the Complementary Filter:
                //  - high-pass filter = theta * alpha: allows short-duration signals to pass while filtering steady signals (trying to cancel drift)
                //  - low-pass filter = accel * (1 - alpha): lets the long-term changes through, filtering out short term fluctuations
                task.theta.X = task.theta.X * task.IMU_AlphaFilter + task.accRadians.X * (1 - task.IMU_AlphaFilter);
                task.theta.Y = task.accRadians.Y;
                task.theta.Z = task.theta.Z * task.IMU_AlphaFilter + task.accRadians.Z * (1 - task.IMU_AlphaFilter);
            }
            double x1 = -(90 + task.accRadians.X * 57.2958);
            double x2 = -(90 + task.theta.X * 57.2958);
            double y1 = task.accRadians.Y - Math.PI;
            if (task.accRadians.X < 0) y1 *= -1;
            strOut = "Angles in degree to gravity (before velocity filter)" + "\n" +
                     x1.ToString(fmt1) + "\t" + (y1 * 57.2958).ToString(fmt1) + "\t" + (task.accRadians.Z * 57.2958).ToString(fmt1) + "\n" +
                     "Velocity-Filtered Angles to gravity in degrees" + "\n" +
                     x2.ToString(fmt1) + "\t" + (y1 * 57.2958).ToString(fmt1) + "\t" + (task.theta.Z * 57.2958).ToString(fmt1) + "\n";
            SetTrueText(strOut);
            task.accRadians = task.theta;
            if (task.accRadians.Y > Math.PI / 2) task.accRadians.Y -= (float)Math.PI / 2;
            task.accRadians.Z += (float)Math.PI / 2;
            SetTrueText(strOut);
        }
    }
    public class CS_IMU_GMatrix : CS_Parent
    {
        public float cx = 1, sx = 0, cy = 1, sy = 0, cz = 1, sz = 0;
        public Mat gMatrix;
        public CS_IMU_GMatrix(VBtask task) : base(task)
        {
            desc = "Find the angle of tilt for the camera with respect to gravity.";
        }
        void buildGmatrix()
        {
            //[cx -sx    0]  [1  0   0 ] 
            //[sx  cx    0]  [0  cz -sz]
            //[0   0     1]  [0  sz  cz]
            float[,] gArray = {{cx * 1 + -sx * 0 + 0 * 0, cx * 0 + -sx * cz + 0 * sz, cx * 0 + -sx * -sz + 0 * cz},
                           {sx * 1 + cx * 0 + 0 * 0, sx * 0 + cx * cz + 0 * sz, sx * 0 + cx * -sz + 0 * cz},
                           {0 * 1 + 0 * 0 + 1 * 0, 0 * 0 + 0 * cz + 1 * sz, 0 * 0 + 0 * -sz + 1 * cz}};
            float g1 = gArray[0, 0] * cy + gArray[0, 1] * 0 + gArray[0, 2] * sy;
            float g2 = gArray[0, 0] * 0 + gArray[0, 1] * 1 + gArray[0, 2] * 0;
            float g3 = gArray[0, 0] * -sy + gArray[0, 1] * 0 + gArray[0, 2] * cy;
            float g4 = gArray[1, 0] * cy + gArray[1, 1] * 0 + gArray[1, 2] * sy;
            float g5 = gArray[1, 0] * 0 + gArray[1, 1] * 1 + gArray[1, 2] * 0;
            float g6 = gArray[1, 0] * -sy + gArray[1, 1] * 0 + gArray[1, 2] * cy;
            float g7 = gArray[2, 0] * cy + gArray[2, 1] * 0 + gArray[2, 2] * sy;
            float g8 = gArray[2, 0] * 0 + gArray[2, 1] * 1 + gArray[2, 2] * 0;
            float g9 = gArray[2, 0] * -sy + gArray[2, 1] * 0 + gArray[2, 2] * cy;
            float[] tmp = new float[] { g1, g2, g3, g4, g5, g6, g7, g8, g9 };
            gMatrix = new Mat(3, 3, MatType.CV_32F, tmp);
        }
        public void RunCS(Mat src)
        {
            //[cos(a) -sin(a)    0]
            //[sin(a)  cos(a)    0]
            //[0       0         1] rotate the point cloud around the x-axis.
            cz = (float)Math.Cos(task.accRadians.Z);
            sz = (float)Math.Sin(task.accRadians.Z);
            //[1       0         0      ] rotate the point cloud around the z-axis.
            //[0       cos(a)    -sin(a)]
            //[0       sin(a)    cos(a) ]
            cx = (float)Math.Cos(task.accRadians.X);
            sx = (float)Math.Sin(task.accRadians.X);
            buildGmatrix();
            cv.Point3f g = task.IMU_Acceleration;
            string fmt = fmt3;
            strOut = "IMU Acceleration in X-direction = " + "\t" + g.X.ToString(fmt) + "\n"
                     + "IMU Acceleration in Y-direction = " + "\t" + g.Y.ToString(fmt) + "\n"
                     + "IMU Acceleration in Z-direction = " + "\t" + g.Z.ToString(fmt) + "\n" + "\n"
                     + "\n" + "sqrt (" + "\t" + g.X.ToString(fmt) + "*" + g.X.ToString(fmt) + "\t" +
                     g.Y.ToString(fmt) + "*" + g.Y.ToString(fmt) + "\t" +
                     g.Z.ToString( fmt) + "*" + g.Z.ToString( fmt) + " ) = " + "\t" +
                     (Math.Sqrt(g.X * g.X + g.Y * g.Y + g.Z * g.Z)).ToString(fmt) + "\n" +
                     "Should be close to the earth's gravitational constant of 9.807 (or the camera was moving.)";
            strOut += "\n" + "Gravity-oriented gMatrix - move camera to test this:" + "\n" + gMatrixToStr(gMatrix);
            SetTrueText(strOut);
            task.gMatrix = gMatrix;
        }
    }
    public class CS_IMU_Stabilize : CS_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        public CS_IMU_Stabilize(VBtask task) : base(task)
        {
            kalman.kInput = new float[3];
            desc = "Stabilize IMU acceleration data.";
            labels = new string[] { "", "", "IMU Stabilize (move camera around)", "Difference from Color Image" };
        }
        public void RunCS(Mat src)
        {
            int borderCrop = 5;
            int vert_Border = borderCrop * src.Rows / src.Cols;
            double dx = task.IMU_AngularVelocity.X;
            double dy = task.IMU_AngularVelocity.Y;
            double dz = task.IMU_AngularVelocity.Z;
            double sx = 1; // assume no scaling is taking place.
            double sy = 1; // assume no scaling is taking place.
            kalman.kInput = new float[] { (float)dx, (float)dy, (float)dz };
            kalman.Run(src);
            dx = kalman.kOutput[0];
            dy = kalman.kOutput[1];
            dz = kalman.kOutput[2];
            Mat smoothedMat = new Mat(2, 3, MatType.CV_64F, new double[] {
            sx * Math.Cos(dz), sx * -Math.Sin(dz), dx,
            sy * Math.Sin(dz), sy * Math.Cos(dz), dy });
            Mat smoothedFrame = src.WarpAffine(smoothedMat, src.Size());
            smoothedFrame = smoothedFrame.RowRange(borderCrop, smoothedFrame.Rows - borderCrop).ColRange(borderCrop, smoothedFrame.Cols - borderCrop);
            dst2 = smoothedFrame.Resize(src.Size());
            Cv2.Subtract(src, dst2, dst3);
            string Text = "dx = " + dx.ToString(fmt2) + "\n" + "dy = " + dy.ToString(fmt2) + "\n" + "dz = " + dz.ToString(fmt2);
            SetTrueText(Text, new cv.Point(10, 10), 3);
        }
    }
    public class CS_IMU_PlotIMUFrameTime : CS_Parent
    {
        Plot_OverTime plot = new Plot_OverTime();
        public double CPUInterval;
        public double IMUtoCaptureEstimate;
        Options_IMUFrameTime options = new Options_IMUFrameTime();
        double imuTotalTime;
        int allZeroCount;
        public CS_IMU_PlotIMUFrameTime(VBtask task) : base(task)
        {
            plot.dst2 = dst3;
            plot.maxScale = 40;
            plot.minScale = -10;
            plot.plotCount = 4;
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Use the IMU timestamp to estimate the delay from IMU capture to image capture.  Just an estimate!";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            int IMUanchor = (int)task.IMU_FrameTime;
            int[] histogramIMU = new int[plot.maxScale];
            // there can be some errant times at startup.
            if (task.IMU_FrameTime >= histogramIMU.Length) task.IMU_FrameTime = plot.maxScale;
            if (task.IMU_FrameTime < 0) task.IMU_FrameTime = 0;
            imuTotalTime += task.IMU_FrameTime;
            if (imuTotalTime == 0)
            {
                allZeroCount++;
                if (allZeroCount > 20)
                {
                    SetTrueText("Is IMU present?  No IMU FrameTimes");
                    allZeroCount = int.MinValue; // don't show message again.
                }
                return; // if the IMU frametime was 0, then no new IMU data was generated (or it is unsupported!)
            }
            int maxval = int.MinValue;
            for (int i = 0; i < histogramIMU.Length; i++)
            {
                if (maxval < histogramIMU[i])
                {
                    maxval = histogramIMU[i];
                    IMUanchor = i;
                }
            }
            int imuFrameTime = (int)task.IMU_FrameTime;
            if (IMUanchor != 0) imuFrameTime = imuFrameTime % IMUanchor;
            IMUtoCaptureEstimate = IMUanchor - imuFrameTime + options.minDelayIMU;
            if (IMUtoCaptureEstimate > IMUanchor) IMUtoCaptureEstimate -= IMUanchor;
            if (IMUtoCaptureEstimate < options.minDelayIMU) IMUtoCaptureEstimate = options.minDelayIMU;
            double sampledIMUFrameTime = task.IMU_FrameTime;
            if (task.heartBeat) sampledIMUFrameTime = task.IMU_FrameTime;
            histogramIMU[Math.Min((int)task.IMU_FrameTime, histogramIMU.Length - 1)]++;
            if (standaloneTest())
            {
                string output = "IMU_TimeStamp (ms) " + task.IMU_TimeStamp.ToString("00") + "\n" +
                                "CPU TimeStamp (ms) " + task.CPU_TimeStamp.ToString("00") + "\n" +
                                "IMU Frametime (ms, sampled) " + sampledIMUFrameTime.ToString("000.00") +
                                " IMUanchor = " + IMUanchor.ToString("00") +
                                " latest = " + task.IMU_FrameTime.ToString("00.00") + "\n" +
                                "IMUtoCapture (ms, sampled, in red) " + IMUtoCaptureEstimate.ToString("00") + "\n" + "\n" +
                                "IMU Frame Time = Blue" + "\n" +
                                "Host Frame Time = Green" + "\n" +
                                "IMU Total Delay = Red" + "\n" +
                                "IMU Anchor Frame Time = White (IMU Frame Time that occurs most often" + "\n" + "\n" + "\n";
                plot.plotData = new Scalar(task.IMU_FrameTime, task.CPU_FrameTime, IMUtoCaptureEstimate, IMUanchor);
                plot.Run(null);
                if (plot.maxScale - plot.minScale > histogramIMU.Length) Array.Resize(ref histogramIMU, plot.maxScale - plot.minScale);
                if (plot.lastXdelta.Count() > options.plotLastX)
                {
                    for (int i = 0; i < plot.plotCount; i++)
                    {
                        string timeLabel = " IMU FrameTime ";
                        if (i == 1) timeLabel = " Host Frame Time ";
                        if (i == 2) timeLabel = " IMUtoCapture ms ";
                        if (i == 3) timeLabel = " IMU Center time ";

                        output += "Last " + options.plotLastX + timeLabel + "\t";
                        for (int j = plot.lastXdelta.Count() - options.plotLastX - 1; j < plot.lastXdelta.Count() - 1; j++)
                        {
                            output += plot.lastXdelta[j][i].ToString("00") + ", ";
                        }
                        output += "\n";
                    }
                }
                SetTrueText(output);
            }
        }
    }
    public class CS_IMU_PlotTotalDelay : CS_Parent
    {
        IMU_PlotHostFrameTimes host = new IMU_PlotHostFrameTimes();
        IMU_PlotIMUFrameTime imu = new IMU_PlotIMUFrameTime();
        Plot_OverTime plot = new Plot_OverTime();
        Kalman_Single kalman = new Kalman_Single();
        System.Windows.Forms.TrackBar countSlider;
        double sampledCPUDelay = 0;
        double sampledIMUDelay = 0;
        double sampledTotalDelay = 0;
        double sampledSmooth = 0;
        public CS_IMU_PlotTotalDelay(VBtask task) : base(task)
        {
            countSlider = FindSlider("Number of Plot Values");
            plot.dst2 = dst3;
            plot.maxScale = 50;
            plot.minScale = 0;
            plot.plotCount = 4;
            labels[2] = "Timing data - total (white) right image";
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Estimate time from IMU capture to host processing to allow predicting effect of camera motion.";
        }
        public void RunCS(Mat src)
        {
            int plotLastX = countSlider.Value;
            host.Run(src);
            imu.Run(src);
            double totaldelay = host.HostInterruptDelayEstimate + imu.IMUtoCaptureEstimate;
            kalman.inputReal = (float)totaldelay;
            kalman.Run(src);
            if (task.FirstPass)
            {
                sampledCPUDelay = host.HostInterruptDelayEstimate;
                sampledIMUDelay = imu.IMUtoCaptureEstimate;
                sampledTotalDelay = totaldelay;
                sampledSmooth = kalman.stateResult;
            }
            if (task.heartBeat)
            {
                sampledCPUDelay = host.HostInterruptDelayEstimate;
                sampledIMUDelay = imu.IMUtoCaptureEstimate;
                sampledTotalDelay = totaldelay;
                sampledSmooth = kalman.stateResult;
            }
            string output = "Estimated host delay (ms, sampled) " + string.Format("{0:00}", sampledCPUDelay) + "\n" +
                            "Estimated IMU delay (ms, sampled) " + string.Format("{0:00}", sampledIMUDelay) + "\n" +
                            "Estimated Total delay (ms, sampled) " + string.Format("{0:00}", sampledTotalDelay) + "\n" +
                            "Estimated Total delay Smoothed (ms, sampled, in White) " + string.Format("{0:00}", sampledSmooth) + "\n" + "\n" +
                            "Blue" + "\t" + "IMU Frame Time" + "\n" +
                            "Green" + "\t" + "Host Frame Time" + "\n" +
                            "Red" + "\t" + "Host+IMU Total Delay (latency)" + "\n" +
                            "White" + "\t" + "Host+IMU Anchor Frame Time (Host Frame Time that occurs most often)" + "\n" + "\n" + "\n";
            plot.plotData = new Scalar(imu.IMUtoCaptureEstimate, host.HostInterruptDelayEstimate, totaldelay, kalman.stateResult);
            plot.Run(empty);
            if (plot.lastXdelta.Count() > plotLastX)
            {
                for (int i = 0; i < plot.plotCount; i++)
                {
                    string timeLabel = " IMU Delay ";
                    if (i == 1) timeLabel = " Host Delay ";
                    if (i == 2) timeLabel = " Total Delay ms ";
                    if (i == 3) timeLabel = " Smoothed Total ";
                    output += "Last " + plotLastX + timeLabel + "\t";
                    for (int j = plot.lastXdelta.Count() - plotLastX - 1; j < plot.lastXdelta.Count(); j++)
                    {
                        output += string.Format("{0:00}", plot.lastXdelta[j][i]) + ", ";
                    }
                    output += "\n";
                }
            }
            SetTrueText(output);
        }
    }
    public class CS_IMU_VerticalAngles : CS_Parent
    {
        Line_GCloud vert = new Line_GCloud();
        public CS_IMU_VerticalAngles(VBtask task) : base(task)
        {
            labels = new[] { "", "", "Highlighted vertical lines", "Line details" };
            desc = "Compare the IMU changes to the angle changes in the vertical lines.";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            vert.Run(src);
            string strOut = "ID" + "\t" + "len3D" + "\t" + "Depth" + "\t" + "Arc X" + "\t" + "Arc Y" + "\t" + "Arc Z" + "\t" + "IMU X" + "\t" + "IMU Y" + "\t" + "IMU Z" + "\n";
            dst3.SetTo(0);
            for (int i = 0; i < vert.sortedVerticals.Count(); i++)
            {
                var gc = vert.sortedVerticals.ElementAt(i).Value;
                strOut += i + "\t" + string.Format("{0}", gc.len3D) + "m" + "\t" + string.Format("{0}", gc.tc1.depth) + "m" + "\t" +
                          string.Format("{0}", gc.arcX) + "\t" + string.Format("{0}", gc.arcY) + "\t" + string.Format("{0}", gc.arcZ) + "\t";
                strOut += string.Format("{0}", task.accRadians.X * 57.2958) + "\t" + string.Format("{0}", task.accRadians.Y * 57.2958) + "\t" + string.Format("{0}", task.accRadians.Z * 57.2958) + "\t" + "\n";
                SetTrueText(i.ToString(), gc.tc1.center, 2);
                SetTrueText(i.ToString(), gc.tc1.center, 3);
                DrawLine(dst2, gc.tc1.center, gc.tc2.center, task.HighlightColor, task.lineWidth);
                DrawLine(dst3, gc.tc1.center, gc.tc2.center, Scalar.White, task.lineWidth);
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_IMU_PlotGravityAngles : CS_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public CS_IMU_PlotGravityAngles(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Plot the motion of the camera based on the IMU data in degrees";
        }
        public void RunCS(Mat src)
        {
            SetTrueText("ts = " + string.Format("{0}", task.IMU_TimeStamp) + "\n" + "X degrees = " + string.Format("{0}", task.accRadians.X * 57.2958) + "\n" +
                        "Y degrees = " + string.Format("{0}", Math.Abs(task.accRadians.Y * 57.2958)) + "\n" + "Z degrees = " + string.Format("{0}", task.accRadians.Z * 57.2958) + "\n" + "\n" +
                        "Motion (radians/sec) " + "\n" + "pitch = " + string.Format("{0}", task.IMU_AngularVelocity.X) + "\n" +
                        "Yaw = " + string.Format("{0}", task.IMU_AngularVelocity.Y) + "\n" + " Roll = " + string.Format("{0}", task.IMU_AngularVelocity.Z), 1);
            plot.plotData = new Scalar(task.accRadians.X * 57.2958, task.accRadians.Y * 57.2958, task.accRadians.Z * 57.2958);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }
    public class CS_IMU_PlotAngularVelocity : CS_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public CS_IMU_PlotAngularVelocity(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Plot the IMU Velocity over time.";
        }
        public void RunCS(Mat src)
        {
            SetTrueText("ts = " + string.Format("{0}", task.IMU_TimeStamp) + "\n" + "X m/sec^2 = " + string.Format("{0}", task.IMU_Acceleration.X) + "\n" +
                        "Y m/sec^2 = " + string.Format("{0}", task.IMU_Acceleration.Y) + "\n" + "Z m/sec^2 = " + string.Format("{0}", task.IMU_Acceleration.Z) + "\n" + "\n" +
                        "Motion (radians/sec) " + "\n" + "X - Pitch = " + string.Format("{0}", task.IMU_AngularVelocity.X) + "\n" +
                        "Y - Yaw = " + string.Format("{0}", task.IMU_AngularVelocity.Y) + "\n" + "Z - Roll = " + string.Format("{0}", task.IMU_AngularVelocity.Z) + "\n" + "\n" +
                        "Move the camera to move values off of zero...", 1);
            plot.plotData = new Scalar(task.IMU_AngularVelocity.X, task.IMU_AngularVelocity.Y, task.IMU_AngularVelocity.Z);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }
    
    public class CS_IMU_Lines : CS_Parent
    {
        Line_GCloud vert = new Line_GCloud();
        Kalman_Basics kalman = new Kalman_Basics();
        gravityLine lastGcell;
        public CS_IMU_Lines(VBtask task) : base(task)
        {
            labels[2] = "Vertical lines in Blue and horizontal lines in Yellow";
            desc = "Find the vertical and horizontal lines";
        }
        public void RunCS(Mat src)
        {
            vert.Run(src);
            dst2 = vert.dst2;
            gravityLine gcell;
            var cells = vert.sortedVerticals;
            if (cells.Count() > 0) gcell = cells.ElementAt(0).Value; else gcell = lastGcell;
            if (gcell.len3D > 0)
            {
                string strOut = "ID" + "\t" + "len3D" + "\t" + "Depth" + "\t" + "Arc Y" + "\t" + "Image" + "\t" + "IMU Y" + "\t" + "\n";
                if (task.heartBeat) dst3.SetTo(0);
                var p1 = gcell.tc1.center;
                var p2 = gcell.tc2.center;
                var lastP1 = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
                var lastp2 = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
                kalman.kInput = new float[] { p1.X, p1.Y, p2.X, p2.Y };
                kalman.Run(empty);
                p1 = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
                p2 = new cv.Point(kalman.kOutput[2], kalman.kOutput[3]);
                DrawCircle(dst2, p1, task.DotSize, task.HighlightColor);
                DrawCircle(dst2, p2, task.DotSize, task.HighlightColor);
                DrawCircle(dst3, p1, task.DotSize, Scalar.White);
                DrawCircle(dst3, p2, task.DotSize, Scalar.White);
                lastGcell = gcell;
                strOut += "0" + "\t" + string.Format("{0}", gcell.len3D) + "m" + "\t" +
                                                    string.Format("{0}", gcell.tc1.depth) + "m" + "\t" +
                                                    string.Format("{0}", gcell.arcY) + "\t" +
                                                    string.Format("{0}", gcell.imageAngle) + "\t";
                strOut += string.Format("{0}", task.accRadians.Y * 57.2958) + "\n";
                SetTrueText(strOut, 3);
                labels[2] = vert.labels[3];
            }
        }
    }
    public class CS_IMU_PlotAcceleration : CS_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public CS_IMU_PlotAcceleration(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Plot the IMU Acceleration in m/Sec^2 over time.";
        }
        public void RunCS(Mat src)
        {
            SetTrueText("ts = " + string.Format("{0}", task.IMU_TimeStamp) + "\n" + "X m/sec^2 = " + string.Format("{0}", task.IMU_Acceleration.X) + "\n" +
                        "Y m/sec^2 = " + string.Format("{0}", task.IMU_Acceleration.Y) + "\n" + "Z m/sec^2 = " + string.Format("{0}", task.IMU_Acceleration.Z) + "\n" + "\n" +
                        "Motion (radians/sec) " + "\n" + "pitch = " + string.Format("{0}", task.IMU_AngularVelocity.X) + "\n" +
                        "Yaw = " + string.Format("{0}", task.IMU_AngularVelocity.Y) + "\n" + " Roll = " + string.Format("{0}", task.IMU_AngularVelocity.Z), 1);
            plot.plotData = new Scalar(task.IMU_Acceleration.X, task.IMU_Acceleration.Y, task.IMU_Acceleration.Z);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
        }
    }
    public class CS_IMU_Average : CS_Parent
    {
        List<Scalar> accList = new List<Scalar>();
        public CS_IMU_Average(VBtask task) : base(task)
        {
            desc = "Average the IMU Acceleration values over the previous X images.";
        }
        public void RunCS(Mat src)
        {
            if (task.optionsChanged) accList.Clear();
            accList.Add(new cv.Scalar(task.IMU_RawAcceleration.X, task.IMU_RawAcceleration.Y, task.IMU_RawAcceleration.Z));
            var accMat = new Mat(accList.Count(), 1, MatType.CV_64FC4, accList.ToArray());
            var imuMean = accMat.Mean();
            task.IMU_AverageAcceleration = new Point3f((float)imuMean[0], (float)imuMean[1], (float)imuMean[2]);
            if (accList.Count() >= task.frameHistoryCount) accList.RemoveAt(0);
            string strOut = "Average IMU acceleration: " + "\n" + string.Format("{0}", task.IMU_AverageAcceleration.X) + "\t" + string.Format("{0}", task.IMU_AverageAcceleration.Y) + "\t" +
                            string.Format("{0}", task.IMU_AverageAcceleration.Z) + "\n";
            SetTrueText(strOut);
        }
    }
    public class CS_IMU_PlotCompareIMU : CS_Parent
    {
        Plot_OverTimeScalar[] plot = new Plot_OverTimeScalar[3];
        IMU_AllMethods imuAll = new IMU_AllMethods();
        public CS_IMU_PlotCompareIMU(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay0();
            if (standaloneTest()) task.gOptions.setDisplay1();
            for (int i = 0; i < plot.Length; i++)
            {
                plot[i] = new Plot_OverTimeScalar();
                plot[i].plotCount = 4;
            }
            labels = new string [] { "IMU Acceleration in X", "IMU Acceleration in Y", "IMU Acceleration in Z", "" };
            desc = "imre the results of the raw IMU data with the same values after Kalman";
        }
        public void RunCS(Mat src)
        {
            imuAll.Run(empty);
            plot[0].plotData = new Scalar(task.IMU_RawAcceleration.X, task.IMU_Acceleration.X, task.kalmanIMUacc.X, task.IMU_AverageAcceleration.X);
            plot[0].Run(empty);
            dst0 = plot[0].dst2;
            plot[1].plotData = new Scalar(task.IMU_RawAcceleration.Y, task.IMU_Acceleration.Y, task.kalmanIMUacc.Y, task.IMU_AverageAcceleration.Y);
            plot[1].Run(empty);
            dst1 = plot[1].dst2;
            plot[2].plotData = new Scalar(task.IMU_RawAcceleration.Z, task.IMU_Acceleration.Z, task.kalmanIMUacc.Z, task.IMU_AverageAcceleration.Z);
            plot[2].Run(empty);
            dst2 = plot[2].dst2;
            SetTrueText("Blue (usually hidden) is the raw signal" + "\n" + "Green (usually hidden) is the Velocity-filtered results" + "\n" +
                        "Red is the Kalman IMU data" + "\n" + "White is the IMU Averaging output (note delay from Kalman output)" + "\n" + "\n" +
                        "Move the camera around to see the impact on the IMU data." + "\n" +
                        "Adjust the global option 'Frame History' to see the impact." + "\n" + "\n" +
                        "Remember that IMU Data filtering only impacts the X and Z values." + "\n" +
                        "Averaging seems to track closer but is not as timely.", 3);
        }
    }
    public class CS_IMU_Kalman : CS_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        public CS_IMU_Kalman(VBtask task) : base(task)
        {
            desc = "Use Kalman Filter to stabilize the IMU acceleration and velocity";
        }
        public void RunCS(Mat src)
        {
            kalman.kInput = new float[] { task.IMU_RawAcceleration.X, task.IMU_RawAcceleration.Y, task.IMU_RawAcceleration.Z,
                                       task.IMU_RawAngularVelocity.X, task.IMU_RawAngularVelocity.Y, task.IMU_RawAngularVelocity.Z };
            kalman.Run(empty);
            task.kalmanIMUacc = new Point3f(kalman.kOutput[0], kalman.kOutput[1], kalman.kOutput[2]);
            task.kalmanIMUvelocity = new Point3f(kalman.kOutput[3], kalman.kOutput[4], kalman.kOutput[5]);
            string strOut = "IMU Acceleration Raw" + "\t" + "IMU Velocity Raw" + "\n" +
                            string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t", task.IMU_RawAcceleration.X, task.IMU_RawAcceleration.Y, task.IMU_RawAcceleration.Z, task.IMU_RawAngularVelocity.X, task.IMU_RawAngularVelocity.Y, task.IMU_RawAngularVelocity.Z) + "\n" + "\n" +
                            "kalmanIMUacc" + "\t" + "\t" + "kalmanIMUvelocity" + "\n" +
                            string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t", task.kalmanIMUacc.X, task.kalmanIMUacc.Y, task.kalmanIMUacc.Z, task.kalmanIMUvelocity.X, task.kalmanIMUvelocity.Y, task.kalmanIMUvelocity.Z);
            SetTrueText(strOut);
        }
    }
    public class CS_IMU_AllMethods : CS_Parent
    {
        IMU_Basics basics = new IMU_Basics();
        IMU_Average imuAvg = new IMU_Average();
        IMU_Kalman kalman = new IMU_Kalman();
        public CS_IMU_AllMethods(VBtask task) : base(task)
        {
            desc = "Compute the IMU acceleration using all available methods - raw, Kalman, averaging, and velocity-filtered.";
        }
        public void RunCS(Mat src)
        {
            basics.Run(empty);
            kalman.Run(empty);
            imuAvg.Run(empty);
            SetTrueText(basics.strOut + "\n" + kalman.strOut + "\n" + "\n" + imuAvg.strOut, 2);
        }
    }
    public class CS_IMU_VelocityPlot : CS_Parent
    {
        IMU_Plot plot = new IMU_Plot();
        public CS_IMU_VelocityPlot(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "Plot the angular velocity";
        }
        public void RunCS(Mat src)
        {
            task.pitch = task.IMU_AngularVelocity.X;
            task.yaw = task.IMU_AngularVelocity.Y;
            task.roll = task.IMU_AngularVelocity.Z;
            plot.blue = task.pitch * 1000;
            plot.green = task.yaw * 1000;
            plot.red = task.roll * 1000;
            plot.labels[2] = "pitch X 1000 (blue), Yaw X 1000 (green), and roll X 1000 (red)";
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            if (task.heartBeat)
            {
                strOut = "Pitch X1000 (blue): " + "\t" + (task.pitch * 1000).ToString(fmt1) + "\n" +
                         "Yaw X1000 (green): " + "\t" + (task.yaw * 1000).ToString(fmt1) + "\n" +
                         "Roll X1000 (red): " + "\t" + (task.roll * 1000).ToString(fmt1);
            }
            SetTrueText(strOut, 1);
        }
    }
    public class CS_IMU_IscameraStable : CS_Parent
    {
        IMU_Plot plot = new IMU_Plot();
        Options_IMU options = new Options_IMU();
        public CS_IMU_IscameraStable(VBtask task) : base(task)
        {
            desc = "Track the standard deviation of the angular velocities.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            task.pitch = task.IMU_AngularVelocity.X;
            task.yaw = task.IMU_AngularVelocity.Y;
            task.roll = task.IMU_AngularVelocity.Z;
            if (task.heartBeat)
            {
                strOut = "Pitch X1000 (blue): " + "\t" + (task.pitch * 1000).ToString(fmt1) + "\n" +
                         "Yaw X1000 (green): " + "\t" + (task.yaw * 1000).ToString(fmt1) + "\n" +
                         "Roll X1000 (red): " + "\t" + (task.roll * 1000).ToString(fmt1);
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_IMU_PlotHostFrameTimes : CS_Parent
    {
        public Plot_OverTime plot = new Plot_OverTime();
        public double CPUInterval;
        public double HostInterruptDelayEstimate;
        Options_IMUFrameTime options = new Options_IMUFrameTime();
        int CPUanchor = 0;
        int[] hist;
        double sampledCPUFrameTime = 0;
        public CS_IMU_PlotHostFrameTimes(VBtask task) : base(task)
        {
            plot.dst2 = dst3;
            plot.maxScale = 50;
            plot.minScale = -10;
            plot.plotCount = 4;
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Use the Host timestamp to estimate the delay from image capture to host interrupt.  Just an estimate!";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.FirstPass) CPUanchor = (int)task.CPU_FrameTime;
            if (task.FirstPass) hist = new int[plot.maxScale + 1];
            // there can be some errant times at startup.
            if (task.CPU_FrameTime > plot.maxScale) task.CPU_FrameTime = plot.maxScale;
            if (task.CPU_FrameTime < 0) task.CPU_FrameTime = 0;
            int maxval = int.MinValue;
            for (int i = 0; i < hist.Length; i++)
            {
                if (maxval < hist[i])
                {
                    maxval = hist[i];
                    CPUanchor = i;
                }
            }
            int cpuFrameTime = (int)task.CPU_FrameTime;
            if (CPUanchor != 0) cpuFrameTime = cpuFrameTime % CPUanchor;
            HostInterruptDelayEstimate = CPUanchor - cpuFrameTime + options.minDelayHost;
            if (HostInterruptDelayEstimate > CPUanchor) HostInterruptDelayEstimate -= CPUanchor;
            if (HostInterruptDelayEstimate < 0) HostInterruptDelayEstimate = options.minDelayHost;
            if (task.FirstPass) sampledCPUFrameTime = task.CPU_FrameTime;
            if (task.heartBeat) sampledCPUFrameTime = task.CPU_FrameTime;
            hist[Math.Min((int)task.CPU_FrameTime, hist.Length - 1)] += 1;
            if (standaloneTest())
            {
                string output = "IMU_TimeStamp (ms) " + task.IMU_TimeStamp.ToString("00") + "\n" +
                                "CPU TimeStamp (ms) " + task.CPU_TimeStamp.ToString("00") + "\n" +
                                "Host Frametime (ms, sampled) " + sampledCPUFrameTime.ToString("000.00") +
                                " CPUanchor = " + CPUanchor.ToString("00") +
                                " latest = " + task.CPU_FrameTime.ToString("00.00") + "\n" +
                                "Host Interrupt Delay (ms, sampled, in red) " + HostInterruptDelayEstimate.ToString("00") + "\n" + "\n" +
                                "Blue" + "\t" + "IMU Frame Time" + "\n" +
                                "Green" + "\t" + "Host Frame Time" + "\n" +
                                "Red" + "\t" + "Host Total Delay (latency)" + "\n" +
                                "White" + "\t" + "Host Anchor Frame Time (Host Frame Time that occurs most often" + "\n" + "\n" + "\n";
                plot.plotData = new Scalar(task.IMU_FrameTime, task.CPU_FrameTime, HostInterruptDelayEstimate, CPUanchor);
                plot.Run(empty);
                if (plot.maxScale - plot.minScale > hist.Length) Array.Resize(ref hist, plot.maxScale - plot.minScale + 1);
                if (plot.lastXdelta.Count() > options.plotLastX)
                {
                    for (int i = 0; i < plot.plotCount; i++)
                    {
                        string timeLabel = " IMU FrameTime ";
                        if (i == 1) timeLabel = " IMU Delay ";
                        if (i == 2) timeLabel = " Host FrameTime ";
                        if (i == 3) timeLabel = " CPUanchor FT";
                        output += "Last " + options.plotLastX.ToString() + timeLabel + "\t";
                        for (int j = plot.lastXdelta.Count() - options.plotLastX - 1; j < plot.lastXdelta.Count(); j++)
                        {
                            output += plot.lastXdelta[j][i].ToString("00") + ", ";
                        }
                        output += "\n";
                    }
                }
                SetTrueText(output);
            }
        }
    }
    public class CS_IMU_PlotHostFrameScalar : CS_Parent
    {
        public Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public double CPUInterval;
        public double HostInterruptDelayEstimate;
        Options_IMUFrameTime options = new Options_IMUFrameTime();
        double CPUanchor = 0;
        double sampledCPUFrameTime = 0;
        public CS_IMU_PlotHostFrameScalar(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            plot.plotCount = 4;
            labels[3] = "IMU (blue) Host (green) Latency est. (red) - all in ms";
            desc = "Use the Host timestamp to estimate the delay from image capture to host interrupt.  Just an estimate!";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (task.FirstPass) CPUanchor = task.CPU_FrameTime;
            int cpuFrameTime = (int)task.CPU_FrameTime;
            if (CPUanchor != 0) cpuFrameTime = (int)(cpuFrameTime % CPUanchor);
            HostInterruptDelayEstimate = CPUanchor - cpuFrameTime + options.minDelayHost;
            if (HostInterruptDelayEstimate > CPUanchor) HostInterruptDelayEstimate -= CPUanchor;
            if (HostInterruptDelayEstimate < 0) HostInterruptDelayEstimate = options.minDelayHost;
            if (task.FirstPass) sampledCPUFrameTime = task.CPU_FrameTime;
            if (task.heartBeat) sampledCPUFrameTime = task.CPU_FrameTime;
            if (standaloneTest())
            {
                string strOut = "IMU_TimeStamp (ms) " + task.IMU_TimeStamp.ToString("00") + "\n" +
                                "CPU TimeStamp (ms) " + task.CPU_TimeStamp.ToString("00") + "\n" +
                                "Host Frametime (ms, sampled) " + sampledCPUFrameTime.ToString("000.00") +
                                " CPUanchor = " + CPUanchor.ToString("00") +
                                " latest = " + task.CPU_FrameTime.ToString("00.00") + "\n" +
                                "Host Interrupt Delay (ms, sampled, in red) " + HostInterruptDelayEstimate.ToString("00") + "\n" + "\n" +
                                "Blue" + "\t" + "IMU Frame Time" + "\n" +
                                "Green" + "\t" + "Host Frame Time" + "\n" +
                                "Red" + "\t" + "Host Total Delay (latency)" + "\n" +
                                "White" + "\t" + "Host Anchor Frame Time (Host Frame Time that occurs most often" + "\n" + "\n" + "\n";
                plot.plotData = new Scalar(task.IMU_FrameTime, task.CPU_FrameTime, HostInterruptDelayEstimate, CPUanchor);
                plot.Run(empty);
                dst2 = plot.dst2;
                dst3 = plot.dst3;
                SetTrueText(strOut, 1);
            }
        }
    }
    public class CS_IMU_GMatrixWithOptions : CS_Parent
    {
        public float cx = 1, sx = 0, cy = 1, sy = 0, cz = 1, sz = 0;
        public Mat gMatrix;
        System.Windows.Forms.TrackBar xSlider;
        System.Windows.Forms.TrackBar ySlider;
        System.Windows.Forms.TrackBar zSlider;
        Options_IMU options = new Options_IMU();
        public CS_IMU_GMatrixWithOptions(VBtask task) : base(task)
        {
            desc = "Find the angle of tilt for the camera with respect to gravity.";
        }
        void getSliderValues()
        {
            if (xSlider == null) xSlider = FindSlider("Rotate pointcloud around X-axis (degrees)");
            if (ySlider == null) ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            if (zSlider == null) zSlider = FindSlider("Rotate pointcloud around Z-axis (degrees)");
            cx = (float)Math.Cos(xSlider.Value * Cv2.PI / 180);
            sx = (float)Math.Sin(xSlider.Value * Cv2.PI / 180);
            cy = (float)Math.Cos(ySlider.Value * Cv2.PI / 180);
            sy = (float)Math.Sin(ySlider.Value * Cv2.PI / 180);
            cz = (float)Math.Cos(zSlider.Value * Cv2.PI / 180);
            sz = (float)Math.Sin(zSlider.Value * Cv2.PI / 180);
        }
        Mat buildGmatrix()
        {
            float[,] gArray = new float[3, 3]
            {
            { cx * 1 + -sx * 0 + 0 * 0, cx * 0 + -sx * cz + 0 * sz, cx * 0 + -sx * -sz + 0 * cz },
            { sx * 1 + cx * 0 + 0 * 0, sx * 0 + cx * cz + 0 * sz, sx * 0 + cx * -sz + 0 * cz },
            { 0 * 1 + 0 * 0 + 1 * 0, 0 * 0 + 0 * cz + 1 * sz, 0 * 0 + 0 * -sz + 1 * cz }
            };
            Mat tmpGMatrix = new Mat(3, 3, MatType.CV_32F, new float[]
            {
            gArray[0, 0] * cy + gArray[0, 1] * 0 + gArray[0, 2] * sy,
            gArray[0, 0] * 0 + gArray[0, 1] * 1 + gArray[0, 2] * 0,
            gArray[0, 0] * -sy + gArray[0, 1] * 0 + gArray[0, 2] * cy,
            gArray[1, 0] * cy + gArray[1, 1] * 0 + gArray[1, 2] * sy,
            gArray[1, 0] * 0 + gArray[1, 1] * 1 + gArray[1, 2] * 0,
            gArray[1, 0] * -sy + gArray[1, 1] * 0 + gArray[1, 2] * cy,
            gArray[2, 0] * cy + gArray[2, 1] * 0 + gArray[2, 2] * sy,
            gArray[2, 0] * 0 + gArray[2, 1] * 1 + gArray[2, 2] * 0,
            gArray[2, 0] * -sy + gArray[2, 1] * 0 + gArray[2, 2] * cy
            });
            return tmpGMatrix;
        }
        public void RunCS(Mat src)
        {
            if (xSlider == null) xSlider = FindSlider("Rotate pointcloud around X-axis (degrees)");
            if (ySlider == null) ySlider = FindSlider("Rotate pointcloud around Y-axis (degrees)");
            if (zSlider == null) zSlider = FindSlider("Rotate pointcloud around Z-axis (degrees)");
            if (task.useGravityPointcloud)
            {
                cz = (float)Math.Cos(task.accRadians.Z);
                sz = (float)Math.Sin(task.accRadians.Z);
                cx = (float)Math.Cos(task.accRadians.X);
                sx = (float)Math.Sin(task.accRadians.X);
            }
            else
            {
                getSliderValues();
            }
            gMatrix = buildGmatrix();
            if (standaloneTest())
            {
                var g = task.IMU_Acceleration;
                strOut = "IMU Acceleration in X-direction = " + "\t\t" + string.Format("{0:F4}", g.X) + "\n";
                strOut += "IMU Acceleration in Y-direction = " + "\t\t" + string.Format("{0:F4}", g.Y) + "\n";
                strOut += "IMU Acceleration in Z-direction = " + "\t\t" + string.Format("{0:F4}", g.Z) + "\n\n";
                strOut += "Rotate around X-axis (in degrees) = " + "\t" + string.Format("{0:F4}", xSlider.Value) + "\n";
                strOut += "Rotate around Y-axis (in degrees) = " + "\t" + string.Format("{0:F4}", ySlider.Value) + "\n";
                strOut += "Rotate around Z-axis (in degrees) = " + "\t" + string.Format("{0:F4}", zSlider.Value) + "\n";
                strOut += "\n" + "sqrt (" + "\t" + string.Format("{0:F4}", g.X) + "*" + string.Format("{0:F4}", g.X) + "\t\t" +
                          string.Format("{0:F4}", g.Y) + "*" + string.Format("{0:F4}", g.Y) + "\t\t" +
                          string.Format("{0:F4}", g.Z) + "*" + string.Format("{0:F4}", g.Z) + " ) = " + "\t\t" +
                          string.Format("{0:F4}", Math.Sqrt(g.X * g.X + g.Y * g.Y + g.Z * g.Z)) + "\n" +
                          "Should be close to the earth's gravitational constant of 9.807 (or the camera was moving.)";
                var tmpGMat1 = buildGmatrix();
                strOut += "\nGravity-oriented gMatrix - move camera to test this:\n" + gMatrixToStr(tmpGMat1);
                getSliderValues();
                var tmpGMat2 = buildGmatrix();
                strOut += "\ngMatrix with slider input - use Options_IMU Sliders to change this:\n" + gMatrixToStr(tmpGMat2);
            }
            SetTrueText(strOut);
            task.gMatrix = gMatrix;
        }
    }
    public class CS_IMU_VerticalVerify : CS_Parent
    {
        public List<gravityLine> gCells = new List<gravityLine>();
        FeatureLine_VH linesVH = new FeatureLine_VH();
        Options_VerticalVerify options = new Options_VerticalVerify();
        public CS_IMU_VerticalVerify(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Highlighted vertical lines", "Line details" };
            desc = "Use the Y-Arc to confirm which vertical lines are valid";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            dst2 = src.Clone();
            if (standaloneTest())
            {
                linesVH.Run(src);
                gCells = linesVH.gCells;
            }
            strOut = "ID" + "\t" + "len3D" + "\t" + "Depth" + "\t" + "Arc Y" + "\t" + "Image" + "\t" + "IMU Y" + "\n";
            dst3.SetTo(0);
            int index;
            for (int i = gCells.Count() - 1; i >= 0; i--)
            {
                var gc = gCells[i];
                if (gc.arcY > options.angleThreshold)
                {
                    index = gCells.Count() - i;
                    var p1 = gc.tc1.center;
                    var p2 = gc.tc2.center;
                    float xOffset = p1.X - p2.X;
                    if (p1.Y < p2.Y) xOffset = p2.X - p1.X;
                    float hypot = (float)p1.DistanceTo(p2);
                    gc.imageAngle = -(float)Math.Asin(xOffset / hypot) * 57.2958f;
                    strOut += index.ToString() + "\t" + string.Format("{0:F1}", gc.len3D) + "m" + "\t" +
                              string.Format("{0:F1}", gc.tc1.depth) + "m" + "\t" +
                              string.Format("{0:F1}", gc.arcY) + "\t" +
                              string.Format("{0:F1}", gc.imageAngle) + "\t";
                    strOut += string.Format("{0:F1}", task.accRadians.Y * 57.2958) + "\n";
                    SetTrueText(index.ToString(), gc.tc1.center, 2);
                    SetTrueText(index.ToString(), gc.tc1.center, 3);
                    DrawLine(dst2, gc.tc1.center, gc.tc2.center, task.HighlightColor, task.lineWidth);
                    DrawLine(dst3, gc.tc1.center, gc.tc2.center, Scalar.White, task.lineWidth);
                    gCells[i] = gc;
                }
                else
                {
                    gCells.RemoveAt(i);
                }
            }
            SetTrueText(strOut, 3);
        }
    }
    public class CS_IMU_Plot : CS_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public float blueA, greenA, redA;
        Options_IMUPlot options = new Options_IMUPlot();
        public CS_IMU_Plot(VBtask task) : base(task)
        {
            plot.plotCount = 3;
            desc = "Plot the angular velocity of the camera based on the IMU data";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (standaloneTest())
            {
                blueA = task.IMU_AngularVelocity.X * 1000;
                greenA = task.IMU_AngularVelocity.Y * 1000;
                redA = task.IMU_AngularVelocity.Z * 1000;
            }
            float blueX = 0, greenX = 0, redX = 0;
            if (options.setBlue) blueX = blueA;
            if (options.setGreen) greenX = greenA;
            if (options.setRed) redX = redA;
            plot.plotData = new Scalar(blueX, greenX, redX);
            plot.Run(empty);
            dst2 = plot.dst2;
            dst3 = plot.dst3;
            labels[2] = "When run standaloneTest(), the default is to plot the angular velocity for X, Y, and Z";
        }
    }
    public class CS_InPaint_Basics : CS_Parent
    {
        Options_InPaint options = new Options_InPaint();
        public CS_InPaint_Basics(VBtask task) : base(task)
        {
            desc = "Create a flaw in an image and then use inPaint to mask it.";
            labels[3] = "Repaired Image";
        }
        public Mat drawRandomLine(Mat dst)
        {
            var p1 = new Point2f(msRNG.Next(dst.Cols / 4, dst.Cols * 3 / 4), msRNG.Next(dst.Rows / 4, dst.Rows * 3 / 4));
            var p2 = new Point2f(msRNG.Next(dst.Cols / 4, dst.Cols * 3 / 4), msRNG.Next(dst.Rows / 4, dst.Rows * 3 / 4));
            DrawLine(dst2, p1, p2, new Scalar(0, 0, 0), task.lineWidth);
            var mask = new Mat(dst2.Size(), MatType.CV_8UC1);
            mask.SetTo(0);
            DrawLine(mask, p1, p2, Scalar.All(255), task.lineWidth);
            return mask;
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            src.CopyTo(dst2);
            Mat mask = drawRandomLine(dst2);
            Cv2.Inpaint(dst2, mask, dst3, task.lineWidth, options.telea ? InpaintMethod.Telea : InpaintMethod.NS);
        }
    }
    public class CS_InPaint_Noise : CS_Parent
    {
        Draw_Noise noise = new Draw_Noise();
        Options_InPaint options = new Options_InPaint();
        public CS_InPaint_Noise(VBtask task) : base(task)
        {
            desc = "Create noise in an image and then use inPaint to remove it.";
            labels[3] = "Repaired Image";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            noise.Run(src); // create some noise in the result1 image.
            dst2 = noise.dst2;
            Cv2.Inpaint(dst2, noise.noiseMask, dst3, noise.options.noiseWidth, options.telea ? InpaintMethod.Telea : InpaintMethod.NS);
        }
    }
    public class CS_InPaint_Depth : CS_Parent
    {
        Options_InPaint options = new Options_InPaint();
        public CS_InPaint_Depth(VBtask task) : base(task)
        {
            labels[2] = "32-bit representation of original depth";
            labels[3] = "32-bit depth repaired with inpainting";
            desc = "Use Navier-Stokes to fill in the holes in the depth";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (src.Type() != MatType.CV_32F) src = task.pcSplit[2];
            dst2 = src.Clone();
            Cv2.Inpaint(src, task.noDepthMask, dst3, 20, options.telea ? InpaintMethod.Telea : InpaintMethod.NS);
        }
    }
    public class CS_Interpolate_Basics : CS_Parent
    {
        public Options_Resize options = new Options_Resize();
        public Options_Interpolate iOptions = new Options_Interpolate();
        int direction = 1;
        int saveSliderValue = 0;
        public CS_Interpolate_Basics(VBtask task) : base(task)
        {
            UpdateAdvice(traceName + ": 'Interpolation threshold' is the primary control" + "\n" +
                         "Local option 'Resize %' has a secondary effect." + "\n" +
                         "Local option 'Line length' affects the lines found.");
            desc = "Resize image using all available interpolation methods in OpenCV";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            iOptions.RunVB();
            if (task.FirstPass) saveSliderValue = iOptions.interpolationThreshold;
            if (standaloneTest())
            {
                bool userGrab = iOptions.interpolationThreshold != iOptions.saveDefaultThreshold;
                if (!userGrab)
                {
                    saveSliderValue += direction;
                    if (saveSliderValue > 50) direction = -1;
                    if (saveSliderValue == 1) direction = 1;
                }
                else
                {
                    userGrab = true;
                    saveSliderValue = iOptions.interpolationThreshold;
                }
            }
            else
            {
                saveSliderValue = iOptions.interpolationThreshold;
            }
            dst2 = src.Clone();
            var newSize = new cv.Size((int)(dst2.Width * saveSliderValue / 100), (int)(dst2.Height * saveSliderValue / 100));
            dst2 = src.Resize(newSize, 0, 0, options.warpFlag);
            labels[2] = "Resize % = " + string.Format("{0:0%}", saveSliderValue / 100.0);
        }
    }
    public class CS_Interpolate_Kalman : CS_Parent
    {
        Interpolate_Basics inter = new Interpolate_Basics();
        Kalman_Basics kalman = new Kalman_Basics();
        int updatedFrames;
        int myFrameCount;
        int heartCount;
        Mat lastFrame = new cv.Mat();
        public CS_Interpolate_Kalman(VBtask task) : base(task)
        {
            desc = "Use Kalman to smooth the grayscale results of interpolation";
        }
        public void RunCS(Mat src)
        {
            inter.Run(src);
            dst2 = inter.dst2.CvtColor(ColorConversionCodes.BGR2GRAY);
            if (task.optionsChanged)
            {
                kalman.kInput = new float[dst2.Width * dst2.Height];
                myFrameCount = 1;
                updatedFrames = 0;
            }
            Mat tmp32f = new Mat();
            dst2.ConvertTo(tmp32f, MatType.CV_32F);
            Marshal.Copy(tmp32f.Data, kalman.kInput, 0, kalman.kInput.Length);
            kalman.Run(empty);
            byte[] results = new byte[kalman.kInput.Length];
            for (int i = 0; i < kalman.kOutput.Length; i++)
            {
                float val = kalman.kOutput[i];
                if (float.IsNaN(val)) val = 255;
                if (val < 0) val = 0;
                if (val > 255) val = 255;
                results[i] = (byte)val;
            }
            Marshal.Copy(results, 0, dst2.Data, kalman.kOutput.Length);
            if (task.gOptions.GetUseKalman())
            {
                labels[2] = "Kalman-smoothed output after resizing to " + dst2.Width + "x" + dst2.Height;
            }
            else
            {
                labels[2] = "Raw output after resizing to " + dst2.Width + "x" + dst2.Height;
            }
            if (task.FirstPass) lastFrame = dst2.Clone();
            if (lastFrame.Size() != dst2.Size()) lastFrame = dst2.Clone();
            Mat tmp = dst2 - lastFrame;
            int diffCount = tmp.CountNonZero();
            if (diffCount > inter.iOptions.pixelCountThreshold)
            {
                lastFrame = dst2.Clone();
                dst3 = src.Clone();
                updatedFrames++;
            }
            labels[3] = "Total frames = " + myFrameCount + " updates=" + updatedFrames +
                         " savings = " + (myFrameCount - updatedFrames) + " or " +
                         string.Format("{0:0%}", (myFrameCount - updatedFrames) / (float)myFrameCount) + " diffCount = " + diffCount;
            if (task.heartBeat)
            {
                heartCount++;
                if (heartCount % 10 == 0)
                {
                    myFrameCount = 0;
                    updatedFrames = 0;
                }
            }
            myFrameCount++;
        }
    }
    public class CS_Interpolate_Lines : CS_Parent
    {
        Line_Basics lines = new Line_Basics();
        Interpolate_Basics inter = new Interpolate_Basics();
        public CS_Interpolate_Lines(VBtask task) : base(task)
        {
            FindSlider("Interpolation Resize %").Value = 80;
            FindSlider("Interpolation threshold").Value = 100;
            desc = "Detect lines in interpolation results.";
        }
        public void RunCS(Mat src)
        {
            inter.Run(src);
            dst1 = inter.dst2.CvtColor(ColorConversionCodes.BGR2GRAY).Resize(dst3.Size());
            dst1 = dst1.Threshold(inter.iOptions.interpolationThreshold, 255, ThresholdTypes.Binary);
            lines.Run(dst1);
            dst2 = lines.dst2;
            dst3 = src;
            foreach (var lp in lines.lpList)
            {
                DrawLine(dst3, lp.p1, lp.p2, Scalar.Yellow, task.lineWidth);
            }
            labels[3] = "There were " + lines.lpList.Count() + " lines found";
            labels[2] = inter.labels[2];
        }
    }
    public class CS_Interpolate_Difference : CS_Parent
    {
        Interpolate_Kalman inter = new Interpolate_Kalman();
        Diff_Basics diff = new Diff_Basics();
        public CS_Interpolate_Difference(VBtask task) : base(task)
        {
            desc = "Highlight the difference between the interpolation results and the current image.";
        }
        public void RunCS(Mat src)
        {
            inter.Run(src);
            dst2 = inter.dst3.CvtColor(ColorConversionCodes.BGR2GRAY);
            labels[2] = inter.labels[3];
            diff.lastFrame = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            diff.Run(dst2);
            dst3 = diff.dst2;
        }
    }
    public class CS_Interpolate_QuarterBeat : CS_Parent
    {
        Diff_Basics diff = new Diff_Basics();
        int updatedFrames;
        int myFrameCount;
        float cameraFPS;
        float processedFPS;
        int heartCount = 0;
        DateTime nextTime = DateTime.Now;
        public CS_Interpolate_QuarterBeat(VBtask task) : base(task)
        {
            desc = "Highlight the image differences after every quarter second.";
        }
        public void RunCS(Mat src)
        {
            if (task.quarterBeat)
            {
                diff.Run(src);
                dst3 = diff.dst2;
                if (diff.dst2.CountNonZero() > 0)
            {
                    diff.lastFrame = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                    dst2 = src;
                    updatedFrames++;
                }
            }
            if (task.heartBeat)
            {
                heartCount++;
                if (heartCount % 3 == 0)
                {
                    DateTime newTime = DateTime.Now;
                    long elapsedTicks = newTime.Ticks - nextTime.Ticks;
                    TimeSpan span = new TimeSpan(elapsedTicks);
                    cameraFPS = myFrameCount / (span.Ticks / TimeSpan.TicksPerSecond);
                    processedFPS = updatedFrames / (span.Ticks / TimeSpan.TicksPerSecond);
                    nextTime = newTime;
                    myFrameCount = 0;
                    updatedFrames = 0;
                }
            }
            myFrameCount++;
            labels[2] = "Total frames = " + myFrameCount + " updates=" + updatedFrames +
                         " savings = " + (myFrameCount - updatedFrames) + " or " +
                         string.Format("{0:0%}", (myFrameCount - updatedFrames) / (float)myFrameCount) + " cameraFPS = " + string.Format("{0:00.0}", cameraFPS) +
                         " processedFPS = " + string.Format("{0:00.0}", processedFPS);
        }
    }
    public class CS_Kalman_Basics : CS_Parent
    {
        Kalman_Simple[] kalman;
        public float[] kInput = new float[4];
        public float[] kOutput = new float[4];
        int saveDimension = -1;
        cv.Rect lastRect = new cv.Rect(0, 0, 0, 0);
        public CS_Kalman_Basics(VBtask task) : base(task)
        {
            desc = "Use Kalman to stabilize values (such as a cv.rect.)";
        }
        public void RunCS(Mat src)
        {
            if (saveDimension != kInput.Length)
            {
                if (kalman != null && kalman.Length > 0)
                {
                    foreach (var k in kalman)
                    {
                        k.Dispose();
                    }
                }
                saveDimension = kInput.Length;
                kalman = new Kalman_Simple[kInput.Length];
                for (int i = 0; i < kInput.Length; i++)
                {
                    kalman[i] = new Kalman_Simple();
                }
                kOutput = new float[kInput.Length];
            }
            if (task.gOptions.GetUseKalman())
            {
                for (int i = 0; i < kalman.Length; i++)
                {
                    kalman[i].inputReal = kInput[i];
                    kalman[i].RunVB(null);
                    if (double.IsNaN(kalman[i].stateResult)) kalman[i].stateResult = kalman[i].inputReal; // kalman failure...
                    kOutput[i] = kalman[i].stateResult;
                }
            }
            else
            {
                kOutput = kInput; // do nothing to the input.
            }
            if (standaloneTest())
            {
                dst2 = src;
                cv.Rect rect = new cv.Rect((int)kOutput[0], (int)kOutput[1], (int)kOutput[2], (int)kOutput[3]);
                rect = ValidateRect(rect);
                if (task.FirstPass) lastRect = rect;
                if (rect == lastRect)
                {
                    var r = InitRandomRect(src.Height <= 240 ? 20 : 50);
                    kInput = new float[] { r.X, r.Y, r.Width, r.Height };
                }
                lastRect = rect;
                dst2.Rectangle(rect, Scalar.White, task.lineWidth + 1);
                dst2.Rectangle(rect, Scalar.Red, task.lineWidth);
            }
        }
    }
    public class CS_Kalman_Compare : CS_Parent
    {
        Kalman_Single[] kalman;
        public Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        public Plot_OverTimeScalar kPlot = new Plot_OverTimeScalar();
        public CS_Kalman_Compare(VBtask task) : base(task)
        {
            plot.plotCount = 3;
            kPlot.plotCount = 3;
            labels[2] = "Kalman input: mean values for RGB";
            labels[3] = "Kalman output: smoothed mean values for RGB";
            desc = "Use this kalman filter to predict the next value.";
        }
        public void RunCS(Mat src)
        {
            if (task.optionsChanged)
            {
                if (kalman != null && kalman.Length > 0)
                {
                    foreach (var k in kalman)
                    {
                        k.Dispose();
                    }
                }
                kalman = new Kalman_Single[3];
                for (int i = 0; i < kalman.Length; i++)
                {
                    kalman[i] = new Kalman_Single();
                }
            }
            plot.plotData = src.Mean();
            plot.Run(empty);
            dst2 = plot.dst2;
            for (int i = 0; i < kalman.Length; i++)
            {
                kalman[i].inputReal = (float)plot.plotData[i];
                kalman[i].Run(src);
            }
            kPlot.plotData = new Scalar(kalman[0].stateResult, kalman[1].stateResult, kalman[2].stateResult);
            kPlot.Run(empty);
            dst3 = kPlot.dst2;
        }
    }
    public class CS_Kalman_RotatingPoint : CS_Parent
    {
        KalmanFilter kf = new KalmanFilter(2, 1, 0);
        Mat kState = new Mat(2, 1, MatType.CV_32F);
        Mat processNoise = new Mat(2, 1, MatType.CV_32F);
        Mat measurement = new Mat(1, 1, MatType.CV_32F, 0);
        Point2f center, statePt;
        float radius;
        cv.Point calcPoint(Point2f center, double R, double angle)
        {
            return new Point((int)(center.X + Math.Cos(angle)), (int)(center.Y - Math.Sin(angle)) * R);
        }
        void drawCross(Mat dst2, cv.Point center, Scalar color)
        {
            int d = 3;
            DrawLine(dst2, new cv.Point(center.X - d, center.Y - d), new cv.Point(center.X + d, center.Y + d), color, task.lineWidth);
            DrawLine(dst2, new cv.Point(center.X + d, center.Y - d), new cv.Point(center.X - d, center.Y + d), color, task.lineWidth);
        }
        public CS_Kalman_RotatingPoint(VBtask task) : base(task)
        {
            labels[2] = "Estimate Yellow < Real Red (if working)";
            Cv2.Randn(kState, new Scalar(0), Scalar.All(0.1));
            kf.TransitionMatrix = new Mat(2, 2, MatType.CV_32F, new float[] { 1, 1, 0, 1 });
            Cv2.SetIdentity(kf.MeasurementMatrix);
            Cv2.SetIdentity(kf.ProcessNoiseCov, Scalar.All(0.00001));
            Cv2.SetIdentity(kf.MeasurementNoiseCov, Scalar.All(0.1));
            Cv2.SetIdentity(kf.ErrorCovPost, Scalar.All(1));
            Cv2.Randn(kf.StatePost, new Scalar(0), Scalar.All(1));
            radius = dst2.Rows / 2.4f; // so we see the entire circle...
            center = new Point2f(dst2.Cols / 2, dst2.Rows / 2);
            desc = "Track a rotating point using a Kalman filter. Yellow line (estimate) should be shorter than red (real).";
        }
        public void RunCS(Mat src)
        {
            float stateAngle = kState.Get<float>(0);
            Mat prediction = kf.Predict();
            float predictAngle = prediction.Get<float>(0);
            cv.Point predictPt = calcPoint(center, radius, predictAngle);
            statePt = calcPoint(center, radius, stateAngle);
            Cv2.Randn(measurement, new Scalar(0), Scalar.All(kf.MeasurementNoiseCov.Get<float>(0)));
            measurement += kf.MeasurementMatrix * kState;
            float measAngle = measurement.Get<float>(0);
            cv.Point measPt = calcPoint(center, radius, measAngle);
            dst2.SetTo(0);
            drawCross(dst2, new cv.Point((int)statePt.X, (int)statePt.Y), Scalar.White);
            drawCross(dst2, measPt, Scalar.White);
            drawCross(dst2, predictPt, Scalar.White);
            DrawLine(dst2, statePt, measPt, new Scalar(0, 0, 255), task.lineWidth + 2);
            DrawLine(dst2, statePt, predictPt, new Scalar(0, 255, 255), task.lineWidth + 2);
            if (msRNG.Next(0, 4) != 0) kf.Correct(measurement);
            Cv2.Randn(processNoise, Scalar.Black, Scalar.All(Math.Sqrt(kf.ProcessNoiseCov.Get<float>(0, 0))));
            kState = kf.TransitionMatrix * kState + processNoise;
        }
    }
    public class CS_Kalman_MousePredict : CS_Parent
    {
        Kalman_Basics kalman = new Kalman_Basics();
        cv.Point lastRealMouse = new cv.Point(0, 0);
        public CS_Kalman_MousePredict(VBtask task) : base(task)
        {
            kalman.kInput = new float[2];
            kalman.kOutput = new float[2];
            labels[2] = "Red is real mouse, white is prediction";
            desc = "Use kalman filter to predict the next mouse location.";
        }
        public void RunCS(Mat src)
        {
            if (task.frameCount % 300 == 0) dst2.SetTo(0);
            cv.Point lastStateResult = new cv.Point(kalman.kOutput[0], kalman.kOutput[1]);
            if (task.FirstPass) lastRealMouse = task.mouseMovePoint;
            kalman.kInput = new float[] { task.mouseMovePoint.X, task.mouseMovePoint.Y };
            kalman.Run(src);
            DrawLine(dst2, new cv.Point(kalman.kOutput[0], kalman.kOutput[1]), lastStateResult, cv.Scalar.White, task.lineWidth);
            dst2.Line(task.mouseMovePoint, lastRealMouse, Scalar.Red);
            lastRealMouse = task.mouseMovePoint;
        }
    }
    public class CS_Kalman_CVMat : CS_Parent
    {
        Kalman_Simple[] kalman;
        public Mat output;
        Kalman_Basics basics = new Kalman_Basics();
        public Mat input;
        int saveDimension = -1;
        cv.Rect lastRect;
        public CS_Kalman_CVMat(VBtask task) : base(task)
        {
            basics.kInput = new float[4];
            input = new Mat(4, 1, MatType.CV_32F, 0);
            if (standaloneTest()) labels[2] = "Rectangle moves smoothly to random locations";
            desc = "Use Kalman to stabilize a set of values such as a cv.rect or cv.Mat";
        }
        public void RunCS(Mat src)
        {
            if (saveDimension != input.Rows)
            {
                if (kalman != null && kalman.Length > 0)
                {
                    foreach (var k in kalman)
                    {
                        k.Dispose();
                    }
                }
                saveDimension = input.Rows;
                kalman = new Kalman_Simple[input.Rows];
                for (int i = 0; i < input.Rows; i++)
                {
                    kalman[i] = new Kalman_Simple();
                }
                output = new Mat(input.Rows, 1, MatType.CV_32F, 0);
            }
            if (task.gOptions.GetUseKalman())
            {
                for (int i = 0; i < kalman.Length; i++)
                {
                    kalman[i].inputReal = input.Get<float>(i, 0);
                    kalman[i].RunVB(src);
                    output.Set<float>(i, 0, kalman[i].stateResult);
                }
            }
            else
            {
                output = input; // do nothing to the input.
            }
            if (standaloneTest())
            {
                float[] rx = new float[input.Rows];
                for (int i = 0; i < input.Rows; i++)
                {
                    rx[i] = output.Get<float>(i, 0);
                }
                dst2 = src;
                Rect rect = new Rect((int)rx[0], (int)rx[1], (int)rx[2], (int)rx[3]);
                rect = ValidateRect(rect);
                if (task.FirstPass) lastRect = rect;
                if (lastRect == rect)
                {
                    var r = InitRandomRect(25);
                    float[] array = { r.X, r.Y, r.Width, r.Height };
                    input = new Mat(4, 1, MatType.CV_32F, array);
                }
                dst2.Rectangle(rect, Scalar.Red, 2);
                lastRect = rect;
            }
        }
    }
    public class CS_Kalman_ImageSmall : CS_Parent
    {
        Kalman_CVMat kalman = new Kalman_CVMat();
        Resize_Smaller resize;
        public CS_Kalman_ImageSmall(VBtask task) : base(task)
        {
            resize = new Resize_Smaller();
            labels[2] = "The small image is processed by the Kalman filter";
            labels[3] = "Mask of the smoothed image minus original";
            desc = "Resize the image to allow the Kalman filter to process the whole image.";
        }
        public void RunCS(Mat src)
        {
            if (src.Channels() == 3) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            resize.Run(src);
            var saveOriginal = resize.dst2.Clone();
            Mat gray32f = new Mat();
            resize.dst2.ConvertTo(gray32f, MatType.CV_32F);
            kalman.input = gray32f.Reshape(1, gray32f.Width * gray32f.Height);
            kalman.Run(src);
            Mat tmp = new Mat();
            kalman.output.ConvertTo(tmp, MatType.CV_8U);
            tmp = tmp.Reshape(1, gray32f.Height);
            dst2 = tmp.Resize(dst2.Size());
            Cv2.Subtract(tmp, saveOriginal, dst3);
            dst3 = dst3.Threshold(1, 255, ThresholdTypes.Binary);
            dst3 = dst3.Resize(dst2.Size());
        }
    }
    public class CS_Kalman_DepthSmall : CS_Parent
    {
        Kalman_ImageSmall kalman = new Kalman_ImageSmall();
        public CS_Kalman_DepthSmall(VBtask task) : base(task)
        {
            labels[2] = "Mask of non-zero depth after Kalman smoothing";
            labels[3] = "Mask of the smoothed image minus original";
            desc = "Use a resized depth Mat to find where depth is decreasing (something getting closer.)";
        }
        public void RunCS(Mat src)
        {
            kalman.Run(task.depthRGB);
            dst2 = kalman.dst2;
            dst3 = kalman.dst3;
        }
    }
    public class CS_Kalman_Depth32f : CS_Parent
    {
        Kalman_CVMat kalman = new Kalman_CVMat();
        Resize_Smaller resize;
        public CS_Kalman_Depth32f(VBtask task) : base(task)
        {
            resize = new Resize_Smaller();
            FindSlider("Resize Percentage (%)").Value = 4;
            labels[2] = "Mask of non-zero depth after Kalman smoothing";
            labels[3] = "Difference from original depth";
            desc = "Use a resized depth Mat to find where depth is decreasing (getting closer.)";
        }
        public void RunCS(Mat src)
        {
            resize.Run(task.pcSplit[2]);
            kalman.input = resize.dst2.Reshape(1, resize.dst2.Width * resize.dst2.Height);
            kalman.Run(src);
            dst2 = kalman.output.Reshape(1, resize.dst2.Height);
            dst2 = dst2.Resize(src.Size());
            Cv2.Subtract(dst2, task.pcSplit[2], dst3);
            dst3 = dst3.Normalize(255);
        }
    }
    public class CS_Kalman_Single : CS_Parent
    {
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        KalmanFilter kf = new KalmanFilter(2, 1, 0);
        Mat processNoise = new Mat(2, 1, MatType.CV_32F);
        public Mat measurement = new Mat(1, 1, MatType.CV_32F, 0);
        public float inputReal;
        public float stateResult;
        public float ProcessNoiseCov = 0.00001f;
        public float MeasurementNoiseCov = 0.1f;
        public float ErrorCovPost = 1f;
        public float[] transitionMatrix = { 1, 1, 0, 1 }; // Change the transition matrix externally and set newTransmissionMat_vbbacrix.
        public bool newTransmissionMatrix = true;
        public CS_Kalman_Single(VBtask task) : base(task)
        {
            float[] tMatrix = { 1, 1, 0, 1 };
            kf.TransitionMatrix = new Mat(2, 2, MatType.CV_32F, tMatrix);
            kf.MeasurementMatrix.SetIdentity(1);
            kf.ProcessNoiseCov.SetIdentity(0.00001);
            kf.MeasurementNoiseCov.SetIdentity(0.1);
            kf.ErrorCovPost.SetIdentity(1);
            plot.plotCount = 2;
            desc = "Estimate a single value using a Kalman Filter - in the default case, the value of the mean of the grayscale image.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                dst1 = src.CvtColor(ColorConversionCodes.BGR2GRAY);
                inputReal = (float)dst1.Mean()[0];
            }
            var prediction = kf.Predict();
            measurement.Set<float>(0, 0, inputReal);
            stateResult = kf.Correct(measurement).Get<float>(0, 0);
            if (standaloneTest())
            {
                plot.plotData = new Scalar(inputReal, stateResult, 0, 0);
                plot.Run(empty);
                dst2 = plot.dst2;
                dst3 = plot.dst3;
                labels[2] = "Mean of the grayscale image is predicted";
                labels[3] = "Mean (blue) = " + string.Format("{0:0.0}", inputReal) + " predicted (green) = " + string.Format("{0:0.0}", stateResult);
            }
        }
    }
    public class CS_Kalman_Simple : IDisposable
    {
        KalmanFilter kf = new KalmanFilter(2, 1, 0);
        Mat processNoise = new Mat(2, 1, MatType.CV_32F);
        public Mat measurement = new Mat(1, 1, MatType.CV_32F, 0);
        public float inputReal;
        public float stateResult;
        public float ProcessNoiseCov = 0.00001f;
        public float MeasurementNoiseCov = 0.1f;
        public float ErrorCovPost = 1f;
        public float[] transitionMatrix = { 1, 1, 0, 1 }; // Change the transition matrix externally and set newTransmissionMatrix.
        public bool newTMatrix = true;
        public void updateTMatrix()
        {
            kf.TransitionMatrix = new Mat(2, 2, MatType.CV_32F, transitionMatrix);
            kf.MeasurementMatrix.SetIdentity(1);
            kf.ProcessNoiseCov.SetIdentity(0.00001);
            kf.MeasurementNoiseCov.SetIdentity(0.1);
            kf.ErrorCovPost.SetIdentity(1);
        }
        public CS_Kalman_Simple()
        {
            float[] tMatrix = { 1, 1, 0, 1 };
        }
        public void RunCS(Mat src)
        {
            if (newTMatrix)
            {
                newTMatrix = false;
                updateTMatrix();
            }
            var prediction = kf.Predict();
            measurement.Set<float>(0, 0, inputReal);
            stateResult = kf.Correct(measurement).Get<float>(0, 0);
        }
        public void Dispose()
        {
            // required dispose function. It is tempting to remove this but it is needed...It does not inherit from CS_Parent...
        }
    }
    
    // https://towardsdatascience.com/kalman-filter-interview-bdc39f3e6cf3
    // https://towardsdatascience.com/extended-kalman-filter-43e52b16757d
    // https://towardsdatascience.com/the-unscented-kalman-filter-anything-ekf-can-do-i-can-do-it-better-ce7c773cf88d
    public class CS_Kalman_CSharp_Basics : CS_Parent
    {
        public float kInput;
        public float kOutput;
        public float kAverage;
        float[,] P = new float[,] { { 1, 0 }, { 0, 1 } }; // 2x2 This is the covariance matrix
        float q_bias;
        float outputError = 0.002f;
        float processCovar = 0.001f; // This is the process covariance matrix. It's how much we trust the accelerometer
        List<float> matrix = new List<float>();
        Plot_OverTimeScalar plot = new Plot_OverTimeScalar();
        int saveAvgCount = 0;
        Options_Kalman options = new Options_Kalman();
        public CS_Kalman_CSharp_Basics(VBtask task) : base(task)
        {
            labels[2] = "Blue = grayscale mean after Kalman, green is grayscale mean value without Kalman, red is the grayscale average without Kalman";
            desc = "Build a generic kalman filter based on Kalman_CSharp";
        }
        public void State_Update(float q_m)
        {
            float unbias = q_m - q_bias; // Unbias our gyro
            float[] Pdot = new float[] { processCovar - P[0, 1] - P[1, 0], -P[1, 1], -P[1, 1], options.pdotEntry };
            kOutput += unbias * options.delta;
            plot.plotCount = 3;
            // Update the covariance matrix
            P[0, 0] += Pdot[0] * options.delta;
            P[0, 1] += Pdot[1] * options.delta;
            P[1, 0] += Pdot[2] * options.delta;
            P[1, 1] += Pdot[3] * options.delta;
        }
        public void Kalman_Update()
        {
            float kError = kInput - kOutput;
            float C_0 = 1;
            float PCt_0 = C_0 * P[0, 0]; // + C_1 * P[0, 1] 'This second part is always 0, so we don't bother
            float PCt_1 = C_0 * P[1, 0]; // + C_1 * P[1, 1]
            float err = outputError + C_0 * PCt_0; // Compute the error estimate.
            float K_0 = PCt_0 / err; // Compute the Kalman filter gains
            float K_1 = PCt_1 / err;
            float t_0 = PCt_0;
            float t_1 = C_0 * P[0, 1];
            P[0, 0] -= K_0 * t_0; // Update covariance matrix
            P[0, 1] -= K_0 * t_1;
            P[1, 0] -= K_1 * t_0;
            P[1, 1] -= K_1 * t_1;
            kOutput += K_0 * kError; // Update our state estimate
            q_bias += K_1 * kError;
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (standaloneTest()) kInput = (float)src.CvtColor(cv.ColorConversionCodes.BGR2GRAY).Mean()[0];
            if (options.averageInputCount != saveAvgCount)
            {
                saveAvgCount = options.averageInputCount;
                matrix.Clear();
                for (int i = 0; i < saveAvgCount; i++)
                {
                    matrix.Add(kInput);
                }
            }
            matrix[task.frameCount % saveAvgCount] = kInput;
            kAverage = (float)(new Mat(saveAvgCount, 1, MatType.CV_32F, matrix.ToArray())).Mean()[0];
            if (task.gOptions.GetUseKalman())
            {
                // The Kalman Filter code comes from:
                // http://www.rotomotion.com/downloads/tilt.c
                State_Update(kInput);
                Kalman_Update();
            }
            else
            {
                kOutput = kInput;
            }
            if (standaloneTest())
            {
                plot.plotData = new Scalar(kOutput, kInput, kAverage);
                plot.Run(empty);
                dst2 = plot.dst2;
                dst3 = plot.dst3;
            }
            labels[3] = "Move the camera around to see the impact of the Kalman filter.";
        }
    }
    public class CS_KLT_Basics : CS_Parent
    {
        public Mat status = new Mat();
        public Mat outputMat = new Mat();
        public Scalar circleColor = Scalar.Red;
        public Options_KLT options = new Options_KLT();
        Mat lastGray;
        public CS_KLT_Basics(VBtask task) : base(task)
        {
            desc = "Track movement with Kanada-Lucas-Tomasi algorithm";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            if (options.nightMode)
                dst2.SetTo(0);
            else
                src.CopyTo(dst2);
            if (task.FirstPass) lastGray = src.Clone();
            if (src.Channels() == 3)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            TermCriteria term = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 10, 1.0);
            if (options.inputPoints == null)
            {
                options.inputPoints = Cv2.GoodFeaturesToTrack(src, options.maxCorners, options.qualityLevel,
                                                              options.minDistance, new Mat(), options.blockSize, false, 0);
                if (options.inputPoints.Length > 0)
                {
                    options.inputPoints = Cv2.CornerSubPix(src, options.inputPoints, options.subPixWinSize, new cv.Size(-1, -1), term);
                }
                outputMat = new Mat(options.inputPoints.Length, 1, MatType.CV_32FC2, options.inputPoints);
                status = new Mat(outputMat.Rows, outputMat.Cols, MatType.CV_8U, 1);
            }
            else if (options.inputPoints.Length > 0)
            {
                Mat err = new Mat();
                // convert the point2f vector to an inputarray (cv.Mat)
                Mat inputMat = new Mat(options.inputPoints.Length, 1, MatType.CV_32FC2, options.inputPoints);
                outputMat = inputMat.Clone();
                Cv2.CalcOpticalFlowPyrLK(lastGray, src, inputMat, outputMat, status, err, options.winSize, 3, term, OpticalFlowFlags.None);
                int k = 0;
                for (int i = 0; i < options.inputPoints.Length; i++)
                {
                    if (status.Get<byte>(i) != 0)
                    {
                        options.inputPoints[k] = outputMat.Get<Point2f>(i);
                        k++;
                    }
                }
                Array.Resize(ref options.inputPoints, k);
            }
            for (int i = 0; i < outputMat.Rows; i++)
            {
                Point2f pt = outputMat.Get<Point2f>(i);
                if (pt.X >= 0 && pt.X <= src.Cols && pt.Y >= 0 && pt.Y <= src.Rows)
                {
                    if (status.Get<byte>(i) != 0)
                    {
                        DrawCircle(dst2, pt, task.DotSize + 1, circleColor);
                    }
                }
                else
                {
                    status.Set<byte>(i, 0); // this point is not visible!
                }
            }
            lastGray = src.Clone();
            labels[2] = "KLT Basics - " + (options.inputPoints == null ? "0" : options.inputPoints.Length.ToString()) + " points";
        }
    }
    public class CS_KLT_OpticalFlow : CS_Parent
    {
        KLT_Basics klt = new KLT_Basics();
        Point2f[] lastpoints;
        public CS_KLT_OpticalFlow(VBtask task) : base(task)
        {
            desc = "KLT optical flow - needs more work";
        }
        public void RunCS(Mat src)
        {
            klt.Run(src);
            if (task.frameCount > 0 && lastpoints != null && klt.options.inputPoints != null)
            {
                dst2 = klt.dst2;
                src.CopyTo(dst3);
                for (int i = 0; i < klt.options.inputPoints.Length; i++)
                {
                    if (klt.status.Get<byte>(i) != 0 && i < lastpoints.Length && i < klt.options.inputPoints.Length)
                    {
                        // DrawLine(dst2, lastpoints[i], klt.inputPoints[i], Scalar.Yellow, task.lineWidth + 1, task.lineType);
                        // static Point2f[] lastFlowPoints = klt.inputPoints;
                        // DrawLine(dst3, lastFlowPoints[i], klt.inputPoints[i], Scalar.Yellow, task.lineWidth + 1, task.lineType);
                        // if (task.heartBeat) lastFlowPoints = klt.inputPoints;
                    }
                }
            }
            lastpoints = klt.options.inputPoints;
        }
    }
    public class CS_KMeans_Basics : CS_Parent
    {
        public Options_KMeans options = new Options_KMeans();
        public Mat colors = new Mat();
        public bool buildPaletteOutput = true;
        public Mat saveLabels = new Mat();
        public int classCount;
        int lastK = 0;
        public CS_KMeans_Basics(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "", "Palette output for the kMeans labels" };
            desc = "Cluster the input using kMeans.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest() && src.Channels() != 1)
                src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            options.RunVB();
            classCount = options.kMeansK;
            if (task.FirstPass) lastK = classCount;
            if (task.optionsChanged || lastK != classCount)
            {
                options.kMeansFlag = KMeansFlags.PpCenters;
                saveLabels = new Mat();
            }
            var columnVector = src.Reshape(src.Channels(), src.Height * src.Width);
            dst2 = saveLabels;
            if (columnVector.ElemSize() % 4 != 0 || columnVector.Type() == MatType.CV_32S)
                columnVector.ConvertTo(columnVector, MatType.CV_32F);
            TermCriteria term = new TermCriteria(CriteriaTypes.Eps | CriteriaTypes.Count, 10, 1.0);
            try
            {
                if (colors.Width == 0 || colors.Height == 0)
                    options.kMeansFlag = KMeansFlags.PpCenters;
                Cv2.Kmeans(columnVector, classCount, dst2, term, 1, options.kMeansFlag, colors);
            }
            catch (Exception)
            {
                columnVector.SetTo(0);
                dst2.SetTo(0);
                Cv2.Kmeans(columnVector, classCount, dst2, term, 1, options.kMeansFlag, colors);
            }
            saveLabels = dst2.Clone();
            dst2.Reshape(1, src.Height).ConvertTo(dst2, MatType.CV_8U);
            dst3 = ShowPalette(dst2 * 255 / classCount);
            lastK = classCount;
            labels[2] = "KMeans labels 0-" + lastK.ToString() + " spread out across 255 values.";
        }
    }
    public class CS_KMeans_MultiChannel : CS_Parent
    {
        public Mat colors = new Mat();
        KMeans_Basics km = new KMeans_Basics();
        public CS_KMeans_MultiChannel(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "KMeans_Basics output with BGR input", "dst3 contains the labels spread across the palette (dst0 contains the exact labels)" };
            desc = "Cluster the input using kMeans.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
                task.color.ConvertTo(src, MatType.CV_32FC3);
            if (src.Type() == MatType.CV_8UC3)
                src.ConvertTo(src, MatType.CV_32FC3);
            if (src.Type() == MatType.CV_8U)
                src.ConvertTo(src, MatType.CV_32F);
            km.Run(src);
            dst3 = km.dst2;
            dst2 = ShowPalette(dst3 * 255 / km.classCount);
        }
    }
    public class CS_KMeans_k2_to_k8 : CS_Parent
    {
        Mat_4Click Mats = new Mat_4Click();
        KMeans_Basics km = new KMeans_Basics();
        int kmIndex;
        System.Windows.Forms.TrackBar kSlider;
        public CS_KMeans_k2_to_k8(VBtask task) : base(task)
        {
            kSlider = FindSlider("KMeans k");
            labels[2] = "kmeans - k=2,4,6,8";
            desc = "Show clustering with various settings for cluster count.  Draw to select region of interest.";
        }
        public void RunCS(Mat src)
        {
            if (task.frameCount % 100 == 0)
            {
                kmIndex++;
                if (kmIndex >= 4) kmIndex = 0;
            }
            kSlider.Value = 2;
            if (kmIndex == 1) kSlider.Value = 4;
            if (kmIndex == 2) kSlider.Value = 6;
            if (kmIndex == 3) kSlider.Value = 8;
            km.Run(src.CvtColor(ColorConversionCodes.BGR2GRAY));
            Mats.mat[kmIndex] = km.dst2 * 255 / km.classCount;
            Mats.Run(empty);
            dst2 = Mats.dst2;
            dst3 = Mats.dst3;
        }
    }
    public class CS_KMeans_Fuzzy : CS_Parent
    {
        KMeans_Image km = new KMeans_Image();
        public Fuzzy_Basics fuzzyD = new Fuzzy_Basics();
        public CS_KMeans_Fuzzy(VBtask task) : base(task)
        {
            labels[3] = "The white marks areas that are busy while the black marks areas that are consistent in color - not fuzzy.";
            desc = "Use the KMeans output as input to the Fuzzy detector - those areas which have little info";
        }
        public void RunCS(Mat src)
        {
            km.Run(src);
            dst2 = km.km.dst2;
            fuzzyD.Run(dst2);
            dst3 = fuzzyD.dst3;
        }
    }
    public class CS_KMeans_MultiGaussian_CPP : CS_Parent
    {
        public CS_KMeans_MultiGaussian_CPP(VBtask task) : base(task)
        {
            cPtr = KMeans_MultiGaussian_Open();
            desc = "Use KMeans on a random multi-gaussian distribution.";
        }
        public void RunCS(Mat src)
        {
            IntPtr imagePtr = KMeans_MultiGaussian_RunCPP(cPtr, src.Rows, src.Cols);
            if (imagePtr != IntPtr.Zero && task.heartBeat)
                dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr).Clone();
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = KMeans_MultiGaussian_Close(cPtr);
        }
    }
    public class CS_KMeans_CustomData : CS_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        public Mat centers = new Mat();
        Random_Basics random = new Random_Basics();
        System.Windows.Forms.TrackBar randslider;
        public CS_KMeans_CustomData(VBtask task) : base(task)
        {
            randslider = FindSlider("Random Pixel Count");
            desc = "Cluster the selected input using kMeans";
        }
        public void RunCS(Mat src)
        {
            km.options.RunVB();
            int k = km.options.kMeansK;
            if (src.Rows < k) k = src.Rows;
            if (standaloneTest())
            {
                if (task.FirstPass) randslider.Value = 50;
                if (randslider.Value < k) randslider.Value = k;
                if (task.heartBeat) random.Run(empty);
                var input = new List<float>();
                foreach (var pt in random.PointList)
                {
                    input.Add(pt.X);
                    input.Add(pt.Y);
                }
                dst0 = new Mat(input.Count(), 1, MatType.CV_32F, input.ToArray());
            }
            km.Run(dst0);
            dst2 = ShowPalette(km.dst2 * 255 / km.classCount);
        }
    }
    public class CS_KMeans_Simple_CPP : CS_Parent
    {
        public CS_KMeans_Simple_CPP(VBtask task) : base(task)
        {
            cPtr = Kmeans_Simple_Open();
            desc = "Split the input into 3 levels - zero (no depth), closer to min, closer to max.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest()) src = task.pcSplit[2];
            if (src.Channels() != 1) src = src.CvtColor(ColorConversionCodes.BGR2GRAY);
            var mm = GetMinMax(src, task.depthMask);
            byte[] cppData = new byte[src.Total() * src.ElemSize()];
            Marshal.Copy(src.Data, cppData, 0, cppData.Length);
            GCHandle handleSrc = GCHandle.Alloc(cppData, GCHandleType.Pinned);
            IntPtr imagePtr = Kmeans_Simple_RunCPP(cPtr, handleSrc.AddrOfPinnedObject(), src.Rows, src.Cols, (float)mm.minVal, task.gOptions.getMaxDepthBar());
            handleSrc.Free();
            dst2 = new Mat(src.Rows, src.Cols, MatType.CV_8UC3, imagePtr);
            SetTrueText("Use 'Max Depth' in the global options to set the boundary between blue and yellow.", 3);
        }
        public void Close()
        {
            if (cPtr != IntPtr.Zero)
                cPtr = Kmeans_Simple_Close(cPtr);
        }
    }
    public class CS_KMeans_Edges : CS_Parent
    {
        Edge_Canny edges = new Edge_Canny();
        public KMeans_Image km = new KMeans_Image();
        public int classCount;
        RedCloud_Basics redC = new RedCloud_Basics();
        public CS_KMeans_Edges(VBtask task) : base(task)
        {
            task.redOptions.setUseColorOnly(true);
            labels[3] = "KMeans with edges output";
            desc = "Use edges to isolate regions in the KMeans output - not much different from KMeans_Basics.";
        }
        public void RunCS(Mat src)
        {
            edges.Run(src);
            src.SetTo(Scalar.White, edges.dst2);
            km.Run(src);
            dst3 = km.dst2 + 1;
            classCount = km.classCount;
            redC.Run(dst3);
            dst2 = redC.dst2;
            labels[2] = redC.labels[3];
        }
    }
    public class CS_KMeans_CompareMulti : CS_Parent
    {
        KMeans_Image km = new KMeans_Image();
        KMeans_MultiChannel multi = new KMeans_MultiChannel();
        public CS_KMeans_CompareMulti(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "KMeans_Basics output", "KMeans on all 3 channels - recombined" };
            desc = "Compare the results of using grayscale KMeans with multi-channel KMeans";
        }
        public void RunCS(Mat src)
        {
            km.Run(src);
            dst2 = km.dst2;
            dst2 = ShowPalette(dst2);
            multi.Run(src);
            dst3 = multi.dst2;
            labels[2] = "";
        }
    }
    public class CS_KMeans_TierCount : CS_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        Depth_TierCount kCount = new Depth_TierCount();
        public int classCount;
        System.Windows.Forms.TrackBar kSlider;
        public CS_KMeans_TierCount(VBtask task) : base(task)
        {
            kSlider = FindSlider("KMeans k");
            desc = "Use the Histogram valleys to find the best 'K' value for the current depth data";
        }
        public void RunCS(Mat src)
        {
            kCount.Run(src);
            if (kSlider.Value != kCount.classCount) kSlider.Value = Math.Max(kCount.classCount, kSlider.Minimum);
            classCount = kCount.classCount;
            km.Run(task.pcSplit[2]);
            dst2 = km.dst2 * 255 / km.classCount;
            dst2.SetTo(0, task.noDepthMask);
            dst3 = ShowPalette(dst2);
            labels[2] = "There were " + classCount.ToString() + " tiers (on average) found in the depth valleys histogram.";
        }
    }
    public class CS_KMeans_Image : CS_Parent
    {
        public KMeans_Basics km = new KMeans_Basics();
        public List<Mat> masks = new List<Mat>();
        public List<int> counts = new List<int>();
        public int classCount;
        int maskIndex;
        public CS_KMeans_Image(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "KMeans output after Palette run", "Each of the KMeans masks is displayed below in rotation." };
            desc = "Cluster the input image pixels using kMeans and allow any region to be selected for highlight in dst3.";
        }
        public void RunCS(Mat src)
        {
            km.Run(src);
            dst2 = ShowPalette(km.dst2 * 255 / km.classCount);
            classCount = km.options.kMeansK;
            masks.Clear();
            counts.Clear();
            int k = km.options.kMeansK;
            for (int i = 0; i < k; i++)
            {
                Mat mask = km.dst2.InRange(i, i);
                masks.Add(mask);
                counts.Add(mask.CountNonZero());
            }
            if (task.heartBeat) maskIndex++;
            if (maskIndex >= masks.Count()) maskIndex = 0;
            dst3 = masks[maskIndex];
        }
    }
    public class CS_KMeans_DepthPlusGray : CS_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        Mat[] grayPlus = new Mat[2];
        public CS_KMeans_DepthPlusGray(VBtask task) : base(task)
        {
            km.buildPaletteOutput = false;
            labels[3] = "KMeans 8-bit results";
            grayPlus[0] = new Mat(task.WorkingRes, MatType.CV_32F, 0);
            desc = "Cluster the rgb+depth image pixels using kMeans";
        }
        public void RunCS(Mat src)
        {
            src.CvtColor(cv.ColorConversionCodes.BGR2GRAY).ConvertTo(grayPlus[0], MatType.CV_32F);
            grayPlus[0].SetTo(0, task.noDepthMask);
            grayPlus[1] = task.pcSplit[2];
            Mat merge = new Mat();
            Cv2.Merge(grayPlus, merge);
            km.Run(merge);
            int k = km.options.kMeansK;
            dst3 = km.dst2;
            dst3.SetTo(0, task.noDepthMask);
            if (standaloneTest()) dst2 = ShowPalette(km.dst2 * 255 / k);
        }
    }
    public class CS_KMeans_Dimensions : CS_Parent
    {
        public KMeans_Basics km = new KMeans_Basics();
        System.Windows.Forms.TrackBar dimSlider;
        public CS_KMeans_Dimensions(VBtask task) : base(task)
        {
            dimSlider = FindSlider("Dimension");
            desc = "Demonstrate how to use KMeans for a variety of dimensions";
        }
        public void RunCS(Mat src)
        {
            Mat merge = new Mat();
            switch (dimSlider.Value)
            {
                case 1: // grayscale
                    if (src.Channels() == 1)
                    {
                        src.ConvertTo(merge, MatType.CV_32F);
                    }
                    else
                    {
                        src.CvtColor(cv.ColorConversionCodes.BGR2GRAY).ConvertTo(merge, MatType.CV_32F);
                    }
                    break;
                case 2: // pointcloud x and y
                    Cv2.Merge(new Mat[] { task.pcSplit[0], task.pcSplit[1] }, merge);
                    break;
                case 3: // pointcloud dimensions
                    merge = task.pointCloud;
                    break;
                case 4: // color + depth
                    src.ConvertTo(src, MatType.CV_32F);
                    task.pcSplit[2] = task.pcSplit[2].Normalize(0, 255, NormTypes.MinMax);
                    Cv2.Merge(new Mat[] { src, task.pcSplit[2] }, merge);
                    break;
                case 5: // color + pcSplit(0) and pcSplit(1)
                    src.ConvertTo(src, MatType.CV_32F);
                    task.pcSplit[0] = task.pcSplit[0].Normalize(0, 255, NormTypes.MinMax);
                    task.pcSplit[1] = task.pcSplit[1].Normalize(0, 255, NormTypes.MinMax);
                    Cv2.Merge(new Mat[] { src, task.pcSplit[0], task.pcSplit[1] }, merge);
                    break;
                case 6: // color + pointcloud
                    src.ConvertTo(src, MatType.CV_32F);
                    Mat tmp1 = task.pcSplit[0].Normalize(0, 255, NormTypes.MinMax);
                    Mat tmp2 = task.pcSplit[1].Normalize(0, 255, NormTypes.MinMax);
                    Mat tmp3 = task.pcSplit[2].Normalize(0, 255, NormTypes.MinMax);
                    Cv2.Merge(new Mat[] { src, tmp1, tmp2, tmp3 }, merge);
                    break;
            }
            km.Run(merge);
            labels[2] = "Dimension = " + dimSlider.Value.ToString();
            labels[3] = labels[2];
            dst2 = km.dst2 + 1;
            dst3 = ShowPalette(dst2 * 255 / km.classCount);
        }
    }
    public class CS_KMeans_Valleys : CS_Parent
    {
        KMeans_Basics km = new KMeans_Basics();
        KMeans_TierCount tiers = new KMeans_TierCount();
        System.Windows.Forms.TrackBar kSlider;
        public CS_KMeans_Valleys(VBtask task) : base(task)
        {
            kSlider = FindSlider("KMeans k");
            labels[2] = "8-Bit input to vbPalette output in dst3";
            desc = "Cluster depth using kMeans - use KMeans_TierCount to determine 'K'";
        }
        public void RunCS(Mat src)
        {
            tiers.Run(src);
            kSlider.Value = tiers.classCount;
            int kMeansK = kSlider.Value;
            km.Run(task.pcSplit[2]);
            dst2 = km.dst2 + 1;
            dst3 = ShowPalette(dst2 * 255 / tiers.classCount);
            dst3.SetTo(0, task.noDepthMask);
        }
    }
    public class CS_KMeans_Depth : CS_Parent
    {
        public KMeans_Basics km = new KMeans_Basics();
        public int classCount;
        public CS_KMeans_Depth(VBtask task) : base(task)
        {
            FindSlider("KMeans k").Value = 10;
            labels[2] = "";
            desc = "Cluster depth using kMeans - useful to split foreground and background";
        }
        public void RunCS(Mat src)
        {
            km.Run(task.pcSplit[2]);
            dst2 = km.dst2 + 1;
            dst2.SetTo(0, task.noDepthMask);
            classCount = km.classCount;
            dst3 = ShowPalette(dst2 * 255 / classCount);
            labels[2] = "Palettized version of the " + classCount.ToString() + " 8UC1 classes";
        }
    }
    public class CS_KMeans_SimKColor : CS_Parent
    {
        Hist3Dcolor_PlotHist1D plot1D = new Hist3Dcolor_PlotHist1D();
        Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public int classCount;
        Mat histogram = new Mat();
        public CS_KMeans_SimKColor(VBtask task) : base(task)
        {
            desc = "Use the gaps in the 3D histogram of the color image to find 'k' and backproject the results.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                plot1D.Run(src);
                dst3 = plot1D.dst2;
                labels[3] = "The 3D histogram of the RGB image stream in 1D - note the number of gaps";
                simK.Run(plot1D.histogram1D);
                histogram = simK.dst2;
                classCount = simK.classCount;
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 0, 1, 2 }, histogram, dst1, task.redOptions.rangesBGR);
            dst2 = ShowPalette(dst1 * 255 / classCount);
            labels[2] = simK.labels[2] + " with " + task.redOptions.getHistBins3D().ToString() + " histogram bins";
        }
    }
    public class CS_KMeans_SimKDepth : CS_Parent
    {
        Hist3Dcloud_PlotHist1D plot1D = new Hist3Dcloud_PlotHist1D();
        Hist3D_BuildHistogram simK = new Hist3D_BuildHistogram();
        public int classCount;
        public CS_KMeans_SimKDepth(VBtask task) : base(task)
        {
            desc = "Use the gaps in the 3D histogram of depth to find simK and backproject the results.";
        }
        public void RunCS(Mat src)
        {
            if (src.Type() != MatType.CV_32FC3) src = task.pointCloud;
            if (task.heartBeat)
            {
                plot1D.Run(src);
                dst3 = plot1D.dst2;
                labels[3] = "The 3D histogram of the depth stream in 1D";
                simK.Run(plot1D.histogram);
                plot1D.histogram = simK.dst2;
                classCount = simK.classCount;
            }
            Cv2.CalcBackProject(new Mat[] { src }, new int[] { 2 }, plot1D.histogram, dst1, task.redOptions.rangesCloud);
            dst1 = dst1.ConvertScaleAbs();
            dst2 = ShowPalette(dst1 * 255 / classCount);
            labels[2] = simK.labels[2] + " with " + task.redOptions.getHistBins3D().ToString() + " histogram bins";
        }
    }
    public class CS_KNN_Basics : CS_Parent
    {
        public List<PointPair> matches = new List<PointPair>();
        public List<Point2f> noMatch = new List<Point2f>();
        public KNN_Core knn = new KNN_Core();
        public List<Point2f> queries = new List<Point2f>();
        public List<int> neighbors = new List<int>();
        Random_Basics random = new Random_Basics();
        public CS_KNN_Basics(VBtask task) : base(task)
        {
            labels[2] = "KNN_Core output with many-to-one results";
            labels[3] = "CS_CS_KNN_Basics output with just the closest match.  Red = training data, yellow = queries.";
            desc = "Map points 1:1 with losses. Toss any farther duplicates. Easier to follow than previous version.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (task.heartBeat)
                {
                    random.Run(empty);
                    knn.trainInput = new List<Point2f>(random.PointList);
                }
                random.Run(empty);
                queries = new List<Point2f>(random.PointList);
            }
            if (queries.Count() == 0)
            {
                SetTrueText("Place some input points in queries before starting the knn run.");
                return;
            }
            knn.queries = queries;
            knn.Run(empty);
            knn.displayResults();
            dst2 = knn.dst2;
            neighbors.Clear();
            for (int i = 0; i < knn.neighbors.Count(); i++)
            {
                neighbors.Add(knn.neighbors[i][0]);
            }
            for (int i = 0; i < neighbors.Count(); i++)
            {
                var p1 = knn.queries[i];
                if (neighbors[i] == -1) continue;
                var ptn = knn.trainInput[neighbors[i]];
                for (int j = i + 1; j < neighbors.Count(); j++)
                {
                    if (neighbors[j] == neighbors[i])
                    {
                        var p2 = knn.queries[j];
                        var d1 = p1.DistanceTo(ptn);
                        var d2 = p2.DistanceTo(ptn);
                        neighbors[d1 > d2 ? i : j] = -1;
                    }
                }
            }
            dst3.SetTo(0);
            foreach (var pt in knn.trainInput)
            {
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Red);
            }
            noMatch.Clear();
            matches.Clear();
            for (int i = 0; i < neighbors.Count(); i++)
            {
                var pt = queries[i];
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Yellow);
                if (neighbors[i] == -1)
                {
                    noMatch.Add(pt);
                }
                else
                {
                    var nn = knn.trainInput[neighbors[i]];
                    matches.Add(new PointPair(pt, nn));
                    DrawLine(dst3, nn, pt, Scalar.White);
                }
            }
            if (!standaloneTest()) knn.trainInput = new List<Point2f>(queries);
        }
    }
    public class CS_CS_KNN_Core : CS_Parent
    {
        public KNearest knn;
        public List<Point2f> trainInput = new List<Point2f>(); // put training data here
        public List<Point2f> queries = new List<Point2f>(); // put Query data here
        public List<List<int>> neighbors = new List<List<int>>();
        public int[,] result; // Get results here...
        public int desiredMatches = -1; // -1 indicates it is to use the number of queries.
        Random_Basics random = new Random_Basics();
        public CS_CS_KNN_Core(VBtask task) : base(task)
        {
            knn = KNearest.Create();
            labels[2] = "Red=TrainingData, yellow = queries";
            desc = "Train a KNN model and map each query to the nearest training neighbor.";
        }
        public void displayResults()
        {
            dst2.SetTo(0);
            int dm = Math.Min(trainInput.Count(), queries.Count());
            for (int i = 0; i < queries.Count(); i++)
            {
                var pt = queries[i];
                var test = result[i, 0];
                if (test >= trainInput.Count() || test < 0) continue;
                var nn = trainInput[result[i, 0]];
                DrawCircle(dst2, pt, task.DotSize + 4, Scalar.Yellow);
                DrawLine(dst2, pt, nn, Scalar.Yellow);
            }
            foreach (var pt in trainInput)
            {
                DrawCircle(dst2, pt, task.DotSize + 4, Scalar.Red);
            }
        }
        public void RunCS(Mat src)
        {
            int KNNdimension = 2;
            if (standalone)
            {
                if (task.heartBeat)
                {
                    random.Run(empty);
                    trainInput = new List<Point2f>(random.PointList);
                }
                random.Run(empty);
                queries = new List<Point2f>(random.PointList);
            }
            var queryMat = new Mat(queries.Count(), KNNdimension, MatType.CV_32F, queries.ToArray());
            if (queryMat.Rows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            if (trainInput.Count() == 0) trainInput = new List<Point2f>(queries); // first pass, just match the queries.
            var trainData = new Mat(trainInput.Count(), KNNdimension, MatType.CV_32F, trainInput.ToArray());
            var response = new Mat(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            var neighborMat = new Mat();
            int dm = desiredMatches < 0 ? trainInput.Count() : desiredMatches;
            knn.FindNearest(queryMat, dm, new Mat(), neighborMat);
            if (neighborMat.Rows != queryMat.Rows || neighborMat.Cols != dm)
            {
                Console.WriteLine("KNN's FindNearest did not return the correct number of neighbors.  Marshal.copy will fail so exit.");
                return;
            }
            float[] nData = new float[queryMat.Rows * dm];
            if (nData.Length == 0) return;
            Marshal.Copy(neighborMat.Data, nData, 0, nData.Length);
            for (int i = 0; i < nData.Length; i++)
            {
                if (Math.Abs(nData[i]) > trainInput.Count()) nData[i] = 0; // value must be within the range of traininput
            }
            result = new int[queryMat.Rows, dm];
            neighbors = new List<List<int>>();
            for (int i = 0; i < queryMat.Rows; i++)
            {
                var pt = queries[i];
                var res = new List<int>();
                for (int j = 0; j < dm; j++)
                {
                    var test = nData[i * dm + j];
                    if (test < nData.Length && test >= 0)
                    {
                        result[i, j] = (int)nData[i * dm + j];
                        int index = (int)nData[i * dm + j];
                        res.Add(index);
                    }
                }
                neighbors.Add(res);
            }
            if (standaloneTest()) displayResults();
        }
    }
    public class CS_CS_KNN_Core2DTest : CS_Parent
    {
        public KNN_Core knn = new KNN_Core();
        Random_Basics random = new Random_Basics();
        public CS_CS_KNN_Core2DTest(VBtask task) : base(task)
        {
            FindSlider("Random Pixel Count").Value = 10;
            desc = "Test knn with random 2D points in the image.  Find the nearest requested neighbors.";
        }
        public void accumulateDisplay()
        {
            int dm = Math.Min(knn.trainInput.Count(), knn.queries.Count());
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                var pt = knn.queries[i];
                var test = knn.result[i, 0];
                if (test >= knn.trainInput.Count() || test < 0) continue;
                var nn = knn.trainInput[knn.result[i, 0]];
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Yellow);
                DrawLine(dst3, pt, nn, Scalar.Yellow);
            }
            foreach (var pt in knn.trainInput)
            {
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Red);
            }
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                dst3.SetTo(0);
                random.Run(empty);
                knn.trainInput = new List<Point2f>(random.PointList);
            }
            random.Run(empty);
            knn.queries = new List<Point2f>(random.PointList);
            knn.Run(empty);
            knn.displayResults();
            dst2 = knn.dst2;
            accumulateDisplay();
            labels[2] = "The top " + knn.trainInput.Count() + " best matches are shown. Red=TrainingData, yellow = queries";
        }
    }
    public class CS_CS_KNN_Core3D : CS_Parent
    {
        public KNearest knn;
        public List<Point3f> trainInput = new List<Point3f>(); // put training data here
        public List<Point3f> queries = new List<Point3f>(); // put Query data here
        public int[,] result; // Get results here...
        public CS_CS_KNN_Core3D(VBtask task) : base(task)
        {
            knn = KNearest.Create();
            desc = "Use knn with the input 3D points in the image.  Find the nearest neighbors.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().  Use the " + traceName + "Test algorithm");
                return;
            }
            int KNNdimension = 3;
            var queryMat = new Mat(queries.Count(), KNNdimension, MatType.CV_32F, queries.ToArray());
            if (queryMat.Rows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            if (trainInput.Count() == 0) trainInput = new List<Point3f>(queries); // first pass, just match the queries.
            var trainData = new Mat(trainInput.Count(), KNNdimension, MatType.CV_32F, trainInput.ToArray());
            var response = new Mat(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            var neighbors = new Mat();
            int dm = trainInput.Count();
            knn.FindNearest(queryMat, dm, new Mat(), neighbors);
            float[] nData = new float[queryMat.Rows * dm];
            Marshal.Copy(neighbors.Data, nData, 0, nData.Length);
            result = new int[queryMat.Rows, dm];
            for (int i = 0; i < queryMat.Rows; i++)
            {
                for (int j = 0; j < dm; j++)
                {
                    var test = nData[i * dm + j];
                    if (test < nData.Length && test >= 0) result[i, j] = (int)nData[i * dm + j];
                }
            }
        }
    }
    public class CS_KNN_Core4D : CS_Parent
    {
        public KNearest knn;
        public List<Vec4f> trainInput = new List<Vec4f>(); // put training data here
        public List<Vec4f> queries = new List<Vec4f>(); // put Query data here
        public int[,] result; // Get results here...
        public CS_KNN_Core4D(VBtask task) : base(task)
        {
            knn = KNearest.Create();
            labels[2] = "Red=TrainingData, yellow = queries, text shows Z distance to that point from query point";
            desc = "Use knn with the input 4D points in the image.  Find the nearest neighbors.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().  Use the " + traceName + "Test algorithm");
                return;
            }
            int KNNdimension = 4;
            Mat queryMat = new Mat(queries.Count(), KNNdimension, MatType.CV_32F, queries.ToArray());
            if (queryMat.Rows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            if (trainInput.Count() == 0) trainInput = new List<Vec4f>(queries); // first pass, just match the queries.
            Mat trainData = new Mat(trainInput.Count(), KNNdimension, MatType.CV_32F, trainInput.ToArray());
            Mat response = new Mat(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            Mat neighbors = new Mat();
            int dm = trainInput.Count();
            knn.FindNearest(queryMat, dm, new Mat(), neighbors);
            float[] nData = new float[queryMat.Rows * dm];
            Marshal.Copy(neighbors.Data, nData, 0, nData.Length);
            result = new int[queryMat.Rows, dm];
            for (int i = 0; i < queryMat.Rows; i++)
            {
                for (int j = 0; j < dm; j++)
                {
                    float test = nData[i * dm + j];
                    if (test < nData.Length && test >= 0) result[i, j] = (int)nData[i * dm + j];
                }
            }
        }
    }
    public class CS_KNN_CoreN : CS_Parent
    {
        public KNearest knn;
        public List<float> trainInput = new List<float>(); // put training data here
        public List<float> queries = new List<float>(); // put Query data here
        public int[,] result; // Get results here...
        bool messageSent;
        public Options_KNN options = new Options_KNN();
        public CS_KNN_CoreN(VBtask task) : base(task)
        {
            knn = KNearest.Create();
            desc = "Generalize the use knn with X input points.  Find the nearest requested neighbors.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();
            IEnumerable<int> responseList = Enumerable.Range(0, 10);
            if (standaloneTest())
            {
                SetTrueText("There is no output for the " + traceName + " algorithm when run standaloneTest().  Use the " + traceName + "_Test algorithm");
                return;
            }
            if (options.knnDimension == 0)
            {
                if (!messageSent)
                {
                    MessageBox.Show("The KNN dimension needs to be set for the general purpose KNN_Core to start");
                    messageSent = true;
                }
                return;
            }
            int qRows = (int)(queries.Count() / options.knnDimension);
            if (qRows == 0)
            {
                SetTrueText("There were no queries provided.  There is nothing to do...");
                return;
            }
            Mat queryMat = new Mat(qRows, options.knnDimension, MatType.CV_32F, queries.ToArray());
            Mat trainData = new Mat((int)(trainInput.Count() / options.knnDimension), options.knnDimension, MatType.CV_32F, trainInput.ToArray());
            Mat response = new Mat(trainData.Rows, 1, MatType.CV_32S, Enumerable.Range(0, trainData.Rows).ToArray());
            knn.Train(trainData, SampleTypes.RowSample, response);
            Mat neighbors = new Mat();
            int dm = trainInput.Count();
            knn.FindNearest(queryMat, dm, new Mat(), neighbors);
            result = new int[neighbors.Rows, neighbors.Cols];
            for (int i = 0; i < neighbors.Rows; i++)
            {
                for (int j = 0; j < neighbors.Cols; j++)
                {
                    float test = neighbors.Get<float>(i, j);
                    if (test < trainInput.Count() && test >= 0) result[i, j] = neighbors.Get<int>(i, j);
                }
            }
        }
    }
    public class CS_KNN_Core3DTest : CS_Parent
    {
        KNN_Core3D knn = new KNN_Core3D();
        Distance_Point3D dist = new Distance_Point3D();
        Random_Basics3D random = new Random_Basics3D();
        public CS_KNN_Core3DTest(VBtask task) : base(task)
        {
            labels[2] = "Red=TrainingData, yellow = queries, text shows Euclidean distance to that point from query point";
            FindSlider("Random Pixel Count").Value = 100;
            desc = "Validate that knn works with random 3D points in the image.  Find the nearest requested neighbors.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                knn.queries.Clear();
                knn.trainInput.Clear();
                random.Run(empty);
                foreach (var pt in random.PointList)
                {
                    var vec = task.pointCloud.Get<Point3f>((int)pt.Y, (int)pt.X);
                    if (knn.trainInput.Count() == 10)
                    {
                        if (vec.Z != 0)
                        {
                            knn.queries.Add(pt);
                            break;
                        }
                    }
                    else
                    {
                        if (vec.Z != 0) knn.trainInput.Add(pt);
                    }
                }
            }
            knn.Run(empty);
            dst2.SetTo(0);
            dist.inPoint1 = knn.queries[0];
            for (int i = 0; i < knn.trainInput.Count(); i++)
            {
                var pt = new Point2f(knn.trainInput[i].X, knn.trainInput[i].Y);
                DrawCircle(dst2, pt, task.DotSize, Scalar.Red);
                dist.inPoint2 = knn.trainInput[i];
                dist.Run(src);
                SetTrueText("depth=" + knn.trainInput[i].Z.ToString() + "\n" + "dist=" + dist.distance.ToString("F0"), pt);
            }
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                var pt = new Point2f(knn.queries[i].X, knn.queries[i].Y);
                for (int j = 0; j <= Math.Min(2, knn.trainInput.Count()); j++)
                {
                    int index = knn.result[i, j];
                    if (index >= knn.trainInput.Count() || index < 0) continue;
                    var nn = new Point2f(knn.trainInput[index].X, knn.trainInput[index].Y);
                    DrawCircle(dst2, pt, task.DotSize, Scalar.Yellow);
                    DrawLine(dst2, pt, nn, Scalar.Yellow);
                    var midPt = new Point2f((pt.X + nn.X) / 2, (pt.Y + nn.Y) / 2);
                    SetTrueText(j.ToString(), midPt);
                    SetTrueText("depth=" + knn.queries[i].Z.ToString(), pt);
                }
            }
        }
    }
    public class CS_KNN_Core4DTest : CS_Parent
    {
        KNN_Core4D knn = new KNN_Core4D();
        Distance_Point4D dist = new Distance_Point4D();
        Random_Basics4D random = new Random_Basics4D();
        public CS_KNN_Core4DTest(VBtask task) : base(task)
        {
            labels[2] = "Red=TrainingData, yellow = queries, text shows Euclidean distance to that point from query point";
            FindSlider("Random Pixel Count").Value = 5;
            desc = "Validate that knn works with random 3D points in the image.  Find the nearest requested neighbors.";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                random.Run(empty);
                knn.trainInput = new List<Vec4f>(random.PointList);
                knn.queries.Clear();
                knn.queries.Add(new Vec4f(msRNG.Next(0, dst2.Width), msRNG.Next(0, dst2.Height), msRNG.Next(0, dst2.Height), msRNG.Next(0, dst2.Height)));
            }
            knn.Run(empty);
            dst2.SetTo(0);
            dist.inPoint1 = knn.queries[0];
            for (int i = 0; i < knn.trainInput.Count(); i++)
            {
                var pt = new Point2f(knn.trainInput[i][0], knn.trainInput[i][1]);
                DrawCircle(dst2, pt, task.DotSize, Scalar.Red);
                dist.inPoint2 = knn.trainInput[i];
                dist.Run(src);
                SetTrueText("dist=" + dist.distance.ToString(fmt0), pt);
            }
            for (int i = 0; i < knn.queries.Count(); i++)
            {
                var pt = new Point2f(knn.queries[i][0], knn.queries[i][1]);
                for (int j = knn.result.GetLowerBound(1); j <= knn.result.GetUpperBound(1); j++)
                {
                    int index = knn.result[i, j];
                    if (index >= knn.trainInput.Count() || index < 0) continue;
                    var nn = new Point2f(knn.trainInput[index][0], knn.trainInput[index][1]);
                    DrawCircle(dst2, pt, task.DotSize, Scalar.Yellow);
                    DrawLine(dst2, pt, nn, task.HighlightColor);
                    var midPt = new Point2f((pt.X + nn.X) / 2, (pt.Y + nn.Y) / 2);
                    SetTrueText(j.ToString(), midPt);
                }
            }
        }
    }
    public class CS_KNN_CoreNTest : CS_Parent
    {
        KNN_CoreN knn = new KNN_CoreN();
        public CS_KNN_CoreNTest(VBtask task) : base(task)
        {
            labels[2] = "Highlight color (Yellow) is query.  The red dots are the training set.";
            desc = "Test the use of the general form KNN_CoreN algorithm";
        }
        public void RunCS(Mat src)
        {
            if (task.heartBeat)
            {
                knn.trainInput.Clear();
                for (int i = 0; i < knn.options.numPoints; i++)
                {
                    for (int j = 0; j < knn.options.knnDimension; j++)
                    {
                        knn.trainInput.Add(msRNG.Next(dst2.Height));
                    }
                }
                knn.queries.Clear();
                for (int j = 0; j < knn.options.knnDimension; j++)
                {
                    knn.queries.Add(msRNG.Next(dst2.Height));
                }
            }
            knn.Run(empty);
            dst2.SetTo(0);
            for (int i = 0; i < knn.trainInput.Count(); i += knn.options.knnDimension)
            {
                var pt = new Point2f(knn.trainInput[i], knn.trainInput[i + 1]);
                DrawCircle(dst2, pt, task.DotSize, Scalar.Red);
            }
            for (int i = 0; i < knn.queries.Count(); i += knn.options.knnDimension)
            {
                var pt = new Point2f(knn.queries[i], knn.queries[i + 1]);
                int index = knn.result[i, 0];
                if (index * knn.options.knnDimension >= knn.trainInput.Count() || index < 0) continue;
                var nn = new Point2f(knn.trainInput[index * knn.options.knnDimension], knn.trainInput[index * knn.options.knnDimension + 1]);
                DrawCircle(dst2, pt, task.DotSize + 1, task.HighlightColor);
                DrawLine(dst2, pt, nn, task.HighlightColor);
            }
            if (standaloneTest())
            {
                SetTrueText("Results are easily verified for the 2-dimensional case.  For higher dimension, " + "\n" + 
                            "the results may appear incorrect because the higher dimensions are projected into " + "\n" +
                            "a 2-dimensional presentation.", 3);
            }
        }
    }
    public class CS_KNN_Emax : CS_Parent
    {
        Random_Basics random = new Random_Basics();
        public KNN_Core knn = new KNN_Core();
        EMax_Basics em = new EMax_Basics();
        public CS_KNN_Emax(VBtask task) : base(task)
        {
            labels[2] = "Output from Emax";
            labels[3] = "Red=TrainingData, yellow = queries - use EMax sigma to introduce more chaos.";
            desc = "Emax centroids move but here KNN is used to matched the old and new locations and keep the colors the same.";
        }
        public void RunCS(Mat src)
        {
            em.Run(src);
            random.Run(empty);
            knn.queries = new List<Point2f>(em.centers);
            knn.Run(src);
            dst2 = em.dst2 + knn.dst2;
            knn.displayResults();
            dst3 = knn.dst2;
            knn.trainInput = new List<Point2f>(knn.queries);
        }
    }
    public class CS_KNN_TrackMean : CS_Parent
    {
        Plot_Histogram plot = new Plot_Histogram();
        KNN_Basics knn = new KNN_Basics();
        Feature_Basics feat = new Feature_Basics();
        const int maxDistance = 50;
        public float shiftX;
        public float shiftY;
        List<Point2f> motionTrack = new List<Point2f>();
        Mat lastImage;
        System.Windows.Forms.TrackBar dotSlider;
        Options_KNN options = new Options_KNN();
        public CS_KNN_TrackMean(VBtask task) : base(task)
        {
            FindSlider("Feature Sample Size").Value = 200;
            dotSlider = FindSlider("Average distance multiplier");
            if (standaloneTest()) task.gOptions.setDisplay1();
            labels = new[] { "", "Histogram of Y-Axis camera motion", "Yellow points are good features and the white trail in the center estimates camera motion.", "Histogram of X-Axis camera motion" };
            desc = "Track points with KNN and match the goodFeatures from frame to frame";
        }
        float plotDiff(List<int> diffList, string xyStr, int labelImage, ref string label)
        {
            int count = diffList.Max() - diffList.Min() + 1;
            float[] hist = new float[maxDistance];
            int zeroLoc = hist.Length / 2;
            int nonZero = 0;
            int zeroCount = 0;
            foreach (int diff in diffList)
            {
                if (diff != 0) nonZero++;
                else zeroCount++;
                int diffPlus = diff + zeroLoc;
                if (diffPlus >= maxDistance) diffPlus = maxDistance - 1;
                if (diffPlus < 0) diffPlus = 0;
                hist[diffPlus] += 1;
            }
            plot.Run(new Mat(hist.Length, 1, MatType.CV_32F, hist));
            var histList = hist.ToList();
            float maxVal = histList.Max();
            int maxIndex = histList.IndexOf(maxVal);
            plot.maxValue = (float)Math.Ceiling((maxVal + 50) - (maxVal + 50) % 50);
            label = xyStr + "Max count = " + maxVal + " at " + (maxIndex - zeroLoc) + " with " + nonZero + " non-zero values or " +
                    string.Format("{0:0%}", (float)nonZero / (nonZero + zeroCount));
            float histSum = 0;
            for (int i = 0; i < histList.Count(); i++)
            {
                histSum += histList[i] * (i - zeroLoc);
            }
            return histSum / histList.Count();
        }
        public void RunCS(Mat src)
        {
            if (task.FirstPass) lastImage = src.Clone();
            int multiplier = dotSlider.Value;
            feat.Run(src);
            knn.queries = new List<Point2f>(task.features);
            knn.Run(src);
            List<int> diffX = new List<int>();
            List<int> diffY = new List<int>();
            Mat correlationMat = new Mat();
            dst2 = src.Clone();
            var sz = task.gridSize;
            foreach (var mps in knn.matches)
            {
                var currRect = ValidateRect(new Rect((int)(mps.p1.X - sz), (int)(mps.p1.Y - sz), sz * 2, sz * 2));
                var prevRect = ValidateRect(new Rect((int)(mps.p2.X - sz), (int)(mps.p2.Y - sz), currRect.Width, currRect.Height));
                Cv2.MatchTemplate(lastImage[prevRect], src[currRect], correlationMat, feat.options.matchOption);
                float corrNext = correlationMat.Get<float>(0, 0);
                DrawCircle(dst2, mps.p1, task.DotSize, task.HighlightColor);
                diffX.Add((int)(mps.p1.X - mps.p2.X));
                diffY.Add((int)(mps.p1.Y - mps.p2.Y));
            }
            if (diffX.Count() == 0 || diffY.Count() == 0) return;
            string xLabel = "", yLabel = "";
            shiftX = multiplier * plotDiff(diffX, " X ", 3, ref xLabel);
            dst3 = plot.dst2.Clone();
            dst3.Line(new cv.Point(plot.plotCenter, 0), new cv.Point(plot.plotCenter, dst2.Height), Scalar.White, 1);
            shiftY = multiplier * plotDiff(diffY, " Y ", 1, ref yLabel);
            dst1 = plot.dst2;
            dst1.Line(new cv.Point(plot.plotCenter, 0), new cv.Point(plot.plotCenter, dst2.Height), Scalar.White, 1);
            lastImage = src.Clone();
            motionTrack.Add(new Point2f(shiftX + dst2.Width / 2, shiftY + dst2.Height / 2));
            if (motionTrack.Count() > task.fpsRate) motionTrack.RemoveAt(0);
            var lastpt = motionTrack[0];
            foreach (var pt in motionTrack)
            {
                DrawLine(dst2, pt, lastpt, Scalar.White);
                lastpt = pt;
            }
            SetTrueText(yLabel, 1);
            SetTrueText(xLabel, 3);
        }
    }
    public class CS_KNN_ClosestTracker : CS_Parent
    {
        public Line_Basics lines = new Line_Basics();
        public PointPair lastPair = new PointPair();
        public List<Point2f> trainInput = new List<Point2f>();
        List<float> minDistances = new List<float>();
        public CS_KNN_ClosestTracker(VBtask task) : base(task)
        {
            labels = new[] { "", "", "Highlight the tracked line (move camera to see track results)", "Candidate lines - standaloneTest() only" };
            desc = "Find the longest line and keep finding it among the list of lines using a minimized KNN test.";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            cv.Point2f p1 = new cv.Point2f(), p2 = new cv.Point2f();
            if (trainInput.Count() == 0)
            {
                lines.Run(src);
                dst3 = lines.dst2;
            }
            else
            {
                p1 = lastPair.p1;
                p2 = lastPair.p2;
            }
            foreach (var lp in lines.lpList)
            {
                if (trainInput.Count() == 0)
                {
                    p1 = lp.p1;
                    p2 = lp.p2;
                }
                trainInput.Add(lp.p1);
                trainInput.Add(lp.p2);
                if (trainInput.Count() >= 10) break;
            }
            if (trainInput.Count() == 0)
            {
                SetTrueText("No lines were found in the current image.");
                return;
            }
            if (lastPair.compare(new PointPair())) lastPair = new PointPair(p1, p2);
            List<float> distances = new List<float>();
            for (int i = 0; i < trainInput.Count(); i += 2)
            {
                var pt1 = trainInput[i];
                var pt2 = trainInput[i + 1];
                distances.Add((float)(Math.Min(pt1.DistanceTo(lastPair.p1) + pt2.DistanceTo(lastPair.p2), pt1.DistanceTo(lastPair.p2) + pt2.DistanceTo(lastPair.p2))));
            }
            float minDist = distances.Min();
            int index = distances.IndexOf(minDist) * 2;
            p1 = trainInput[index];
            p2 = trainInput[index + 1];
            if (minDistances.Count() > 0)
            {
                if (minDist > minDistances.Max() * 2)
                {
                    Console.WriteLine("Overriding KNN min Distance Rule = " + string.Format("{0:0}", minDist) + " max = " + string.Format("{0:0}", minDistances.Max()));
                    lastPair = new PointPair(trainInput[0], trainInput[1]);
                }
                else
                {
                    lastPair = new PointPair(p1, p2);
                }
            }
            else
            {
                lastPair = new PointPair(p1, p2);
            }
            if (minDist > 0) minDistances.Add(minDist);
            if (minDistances.Count() > 100) minDistances.RemoveAt(0);
            DrawLine(dst2, p1, p2, task.HighlightColor);
            trainInput.Clear();
        }
    }
    public class CS_KNN_ClosestLine : CS_Parent
    {
        public Point2f lastP1;
        public Point2f lastP2;
        public int lastIndex;
        public List<Point2f> trainInput = new List<Point2f>();
        List<float> minDistances;
        public CS_KNN_ClosestLine(VBtask task) : base(task)
        {
            desc = "Try to find the closest pair of points in the traininput.  Dynamically compute distance ceiling to determine when to report fail.";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            if (lastP1 == new Point2f())
            {
                SetTrueText("CS_KNN_ClosestLine is only run with other KNN algorithms" + "\n" +
                            "lastP1 and lastP2 need to be initialized by the other algorithm." + "\n" +
                            "Initialize with a pair of points to track a line. ", 3);
                return;
            }
            List<float> distances = new List<float>();
            for (int i = 0; i < trainInput.Count(); i += 2)
            {
                var pt1 = trainInput[i];
                var pt2 = trainInput[i + 1];
                distances.Add((float)(Math.Min(pt1.DistanceTo(lastP1) + pt2.DistanceTo(lastP2), pt1.DistanceTo(lastP2) + pt2.DistanceTo(lastP2))));
            }
            float minDist = distances.Min();
            lastIndex = distances.IndexOf(minDist) * 2;
            lastP1 = trainInput[lastIndex];
            lastP2 = trainInput[lastIndex + 1];
            if (task.FirstPass) minDistances = new List<float> { distances[0] };
            if (minDist > minDistances.Max() * 4)
            {
                Console.WriteLine("Overriding KNN min Distance Rule = " + string.Format("{0:0}", minDist) + " max = " + string.Format("{0:0}", minDistances.Max()));
                lastP1 = trainInput[0];
                lastP2 = trainInput[1];
            }
            if (minDist > 0) minDistances.Add(minDist);
            if (minDistances.Count() > 100) minDistances.RemoveAt(0);
            DrawLine(dst2, lastP1, lastP2, task.HighlightColor);
            trainInput.Clear();
        }
    }
    public class CS_KNN_ClosestVertical : CS_Parent
    {
        public FeatureLine_Finder lines = new FeatureLine_Finder();
        public KNN_ClosestLine knn = new KNN_ClosestLine();
        public Point3f pt1 = new Point3f();
        public Point3f pt2 = new Point3f();
        public CS_KNN_ClosestVertical(VBtask task) : base(task)
        {
            labels = new[] { "", "", "Highlight the tracked line", "Candidate vertical lines are in Blue" };
            desc = "Test the code find the longest line and track it using a minimized KNN test.";
        }
        public void RunCS(Mat src)
        {
            dst2 = src.Clone();
            lines.Run(src);
            if (lines.sortedVerticals.Count() == 0)
            {
                SetTrueText("No vertical lines were found.");
                return;
            }
            int index = lines.sortedVerticals.ElementAt(0).Value;
            float lastDistance = (float)knn.lastP1.DistanceTo(knn.lastP2);
            float bestDistance = (float)lines.lines2D[index].DistanceTo(lines.lines2D[index + 1]);
            if (knn.lastP1 == new Point2f() || lastDistance < 0.75f * bestDistance)
            {
                knn.lastP1 = lines.lines2D[index];
                knn.lastP2 = lines.lines2D[index + 1];
            }
            knn.trainInput.Clear();
            for (int i = 0; i < lines.sortedVerticals.Count(); i++)
            {
                index = lines.sortedVerticals.ElementAt(i).Value;
                knn.trainInput.Add(lines.lines2D[index]);
                knn.trainInput.Add(lines.lines2D[index + 1]);
            }
            knn.Run(src);
            pt1 = lines.lines3D[knn.lastIndex];
            pt2 = lines.lines3D[knn.lastIndex + 1];
            dst3 = lines.dst3;
            DrawLine(dst2, knn.lastP1, knn.lastP2, task.HighlightColor);
        }
    }
    public class CS_KNN_BasicsOld : CS_Parent
    {
        public List<PointPair> matches = new List<PointPair>();
        public List<Point> noMatch = new List<Point>();
        public KNN_Core knn = new KNN_Core();
        public List<Point2f> queries = new List<Point2f>();
        Random_Basics random = new Random_Basics();
        public CS_KNN_BasicsOld(VBtask task) : base(task)
        {
            labels[2] = "KNN_Core output with many-to-one results";
            labels[3] = "CS_KNN_BasicsOld output with just the closest match.  Red = training data, yellow = queries.";
            desc = "Map points 1:1 with losses.  When duplicates are found, toss the farthest.  Too hard to follow.  Trying a better approach.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (task.heartBeat)
                {
                    random.Run(empty);
                    knn.trainInput = new List<Point2f>(random.PointList);
                }
                random.Run(empty);
                queries = new List<Point2f>(random.PointList);
            }
            if (queries.Count() == 0)
            {
                SetTrueText("Place some input points in queries before starting the knn run.");
                return;
            }
            knn.queries = queries;
            knn.Run(empty);
            knn.displayResults();
            dst2 = knn.dst2;
            var nearest = new List<int>();
            var sortedResults = new SortedList<int, int>(new CompareAllowIdenticalInteger());
            for (int i = 0; i < queries.Count(); i++)
            {
                nearest.Add(knn.result[i, 0]);
                sortedResults.Add(knn.result[i, 0], i);
            }
            for (int i = 0; i < sortedResults.Count() - 1; i++)
            {
                var resultA = sortedResults.ElementAt(i).Key;
                var resultB = sortedResults.ElementAt(i + 1).Key;
                if (resultA == resultB)
                {
                    var nn = knn.trainInput[resultA];
                    var queryA = sortedResults.ElementAt(i).Value;
                    for (int j = i + 1; j < sortedResults.Count(); j++)
                    {
                        resultB = sortedResults.ElementAt(j).Key;
                        if (resultA != resultB) break;
                        var queryB = sortedResults.ElementAt(j).Value;
                        var p1 = queries[queryA];
                        var p2 = queries[queryB];
                        var distance1 = Math.Sqrt((p1.X - nn.X) * (p1.X - nn.X) + (p1.Y - nn.Y) * (p1.Y - nn.Y));
                        var distance2 = Math.Sqrt((p2.X - nn.X) * (p2.X - nn.X) + (p2.Y - nn.Y) * (p2.Y - nn.Y));
                        if (distance1 < distance2)
                        {
                            nearest[queryB] = -1;
                        }
                        else
                        {
                            nearest[queryA] = -1;
                            queryA = queryB;
                        }
                    }
                }
            }
            dst3.SetTo(0);
            foreach (var pt in knn.trainInput)
            {
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Red);
            }
            noMatch.Clear();
            matches.Clear();
            for (int i = 0; i < queries.Count(); i++)
            {
                var pt = queries[i];
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Yellow);
                if (nearest[i] == -1)
                {
                    noMatch.Add(new cv.Point((int)pt.X, (int)pt.Y));
                }
                else
                {
                    if (nearest[i] < knn.trainInput.Count())
                    {
                        var nn = knn.trainInput[nearest[i]];
                        matches.Add(new PointPair(pt, nn));
                        DrawLine(dst3, nn, pt, Scalar.White);
                    }
                }
            }
            if (!standaloneTest()) knn.trainInput = new List<Point2f>(queries);
        }
    }
    public class CS_KNN_Farthest : CS_Parent
    {
        KNN_Core knn = new KNN_Core();
        public PointPair mpFar;
        Random_Basics random = new Random_Basics();
        public CS_KNN_Farthest(VBtask task) : base(task)
        {
            labels = new string[] { "", "", "Lines connecting pairs that are farthest.", "Training Input which is also query input and longest line" };
            desc = "Use KNN to find the farthest point from each query point.";
        }
        public void RunCS(Mat src)
        {
            if (standaloneTest())
            {
                if (task.heartBeat)
                {
                    random.Run(empty);
                    knn.trainInput = new List<Point2f>(random.PointList);
                    knn.queries = new List<Point2f>(knn.trainInput);
                }
            }
            knn.Run(empty);
            dst2.SetTo(0);
            dst3.SetTo(0);
            var farthest = new List<PointPair>();
            var distances = new List<float>();
            for (int i = 0; i <= knn.result.GetUpperBound(0) - 1; i++)
            {
                int farIndex = knn.result[i, knn.result.GetUpperBound(1)];
                var mp = new PointPair(knn.queries[i], knn.trainInput[farIndex]);
                DrawCircle(dst2, mp.p1, task.DotSize + 4, Scalar.Yellow);
                DrawCircle(dst2, mp.p2, task.DotSize + 4, Scalar.Yellow);
                DrawLine(dst2, mp.p1, mp.p2, Scalar.Yellow);
                farthest.Add(mp);
                distances.Add((float)mp.p1.DistanceTo(mp.p2));
            }
            foreach (var pt in knn.queries)
            {
                DrawCircle(dst3, pt, task.DotSize + 4, Scalar.Red);
            }
            var maxIndex = distances.IndexOf(distances.Max());
            mpFar = farthest[maxIndex];
            DrawLine(dst3, mpFar.p1, mpFar.p2, Scalar.White);
        }
    }
    public class CS_KNN_TrackEach : CS_Parent
    {
        KNN_Basics knn = new KNN_Basics();
        Feature_Basics feat = new Feature_Basics();
        List<List<PointPair>> trackAll = new List<List<PointPair>>();
        public CS_KNN_TrackEach(VBtask task) : base(task)
        {
            desc = "Track each good feature with KNN and match the goodFeatures from frame to frame";
        }
        public void RunCS(Mat src)
        {
            var minDistance = feat.options.minDistance;
            if (!task.motionFlag || task.optionsChanged) minDistance = 2;
            feat.Run(src);
            knn.queries = new List<Point2f>(task.features);
            knn.Run(src);
            var tracker = new List<PointPair>();
            dst2 = src.Clone();
            foreach (var mp in knn.matches)
            {
                if (mp.p1.DistanceTo(mp.p2) < minDistance) tracker.Add(mp);
            }
            trackAll.Add(tracker);
            for (int i = 0; i < trackAll.Count(); i += 2)
            {
                var t1 = trackAll[i];
                foreach (var mp in t1)
                {
                    DrawCircle(dst2, mp.p1, task.DotSize, task.HighlightColor);
                    DrawCircle(dst2, mp.p2, task.DotSize, task.HighlightColor);
                    DrawLine(dst2, mp.p1, mp.p2, Scalar.Red);
                }
            }
            labels[2] = task.features.Count().ToString() + " good features were tracked across " + task.frameHistoryCount.ToString() + " frames.";
            SetTrueText(labels[2] + "\nThe highlighted dots are the good feature points", 3);
            if (trackAll.Count() > task.frameHistoryCount) trackAll.RemoveAt(0);
        }
    }
    public class CS_LaneFinder_Basics : CS_Parent
    {
        LaneFinder_SlopeIntercept lane = new LaneFinder_SlopeIntercept();
        public CS_LaneFinder_Basics(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            if (standaloneTest()) task.gOptions.setDisplay1();
            desc = "The basics of lane-finding.  A better name than LaneFinder_SlopeIntercept";
        }
        public void RunCS(Mat src)
        {
            lane.Run(src);
            dst0 = lane.dst0;
            dst1 = lane.dst1;
            dst2 = lane.dst2;
            dst3 = lane.dst3;
        }
    }
    public class CS_LaneFinder_Videos : CS_Parent
    {
        public Video_Basics video = new Video_Basics();
        Options_LaneFinder options = new Options_LaneFinder();
        public CS_LaneFinder_Videos(VBtask task) : base(task)
        {
            if (standaloneTest()) task.gOptions.setDisplay1();
            if (standaloneTest()) task.gOptions.setDisplay1();

            desc = "Read in the videos showing road conditions.";
        }
        public void RunCS(Mat src)
        {
            options.RunVB();

            if (task.optionsChanged)
            {
                if (options.inputfile.Exists) video.fileNameForm.setFileName(options.inputfile.FullName);
            }
            video.Run(empty);
            dst2 = video.dst2;
        }
    }
    public class CS_LaneFinder_Edges : CS_Parent
    {
        LaneFinder_Videos input = new LaneFinder_Videos();
        Edge_All edges = new Edge_All();
        public CS_LaneFinder_Edges(VBtask task) : base(task)
        {
            desc = "Using the videos provided, find the lane markers.";
        }
        public void RunCS(Mat src)
        {
            input.Run(empty);
            dst0 = input.dst2;
            edges.Run(dst0);
            dst2 = edges.dst2;
        }
    }
    public class CS_LaneFinder_HLSColor : CS_Parent
    {
        public LaneFinder_Videos input = new LaneFinder_Videos();
        public CS_LaneFinder_HLSColor(VBtask task) : base(task)
        {
            labels = new string[] { "HLS color conversion", "InRange White", "InRange Yellow", "Combined InRange White and InRange Yellow results" };
            desc = "Isolate the colors for the white and yellow";
        }
        public void RunCS(Mat src)
        {
            input.Run(empty);
            dst0 = input.dst2.CvtColor(cv.ColorConversionCodes.BGR2HLS);
            dst1 = dst0.InRange(new Scalar(0, 200, 0), new Scalar(255, 255, 255));
            dst2 = dst0.InRange(new Scalar(10, 0, 100), new Scalar(40, 255, 255));
            dst3 = dst1 | dst2;
        }
    }
    public class CS_LaneFinder_ROI : CS_Parent
    {
        LaneFinder_HLSColor hls = new LaneFinder_HLSColor();
        Point[][] pListList = new Point[1][];
        public CS_LaneFinder_ROI(VBtask task) : base(task)
        {
            labels = new string[] { "Original input", "Mask showing ROI", "HLS version with ROI outline", "HLS Mask with ROI outline" };
            desc = "Define the ROI for the location of the lanes";
        }
        public void RunCS(Mat src)
        {
            hls.Run(empty);
            if (task.optionsChanged)
            {
                var w = hls.input.video.dst2.Width;
                var h = hls.input.video.dst2.Height;
                var bl = new cv.Point(w * 0.1, h * 0.95);
                var tl = new cv.Point(w * 0.4, h * 0.6);
                var br = new cv.Point(w * 0.95, h * 0.95);
                var tr = new cv.Point(w * 0.6, h * 0.6);
                var pList = new Point[] { bl, tl, tr, br };
                dst1 = new Mat(new cv.Size(w, h), MatType.CV_8U, 0);
                dst1.FillConvexPoly(pList, Scalar.White, task.lineType);
                pListList[0] = pList;
            }
            dst0 = hls.input.video.dst2;
            dst2 = hls.dst0;
            dst3 = hls.dst3;
            Cv2.Polylines(dst0, pListList, true, Scalar.White, task.lineWidth, task.lineType, 0);
            Cv2.Polylines(dst2, pListList, true, Scalar.White, task.lineWidth, task.lineType, 0);
            Cv2.Polylines(dst3, pListList, true, Scalar.White, task.lineWidth, task.lineType, 0);
        }
    }
    public class CS_LaneFinder_SlopeIntercept : CS_Parent
    {
        Hough_LaneFinder hough = new Hough_LaneFinder();
        public float leftLaneIntercept;
        public float rightLaneIntercept;
        public float leftAvgSlope;
        public float rightAvgSlope;
        public CS_LaneFinder_SlopeIntercept(VBtask task) : base(task)
        {
            desc = "Use the Hough lines found to build a slope intercept format line.";
        }
        public void RunCS(Mat src)
        {
            hough.Run(empty);
            dst0 = hough.dst0;
            dst1 = hough.dst2;
            dst2 = hough.dst3;
            dst3 = hough.dst0.Clone();
            if (hough.segments.Count() == 0) return;
            var leftIntercept = new List<float>();
            var leftSlope = new List<float>();
            var leftWeight = new List<float>();
            var rightIntercept = new List<float>();
            var rightSlope = new List<float>();
            var rightWeight = new List<float>();
            foreach (var line in hough.segments)
            {
                if (line.P1.X == line.P2.X) continue;
                var slope = (line.P1.Y - line.P2.Y) / (line.P1.X - line.P2.X);
                if (slope < 0)
                {
                    leftIntercept.Add(line.P1.Y - (slope * line.P1.X));
                    leftSlope.Add(slope);
                    leftWeight.Add((float)line.P1.DistanceTo(line.P2));
                }
                else
                {
                    rightIntercept.Add(line.P1.Y - (slope * line.P1.X));
                    rightSlope.Add(slope);
                    rightWeight.Add((float)line.P1.DistanceTo(line.P2));
                }
            }
            var mat1 = new Mat(leftWeight.Count(), 1, MatType.CV_32F, leftWeight.ToArray());
            var mat2 = new Mat(leftSlope.Count(), 1, MatType.CV_32F, leftSlope.ToArray());
            var mat3 = new Mat(leftIntercept.Count(), 1, MatType.CV_32F, leftIntercept.ToArray());
            var weight = leftWeight.Sum();
            leftLaneIntercept = (float)(mat1.Dot(mat3) / weight);
            leftAvgSlope = (float)(mat1.Dot(mat2) / weight);
            mat1 = new Mat(rightWeight.Count(), 1, MatType.CV_32F, rightWeight.ToArray());
            mat2 = new Mat(rightSlope.Count(), 1, MatType.CV_32F, rightSlope.ToArray());
            mat3 = new Mat(rightIntercept.Count(), 1, MatType.CV_32F, rightIntercept.ToArray());
            weight = rightWeight.Sum();
            rightLaneIntercept = (float)(mat1.Dot(mat3) / weight);
            rightAvgSlope = (float)(mat1.Dot(mat2) / weight);
            SetTrueText("Left lane intercept = " + string.Format(fmt1, leftLaneIntercept) +
                        " Right lane intercept = " + string.Format(fmt1, rightLaneIntercept) + "\n" +
                        "Left slope = " + string.Format(fmt3, leftAvgSlope) +
                        " Right slope = " + string.Format(fmt3, rightAvgSlope), 3);
            var tmp = dst2.EmptyClone();
            var p1 = new cv.Point(0, leftLaneIntercept);
            var p2 = new cv.Point(-leftLaneIntercept / leftAvgSlope, 0);
            tmp.Line(p1, p2, Scalar.White, task.lineWidth, task.lineType);
            p1 = new cv.Point(0, rightLaneIntercept);
            p2 = new cv.Point((dst0.Height - rightLaneIntercept) / rightAvgSlope, dst2.Height);
            tmp.Line(p1, p2, Scalar.White, task.lineWidth, task.lineType);
            tmp.CopyTo(dst2, hough.mask);
            dst2.CopyTo(dst3, dst2);
        }
    }











}


